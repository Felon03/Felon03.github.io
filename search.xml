<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[【每周一坑】程序员的浪漫]]></title>
      <url>%2F2017%2F04%2F27%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB%2F</url>
      <content type="text"><![CDATA[关注了Crossin的编程教室，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。 问题如下： 在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符： ‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n’ 在此给出4个选项 我们在一起吧 我选择原谅你 别说话，吻我 多喝热水 使用科学的方法算出说的是什么。 思路其实思路也挺简单，hashlib里有MD5模块，只需调用 hashlib.md5(“要生成MD5的字符串”) 即可生成。 而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数： base64.b64decode(“已知的字符串”) 即可得到解码后的内容。 最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。 Python实现1234567891011121314151617import base64, hashlib # 引入需要使用的库answer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n' # 问题中的字符串checkStr = &#123;'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'&#125; # 将选项存入字典，后面使用def main(): for x in checkStr: # 遍历字典中的个字符串 md5 = hashlib.md5(x.encode('utf-8')) # 使用hashlib.md5()进行编码 md5_byte = bytes(md5.hexdigest().encode('utf-8')) # base64.decode()得到的是bytes类型的， # 无法直接与string比较，这里把string类型的md5转换成bytes类型的 b64_byte = base64.decode(answer) if md5_byte == b64_byte: print('The answer is', x) if __name__ == '__main__': main() 输出结果万！万！没！想！到！ 结果居然是…. 多喝热水 说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧… 然而… 和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭ End~ [1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数返回数组指针或数组引用]]></title>
      <url>%2F2017%2F04%2F15%2F%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E6%88%96%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%2F</url>
      <content type="text"><![CDATA[因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。下面就介绍几种方法： 方法一： 使用类型别名1234typedef int arrT[10]; // arrT是一个类型别名，表示的类型 // 是含有10个整型的数组using arrT = int[10]; // arrT的等价声明arrT* func(int i); // func返回一个指向含有10个整数的数组的指针 其中arrT是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此func函数接受一个int实参，返回一个指向包含10个整数的数组的指针。 方法二： 声明一个返回数组指针的函数要想在声明func时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：123int arr[10]; // arr是一个含有10个整数的数组int *p1[10]; // p1是一个含有10个指针的数组int (*p2)[10] = &amp;arr; // p2是一个指针，他只想含有10个整数的数组 和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示： Type (*function(parameter_list)) [dimension] 类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。(*function(parameter_list))两段的括号必须存在，就像定义p2时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。 举个具体点的例子，下面这个func函数的声明没有使用类型别名：1int (*func(int i)) [10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i)表示调用func函数时需要一个int类型的实参 (*func(int i))意味这我们可以对函数调用的结果执行解引用操作 (*func(int i)) [10]表示解引用func的调用将得到一个大小是10的数组 int(*func(int i)) [10]表示数组中元素是int类型 方法三： 使用尾置返回类型在C++11新标准中海油可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto： 12// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*) [10]; 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 方法四： 使用decltype还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：1234567int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;// 返回一个指针，该指针指向含有5个整数的数组decltype(odd) *addPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even; // 返回一个指向数组的指针&#125; arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个*符号。 练习1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。1string (&amp;func(string (&amp;arr)[10])) [10]; 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。12345678910// 使用类型别名using arrT = string[10];arrT&amp; func1(arrT&amp; arr);// 使用尾置返回类型auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];// 使用decltype关键字string arrS[10];decltype(arrS) &amp;func3(arrT&amp; arr); 3. 修改arrPtr函数，使其返回数组的引用123456int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;decltype(odd) &amp;arrPtr(int i)&#123; return (i % 2) ? odd : even;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++前置递增（递减）和后置递增（递减）运算符]]></title>
      <url>%2F2017%2F04%2F07%2FC-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E5%92%8C%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在做C++ primer 第五版课后习题4.31时遇到一个问题： 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。 源程序代码如下：12345vector&lt;int&gt;::size_type cnt = ivec.size();// 将把从size到1的值赋给ivec的元素for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; 可以看到源程序用的是前置递增和递减运算符我根据源代码写了一下可运行的版本：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 然后根据题目的意思，使用了后置版本的递增和递减运算符：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 结果一样啊喂！(＃°Д°)哪里需要修改了(╯‵□′)╯︵┻━┻各种百度没有没百度到，突然想起来可以找课后练习答案啊！找到了结果，还以为我错了，没想到答案居然是… We use prefix and not postfix, just because of the Advice: Use Postfix Advice: Use Postfix Operators only When Necessary.So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:12for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; This is not an appropriate example to discuss the difference of prefix and postfix. 果然不是我的问题 ( •̀ ω •́ )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ string输入问题]]></title>
      <url>%2F2017%2F03%2F31%2FC-string%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[问题描述 使用cin读入一组字符串并存入一个vector对象 代码实现使用如下代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;/*用cin读入一组字符串并把它们存入一个vector对象*/int main()&#123; vector&lt;string&gt; text; string word; while (getline(cin, word)) &#123; text.push_back(word); &#125; cout &lt;&lt; "["; for (auto i : text) if (i == text.back()) cout &lt;&lt; i; else cout &lt;&lt; i &lt;&lt; ","; cout &lt;&lt; "]"; return 0;&#125; 在运行测试时发现了一个问题：当输入为 aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的) 按回车后发现输出卡出了，并不会输出所输入的字符串 当输入为 aa ss dd qq ww ee^Z(换行后的^Z) 就可以正确输出了 解决办法百思不得其解，遂百度之。看到了两种解释，感觉都有道理，就都贴上来好了1. 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。 2. windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。 意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给出一个表达式，按照顺序求出表达式的值]]></title>
      <url>%2F2017%2F03%2F25%2F%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%2F</url>
      <content type="text"><![CDATA[按顺序求出表达式的值今天碰到一个题目：题目描述： 常规的表达式求值，我们都会根据计算的优先级来计算， 比如*、/的优先级就高于+、-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有/，只有(+,-和*)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入描述： 输入为一行字符串，即一个表达式。其中运算符只有+,-和*。参与计算的数字只有0-9。保证表达式是合法的，排列规则如样例所示。 输出描述 输出一个数，即表达式的值 输入例子 3+5*7 输出例子 56 刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的… C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * 输入字符串表达式，按照输入顺序求出表达式的结果 */#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;cmath&gt;using namespace std;// 字符串转数字int get_number(string num_str)&#123; stringstream stream; // 声明stringstram变量 int result = 0; int str_len = num_str.length(); stream &lt;&lt; num_str; stream &gt;&gt; result; return result;&#125;int main()&#123; string s; // 保存输入的字符串 cout &lt;&lt; "请输入要计算的表达式(不包含除):" &lt;&lt; endl; cin &gt;&gt; s; int number[100] = &#123; 0 &#125;; // 保存数字的数组 string operator_str; // 保存操作符的字符串 int length = s.length(); string number_str; // 保存每个操作符之前的字符串 int index = 0; // 标记保存数字的数组的指针 for (int i = 0; i &lt; length; i++) &#123; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') // 如果是数字，则存入 number_str &#123; number_str += s[i]; &#125; else // 如果是操作符，存入operator_str &#123; operator_str += s[i]; number[index] = get_number(number_str); // 得到两个操作符之间的操作数，并存入数组 index++; number_str = ""; // 将字符串置为空，重新存入下一个操作数的字符串 &#125; if (i == length -1) // 得到表达式的最后一个操作数 &#123; number[index] = get_number(number_str); index++; &#125; &#125; int result = 0; // 计算结果 for (int i = 0; i &lt; index; i++) &#123; //todo 计算结果 if (i&lt;1) &#123; result += number[i]; &#125; else &#123; switch (operator_str[i-1]) &#123; case '+': result = result + number[i]; break; case '-': result = result - number[i]; break; case '*': result = result * number[i]; break; default: break; &#125; &#125; //cout &lt;&lt; number[i] &lt;&lt; endl; &#125; //for (int i = 0; i &lt; operator_str.length(); i++) //&#123; // cout &lt;&lt; operator_str[i] &lt;&lt; endl; //&#125; //cout &lt;&lt; "输入的字符串为:" &lt;&lt; s &lt;&lt; " 得到的数字为: " &lt;&lt; number &lt;&lt; endl; cout &lt;&lt; "Result = " &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125; 挺简单的题目，居然写了这么多！ (:3」∠) 太久没写了，写的有点丑¬¬，看来还是要多练习 (ง •̀•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python生成词云]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%2F</url>
      <content type="text"><![CDATA[Python如何生成词云最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P通过度娘发现可以用Python库来生成词云， So Let’s go! 用到的库WorldCloud 官网: https://amueller.github.io/word_cloud github: https://github.com/amueller/word_cloud 安装WordCloud通过PIP安装pip install wordcloud 下载WHL包安装当然可能通过PIP会安装出错，我们可以下WHL包手动安装 下载完成后，再使用PIP命令安装： pip install yourfilepath\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl 其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl。 使用WordlCloud安装完成后，就可以用了。可以先测试以下是否安装成功： from wordcould import WordCloud 如果没有报错，表示安装成功了。 源代码下面就是源码部分了:1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from wordcloud import WordCloudimport matplotlib.pyplot as pltfrom scipy.misc omport imread# 读入一个文件text = open('your text file.txt', 'r').read()# 读入图片bg_pic = imread('your picture.png')# 配置词云参数wc = WordCloud( # 设置背景色,我这里设置为了黑色 background_color = 'black', # 设置词云形状，就是之前读入的图片 mask = bg_pic, # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块 font_path = 'Sketch Fine Serif.otf')# 生成词云wordcloud = wc.generate(text)# 显示词云图片plt.imshow(wordcloud)plt.axis('off')plt.show()# 保存图片wordcloud.to_file('wordcloud.jpg') 生成的词云效果如图: 参数其中配置词云参数的时候，有多个参数可选： Parameters1font_path : string Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path. 1width : int (default=400) Width of the canvas. 1height : int (default=200) Height of canvas 1prefer_horizontal : float (default=0.90) The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.) 1mask : nd-array or None (default=None) If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!] 1scale : float (default=1) Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words. 1min_font_size : int (default=4) Smallest font size to use. Will stop when there is no more room in this size. 1font_step : int (default=1) Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit. 1max_words : number (default=200) The maximum number of words. 1stopwords : set of strings or None The words that will be eliminated. If None, the build-in STOPWORDS list will be used. 1background_color : color value (default=”black”) Background color for the word cloud image. 1max_font_size : int or None (default=None) Maximum font size for the largest word. If None, height of the image is used. 1mode : string (default=”RGB”) Transparent background will be generated when mode is “RGBA” and background_color is None. 1relative_scaling : float (default=.5) Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good. 1color_func : callable, default=None Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead. 1regexp : string or None (optional) Regular expression to split the input text into tokens in process_text. If None is specified, r”\w[\w’]+” is used. 1collocations : bool, default=True Whether to include collocations (bigrams) of two words. 1colormap : string or matplotlib colormap, default=”viridis” Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified. 1normalize_plurals : bool, default=True Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’. 以上就是所有可以配置的参数，可以根据需要来用。 End~ [1]: 图片出处: https://github.com/amueller/word_cloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python脚本抓取Bing美图]]></title>
      <url>%2F2017%2F03%2F23%2FPython3%E8%84%9A%E6%9C%AC%E6%8A%93%E5%8F%96Bing%E7%BE%8E%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[使用Python脚本下载Bing美图Bing首页每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。 Bing美图APIBing官方有两个API：xml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1json版： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1有了API就可以愉快地抓图了:D Python抓图至于为什么要用Python，前段时间学习了廖大的Python教程,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！ 用到的库 Requests Beautiful Soup 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import requestsimport reimport timeimport osimport jsonfrom bs4 import BeautifulSoupdef downloadPic(file_name, picurl): # 判断文件夹是否存在，如果不存在就新建 if os.path.exists(r'C:\Users\Freed\Pictures\bingwallpaper'): print('Find dir already...') else: print('Dir not found, makdir...') os.mkdir(r'C:\Users\Freed\Pictures\bingwallpaper') print('success...') if os.path.exists(r'c:\users\freed\pictures\bingwallpaper\\' + file_name): print('downlaod already...') else: pic = getHtml(picurl) fp = open(r'c:\users\freed\pictures\bingwallpaper\\' + file_name, 'wb') fp.write(pic) fp.close() def getHtml(url): r = requests.get(url) return r.contenturl = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'json_str = getHtml(url) # 得到的是strjson_str = json_str.decode()print(type(json_str))#print(json_str)json_list = json_str.split(',') # 得到list#print(json_list)pic_head = 'http://s.cn.bing.net'json_url = ''json_url = json_url.join(json_list[3])picurl = json_url[7:-1]picurl = pic_head + picurlprint(picurl)# 设置图片名称file_name = str("BingWallPaper-" + time.strftime('%Y-%m-%d',time.localtime(time.time())) + '.jpg')downloadPic(file_name, picurl) 用Pthon命令运行文件即可。到此大功告成! :D]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
