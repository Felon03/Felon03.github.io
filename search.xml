<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[【每周一坑】阿姆斯特朗数]]></title>
      <url>%2F2017%2F08%2F04%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0%2F</url>
      <content type="text"><![CDATA[快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~ 一个经典的编程练习题： 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数 问题 输出1000以内的所有阿姆斯特朗数。 附加题 输入一个整数，输出距离它最近的阿姆斯特朗数。 思路一眼看到阿姆斯特朗就想到了《银魂》阿姆斯特朗回旋加速喷气式阿姆斯特朗炮了，果然银魂毁节操QAQ。 回到主题，其实阿姆斯特朗数和水仙花数差不多。满足阿姆斯特朗数的公式如下，设 $n = dkd{k-1}\cdots d_1$，则有 $$ n = dk^k + d{k-1}^k+\cdots+d_2^k+d_1^k $$ 编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。 12345678temp = numwhile temp: # 求出每位数的k次幂的和 res += (temp % 10)**n num //= 10if res == num: # 如果满足阿姆斯特朗数的条件，就返回这个数 return num Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# 得到bound以内的阿姆斯特朗数，bound默认为1000def get_number(bound=1000): armstrong_number = [] for i in range(bound): temp = i n = len(str(i)) res = 0 while temp: res += (temp % 10) ** n temp //= 10 if res == i: armstrong_number.append(i) return armstrong_number# 得到离number最近的阿姆斯特朗数def get_nearest_number(num): if is_arm_num(num): return num temp = num res = get_number(temp)[-1] while not is_arm_num(temp): temp += 1 res_new = temp if abs(res_new - num) &lt; abs(res - num): return res_new else: return res# 判断num是否是阿姆斯特朗数def is_arm_num(num): temp = num res = 0 n = len(str(num)) while temp: res += (temp % 10) ** n temp //= 10 return res == numif __name__ == '__main__': print(get_number()) print(get_nearest_number(390)) print(get_nearest_number(389)) 测试输出结果 12345678&gt;&gt;&gt; get_number(1000)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]&gt;&gt;&gt; get_nearest_number(390)407&gt;&gt;&gt; get_nearest_number(389)371 满足问题要求 参考资料[1]: Wiki 水仙花数 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】罗马数字转换]]></title>
      <url>%2F2017%2F07%2F08%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。 罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9 在一个数的上面画一条横线，表示这个数曾1000倍 常见罗马字符表 数字 罗马字符 数字 罗马字符 1 Ⅰ 2 Ⅱ 3 Ⅲ 4 Ⅳ 5 Ⅴ 6 Ⅵ 7 Ⅶ 8 Ⅷ 9 Ⅸ 10 Ⅹ 40 XL 50 L 90 XC 100 C 400 CD 500 D 900 CM 1000 M 2000 MM 2500 MMD 问题编写一个罗马数字和阿拉伯数字的转换器： 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980 附加题 给定一个小于3999的整数，将其转换为罗马数 示例： 1234567891011def romanToInt(s): # your code return iassert romanToInt('III') == 3assert romanToInt('IV') == 4assert romanToInt('VI') == 6assert romanToInt('XIX') == 19assert romanToInt('XX') == 20assert romaToInt('XLV') == 45assert romanToInt('MCMLXXX') == 1980 思路罗马数转阿拉伯数根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，左边的罗马数均比右边的小，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以将罗马数字符反转，然后从头遍历，如果当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字。 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)： 第一位是X，表示10，pre = 0，res = 0 + 10 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000 经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确 阿拉伯数(整数)转罗马数将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0 如1980，(res表示结果): 1980 // 1000 = 1, res += M, 1980 % 1000 = 980 980 // 900 = 1, res += CM, 980 % 900 = 80 80 // 50 = 1, res += L, 80 % 50 = 30 30 // 10 = 3, res += 3*X, 30 % 10 = 0 经过上述步骤即可得整数1980 = MCMLXXX Python实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-# 罗马数字转换# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC# 400CCC;CD 500D 900CM 1000M 2500MMD# e.g.# 3-&gt;III# 4-&gt;IV# 6-&gt;VI# 19-&gt;XIX# 45-&gt;XLV# 999-&gt;CMXCIX# 1980-&gt;MCMLXXX# 3999-&gt;MMMCMXCIX# 罗马转数字def roman_to_int(s): roman_int_dic = &#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &#125; s = s[::-1] res, pre = 0, 0 for x in s: if roman_int_dic[x] &gt;= pre: res += roman_int_dic[x] pre = roman_int_dic[x] else: res -= roman_int_dic[x] pre = roman_int_dic[x] return res # 数字转罗马def int_to_roman(i): dic = &#123; 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' &#125; res = "" for k in dic: if i != 0: res += i // k * dic[k] i %= k return res# 测试if __name__ == '__main__': result = roman_to_int('MMMCMXCIX') print(result) int_res = int_to_roman(3999) print(int_res) result = roman_to_int('MCMLXXX') print(result) int_res = int_to_roman(1980) print(int_res) assert roman_to_int('III') == 3 assert roman_to_int('IV') == 4 assert roman_to_int('VI') == 6 assert roman_to_int('XIX') == 19 assert roman_to_int('XLV') == 45 assert roman_to_int('MCMLXXX') == 1980 assert roman_to_int('CMXCIX') == 999 print("OK") 测试输出结果 1234567891011&gt;&gt;&gt; roman_to_int('MMMCMXCIX')3999&gt;&gt;&gt; int_to_roman(3999)MMMCMXCIX&gt;&gt;&gt; roman_to_int(MCMLXXX)1980&gt;&gt;&gt; int_to_roman(1980)MCMLXXX 结果与要求一致 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】螺旋矩阵]]></title>
      <url>%2F2017%2F06%2F23%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
      <content type="text"><![CDATA[螺旋矩阵是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。 问题 输出如图的螺旋矩阵 1234 1 2 3 412 13 14 511 16 15 610 9 8 7 附加题 输入一个正整数N，输出以N为边长的螺旋矩阵。 思路需要找到数字在二维数组中赋值的规律： 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0； 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值； 从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)； 然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)； 接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)； 最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)； 重复3-6步，直到最后赋的值等于N的平方 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# 打印输出螺旋矩阵def gen_matrix(n): # 用二维数组来代表矩阵 matrix = [[0 for col in range(n)] for row in range(n)] return matrixdef get_rota_matrix(n): mat = gen_matrix(n) # 初始矩阵，所有元素都为0 x = y = 0 total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1 while total != n * n: while y + 1 &lt; n and not mat[x][y + 1]: # 从左至右 y += 1 total += 1 mat[x][y] = total while x + 1 &lt; n and not mat[x + 1][y]: # 从上之下 x += 1 total += 1 mat[x][y] = total while y - 1 &gt;= 0 and not mat[x][y - 1]: # 从右至左 y -= 1 total += 1 mat[x][y] = total while x - 1 &gt;= 0 and not mat[x - 1][y]: # 从下至上 x -= 1 total += 1 mat[x][y] = total return matif __name__ == '__main__': n = int(input("请输入矩形数组的大小:")) matrix = get_rota_matrix(n) # print(matrix) for i in range(n): for j in range(n): print('%4d' % matrix[i][j], end=" ") print() 测试输出结果当N = 4 时：123456&gt;&gt;&gt; 请输入矩形数组的大小： 4 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 当N = 5 时：1234567&gt;&gt;&gt; 请输入矩形数组的大小： 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 结果与要求一致，可以输出任意N的螺旋矩阵。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++中的explicit关键字]]></title>
      <url>%2F2017%2F06%2F15%2FC-%E4%B8%AD%E7%9A%84explicit%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[隐式的类类型转换在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下： 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作转换构造函数(converting constructor) 也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。 转换示例下面就给出一个例子，一个类的构造函数可以被用于隐式转换： 123456789101112131415161718192021222324class Foo &#123;public: // 单形参构造函数，可以用作隐式转换 Foo(int foo) : m_foo(foo) &#123;&#125; int getFoo() &#123; return m_foo; &#125;private: int m_foo;&#125;;// 定义一个函数，接受Foo类型的形参void Bar(Foo foo)&#123; int i = foo.getFoo();&#125;// 主函数int main()&#123; Bar(42); return 0;&#125; 可以看到在main函数中，传入Bar的并不是一个Foo的对象，而是内置类型int，但类Foo的构造函数接受一个int，因此这个构造函数可以用来将参数转换成正确的类型。 使用explicit抑制构造函数定义的隐式转换为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个explicit关键字： 1explicit Foo(int foo) : m_foo(foo) &#123;&#125; 这样就可以有效防止隐式转换。之前在main函数中Bar(42)就会报错： void Bar(Foo): 无法将参数1从”int”转换为”Foo” 进行如下修改，对传入的int进行显式转换1Bar(Foo(42)) 这样就不会报错了。使用explicit关键字的原因是为了防止预想之外的情况发生。下面举个例子（感觉不太合适）： 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。 结论关于explicit的结论： 关键字explicit只对一个实参的构造函数有效 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit的 只能在类内声明构造函数时使用explicit关键字，在类外部定义式不应重复 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式(例如string s(&quot;Hello&quot;))使用。而且编译器将不会在自动转换过程中使用改构造函数。 如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为explicit的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。 参考资料[1]: Stack OverFlow - What does the explicit keyword mean? End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】校验文件哈希]]></title>
      <url>%2F2017%2F06%2F09%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E5%93%88%E5%B8%8C%2F</url>
      <content type="text"><![CDATA[我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。 问题 请使用Python写一个小程序，用来计算指定文件的哈希值。 附加题 可以指定哈希加密算法，并让程序尽可能简单易用。 思路问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库【每周一坑】程序员的浪漫,具体用法在之前的文章中也讲过了。 Python实现计算哈希值的函数123456789# 计算哈希值def generate_hash(file): with open(file, 'rb') as f: s = f.read() md5 = hashlib.md5(s).hexdigest() # 生成MD5 sha1 = hashlib.sha1(s).hexdigest() # 生成SHA1 sha256 = hashlib.sha256(s).hexdigest() # 生成SHA256 sha512 = hashlib.sha512(s).hexdigest() # 生成SHA512 return md5, sha1, sha256, sha512 可以指定哈希加密算法的函数12345678910111213141516# 计算哈希值def generate_hash_type(file, hash_type): with open(file, 'rb') as f: s = f.read() if hash_type.lower() == 'md5': hash_res = hashlib.md5(s).hexdigest() elif hash_type.lower() == 'sha1': hash_res = hashlib.sha1(s).hexdigest() elif hash_type.lower() == 'sha256': hash_res = hashlib.sha256(s).hexdigest() elif hash_type.lower() == 'sha512': hash_res = hashlib.sha512(s).hexdigest() else: print("Hash type error!") hash_res = "Type Error" return hash_type, hash_res 测试程序1234567if __name__ == '__main__': file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split()) md = generate_hash_type(file_path, hash_t) print(md,'\n') md = generate_hash(file_path) for i in md: print(i) 最后别忘了引入hashlib库: 1import hashlib 还有设置编码格式以防万一 1# -*- coding: utf-8 -*- 测试这里我使用的是Python官网下载的python-3.6.1-amd64.exe做的测试，官网也给出了它的md5哈希值，方便校验。首先是用generate_hash()函数，分别生成md5,sha1,sha256和sha512的校验码： 12&gt;&gt;&gt; please enter the path of the file:&gt;&gt;&gt; 文件路径，我这里是 C:\Users\Freed\Downloads\python-3.6.1-amd64.exe 输出结果为： md5ad69fdacde90f2ce8286c279b11ca188sha1bf54252c4065b20f4a111cc39cf5215fb1edccffsha256591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8sha512f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873 然后是输入路径+指定加密算法： 12&gt;&gt;&gt; please enter the path of the file and hash type:&gt;&gt;&gt; C:\Users\Freed\Downloads\python-3.6.1-amd64.exe md5 输出结果为： (‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’) 再来看看官网给出的md5： ad69fdacde90f2ce8286c279b11ca188 和程序计算的结果一致。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ Primer 第五版 练习 12.33]]></title>
      <url>%2F2017%2F06%2F07%2FC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A0-12-33%2F</url>
      <content type="text"><![CDATA[C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——文本查询程序。 文本查询程序 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。 文本查询程序设计设计两个类：TextQuery和QueryResult其中TextQuery用来生成每个单词对应的行号以及进行相关的查询操作；QuerResult用来保存查询结果，通过其成员函数print()输出查询结果。 查询程序的实现Query.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器， 指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员， 返回一个shared_ptr，指向QueryResult对象中的文件*/#include"12.22.h"// 定义了StrBlob类的头文件using std::shared_ptr;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;set&gt;// 为了定义函数query的返回类型，这个定义是必须的class QueryResult;class TextQuery &#123;public: TextQuery(std::ifstream&amp;); QueryResult query(const string&amp;) const;private: // 输入文件 shared_ptr&lt;StrBlob&gt; file; // 每个单词到它所在行号的映射 std::map&lt;std::string, shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;&#125;;class QueryResult &#123; using qr_iter = std::set&lt;StrBlob::size_type&gt;::iterator; friend std::ostream &amp;print(std::ostream&amp;, QueryResult&amp;);public: QueryResult(string s, shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; l, shared_ptr&lt;StrBlob&gt; f) : word(s), lines(l), file(f) &#123;&#125; qr_iter begin() const &#123; return lines-&gt;begin(); &#125; qr_iter end() const &#123; return lines-&gt;end(); &#125; shared_ptr&lt;StrBlob&gt; get_file() const &#123; return file; &#125;private: // 查询单词 string word; // 出现的行号 shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; lines; // 输入文件 shared_ptr&lt;StrBlob&gt; file;&#125;;std::ostream &amp;print(std::ostream &amp;os, QueryResult &amp;query_result); Query.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include "Query.h"#include&lt;iterator&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;//读取输入文件并建立单词到行号的映射TextQuery::TextQuery(std::ifstream &amp;ifs) : file(new StrBlob)&#123; // 保存行号 StrBlob::size_type line_no&#123; 0 &#125;; // 对文件中的每一行 for (string line; std::getline(ifs, line); ++line_no) &#123; // 保存此行文本 file-&gt;push_back(line); // 将文本分解为单词 std::istringstream stream(line); // 对行中每个单词 for (string text, word; stream &gt;&gt; text; word.clear()) &#123; // 去除单词中的标点符号 std::remove_copy_if(text.begin(), text.end(), std::back_inserter(word), ispunct); // 如果单词不在wordmap中，以之为下标在wordmap中添加一项 auto &amp;lines = wordmap[word]; // 第一次遇到这个单词时，lines的指针为空 // 分配一个新的set if (!lines) lines.reset(new std::set&lt;StrBlob::size_type&gt;); // 将此行号插入set中 lines-&gt;insert(line_no); &#125; &#125;&#125;QueryResult TextQuery::query(const string &amp;sought) const&#123; // 如果未找到sought，将返回一个指向此set的指针 static shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; nodata(new std::set&lt; StrBlob::size_type&gt;); // 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中 auto found = wordmap.find(sought); if (found != wordmap.end()) // 找到单词 return QueryResult(sought, found-&gt;second, file); else // 未找到 return QueryResult(sought, nodata, file);&#125;std::ostream &amp; print(std::ostream &amp;os, QueryResult &amp;query_result)&#123; // TODO: 在此处插入 return 语句 // 如果找到了单词，打印出现次数和所有出现的位置 os &lt;&lt; query_result.word &lt;&lt; " occurs " &lt;&lt; query_result.lines-&gt;size() &lt;&lt; " " &lt;&lt; (query_result.lines-&gt;size() &gt; 1 ? "times." : "time.") &lt;&lt; std::endl; // 打印单词出现的每一行 for (auto it = query_result.begin(); it != query_result.end(); ++it) &#123; ConstStrBlobPtr p(*query_result.file, *it); os &lt;&lt; "\t(line " &lt;&lt; *it + 1 &lt;&lt; ") " &lt;&lt; p.deref() &lt;&lt; std::endl; &#125; return os;&#125; 测试Query_test.cpp123456789101112131415161718192021#include"12.33.h"void runQueries(std::ifstream &amp;ifs)&#123; TextQuery text_query(ifs); do &#123; std::cout &lt;&lt; "Enter word to look for or q to quit: "; string word; if (!(std::cin &gt;&gt; word) || word == "q") break; print(std::cout, text_query.query(word)) &lt;&lt; std::endl; &#125; while (true);&#125;int main()&#123; std::ifstream ifs("data/story.txt"); runQueries(ifs); return 0;&#125; 总结这里用到了之前几节定义的StrBlob来代替vector&lt;string&gt;来保存每一行的内容。算是一个比较综合的练习了。刚开始做没什么思路，多亏了GayHub（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!(ง •̀_•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】验证哥德巴赫猜想]]></title>
      <url>%2F2017%2F05%2F28%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%AA%8C%E8%AF%81%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%2F</url>
      <content type="text"><![CDATA[哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。 问题描述本周题目 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。 示例： 1234&gt;&gt;&gt; Goldbach(123456)7 123449&gt;&gt;&gt; Goldbach(12345678)31 12345647 思路这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。 Python实现123456789101112131415161718192021222324252627282930import math# 求得小于等于n的所有质数def get_prime(n): prime = [] prime_dic = &#123;&#125; for i in range(2, n+1): prime_dic[i] = 1 for i in range(2, int(math.sqrt(n)) + 1): for j in range(i * i, n + 1, i): if prime_dic[i] == 1: prime_dic[j] = 0 for k, v in prime.items(): if v == 1: prime.append(k) return prime# 求满足猜想的质数和def gold_bach(n): cnt = 0 prime = get_prime(n) for prime1 in prime: prime2 = n - prime1 if prime2 in prime and cnt != 1: # 只输出一种结果 cnt += 1 return prime1. prime2if __name__ == '__main__'： print(gold_bach(123456)) print(gold_bach(12345678)) 输出结果print(gold_bach(123456)) (7, 123449) print(gold_bach(12345678)) (31, 12345647) 与示例一致。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ Primer 第五版 练习12.3]]></title>
      <url>%2F2017%2F05%2F26%2FC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A012-3%2F</url>
      <content type="text"><![CDATA[问题StrBlob需要const版本的push_back和pop_back吗？如果需要，添加进去。否则，解释为什么不需要。 定义StrBlob类首先，定义StrBlob类。类的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* StrBlob.h *//* 编写你自己的StrBlob类，包含const版本的front和back */#pragma once#include&lt;vector&gt;#include&lt;string&gt;#include&lt;initializer_list&gt;#include&lt;memory&gt;#include&lt;exception&gt;using std::vector;using std::string;class StrBlob &#123;public: using size_type = vector&lt;string&gt;::size_type; StrBlob() : data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125; StrBlob(std::initializer_list&lt;string&gt; il) : data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125; size_type size() cosnt &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; // 添加和删除元素 void push_back(const string &amp;t) &#123; data-&gt;push_back(t); &#125; void pop_back() &#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back(); &#125; // 元素访问 string &amp;front() &#123; // 如果vector为空，check会抛出一个异常 check(0, "front on empty StrBlob"); return data-&gt;front(); &#125; const string &amp;front() const &#123; check(0, "front on empty StrBlob"); return data-&gt;front(); &#125; string &amp;back() &#123; check(0, "back on empty StrBlob"); return data-&gt;back(); &#125; const string &amp;back() const &#123; check(0, "back on empty StrBlob"); return data-&gt;back(); &#125;private: void check(size_type i, const string &amp;msg) const &#123; if (i &gt;= data-&gt;size()) throw std::out_of_range(msg); &#125;private: std::shared_ptr&lt;vector&lt;string&gt;&gt; data; 测试非const StrBlob对象根据StrBlob的定义，我们来测试一下：首先声明一个StrBlob对象b1： StrBlob b1 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;}; // 非const对象 然后分别对b1调用push_back()和pop_back()： b1.push_back(&quot;test&quot;); // 向b1添加元素test 此时b1保存的内容是 a, an, the, test;接着就是 b1.pop_back(); // 删除刚刚添加的元素 此时b1保存的内容是 a, an, the;可以看到，我们定义的非const的StrBlob对象进行push_back()和pop_back()操作是没有问题的。 const StrBlob对象上面的操作都很顺利，那么当我们声明一个const StrBlob对象会怎么样呢？接下来，我们声明一个const类型的StrBlob对象： const StrBlob cb = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;}; // const 对象 同样的，我们对cb调用push_back()和pop_back()，看看会发生什么： cb.push_back(&quot;test&quot;); // 向cb添加元素test 运行一下程序，就会报错： Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;” cb.pop_back(); // 删除元素 在运行程序，同样也会报错： Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;” 原因是我们在定义StrBlob类时，push_back()和pop_back()并没有添const版本。那么，自然而然地，我们将添加const版本的push_back()和pop_back()，在StrBlob.h中添加以下代码: 1234567891011121314151617181920/* StrBlob.h */...void push_back(const string &amp;t) &#123; data-&gt;push_back(t); &#125;void pop_back()&#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back();&#125;// 添加const类型的push_back()和pop_back()void push_back(const string &amp;t) const &#123; data-&gt;push_back(t);&#125;void pop_back() const&#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back();&#125;... 再运行一下程序，通过了，并且输出和之前非const版本的一样。 讨论那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？ 如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的push_back()和pop_back()是必须的。但是要注意的是： 我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向vector&lt;string&gt;的智能指针；但由于类的封装，在使用者看来，数据成员是vector&lt;string&gt;，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是vector&lt;string&gt;的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像push_back()和pop_back()这样会改变智能指针所指向的vector&lt;string&gt;内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用push_back()和pop_back()成员函数，不能改变智能指针所指向的vector的内容了，这正好与类的使用者意图相符。 通过以上的考虑，我认为StrBlob不需要const版本的push_back和pop_back。 参考资料 [1]: 豆瓣 - 大家来讨论一下 exercise 12.3 [2]: Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function? End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】杨辉三角形]]></title>
      <url>%2F2017%2F05%2F19%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[问题描述本周题目 杨辉三角形，也称帕斯卡三角，其定义为：顶端是1，视为(row0).第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).以此类推第2行(row2)：0+1=1; 1+1=2; 1+0=1.第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1. 根据上述方法可产生杨辉三角。如下所示： 1234567n = 0 1 n = 1 1 1 n = 2 1 2 1 n = 3 1 3 3 1 n = 4 1 4 6 4 1 n = 5 1 5 10 10 5 1 n = ... ... ... 根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 Invalid query。 示例代码：123456789def yang_hui(m, n): ''' &gt;&gt;&gt;yang_hui(1, 1) 1 &gt;&gt;&gt;yang_hui(3,2) 3 &gt;&gt;&gt;yang_hui(1,4) Invalid query ''' 附加题生成杨辉三角形定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。示例代码： 1234567def generate_yh(m): ''' generate_yh(3): 1 1 1 1 2 1 ''' 思路根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：N &gt; M时，返回的应该是 Invalidquery。还有 n=0 或 n=m 时，返回的值应该为1.要求第(M,N)个数字，可以用递归的方式来求得：1yang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n) Python实现yang_hui(m,n):1234567# 输出杨辉三角中第m行第n列的数值def yang_hui(m, n): if n and n &gt; m: return "Invalid query!" if n == 0 or n == m: return 1 return yang_hui(m-1,n-1) + yang_hui(m-1,n) triangles(m):12345678910打印输出杨辉三角def triangles(m): ret = [1] while m: yield ret for i in range(1,len(ret)): ret[i] = pre[i] + pre[i-1] ret.append(1) pre = ret[:] m = m - 1 在生成杨辉三角的时候，用到了生成器(generator)。generator在执行过程中，遇到yield语句就返回，再次执行时从上次返回的yield语句处继续执行。普通函数和generator函数的区别：普通函数调用直接返回结果：123&gt;&gt;&gt; r = abs(6)&gt;&gt;&gt; r6 generator函数的“调用”实际返回一个generator对象：123&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; g&lt;generator object fib at 0x1022ef498&gt; 关于generator，可以参考这里。 测试123456789101112# 测试if __name__ == '__main__': print(yang_hui(0, 0)) print(yang_hui(1, 1)) print(yang_hui(1, 2)) print(yang_hui(6, 3)) print(yang_hui(4, 9)) # 打印杨辉三角 triangle = triangles(10) for i in triangle: print(i) 输出结果输出结果如下： 11Invalid query20Invalid query[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1] End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】神奇的九宫格]]></title>
      <url>%2F2017%2F05%2F15%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A5%9E%E5%A5%87%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[本周题目： 给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。 示例：1234567def Jiugongge(): ''' &gt;&gt;&gt; Jiugongge() 4 9 2 3 5 7 8 1 6 ''' 附加题： 给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。 比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。 思路在解决问题之前，要先了解一个东西 —— “幻方”。Wiki上给出的中文定义： 幻方(Magic Square)，有时又称魔方（该称呼现一般指立方体的魔术方块）或纵横图，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。 幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\dots ,N^{2}$，那么有$$M_{2}(N)={\frac {N(N^{2}+1)}{2}}$$ $N$阶幻方的解题思路分为三种情况： $N$为奇数 $N$为4的倍数 $N$为其他偶数 1. $N$为奇数 将$1$放在第一行中间一列； 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$； 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$； 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。 2. $N$为$4$的倍数采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。 3. $N$为非$4$的倍数的偶数(即$4n+2$)首先把大方阵分解为$4$个奇数字方阵。按上述奇数幻方给分解的4个子方阵对应赋值,其中：上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$即$4$个子方阵对应元素相差$v$，其中$v={\frac {n*n}{4}}$四个子矩阵由小到大排列方式为 $$ \begin{bmatrix} 1 &amp; 3 \ 4 &amp; 2 \ \end{bmatrix}$$ 然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\lt t或j\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中$k = n//2，t=(n-2)//4$。 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# n为奇数def oddN(): # 构造二维列表 lst = [[0 for i in range(n)] for i in range(n)] # 初始化列表位置 x, y = 0, n//2 for num in range(1, n*n+1): lst[x][y] = num xa, ya = x-1, y+1 # 回绕情况 if xa &lt; 0: xa = n-1 if ya &gt; n-1: ya = 0 # 占位情况 if lst[xa][ya] != 0: x = x+1 if x &gt; n-1: x = 0 else: x, y = xa, ya return lst # n为4的倍数def fourN(n): # 初始化列表 lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)] # 交换对角线位置 for i in range(n//2): lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i] lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i] return lst# n为非4倍数的偶数# 累加子矩阵def acc(p, lst): # print(lst) for row in lst: for index in range(len(row)): row[index] += p return lstdef fourNplus2(n): m = n // 2 A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m) B = acc(m ** 2, B) C = acc(m ** 2 * 2, C) D = acc(m ** 2 * 3, D) for row_index in range(len(A)): A[row_index].extend(C[row_index]) D[row_index].extend(B[row_index]) # 合并子矩阵 matrix = A + D t = (n - 2) // 4 # 列交换 for col_index in range(len(matrix[0])): if col_index &lt; t or col_index &gt; n - t: for row_index in range(len(matrix) // 2): matrix[row_index][col_index], matrix[row_index + m][col_index] = \ matrix[row_index + m][col_index], matrix[row_index][col_index] # 交换特殊位置 matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0] matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t] return matrix End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】求乘积最大]]></title>
      <url>%2F2017%2F05%2F03%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B1%82%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[本周题目： 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值 示例：1234567891011def product(num): ''' &gt;&gt;&gt;product(312) 62 &gt;&gt;&gt;product(1234) 492 &gt;&gt;&gt;product(12345) 6170 &gt;&gt;&gt;product(123456) 74070 ''' 思路从头到尾遍历这个数字串， 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果 以此类推…直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。 可以将每一步求出的值存入初始值为0的max_num中，每次求出的值都与max_num比较，若大于max_num，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。 Python实现12345678910111213141516171819# coding: utf-8def product(num): i = 1 max_num = 0 while i != len(str(num)): num1 = int(str(num)[:i]) num2 = int(str(num)[i:]) result = num1 * num2 # result = int(str(num)[:i]) * int(str(num)[i:]) if result &gt; max_num: max_num = result i += 1 return max_num# 测试print(product(312))print(product(1234))print(product(12345))print(product(123456)) 输出结果结果为： 62492617074070 结果与示例相符合 附加题上述的题目感觉还是比较简单的，因此多了一个附加题： 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。 示例：123456789def product_2(num): ''' &gt;&gt;&gt;product_2(1234) 1312 &gt;&gt;&gt;product_2(12345) 22412 &gt;&gt;&gt;product_2(123456) 342002 ''' 思路可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：itertools。它属于Python标准库，今天用到的是permutations()这个函数： permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同返回p中任意取r个元素做排列的元组的迭代器 例如： permutations(‘ABCD’, 2) 返回的结果为： AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD 有了这个函数，我们就可以完成附加题了 Python实现1234567891011121314151617181920# coding: utf-8from itertools import permutationsdef product_2(num): i = 1 max_num = 0 for p in permutations(str(num)): new_num = "".join(p) # 排列后返回的是一个元组，通过join()来重新生成数字串 # print(new_num) result = product(new_num) # 就是上面的product() if result &gt; max_num: max_num = result return max_num # 测试print(product_2(1234))print(product_2(12345))print(product_2(123456)) 输出结果结果为： 131222412342002 与示例一致 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】程序员的浪漫]]></title>
      <url>%2F2017%2F04%2F27%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB%2F</url>
      <content type="text"><![CDATA[关注了Crossin的编程教室，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。 问题如下： 在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符： ‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n’ 在此给出4个选项 我们在一起吧 我选择原谅你 别说话，吻我 多喝热水 使用科学的方法算出说的是什么。 思路其实思路也挺简单，hashlib里有MD5模块，只需调用 hashlib.md5(“要生成MD5的字符串”) 即可生成。 而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数： base64.b64decode(“已知的字符串”) 即可得到解码后的内容。 最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。 Python实现1234567891011121314151617import base64, hashlib # 引入需要使用的库answer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n' # 问题中的字符串checkStr = &#123;'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'&#125; # 将选项存入字典，后面使用def main(): for x in checkStr: # 遍历字典中的个字符串 md5 = hashlib.md5(x.encode('utf-8')) # 使用hashlib.md5()进行编码 md5_byte = bytes(md5.hexdigest().encode('utf-8')) # base64.decode()得到的是bytes类型的， # 无法直接与string比较，这里把string类型的md5转换成bytes类型的 b64_byte = base64.decode(answer) if md5_byte == b64_byte: print('The answer is', x) if __name__ == '__main__': main() 输出结果万！万！没！想！到！ 结果居然是…. 多喝热水 说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧… 然而… 和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭ End~ [1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数返回数组指针或数组引用]]></title>
      <url>%2F2017%2F04%2F15%2F%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E6%88%96%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%2F</url>
      <content type="text"><![CDATA[因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。下面就介绍几种方法： 方法一： 使用类型别名1234typedef int arrT[10]; // arrT是一个类型别名，表示的类型 // 是含有10个整型的数组using arrT = int[10]; // arrT的等价声明arrT* func(int i); // func返回一个指向含有10个整数的数组的指针 其中arrT是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此func函数接受一个int实参，返回一个指向包含10个整数的数组的指针。 方法二： 声明一个返回数组指针的函数要想在声明func时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：123int arr[10]; // arr是一个含有10个整数的数组int *p1[10]; // p1是一个含有10个指针的数组int (*p2)[10] = &amp;arr; // p2是一个指针，他只想含有10个整数的数组 和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示： Type (*function(parameter_list)) [dimension] 类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。(*function(parameter_list))两段的括号必须存在，就像定义p2时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。 举个具体点的例子，下面这个func函数的声明没有使用类型别名：1int (*func(int i)) [10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i)表示调用func函数时需要一个int类型的实参 (*func(int i))意味这我们可以对函数调用的结果执行解引用操作 (*func(int i)) [10]表示解引用func的调用将得到一个大小是10的数组 int(*func(int i)) [10]表示数组中元素是int类型 方法三： 使用尾置返回类型在C++11新标准中海油可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto： 12// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*) [10]; 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 方法四： 使用decltype还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：1234567int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;// 返回一个指针，该指针指向含有5个整数的数组decltype(odd) *addPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even; // 返回一个指向数组的指针&#125; arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个*符号。 练习1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。1string (&amp;func(string (&amp;arr)[10])) [10]; 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。12345678910// 使用类型别名using arrT = string[10];arrT&amp; func1(arrT&amp; arr);// 使用尾置返回类型auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];// 使用decltype关键字string arrS[10];decltype(arrS) &amp;func3(arrT&amp; arr); 3. 修改arrPtr函数，使其返回数组的引用123456int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;decltype(odd) &amp;arrPtr(int i)&#123; return (i % 2) ? odd : even;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++前置递增（递减）和后置递增（递减）运算符]]></title>
      <url>%2F2017%2F04%2F07%2FC-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E5%92%8C%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在做C++ primer 第五版课后习题4.31时遇到一个问题： 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。 源程序代码如下：12345vector&lt;int&gt;::size_type cnt = ivec.size();// 将把从size到1的值赋给ivec的元素for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; 可以看到源程序用的是前置递增和递减运算符我根据源代码写了一下可运行的版本：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 然后根据题目的意思，使用了后置版本的递增和递减运算符：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 结果一样啊喂！(＃°Д°)哪里需要修改了(╯‵□′)╯︵┻━┻各种百度没有没百度到，突然想起来可以找课后练习答案啊！找到了结果，还以为我错了，没想到答案居然是… We use prefix and not postfix, just because of the Advice: Use Postfix Advice: Use Postfix Operators only When Necessary.So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:12for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; This is not an appropriate example to discuss the difference of prefix and postfix. 果然不是我的问题 ( •̀ ω •́ )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ string输入问题]]></title>
      <url>%2F2017%2F03%2F31%2FC-string%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[问题描述 使用cin读入一组字符串并存入一个vector对象 代码实现使用如下代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;/*用cin读入一组字符串并把它们存入一个vector对象*/int main()&#123; vector&lt;string&gt; text; string word; while (getline(cin, word)) &#123; text.push_back(word); &#125; cout &lt;&lt; "["; for (auto i : text) if (i == text.back()) cout &lt;&lt; i; else cout &lt;&lt; i &lt;&lt; ","; cout &lt;&lt; "]"; return 0;&#125; 在运行测试时发现了一个问题：当输入为 aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的) 按回车后发现输出卡出了，并不会输出所输入的字符串 当输入为 aa ss dd qq ww ee^Z(换行后的^Z) 就可以正确输出了 解决办法百思不得其解，遂百度之。看到了两种解释，感觉都有道理，就都贴上来好了1. 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。 2. windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。 意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给出一个表达式，按照顺序求出表达式的值]]></title>
      <url>%2F2017%2F03%2F25%2F%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%2F</url>
      <content type="text"><![CDATA[按顺序求出表达式的值今天碰到一个题目：题目描述： 常规的表达式求值，我们都会根据计算的优先级来计算， 比如*、/的优先级就高于+、-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有/，只有(+,-和*)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入描述： 输入为一行字符串，即一个表达式。其中运算符只有+,-和*。参与计算的数字只有0-9。保证表达式是合法的，排列规则如样例所示。 输出描述 输出一个数，即表达式的值 输入例子 3+5*7 输出例子 56 刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的… C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * 输入字符串表达式，按照输入顺序求出表达式的结果 */#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;cmath&gt;using namespace std;// 字符串转数字int get_number(string num_str)&#123; stringstream stream; // 声明stringstram变量 int result = 0; int str_len = num_str.length(); stream &lt;&lt; num_str; stream &gt;&gt; result; return result;&#125;int main()&#123; string s; // 保存输入的字符串 cout &lt;&lt; "请输入要计算的表达式(不包含除):" &lt;&lt; endl; cin &gt;&gt; s; int number[100] = &#123; 0 &#125;; // 保存数字的数组 string operator_str; // 保存操作符的字符串 int length = s.length(); string number_str; // 保存每个操作符之前的字符串 int index = 0; // 标记保存数字的数组的指针 for (int i = 0; i &lt; length; i++) &#123; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') // 如果是数字，则存入 number_str &#123; number_str += s[i]; &#125; else // 如果是操作符，存入operator_str &#123; operator_str += s[i]; number[index] = get_number(number_str); // 得到两个操作符之间的操作数，并存入数组 index++; number_str = ""; // 将字符串置为空，重新存入下一个操作数的字符串 &#125; if (i == length -1) // 得到表达式的最后一个操作数 &#123; number[index] = get_number(number_str); index++; &#125; &#125; int result = 0; // 计算结果 for (int i = 0; i &lt; index; i++) &#123; //todo 计算结果 if (i&lt;1) &#123; result += number[i]; &#125; else &#123; switch (operator_str[i-1]) &#123; case '+': result = result + number[i]; break; case '-': result = result - number[i]; break; case '*': result = result * number[i]; break; default: break; &#125; &#125; //cout &lt;&lt; number[i] &lt;&lt; endl; &#125; //for (int i = 0; i &lt; operator_str.length(); i++) //&#123; // cout &lt;&lt; operator_str[i] &lt;&lt; endl; //&#125; //cout &lt;&lt; "输入的字符串为:" &lt;&lt; s &lt;&lt; " 得到的数字为: " &lt;&lt; number &lt;&lt; endl; cout &lt;&lt; "Result = " &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125; 挺简单的题目，居然写了这么多！ (:3」∠) 太久没写了，写的有点丑¬¬，看来还是要多练习 (ง •̀•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python生成词云]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%2F</url>
      <content type="text"><![CDATA[Python如何生成词云最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P通过度娘发现可以用Python库来生成词云， So Let’s go! 用到的库WorldCloud 官网: https://amueller.github.io/word_cloud github: https://github.com/amueller/word_cloud 安装WordCloud通过PIP安装pip install wordcloud 下载WHL包安装当然可能通过PIP会安装出错，我们可以下WHL包手动安装 下载完成后，再使用PIP命令安装： pip install yourfilepath\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl 其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl。 使用WordlCloud安装完成后，就可以用了。可以先测试以下是否安装成功： from wordcould import WordCloud 如果没有报错，表示安装成功了。 源代码下面就是源码部分了:1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from wordcloud import WordCloudimport matplotlib.pyplot as pltfrom scipy.misc omport imread# 读入一个文件text = open('your text file.txt', 'r').read()# 读入图片bg_pic = imread('your picture.png')# 配置词云参数wc = WordCloud( # 设置背景色,我这里设置为了黑色 background_color = 'black', # 设置词云形状，就是之前读入的图片 mask = bg_pic, # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块 font_path = 'Sketch Fine Serif.otf')# 生成词云wordcloud = wc.generate(text)# 显示词云图片plt.imshow(wordcloud)plt.axis('off')plt.show()# 保存图片wordcloud.to_file('wordcloud.jpg') 生成的词云效果如图: 参数其中配置词云参数的时候，有多个参数可选： Parameters1font_path : string Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path. 1width : int (default=400) Width of the canvas. 1height : int (default=200) Height of canvas 1prefer_horizontal : float (default=0.90) The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.) 1mask : nd-array or None (default=None) If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!] 1scale : float (default=1) Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words. 1min_font_size : int (default=4) Smallest font size to use. Will stop when there is no more room in this size. 1font_step : int (default=1) Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit. 1max_words : number (default=200) The maximum number of words. 1stopwords : set of strings or None The words that will be eliminated. If None, the build-in STOPWORDS list will be used. 1background_color : color value (default=”black”) Background color for the word cloud image. 1max_font_size : int or None (default=None) Maximum font size for the largest word. If None, height of the image is used. 1mode : string (default=”RGB”) Transparent background will be generated when mode is “RGBA” and background_color is None. 1relative_scaling : float (default=.5) Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good. 1color_func : callable, default=None Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead. 1regexp : string or None (optional) Regular expression to split the input text into tokens in process_text. If None is specified, r”\w[\w’]+” is used. 1collocations : bool, default=True Whether to include collocations (bigrams) of two words. 1colormap : string or matplotlib colormap, default=”viridis” Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified. 1normalize_plurals : bool, default=True Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’. 以上就是所有可以配置的参数，可以根据需要来用。 End~ [1]: 图片出处: https://github.com/amueller/word_cloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python脚本抓取Bing美图]]></title>
      <url>%2F2017%2F03%2F23%2FPython3%E8%84%9A%E6%9C%AC%E6%8A%93%E5%8F%96Bing%E7%BE%8E%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[使用Python脚本下载Bing美图Bing首页每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。 Bing美图APIBing官方有两个API：xml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1json版： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1有了API就可以愉快地抓图了:D Python抓图至于为什么要用Python，前段时间学习了廖大的Python教程,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！ 用到的库 Requests Beautiful Soup 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import requestsimport reimport timeimport osimport jsonfrom bs4 import BeautifulSoupdef downloadPic(file_name, picurl): # 判断文件夹是否存在，如果不存在就新建 if os.path.exists(r'C:\Users\Freed\Pictures\bingwallpaper'): print('Find dir already...') else: print('Dir not found, makdir...') os.mkdir(r'C:\Users\Freed\Pictures\bingwallpaper') print('success...') if os.path.exists(r'c:\users\freed\pictures\bingwallpaper\\' + file_name): print('downlaod already...') else: pic = getHtml(picurl) fp = open(r'c:\users\freed\pictures\bingwallpaper\\' + file_name, 'wb') fp.write(pic) fp.close() def getHtml(url): r = requests.get(url) return r.contenturl = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'json_str = getHtml(url) # 得到的是strjson_str = json_str.decode()print(type(json_str))#print(json_str)json_list = json_str.split(',') # 得到list#print(json_list)pic_head = 'http://s.cn.bing.net'json_url = ''json_url = json_url.join(json_list[3])picurl = json_url[7:-1]picurl = pic_head + picurlprint(picurl)# 设置图片名称file_name = str("BingWallPaper-" + time.strftime('%Y-%m-%d',time.localtime(time.time())) + '.jpg')downloadPic(file_name, picurl) 用Pthon命令运行文件即可。到此大功告成! :D]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
