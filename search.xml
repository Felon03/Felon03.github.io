<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[LeetCode 19. Remove Nth Node From End of List]]></title>
      <url>%2F2018%2F01%2F09%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
      <content type="text"><![CDATA[ProblemGive a linked list, remove the $n^{th}$ node from the end of list and return its head. Example Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. NoteGiven n will always be valid.Try do this in one pass. Answer单链表结构定义123456// Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 普通方法(遍历两次链表)先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素： 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int cnt = 0; ListNode *p1 = head, *p2 = head; while (p1) &#123; ++cnt; p1 = p1-&gt;next; &#125; int j = 0; if (cnt == n) return head-&gt;next; while (j &lt; cnt - n - 1) &#123; j++; p2 = p2-&gt;next; &#125; auto tmp = p2-&gt;next; p2-&gt;next = p2-&gt;next-&gt;next; delete tmp; return head; &#125;&#125;; New Meta(使用二级指针，遍历一次链表)1234567891011121314151617181920212223242526class Solution&#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 利用二级指针删除元素 ListNode **t1 = &amp;head, *t2 = head; // 将t2向后移动n位，此时t2的位置在len(head) - n for (int i = 1; i &lt; n; ++i) t2 = t2-&gt;next; // 当t2的下一个节点不为空时，开始移动t1 while (t2-&gt;next) &#123; // t1指向下一个元素指针的地址 t1 = &amp;((*t1)-&gt;next); t2 = t2-&gt;next; &#125; // 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址 // 因此我们需要删除该元素,并使t1指向下一个元素指针的地址 auto tmp = *t1; *t1 = (*t1)-&gt;next; delete tmp; return head; &#125;&#125;; 使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 751. IP to CIDR]]></title>
      <url>%2F2017%2F12%2F29%2FLeetCode-751-IP-to-CIDR%2F</url>
      <content type="text"><![CDATA[ProblemGiven a start IP address ip and a number of ips we need to cover n, return a representation of the range as a list (of smallest possible length) of CIDR blocks. A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range. Example 1 Input: ip = “255.0.0.7”, n = 10Output: [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]Explanation:The initial ip address, when convered to binary, look like this (spaces added for clarity):255.0.0.7 -&gt; 1111111 00000000 00000000 00000111The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,ie. just this one address. The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:255.0.0.8 -&gt; 11111111 00000000 0000000 00001000Address with common prefix of 29 bits are:11111111 00000000 00000000 0000100011111111 00000000 00000000 0000100111111111 00000000 00000000 0000101011111111 00000000 00000000 0000101111111111 00000000 00000000 0000110011111111 00000000 00000000 0000110111111111 00000000 00000000 0000111011111111 00000000 00000000 00001111 The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,ie. just 11111111 00000000 00000000 00010000 In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 . There were other representations, such as:[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],but our answer was the shortest possible. Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100that are outside the specified range. Note ip will be a valid IPv4 address. Every implied address ip + x (for x &lt; n) will be a valid IPv4 address. n will be an integer in the range [1, 1000]. Answer这个问题是在给定的起始IP地址，求最少的CIDR正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。 先说明一下255.255.0.8/29中29的含义：一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。 比如我们以255.0.0.7开始，覆盖30个地址，那么就有： 255.0.0.7/32只有一个IP地址 剩余30 - 1 = 29 接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21 8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5 接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1 那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖至此可以得到最少的CIDR。 实现代码将IP转为数字: 12345678910111213141516171819202122vector&lt;string&gt; split(const string &amp;str, char delim)&#123; stringstream ss(str); string word; vector&lt;string&gt; ret; while (getline(ss, word, delim)) &#123; ret.emplace_back(word); &#125; return ret;&#125;int ip2Num(const string &amp;ip)&#123; vector&lt;string&gt; vec = split(ip, '.'); int num = 0; num = static_cast&lt;int&gt;(stoi(vec[0)); num = num &lt;&lt; 8 | static_cast&lt;int&gt;(stoi(vec[1])); num = num &lt;&lt; 8 | static_cast&lt;int&gt;(stoi(vec[2])); num = num &lt;&lt; 8 | static_cast&lt;int&gt;(stoi(vec[3])); return num;&#125; 数字转换为IP123456789101112131415string num2Ip(int num)&#123; vector&lt;string&gt; vec; for (int i = 0; i &lt; 4; ++i) &#123; vec.emplace_back(to_string(num &amp; 0xff)); num &gt;&gt;= 8; &#125; string ret; ret.append(vec[3] + '.'); ret.append(vec[2] + '.'); ret.append(vec[1] + '.'); ret.append(vec[0]); return ret;&#125; 主函数1234567891011121314151617181920212223vector&lt;string&gt; ipToCIDR(string ip, int range)&#123; vector&lt;string&gt; ret; unsigned num = ip2Num(ip); while (range) &#123; int weight = 1; int i = 0; while (i &lt; 32) &#123; weight &lt;&lt;= 1; if ((1 &lt;&lt; i &amp; num) || (weight &gt; range)) break; ++i; &#125; weight &gt;&gt;= 1; range -= weight; ret.emplace_back(num2Ip(num) + "/" + to_string(32 - i)); num += weight; &#125; return ret;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Visual Studio项目中集成Google Test测试框架]]></title>
      <url>%2F2017%2F11%2F17%2FVisual-Studio%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Google-Test%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。 VS2015下配置Google Test下载Google TestGoogle Test是Google旗下的一个单元测试框架。下载地址在Release中，在release页面下，有它的历史版本，我们下载最新的即可。 解压下载的文件，可以看到两个文件夹，这里我们要用的是googletest文件夹下的内容，其他的可以不用管。 解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的include和src。其中include用于配置项目时添加到包含目录中；src是Google Test框架的源码。 配置Google Test(2018-04-04更新)感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇博客。 下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。 新建项目打开VS2105，新建项目-&gt;Win32控制台应用程序，我们将项目名称设置为SimpleTest。然后选择空项目，完成即可。 我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下： 123456789101112131415161718192021// simple_math.h#pragma once#include &lt;cmath&gt;double square(double num)&#123; return pow(num, 2);&#125;// simple_math.cpp#include "simple_math.h"#include &lt;iostream&gt;using namespace std;int main()&#123; auto ans = square(10); return 0;&#125; 我们在simple_math.h中定义了一个square函数，返回传入的参数的平方值。并在simple_math.cpp中调用了该函数。可以按Ctrl+F5来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。 配置Google Test接下来我们右键最上面的解决方案，选择添加-&gt;新建项目-&gt;Win32项目，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择静态库，取消预编译头，然后点击完成。 现在解决方案下面有两个项目，一个是我们之前创建的项目SimpleTest，一个是刚刚创建的GoogleTest。 下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录，我们在包含目录中添加Google Test相关文件。我们googletest文件夹和googletest目录下的include文件夹都添加进去，然后点击确定。 接着再给GoogleTest项目添加源文件。右键GoogleTest的源文件-&gt;添加-&gt;现有项，把之前提到的src目录下的gtest_main.cc和gtest-all.cc添加进去。 现在GoogleTest项目下有两个源文件。 生成静态库上述配置完成后，我们右键GoogleTest-&gt;生成，就可以生成GoogleTest的静态库了。 添加单元测试下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目UnittestSimpleTest，右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序，选择空项目，然后完成即可。 现在我们的解决方案中共有三个项目：GoogleTest，SimpleTest，UnittestSimpleTest。 同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。 添加完包含目录后，再为其添加引用：右键UnittestSimpleTest-&gt;添加-&gt;引用，将GoogleTest和SimpleTest全勾上 单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。 新建测试我们现在可以添加源文件，编写单元测试了。新建一个源文件test.cpp，编写代码如下：12345678// test.cpp#include "simple_math.h"#include "gtest/gtest.h"TEST(testSquare, mySquareTest)&#123; EXPECT_EQ(100, square(10));&#125; 然后我们将UnittestSimpleTest作为启动项目（右键项目-&gt;设为启动项目），然后运行即可。运行结果如图所示。 将现有的项目作为引用添加到其他项目中在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。 百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为静态库给新的项目引用，解决方法如下：右键项目-&gt;属性-&gt;配置属性-&gt;常规，将目标文件扩展名改为.lib，然后在下面的项目默认值中的配置类型改为静态库。 然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示： 在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。 参考链接 C++ TUTORIAL - GOOGLE TEST (GTEST) 带你玩转Visual Studio——带你发布自己的工程库 带你玩转Visual Studio——带你多工程开发 GTEST基础学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】注册表单验证]]></title>
      <url>%2F2017%2F10%2F13%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[用Python实现类似于网页表单信息验证的功能。 基本要求： 需要输入邮箱地址、密码两项 邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格 密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有） 重名验证 思路：通过正则表达式来实现 正则表达式正则表达式库Python中有正则表达式标准库，引入正则表达式库Re即可: 1import re 由于Python的字符串本身也用\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。 正则表达式特殊字符在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考正则表达式-菜鸟教程。 特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如*表示匹配某字符串零次或多次，如果想要匹配*，则需要转义，即匹配\*，这样就是匹配*这个字符。正则表达式的特殊字符如下表所示： 特殊字符 描述 $ 匹配输入字符串的结尾位置 () 标记一个子表达式的开始和结束位置 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符\n之外的任何单字符 [] 标记一个中括号表达式的开始和结束位置 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 \ 将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符 ^ 匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集 {} 标记限定符表达式的开始 &#124; 指明两项之间的一个选择 验证邮箱1checkEmail = re.compile(r'^(\w+_?-?\.?\w*)@([\w+\.]+[a-zA-Z]+$)') 验证密码1checkPwd = re.compile(r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$') 重名验证没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。 12345678910111213141516171819# 打开存储邮箱地址的文档，如果不存在则新建if no os.path.exists('./users.txt'): f = open('./users.txt', 'w') f.close() # 读取文本中的邮箱地址，存入一个list，后面验证重名时使用with open('./users.txt', 'r') as f: userName = f.readlines()# 验证重名def check_email(email_address): while not checkEmail.match(email_address): email_address = input('邮箱地址格式不正确，请重新输入: ') if email_address + '\n' in userName: email_address = input('邮箱地址已注册，请输入其他邮箱: ') check_email(email_address) else: print('邮箱地址可用!') return email_address 验证密码是否符合要求12345def check_pwd(password): while not checkPwd.match(password): print('密码需要8位以上，包含大小写和数字。请重新输入。') password = input('密码: ') return password 主程序12345678910111213# check email addressemailAdd = input('请输入邮箱地址: ')emailAdd = check_email(emailAdd)print('邮箱地址: ', emailAdd)# check passwordpwd = input('密码: ')pwd = check_pwd(pwd)# 保存新注册的邮箱with open('./users.txt', 'a') as f: f.write(emailAdd + '\n')print('注册成功!')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树相关问题(转载)]]></title>
      <url>%2F2017%2F10%2F09%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[文章转自 http://blog.csdn.net/walkinginthewind/article/details/7518888 二叉树树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。 二叉树节点定义1234567/* Definition for a binary tree node*/struct TreeNode &#123; int val; TreeNode* left; // left tree node TreeNode* right; // right tree node TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; // ctor&#125;; 问题列表二叉树的大部分题目都应用了递归，时刻往递归结构去思考。 1. 求二叉树中的节点个数2. 求二叉树的深度3. 前序、中序、后序遍历4. 其他遍历二叉树方法（深度、广度优先）5. 将二叉查找树变为有序的双向链表6. 求二叉树第K层的节点个数7. 求二叉树中叶子节点的个数8. 判断两棵二叉树结构是否相同9. 判断二叉树是不是平衡二叉树10. 求二叉树的镜像11. 求二叉树中两个节点的最低公共祖先节点12. 求二叉树中节点的最大距离13. 由前序遍历序列和中序遍历序列重建二叉树14. 判断二叉树是不是完全二叉树 详细解答求二叉树中的节点个数递归解法： 如果二叉树为空，节点个数为 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1 参考代码：12345int getNodeNum(TreeNode* root)&#123; if (!root) return 0; // 递归出口 return getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + 1;&#125; 求二叉树的深度递归解法： 如果二叉树为空，二叉树的深度为0 如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1 参考代码：1234567int getDepth(TreeNode* root)&#123; if (!root) return 0; // 递归出口 int depthLeft = getDepth(root-&gt;left); int depthRight = getDepth(root-&gt;right); return depthLeft &gt; depthRight ? depthLeft + 1 : depthRight + 1;&#125; 前序、中序、后序遍历前序遍历递归解法： 如果二叉树为空，空操作 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树 参考代码：1234567void preOrderTraverse(TreeNode* root)&#123; if (!root) return; visit(root); // 访问根结点 preOrderTraverse(root-&gt;left); // 前序遍历左子树 preOrderTraverse(root-&gt;right); // 前序遍历右子树&#125; 中序遍历递归解法： 如果二叉树为空，空操作 如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树 参考代码：1234567void inOrderTraverse(TreeNode* root)&#123; if (!root) return; inOrderTraverse(root-&gt;left); // 中序遍历左子树 visit(root)； // 访问根结点 inOrderTraverse(root-&gt;right); // 中序遍历右子树&#125; 后序遍历递归解法： 如果二叉树为空，空操作 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点 参考代码：1234567void postOrderTraverse(TreeNode* root)&#123; if (!root) return; postOrderTraverse(root-&gt;left); // 后序遍历左子树 postOrderTraverse(root-&gt;right); // 后序遍历右子树 visit(root); // 访问根结点&#125; 其他遍历二叉树方法(深度、广度优先)深度优先遍历解法： 借助一个栈（后进先出）来实现深度遍历 先访问根结点 遍历左子树接着遍历右子树 参考代码：123456789101112131415void DFS(TreeNode* root)&#123; if (!root) return; stack&lt;TreeNode*&gt; nodeStack; nodeStack.push(root); while (!nodeStack.empty()) &#123; TreeNode *tmp = nodeStack.top(); visit(tmp); nodeStack.pop(); if (tmp-&gt;right) nodeStack.push(tmp-&gt;right); if (tmp-&gt;left) nodeStack.push(tmp-&gt;left); &#125;&#125; 广度优先遍历解法： 借助队列（先进先出）来实现广度优先遍历 将根节点入队 当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队 参考代码：1234567891011121314void BFS(TreeNode* root)&#123; if (!root) return; queue&lt;TreeNode*&gt; nodeQueue; q.push(root); while (!nodeQueue.empty()) &#123; TreeNode *tmp = q.front(); q.pop(); visit(tmp); if (tmp-&gt;left) nodeQueue.push(tmp-&gt;left); if (tmp-&gt;right) nodeQueue.push(tmp-&gt;right);&#125; 将二叉查找树变为有序的双向链表要求不创建新节点，只调整指针。递归解法： 如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL 如果二叉查找树不为空： 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作； 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接； 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作； 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041/** * root: 二叉查找树的根结点指针 * pFirstNode: 转换后双向有序链表的第一个节点指针 * pLastNode: 转换后双向有序链表的最后一个节点指针 **/ void convert(TreeNode* root, TreeNode* &amp;pFirstNode, TreeNode* &amp;pLastNode) &#123; TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight; if (!root) &#123; pFirstNode = NULL; pLastNode = NULL; return; &#125; if (!root-&gt;left) // 如果左子树为空，对应双向有序链表的第一个节点是根节点 pFirstNode = root; else &#123; convert(root-&gt;left, pFirstLeft, pLastLeft); // 二叉查找树对应双向有序链表的第一个节点就是 // 左子树转换后双向有序链表的第一个节点 pFristNode = pFirstLeft; // 将根节点与左子树转换后的双向有序链表的最后一个节点连接 root-&gt;left = pLastLeft; pLastLeft-&gt;right = root; &#125; if (!root-&gt;right) // 对应双向有序链表的最后一个节点是根节点 pLastNode = root; else &#123; convert(root-&gt;right, pFirstRight, pLastRight); // 对应双向有序链表的最后一个节点就是 // 右子树转换后双向有序链表的最后一个节点 pLastNode = pLastRight; // 将根节点和右子树转换后的双向有序链表的第一个节点连接 root-&gt;right = pFirstRight; pFirstRight-&gt;left = root; &#125;&#125; 求二叉树第K层的节点个数递归解法: 如果二叉树为空或者k &lt; 1，返回0 如果二叉树不为空且k = 1，返回1 如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和 参考代码：123456789int getKthLevelNodeNum(TreeNode* root)&#123; if (!roo || k &lt; 1) return 0; if (k == 1) return 1; int leftNum = getKthLevelNodeNum(root-&gt;left); // 左子树中k-1层节点个数 int rightNum = getKthLevelNodeNum(root-&gt;right); // 右子树中k-1层节点个数 return (leftNum + rightNum);&#125; 求二叉树中叶子节点的个数递归解法： 如果二叉树为空，返回0 如果二叉树不为空且左右子树为空，返回1 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数 参考代码：123456789int getLeafNodeNum(TreeNode* root)&#123; if (!root) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; int numLeft = getLeafNodeNum(root-&gt;left); // 左子树中叶节点个数 int numRight = getLeafNodeNum(root-&gt;right); // 右子树中叶节点个数 return (numLeft + numRight);&#125; 判断两棵二叉树结构是否相同不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。递归解法: 如果两棵二叉树都为空，返回真 如果两颗二叉树一棵为空，另一个不为空，返回假 如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假 参考代码：12345678bool structureCmp(TreeNode* lhs, TreeNode* rhs)&#123; if (!lhs &amp;&amp; !rhs) return true; // 都为空树，返回真 else if (!lhs || !rhs) return false; // 一个为空而另一个不为空，返回假bool resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left); // 比较对应左子树bool resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); // 比较对应右子树return (resultLeft &amp;&amp; resultRight);&#125; 判断二叉树是不是平衡二叉树递归解法： 如果二叉树为空，返回真 如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假 参考代码：123456789101112131415161718192021boo isAVL(TreeNode* root, int &amp;height)&#123; if (!root) &#123; // 空树，返回真 height = 0; return true; &#125; int heightLeft; bool resultLeft = isAVL(root-&gt;left, heightLeft); int heightRight; bool resultRight = isAVL(root-&gt;right, heightRight); if (resultLeft &amp;&amp; resultRight &amp;&amp; abs(heightLeft - heightRight) &lt;= 1)&#123; // 左右子树都是AVL树，并且高度差不大于1，返回真 height = max(heightLeft, heightRight) + 1; return true; &#125; else &#123; height = max(heightLeft, heightRight) + 1; return false; &#125;&#125; 求二叉树的镜像递归解法： 如果二叉树为空，返回空 如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树 参考代码：1234567891011TreeNode* mirrorTree(TreeNode* root)&#123; if (!root) return NULL; TreeNode *leftTree = mirrorTree(root-&gt;left); // 求左子树镜像 TreeNode *rightTree = mirrorTree(root-&gt;right); // 求右子树镜像 // 交换左右子树 root-&gt;left = leftTree; root-&gt;right = rightTree; return root;&#125; 求二叉树中两个节点的最低公共祖先节点递归解法： 如果两个节点分别在根结点的左子树和右子树，则返回根结点 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树 参考代码：12345678910111213141516171819202122232425262728bool findNode(TreeNode* root, TreeNode *pNode)&#123; if (!root || !pNode) return false; if (root == pNode) return true; bool found = findNode(root-&gt;left, pNode); if (!found) found = findNode(root-&gt;right, pNode); return found;&#125;TreeNode* getLowestCommonAncestor(TreeNode* root, TreeNode* pNode1, TreeNode* pNode2)&#123; if (findNode(root-&gt;left, pNode1)) &#123; if (findNode(root-&gt;right, pNode2)) return root; else return getLowestCommonAncestor(root-&gt;left, pNode1, pNode2); &#125; else &#123; if (find(root-&gt;left, pNode2)) return root; else return getLowestCommonAncestor(root-&gt;right, pNode1, pNode2); &#125;&#125; 递归解法效率较低，有很多重复遍历，下面看一下非递归解法。 非递归解法：先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344bool getNodePath(TreeNode* root, TreeNode* pNode, list&lt;TreeNode*&gt; &amp;path)&#123; if (root == pNode) &#123; path.push_back(root); return true; &#125; if (!root) return false; path.push_back(root); bool found = false; found = getNodePath(root-&gt;left, pNode, path); if (!found) found = getNodePath(root-&gt;right, pNode, path); if (!found) path.pop_back(); return found;&#125;TreeNode* getLowestCommonAncestor(TreeNode *root, TreeNode* pNode1, TreeNode* pNode2)&#123; if (!root || !pNode1 || !pNode2) return NULL; list&lt;TreeNode*&gt; path1; bool result1 = getNodePath(root, pNode1, path1); list&lt;TreeNode*&gt; path2; bool result2 = getNodePath(root, pNode2, path2); if (!result1 || !result2) return NULL; TreeNode* pLast = NULL; list&lt;TreeNode*&gt;::iterator iter1 = path1.begin(); list&lt;TreeNode*&gt;::iterator iter2 = path2.begin(); while (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123; if (*iter1 == *iter2) pLast = *iter1; else break; ++iter1; ++iter2; &#125; return pLast;&#125; 在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。 求二叉树中节点的最大距离即二叉树中相距最远的两个节点之间的距离。递归解法： 如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0 如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离 参考代码：123456789101112131415161718192021222324252627282930int getMaxDistance(TreeNode* root, int &amp;maxLeft, int &amp;maxRight)&#123; // maxLeft: 左子树中的节点离根节点的最远距离 // maxRight: 右子树中的节点离根节点的最远距离 if (!root) &#123; maxLeft = 0; maxRight = 0; return 0; &#125; int maxLL, maxLR, maxRL, maxRR; int maxDistLeft, maxDistRight; if (root-&gt;left) &#123; maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR); maxLeft = max(maxLL, maxLR) + 1; &#125; else &#123; maxDistLeft = 0; maxLeft = 0; &#125; if (root-&gt;right) &#123; maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR); maxRight = max(maxRL, maxRR) + 1; &#125; else &#123; maxDistRight = 0; maxRight = 0; &#125; return max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);&#125; 由前序遍历序列和中序遍历序列重建二叉树二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。递归解法： 如果前序遍历为空或者节点个数小于等于0，返回NULL。 创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 参考代码：123456789101112131415161718192021222324252627282930313233343536/** * pPreOrder: 前序遍历序列 * pInOrder: 中序遍历序列 * nodeNum: 二叉树节点数 **/TreeNode* rebuildTree(int* pPreOrder, int* pInOrder, int nodeNum)&#123; if (!pPreOrder || !pInOrder || nodeNum &lt;= 0) return NULL; TreeNode* root = new TreeNode; // 前序遍历的第一个节点就是根节点 root-&gt;val = pPreOrder[0]; root-&gt;left = NULL; root-&gt;right = NULL; // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树 int rootPoistionInOrder = -1; for (int i = 0; i &lt; nodeNum; ++i) &#123; if (pInOrder[i] == root-&gt;val) &#123; rootPositionInOrder = i; break; &#125; &#125; if (rootPositionInOrder == -1) throw std::exception("Invalid Input."); // 重建左子树 int nodeNumLeft = rootPositionInOrder; int* pPreOrderLeft = pPreOrder + 1; int* pInOrderLeft = pInOrder; root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft); // 重建右子树 int nodeNumRight = nodeNum - nodeNumLeft -1; int* pPreOrderRight = pPreOrder + 1 + nodeNumLeft; int* pInOrderRight = pInOrder + nodeNumLeft + 1; root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight); return root;&#125; 同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树 判断二叉树是不是完全二叉树若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。如何判断是否为完全二叉树：按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树 参考代码：1234567891011121314151617181920212223242526272829303132333435bool isCompleteTree(TreeNode* root)&#123; if (!root) return false; queue&lt;TreeNode*&gt; nodeQueue; nodeQueue.push(root); bool mustHaveNoChild = false; bool result = true; while (!nodeQueue.empty()) &#123; TreeNode* pNode = nodeQueue.front(); nodeQueue.pop(); if (mustHaveNoChild) &#123; // 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点) if (pNode-&gt;left || pNode-&gt;right) &#123; result = false; break; &#125; &#125; else &#123; if (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123; nodeQueue.push(pNode-&gt;left); nodeQueue.push(pNode-&gt;right); &#125; else if (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123; mustHaveNoChild = true; nodeQueue.push(pNode-&gt;left); &#125; else if (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123; result = false; break; &#125; else mastHaveNoChild = true; &#125; &#125; return result;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UTF-8 码点]]></title>
      <url>%2F2017%2F10%2F09%2FUTF-8-%E7%A0%81%E7%82%B9%2F</url>
      <content type="text"><![CDATA[UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节： 码点范围 码点位数 字节1 字节2 字节3 字节4 U+0000~U+007F 7 0xxxxxxx U+0080~U+07FF 11 110xxxxx 10xxxxxx U+0800~U+FFFF 16 1110xxxx 10xxxxxx 10xxxxxx U+10000~U+10FFFF 21 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 1000 0000 -&gt; 80 1100 0000 -&gt; C0 1110 0000 -&gt; E0 1111 0000 -&gt; F0 1111 1111 -&gt; FF 0011 1111 -&gt; 3F e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF 所以0x20AC有16位码点,编成三字节 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即 0010 0000 1010 1100 将其分成三组： 0010， 000010， 101100 加上前缀： 1110 0010, 1000 0010, 1010 1100 则得到 0xE2, 0x82, 0xAC 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010 0000 0010 &amp; 1111 1111 -&gt; 0000 0010 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010 1000 0010 &amp; 0011 1111 -&gt; 0000 0010 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC 代码表示(C): 1234567891011121314151617// u &lt;= 0x007FPUTC(c, u &amp; 0xFF);// u &lt;= 0x07FFPUTC(c, 0xC0 | ((u &gt;&gt; 6) &amp; 0xFF));PUTC(c, 0x80 | (u &amp; 0x3F);// u &lt;= 0xFFFFPUTC(c, 0xE0 | ((u &gt;&gt; 12) &amp; 0xFF));PUTC(c, 0x80 | ((u &gt;&gt; 6) &amp; 0x3F));PUTC(c, 0x80 | (u &amp; 0x3F));// u &lt;= 0x10FFFFPUTC(c, 0xF0 | ((u &gt;&gt; 18) &amp; 0xFF));PUTC(c, 0x80 | ((u &gt;&gt; 12) &amp; 0x3F));PUTC(c, 0x80 | ((u &gt;&gt; 6) &amp; 0x3F));PUTC(c, 0x80 | (u &amp; 0x3F));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】矩阵旋转]]></title>
      <url>%2F2017%2F09%2F06%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[本次的题目是关于矩阵旋转的 问题 给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。举例：1 2 34 5 67 8 9旋转后输出的结果应该是：7 4 18 5 29 6 3 附加要求 在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。 解法1. 使用额外的空间顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。 如：1 2 34 5 67 8 9取出每一列作为新的行：1 4 72 5 83 6 9再将每一行反转就得到了：7 4 18 5 29 6 3 代码如下： 123456789101112131415def rotate(matrix): """ :param matrix: List(List(int)) :return: List(List(int)) """ res = [] if len(matrix[0]) == 0: return matrix for i in range(len(matrix[0])): l = [] for subList in matrix: l.append(subList[i]) l.reverse() res.append(l) return res 2. 在原矩阵上进行操作旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (原博客) 代码如下： 1234567891011121314151617181920212223'''将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照对角线对称交换以后再进行反转后得到的'''def rotate1(matrix): """ :param matrix: List(List(int)) :return: matrix """ if len(matrix[0]) == 0: return matrix for i in range(len(matrix)): j = i + 1 while j &lt; len(matrix[0]): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] j += 1 for i in range(len(matrix)): # print(matrix[i]) matrix[i].reverse() # print(matrix[i]) # matrix.reverse() # print(matrix) return matrix 参考资料CSDN Blog — 二维数组旋转90度(by @lynne233) End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】阿姆斯特朗数]]></title>
      <url>%2F2017%2F08%2F04%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0%2F</url>
      <content type="text"><![CDATA[快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~ 一个经典的编程练习题： 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数 问题 输出1000以内的所有阿姆斯特朗数。 附加题 输入一个整数，输出距离它最近的阿姆斯特朗数。 思路一眼看到阿姆斯特朗就想到了《银魂》阿姆斯特朗回旋加速喷气式阿姆斯特朗炮了，果然银魂毁节操QAQ。 回到主题，其实阿姆斯特朗数和水仙花数差不多。满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\cdots d_1 $，则有 n = d\_k^k + d\_{k-1}^k+\cdots+d\_2^k+d\_1^k编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。 12345678temp = numwhile temp: # 求出每位数的k次幂的和 res += (temp % 10)**n num //= 10if res == num: # 如果满足阿姆斯特朗数的条件，就返回这个数 return num Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# 得到bound以内的阿姆斯特朗数，bound默认为1000def get_number(bound=1000): armstrong_number = [] for i in range(bound): temp = i n = len(str(i)) res = 0 while temp: res += (temp % 10) ** n temp //= 10 if res == i: armstrong_number.append(i) return armstrong_number# 得到离number最近的阿姆斯特朗数def get_nearest_number(num): if is_arm_num(num): return num temp = num res = get_number(temp)[-1] while not is_arm_num(temp): temp += 1 res_new = temp if abs(res_new - num) &lt; abs(res - num): return res_new else: return res# 判断num是否是阿姆斯特朗数def is_arm_num(num): temp = num res = 0 n = len(str(num)) while temp: res += (temp % 10) ** n temp //= 10 return res == numif __name__ == '__main__': print(get_number()) print(get_nearest_number(390)) print(get_nearest_number(389)) 测试输出结果 12345678&gt;&gt;&gt; get_number(1000)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]&gt;&gt;&gt; get_nearest_number(390)407&gt;&gt;&gt; get_nearest_number(389)371 满足问题要求 参考资料[1]: Wiki 水仙花数 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】罗马数字转换]]></title>
      <url>%2F2017%2F07%2F08%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。 罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9 在一个数的上面画一条横线，表示这个数曾1000倍 常见罗马字符表 数字 罗马字符 数字 罗马字符 1 Ⅰ 2 Ⅱ 3 Ⅲ 4 Ⅳ 5 Ⅴ 6 Ⅵ 7 Ⅶ 8 Ⅷ 9 Ⅸ 10 Ⅹ 40 XL 50 L 90 XC 100 C 400 CD 500 D 900 CM 1000 M 2000 MM 2500 MMD 问题编写一个罗马数字和阿拉伯数字的转换器： 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980 附加题 给定一个小于3999的整数，将其转换为罗马数 示例： 1234567891011def romanToInt(s): # your code return iassert romanToInt('III') == 3assert romanToInt('IV') == 4assert romanToInt('VI') == 6assert romanToInt('XIX') == 19assert romanToInt('XX') == 20assert romaToInt('XLV') == 45assert romanToInt('MCMLXXX') == 1980 思路罗马数转阿拉伯数根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，左边的罗马数均比右边的小，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以将罗马数字符反转，然后从头遍历，如果当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字。 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)： 第一位是X，表示10，pre = 0，res = 0 + 10 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000 经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确 阿拉伯数(整数)转罗马数将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0 如1980，(res表示结果): 1980 // 1000 = 1, res += M, 1980 % 1000 = 980 980 // 900 = 1, res += CM, 980 % 900 = 80 80 // 50 = 1, res += L, 80 % 50 = 30 30 // 10 = 3, res += 3*X, 30 % 10 = 0 经过上述步骤即可得整数1980 = MCMLXXX Python实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-# 罗马数字转换# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC# 400CCC;CD 500D 900CM 1000M 2500MMD# e.g.# 3-&gt;III# 4-&gt;IV# 6-&gt;VI# 19-&gt;XIX# 45-&gt;XLV# 999-&gt;CMXCIX# 1980-&gt;MCMLXXX# 3999-&gt;MMMCMXCIX# 罗马转数字def roman_to_int(s): roman_int_dic = &#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &#125; s = s[::-1] res, pre = 0, 0 for x in s: if roman_int_dic[x] &gt;= pre: res += roman_int_dic[x] pre = roman_int_dic[x] else: res -= roman_int_dic[x] pre = roman_int_dic[x] return res # 数字转罗马def int_to_roman(i): dic = &#123; 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' &#125; res = "" for k in dic: if i != 0: res += i // k * dic[k] i %= k return res# 测试if __name__ == '__main__': result = roman_to_int('MMMCMXCIX') print(result) int_res = int_to_roman(3999) print(int_res) result = roman_to_int('MCMLXXX') print(result) int_res = int_to_roman(1980) print(int_res) assert roman_to_int('III') == 3 assert roman_to_int('IV') == 4 assert roman_to_int('VI') == 6 assert roman_to_int('XIX') == 19 assert roman_to_int('XLV') == 45 assert roman_to_int('MCMLXXX') == 1980 assert roman_to_int('CMXCIX') == 999 print("OK") 测试输出结果 1234567891011&gt;&gt;&gt; roman_to_int('MMMCMXCIX')3999&gt;&gt;&gt; int_to_roman(3999)MMMCMXCIX&gt;&gt;&gt; roman_to_int(MCMLXXX)1980&gt;&gt;&gt; int_to_roman(1980)MCMLXXX 结果与要求一致 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】螺旋矩阵]]></title>
      <url>%2F2017%2F06%2F23%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
      <content type="text"><![CDATA[螺旋矩阵是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。 问题 输出如图的螺旋矩阵 1234 1 2 3 412 13 14 511 16 15 610 9 8 7 附加题 输入一个正整数N，输出以N为边长的螺旋矩阵。 思路需要找到数字在二维数组中赋值的规律： 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0； 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值； 从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)； 然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)； 接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)； 最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)； 重复3-6步，直到最后赋的值等于N的平方 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# 打印输出螺旋矩阵def gen_matrix(n): # 用二维数组来代表矩阵 matrix = [[0 for col in range(n)] for row in range(n)] return matrixdef get_rota_matrix(n): mat = gen_matrix(n) # 初始矩阵，所有元素都为0 x = y = 0 total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1 while total != n * n: while y + 1 &lt; n and not mat[x][y + 1]: # 从左至右 y += 1 total += 1 mat[x][y] = total while x + 1 &lt; n and not mat[x + 1][y]: # 从上之下 x += 1 total += 1 mat[x][y] = total while y - 1 &gt;= 0 and not mat[x][y - 1]: # 从右至左 y -= 1 total += 1 mat[x][y] = total while x - 1 &gt;= 0 and not mat[x - 1][y]: # 从下至上 x -= 1 total += 1 mat[x][y] = total return matif __name__ == '__main__': n = int(input("请输入矩形数组的大小:")) matrix = get_rota_matrix(n) # print(matrix) for i in range(n): for j in range(n): print('%4d' % matrix[i][j], end=" ") print() 测试输出结果当N = 4 时：123456&gt;&gt;&gt; 请输入矩形数组的大小： 4 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 当N = 5 时：1234567&gt;&gt;&gt; 请输入矩形数组的大小： 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 结果与要求一致，可以输出任意N的螺旋矩阵。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++中的explicit关键字]]></title>
      <url>%2F2017%2F06%2F15%2FC-%E4%B8%AD%E7%9A%84explicit%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[隐式的类类型转换在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下： 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作转换构造函数(converting constructor) 也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。 转换示例下面就给出一个例子，一个类的构造函数可以被用于隐式转换： 123456789101112131415161718192021222324class Foo &#123;public: // 单形参构造函数，可以用作隐式转换 Foo(int foo) : m_foo(foo) &#123;&#125; int getFoo() &#123; return m_foo; &#125;private: int m_foo;&#125;;// 定义一个函数，接受Foo类型的形参void Bar(Foo foo)&#123; int i = foo.getFoo();&#125;// 主函数int main()&#123; Bar(42); return 0;&#125; 可以看到在main函数中，传入Bar的并不是一个Foo的对象，而是内置类型int，但类Foo的构造函数接受一个int，因此这个构造函数可以用来将参数转换成正确的类型。 使用explicit抑制构造函数定义的隐式转换为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个explicit关键字： 1explicit Foo(int foo) : m_foo(foo) &#123;&#125; 这样就可以有效防止隐式转换。之前在main函数中Bar(42)就会报错： void Bar(Foo): 无法将参数1从”int”转换为”Foo” 进行如下修改，对传入的int进行显式转换1Bar(Foo(42)) 这样就不会报错了。使用explicit关键字的原因是为了防止预想之外的情况发生。下面举个例子（感觉不太合适）： 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。 结论关于explicit的结论： 关键字explicit只对一个实参的构造函数有效 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit的 只能在类内声明构造函数时使用explicit关键字，在类外部定义式不应重复 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式(例如string s(&quot;Hello&quot;))使用。而且编译器将不会在自动转换过程中使用改构造函数。 如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为explicit的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。 参考资料[1]: Stack OverFlow - What does the explicit keyword mean? End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】校验文件哈希]]></title>
      <url>%2F2017%2F06%2F09%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E5%93%88%E5%B8%8C%2F</url>
      <content type="text"><![CDATA[我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。 问题 请使用Python写一个小程序，用来计算指定文件的哈希值。 附加题 可以指定哈希加密算法，并让程序尽可能简单易用。 思路问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库【每周一坑】程序员的浪漫,具体用法在之前的文章中也讲过了。 Python实现计算哈希值的函数123456789# 计算哈希值def generate_hash(file): with open(file, 'rb') as f: s = f.read() md5 = hashlib.md5(s).hexdigest() # 生成MD5 sha1 = hashlib.sha1(s).hexdigest() # 生成SHA1 sha256 = hashlib.sha256(s).hexdigest() # 生成SHA256 sha512 = hashlib.sha512(s).hexdigest() # 生成SHA512 return md5, sha1, sha256, sha512 可以指定哈希加密算法的函数12345678910111213141516# 计算哈希值def generate_hash_type(file, hash_type): with open(file, 'rb') as f: s = f.read() if hash_type.lower() == 'md5': hash_res = hashlib.md5(s).hexdigest() elif hash_type.lower() == 'sha1': hash_res = hashlib.sha1(s).hexdigest() elif hash_type.lower() == 'sha256': hash_res = hashlib.sha256(s).hexdigest() elif hash_type.lower() == 'sha512': hash_res = hashlib.sha512(s).hexdigest() else: print("Hash type error!") hash_res = "Type Error" return hash_type, hash_res 测试程序1234567if __name__ == '__main__': file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split()) md = generate_hash_type(file_path, hash_t) print(md,'\n') md = generate_hash(file_path) for i in md: print(i) 最后别忘了引入hashlib库: 1import hashlib 还有设置编码格式以防万一 1# -*- coding: utf-8 -*- 测试这里我使用的是Python官网下载的python-3.6.1-amd64.exe做的测试，官网也给出了它的md5哈希值，方便校验。首先是用generate_hash()函数，分别生成md5,sha1,sha256和sha512的校验码： 12&gt;&gt;&gt; please enter the path of the file:&gt;&gt;&gt; 文件路径，我这里是 C:\Users\Freed\Downloads\python-3.6.1-amd64.exe 输出结果为： md5ad69fdacde90f2ce8286c279b11ca188sha1bf54252c4065b20f4a111cc39cf5215fb1edccffsha256591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8sha512f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873 然后是输入路径+指定加密算法： 12&gt;&gt;&gt; please enter the path of the file and hash type:&gt;&gt;&gt; C:\Users\Freed\Downloads\python-3.6.1-amd64.exe md5 输出结果为： (‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’) 再来看看官网给出的md5： ad69fdacde90f2ce8286c279b11ca188 和程序计算的结果一致。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ Primer 第五版 练习 12.33]]></title>
      <url>%2F2017%2F06%2F07%2FC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A0-12-33%2F</url>
      <content type="text"><![CDATA[C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——文本查询程序。 文本查询程序 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。 文本查询程序设计设计两个类：TextQuery和QueryResult其中TextQuery用来生成每个单词对应的行号以及进行相关的查询操作；QuerResult用来保存查询结果，通过其成员函数print()输出查询结果。 查询程序的实现Query.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器， 指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员， 返回一个shared_ptr，指向QueryResult对象中的文件*/#include"12.22.h"// 定义了StrBlob类的头文件using std::shared_ptr;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;set&gt;// 为了定义函数query的返回类型，这个定义是必须的class QueryResult;class TextQuery &#123;public: TextQuery(std::ifstream&amp;); QueryResult query(const string&amp;) const;private: // 输入文件 shared_ptr&lt;StrBlob&gt; file; // 每个单词到它所在行号的映射 std::map&lt;std::string, shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;&#125;;class QueryResult &#123; using qr_iter = std::set&lt;StrBlob::size_type&gt;::iterator; friend std::ostream &amp;print(std::ostream&amp;, QueryResult&amp;);public: QueryResult(string s, shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; l, shared_ptr&lt;StrBlob&gt; f) : word(s), lines(l), file(f) &#123;&#125; qr_iter begin() const &#123; return lines-&gt;begin(); &#125; qr_iter end() const &#123; return lines-&gt;end(); &#125; shared_ptr&lt;StrBlob&gt; get_file() const &#123; return file; &#125;private: // 查询单词 string word; // 出现的行号 shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; lines; // 输入文件 shared_ptr&lt;StrBlob&gt; file;&#125;;std::ostream &amp;print(std::ostream &amp;os, QueryResult &amp;query_result); Query.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include "Query.h"#include&lt;iterator&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;//读取输入文件并建立单词到行号的映射TextQuery::TextQuery(std::ifstream &amp;ifs) : file(new StrBlob)&#123; // 保存行号 StrBlob::size_type line_no&#123; 0 &#125;; // 对文件中的每一行 for (string line; std::getline(ifs, line); ++line_no) &#123; // 保存此行文本 file-&gt;push_back(line); // 将文本分解为单词 std::istringstream stream(line); // 对行中每个单词 for (string text, word; stream &gt;&gt; text; word.clear()) &#123; // 去除单词中的标点符号 std::remove_copy_if(text.begin(), text.end(), std::back_inserter(word), ispunct); // 如果单词不在wordmap中，以之为下标在wordmap中添加一项 auto &amp;lines = wordmap[word]; // 第一次遇到这个单词时，lines的指针为空 // 分配一个新的set if (!lines) lines.reset(new std::set&lt;StrBlob::size_type&gt;); // 将此行号插入set中 lines-&gt;insert(line_no); &#125; &#125;&#125;QueryResult TextQuery::query(const string &amp;sought) const&#123; // 如果未找到sought，将返回一个指向此set的指针 static shared_ptr&lt;std::set&lt;StrBlob::size_type&gt;&gt; nodata(new std::set&lt; StrBlob::size_type&gt;); // 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中 auto found = wordmap.find(sought); if (found != wordmap.end()) // 找到单词 return QueryResult(sought, found-&gt;second, file); else // 未找到 return QueryResult(sought, nodata, file);&#125;std::ostream &amp; print(std::ostream &amp;os, QueryResult &amp;query_result)&#123; // TODO: 在此处插入 return 语句 // 如果找到了单词，打印出现次数和所有出现的位置 os &lt;&lt; query_result.word &lt;&lt; " occurs " &lt;&lt; query_result.lines-&gt;size() &lt;&lt; " " &lt;&lt; (query_result.lines-&gt;size() &gt; 1 ? "times." : "time.") &lt;&lt; std::endl; // 打印单词出现的每一行 for (auto it = query_result.begin(); it != query_result.end(); ++it) &#123; ConstStrBlobPtr p(*query_result.file, *it); os &lt;&lt; "\t(line " &lt;&lt; *it + 1 &lt;&lt; ") " &lt;&lt; p.deref() &lt;&lt; std::endl; &#125; return os;&#125; 测试Query_test.cpp123456789101112131415161718192021#include"12.33.h"void runQueries(std::ifstream &amp;ifs)&#123; TextQuery text_query(ifs); do &#123; std::cout &lt;&lt; "Enter word to look for or q to quit: "; string word; if (!(std::cin &gt;&gt; word) || word == "q") break; print(std::cout, text_query.query(word)) &lt;&lt; std::endl; &#125; while (true);&#125;int main()&#123; std::ifstream ifs("data/story.txt"); runQueries(ifs); return 0;&#125; 总结这里用到了之前几节定义的StrBlob来代替vector&lt;string&gt;来保存每一行的内容。算是一个比较综合的练习了。刚开始做没什么思路，多亏了GayHub（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!(ง •̀_•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】验证哥德巴赫猜想]]></title>
      <url>%2F2017%2F05%2F28%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%AA%8C%E8%AF%81%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%2F</url>
      <content type="text"><![CDATA[哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。 问题描述本周题目 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。 示例： 1234&gt;&gt;&gt; Goldbach(123456)7 123449&gt;&gt;&gt; Goldbach(12345678)31 12345647 思路这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。 Python实现123456789101112131415161718192021222324252627282930import math# 求得小于等于n的所有质数def get_prime(n): prime = [] prime_dic = &#123;&#125; for i in range(2, n+1): prime_dic[i] = 1 for i in range(2, int(math.sqrt(n)) + 1): for j in range(i * i, n + 1, i): if prime_dic[i] == 1: prime_dic[j] = 0 for k, v in prime.items(): if v == 1: prime.append(k) return prime# 求满足猜想的质数和def gold_bach(n): cnt = 0 prime = get_prime(n) for prime1 in prime: prime2 = n - prime1 if prime2 in prime and cnt != 1: # 只输出一种结果 cnt += 1 return prime1. prime2if __name__ == '__main__'： print(gold_bach(123456)) print(gold_bach(12345678)) 输出结果print(gold_bach(123456)) (7, 123449) print(gold_bach(12345678)) (31, 12345647) 与示例一致。 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ Primer 第五版 练习12.3]]></title>
      <url>%2F2017%2F05%2F26%2FC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A012-3%2F</url>
      <content type="text"><![CDATA[问题StrBlob需要const版本的push_back和pop_back吗？如果需要，添加进去。否则，解释为什么不需要。 定义StrBlob类首先，定义StrBlob类。类的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* StrBlob.h *//* 编写你自己的StrBlob类，包含const版本的front和back */#pragma once#include&lt;vector&gt;#include&lt;string&gt;#include&lt;initializer_list&gt;#include&lt;memory&gt;#include&lt;exception&gt;using std::vector;using std::string;class StrBlob &#123;public: using size_type = vector&lt;string&gt;::size_type; StrBlob() : data(std::make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125; StrBlob(std::initializer_list&lt;string&gt; il) : data(std::make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125; size_type size() cosnt &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; // 添加和删除元素 void push_back(const string &amp;t) &#123; data-&gt;push_back(t); &#125; void pop_back() &#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back(); &#125; // 元素访问 string &amp;front() &#123; // 如果vector为空，check会抛出一个异常 check(0, "front on empty StrBlob"); return data-&gt;front(); &#125; const string &amp;front() const &#123; check(0, "front on empty StrBlob"); return data-&gt;front(); &#125; string &amp;back() &#123; check(0, "back on empty StrBlob"); return data-&gt;back(); &#125; const string &amp;back() const &#123; check(0, "back on empty StrBlob"); return data-&gt;back(); &#125;private: void check(size_type i, const string &amp;msg) const &#123; if (i &gt;= data-&gt;size()) throw std::out_of_range(msg); &#125;private: std::shared_ptr&lt;vector&lt;string&gt;&gt; data; 测试非const StrBlob对象根据StrBlob的定义，我们来测试一下：首先声明一个StrBlob对象b1： StrBlob b1 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;}; // 非const对象 然后分别对b1调用push_back()和pop_back()： b1.push_back(&quot;test&quot;); // 向b1添加元素test 此时b1保存的内容是 a, an, the, test;接着就是 b1.pop_back(); // 删除刚刚添加的元素 此时b1保存的内容是 a, an, the;可以看到，我们定义的非const的StrBlob对象进行push_back()和pop_back()操作是没有问题的。 const StrBlob对象上面的操作都很顺利，那么当我们声明一个const StrBlob对象会怎么样呢？接下来，我们声明一个const类型的StrBlob对象： const StrBlob cb = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;}; // const 对象 同样的，我们对cb调用push_back()和pop_back()，看看会发生什么： cb.push_back(&quot;test&quot;); // 向cb添加元素test 运行一下程序，就会报错： Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;” cb.pop_back(); // 删除元素 在运行程序，同样也会报错： Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;” 原因是我们在定义StrBlob类时，push_back()和pop_back()并没有添const版本。那么，自然而然地，我们将添加const版本的push_back()和pop_back()，在StrBlob.h中添加以下代码: 1234567891011121314151617181920/* StrBlob.h */...void push_back(const string &amp;t) &#123; data-&gt;push_back(t); &#125;void pop_back()&#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back();&#125;// 添加const类型的push_back()和pop_back()void push_back(const string &amp;t) const &#123; data-&gt;push_back(t);&#125;void pop_back() const&#123; check(0, "pop_back on empty StrBlob"); data-&gt;pop_back();&#125;... 再运行一下程序，通过了，并且输出和之前非const版本的一样。 讨论那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？ 如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的push_back()和pop_back()是必须的。但是要注意的是： 我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向vector&lt;string&gt;的智能指针；但由于类的封装，在使用者看来，数据成员是vector&lt;string&gt;，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是vector&lt;string&gt;的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像push_back()和pop_back()这样会改变智能指针所指向的vector&lt;string&gt;内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用push_back()和pop_back()成员函数，不能改变智能指针所指向的vector的内容了，这正好与类的使用者意图相符。 通过以上的考虑，我认为StrBlob不需要const版本的push_back和pop_back。 参考资料 [1]: 豆瓣 - 大家来讨论一下 exercise 12.3 [2]: Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function? End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】杨辉三角形]]></title>
      <url>%2F2017%2F05%2F19%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[问题描述本周题目 杨辉三角形，也称帕斯卡三角，其定义为：顶端是1，视为(row0).第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).以此类推第2行(row2)：0+1=1; 1+1=2; 1+0=1.第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1. 根据上述方法可产生杨辉三角。如下所示： 1234567n = 0 1 n = 1 1 1 n = 2 1 2 1 n = 3 1 3 3 1 n = 4 1 4 6 4 1 n = 5 1 5 10 10 5 1 n = ... ... ... 根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 Invalid query。 示例代码：123456789def yang_hui(m, n): ''' &gt;&gt;&gt;yang_hui(1, 1) 1 &gt;&gt;&gt;yang_hui(3,2) 3 &gt;&gt;&gt;yang_hui(1,4) Invalid query ''' 附加题生成杨辉三角形定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。示例代码： 1234567def generate_yh(m): ''' generate_yh(3): 1 1 1 1 2 1 ''' 思路根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：N &gt; M时，返回的应该是 Invalidquery。还有 n=0 或 n=m 时，返回的值应该为1.要求第(M,N)个数字，可以用递归的方式来求得：1yang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n) Python实现yang_hui(m,n):1234567# 输出杨辉三角中第m行第n列的数值def yang_hui(m, n): if n and n &gt; m: return "Invalid query!" if n == 0 or n == m: return 1 return yang_hui(m-1,n-1) + yang_hui(m-1,n) triangles(m):12345678910打印输出杨辉三角def triangles(m): ret = [1] while m: yield ret for i in range(1,len(ret)): ret[i] = pre[i] + pre[i-1] ret.append(1) pre = ret[:] m = m - 1 在生成杨辉三角的时候，用到了生成器(generator)。generator在执行过程中，遇到yield语句就返回，再次执行时从上次返回的yield语句处继续执行。普通函数和generator函数的区别：普通函数调用直接返回结果：123&gt;&gt;&gt; r = abs(6)&gt;&gt;&gt; r6 generator函数的“调用”实际返回一个generator对象：123&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; g&lt;generator object fib at 0x1022ef498&gt; 关于generator，可以参考这里。 测试123456789101112# 测试if __name__ == '__main__': print(yang_hui(0, 0)) print(yang_hui(1, 1)) print(yang_hui(1, 2)) print(yang_hui(6, 3)) print(yang_hui(4, 9)) # 打印杨辉三角 triangle = triangles(10) for i in triangle: print(i) 输出结果输出结果如下： 11Invalid query20Invalid query[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1] End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】神奇的九宫格]]></title>
      <url>%2F2017%2F05%2F15%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A5%9E%E5%A5%87%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[本周题目： 给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。 示例：1234567def Jiugongge(): ''' &gt;&gt;&gt; Jiugongge() 4 9 2 3 5 7 8 1 6 ''' 附加题： 给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。 比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。 思路在解决问题之前，要先了解一个东西 —— “幻方”。Wiki上给出的中文定义： 幻方(Magic Square)，有时又称魔方（该称呼现一般指立方体的魔术方块）或纵横图，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。 幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\dots ,N^{2}$，那么有 M_{2}(N)={\frac {N(N^{2}+1)}{2}} $N$阶幻方的解题思路分为三种情况： $N$为奇数 $N$为4的倍数 $N$为其他偶数 1. $N$为奇数 将$1$放在第一行中间一列； 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$； 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$； 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。 2. $N$为$4$的倍数采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。 3. $N$为非$4$的倍数的偶数(即$4n+2$)首先把大方阵分解为$4$个奇数字方阵。按上述奇数幻方给分解的4个子方阵对应赋值,其中：上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$即$4$个子方阵对应元素相差$v$，其中$v={\frac {n*n}{4}}$四个子矩阵由小到大排列方式为 \begin{bmatrix} 1 & 3 \\ 4 & 2 \\ \end{bmatrix}然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\lt t或j\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中$k = n//2，t=(n-2)//4$。 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# n为奇数def oddN(): # 构造二维列表 lst = [[0 for i in range(n)] for i in range(n)] # 初始化列表位置 x, y = 0, n//2 for num in range(1, n*n+1): lst[x][y] = num xa, ya = x-1, y+1 # 回绕情况 if xa &lt; 0: xa = n-1 if ya &gt; n-1: ya = 0 # 占位情况 if lst[xa][ya] != 0: x = x+1 if x &gt; n-1: x = 0 else: x, y = xa, ya return lst # n为4的倍数def fourN(n): # 初始化列表 lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)] # 交换对角线位置 for i in range(n//2): lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i] lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i] return lst# n为非4倍数的偶数# 累加子矩阵def acc(p, lst): # print(lst) for row in lst: for index in range(len(row)): row[index] += p return lstdef fourNplus2(n): m = n // 2 A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m) B = acc(m ** 2, B) C = acc(m ** 2 * 2, C) D = acc(m ** 2 * 3, D) for row_index in range(len(A)): A[row_index].extend(C[row_index]) D[row_index].extend(B[row_index]) # 合并子矩阵 matrix = A + D t = (n - 2) // 4 # 列交换 for col_index in range(len(matrix[0])): if col_index &lt; t or col_index &gt; n - t: for row_index in range(len(matrix) // 2): matrix[row_index][col_index], matrix[row_index + m][col_index] = \ matrix[row_index + m][col_index], matrix[row_index][col_index] # 交换特殊位置 matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0] matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t] return matrix End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】求乘积最大]]></title>
      <url>%2F2017%2F05%2F03%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B1%82%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[本周题目： 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值 示例：1234567891011def product(num): ''' &gt;&gt;&gt;product(312) 62 &gt;&gt;&gt;product(1234) 492 &gt;&gt;&gt;product(12345) 6170 &gt;&gt;&gt;product(123456) 74070 ''' 思路从头到尾遍历这个数字串， 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果 以此类推…直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。 可以将每一步求出的值存入初始值为0的max_num中，每次求出的值都与max_num比较，若大于max_num，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。 Python实现12345678910111213141516171819# coding: utf-8def product(num): i = 1 max_num = 0 while i != len(str(num)): num1 = int(str(num)[:i]) num2 = int(str(num)[i:]) result = num1 * num2 # result = int(str(num)[:i]) * int(str(num)[i:]) if result &gt; max_num: max_num = result i += 1 return max_num# 测试print(product(312))print(product(1234))print(product(12345))print(product(123456)) 输出结果结果为： 62492617074070 结果与示例相符合 附加题上述的题目感觉还是比较简单的，因此多了一个附加题： 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。 示例：123456789def product_2(num): ''' &gt;&gt;&gt;product_2(1234) 1312 &gt;&gt;&gt;product_2(12345) 22412 &gt;&gt;&gt;product_2(123456) 342002 ''' 思路可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：itertools。它属于Python标准库，今天用到的是permutations()这个函数： permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同返回p中任意取r个元素做排列的元组的迭代器 例如： permutations(‘ABCD’, 2) 返回的结果为： AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD 有了这个函数，我们就可以完成附加题了 Python实现1234567891011121314151617181920# coding: utf-8from itertools import permutationsdef product_2(num): i = 1 max_num = 0 for p in permutations(str(num)): new_num = "".join(p) # 排列后返回的是一个元组，通过join()来重新生成数字串 # print(new_num) result = product(new_num) # 就是上面的product() if result &gt; max_num: max_num = result return max_num # 测试print(product_2(1234))print(product_2(12345))print(product_2(123456)) 输出结果结果为： 131222412342002 与示例一致 End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【每周一坑】程序员的浪漫]]></title>
      <url>%2F2017%2F04%2F27%2F%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB%2F</url>
      <content type="text"><![CDATA[关注了Crossin的编程教室，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。 问题如下： 在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符： ‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n’ 在此给出4个选项 我们在一起吧 我选择原谅你 别说话，吻我 多喝热水 使用科学的方法算出说的是什么。 思路其实思路也挺简单，hashlib里有MD5模块，只需调用 hashlib.md5(“要生成MD5的字符串”) 即可生成。 而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数： base64.b64decode(“已知的字符串”) 即可得到解码后的内容。 最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。 Python实现1234567891011121314151617import base64, hashlib # 引入需要使用的库answer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n' # 问题中的字符串checkStr = &#123;'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'&#125; # 将选项存入字典，后面使用def main(): for x in checkStr: # 遍历字典中的个字符串 md5 = hashlib.md5(x.encode('utf-8')) # 使用hashlib.md5()进行编码 md5_byte = bytes(md5.hexdigest().encode('utf-8')) # base64.decode()得到的是bytes类型的， # 无法直接与string比较，这里把string类型的md5转换成bytes类型的 b64_byte = base64.decode(answer) if md5_byte == b64_byte: print('The answer is', x) if __name__ == '__main__': main() 输出结果万！万！没！想！到！ 结果居然是…. 多喝热水 说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧… 然而… 和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭ End~ [1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数返回数组指针或数组引用]]></title>
      <url>%2F2017%2F04%2F15%2F%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E6%88%96%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%2F</url>
      <content type="text"><![CDATA[因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。下面就介绍几种方法： 方法一： 使用类型别名1234typedef int arrT[10]; // arrT是一个类型别名，表示的类型 // 是含有10个整型的数组using arrT = int[10]; // arrT的等价声明arrT* func(int i); // func返回一个指向含有10个整数的数组的指针 其中arrT是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此func函数接受一个int实参，返回一个指向包含10个整数的数组的指针。 方法二： 声明一个返回数组指针的函数要想在声明func时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：123int arr[10]; // arr是一个含有10个整数的数组int *p1[10]; // p1是一个含有10个指针的数组int (*p2)[10] = &amp;arr; // p2是一个指针，他只想含有10个整数的数组 和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示： Type (*function(parameter_list)) [dimension] 类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。(*function(parameter_list))两段的括号必须存在，就像定义p2时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。 举个具体点的例子，下面这个func函数的声明没有使用类型别名：1int (*func(int i)) [10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i)表示调用func函数时需要一个int类型的实参 (*func(int i))意味这我们可以对函数调用的结果执行解引用操作 (*func(int i)) [10]表示解引用func的调用将得到一个大小是10的数组 int(*func(int i)) [10]表示数组中元素是int类型 方法三： 使用尾置返回类型在C++11新标准中海油可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto： 12// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*) [10]; 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 方法四： 使用decltype还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：1234567int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;// 返回一个指针，该指针指向含有5个整数的数组decltype(odd) *addPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even; // 返回一个指向数组的指针&#125; arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个*符号。 练习1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。1string (&amp;func(string (&amp;arr)[10])) [10]; 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。12345678910// 使用类型别名using arrT = string[10];arrT&amp; func1(arrT&amp; arr);// 使用尾置返回类型auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];// 使用decltype关键字string arrS[10];decltype(arrS) &amp;func3(arrT&amp; arr); 3. 修改arrPtr函数，使其返回数组的引用123456int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;decltype(odd) &amp;arrPtr(int i)&#123; return (i % 2) ? odd : even;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++前置递增（递减）和后置递增（递减）运算符]]></title>
      <url>%2F2017%2F04%2F07%2FC-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E5%92%8C%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在做C++ primer 第五版课后习题4.31时遇到一个问题： 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。 源程序代码如下：12345vector&lt;int&gt;::size_type cnt = ivec.size();// 将把从size到1的值赋给ivec的元素for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; 可以看到源程序用的是前置递增和递减运算符我根据源代码写了一下可运行的版本：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 然后根据题目的意思，使用了后置版本的递增和递减运算符：123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec(10, 0); // 初始化ivec vector&lt;int&gt;::size_type cnt = ivec.size(); for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; for (auto x : ivec) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 输出的结果为 10 9 8 7 6 5 4 3 2 1 结果一样啊喂！(＃°Д°)哪里需要修改了(╯‵□′)╯︵┻━┻各种百度没有没百度到，突然想起来可以找课后练习答案啊！找到了结果，还以为我错了，没想到答案居然是… We use prefix and not postfix, just because of the Advice: Use Postfix Advice: Use Postfix Operators only When Necessary.So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:12for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ix++, cnt--) ivec[ix] = cnt; This is not an appropriate example to discuss the difference of prefix and postfix. 果然不是我的问题 ( •̀ ω •́ )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ string输入问题]]></title>
      <url>%2F2017%2F03%2F31%2FC-string%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[问题描述 使用cin读入一组字符串并存入一个vector对象 代码实现使用如下代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;/*用cin读入一组字符串并把它们存入一个vector对象*/int main()&#123; vector&lt;string&gt; text; string word; while (getline(cin, word)) &#123; text.push_back(word); &#125; cout &lt;&lt; "["; for (auto i : text) if (i == text.back()) cout &lt;&lt; i; else cout &lt;&lt; i &lt;&lt; ","; cout &lt;&lt; "]"; return 0;&#125; 在运行测试时发现了一个问题：当输入为 aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的) 按回车后发现输出卡出了，并不会输出所输入的字符串 当输入为 aa ss dd qq ww ee^Z(换行后的^Z) 就可以正确输出了 解决办法百思不得其解，遂百度之。看到了两种解释，感觉都有道理，就都贴上来好了1. 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。 2. windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。 意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给出一个表达式，按照顺序求出表达式的值]]></title>
      <url>%2F2017%2F03%2F25%2F%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%2F</url>
      <content type="text"><![CDATA[按顺序求出表达式的值今天碰到一个题目：题目描述： 常规的表达式求值，我们都会根据计算的优先级来计算， 比如*、/的优先级就高于+、-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有/，只有(+,-和*)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入描述： 输入为一行字符串，即一个表达式。其中运算符只有+,-和*。参与计算的数字只有0-9。保证表达式是合法的，排列规则如样例所示。 输出描述 输出一个数，即表达式的值 输入例子 3+5*7 输出例子 56 刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的… C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * 输入字符串表达式，按照输入顺序求出表达式的结果 */#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;cmath&gt;using namespace std;// 字符串转数字int get_number(string num_str)&#123; stringstream stream; // 声明stringstram变量 int result = 0; int str_len = num_str.length(); stream &lt;&lt; num_str; stream &gt;&gt; result; return result;&#125;int main()&#123; string s; // 保存输入的字符串 cout &lt;&lt; "请输入要计算的表达式(不包含除):" &lt;&lt; endl; cin &gt;&gt; s; int number[100] = &#123; 0 &#125;; // 保存数字的数组 string operator_str; // 保存操作符的字符串 int length = s.length(); string number_str; // 保存每个操作符之前的字符串 int index = 0; // 标记保存数字的数组的指针 for (int i = 0; i &lt; length; i++) &#123; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') // 如果是数字，则存入 number_str &#123; number_str += s[i]; &#125; else // 如果是操作符，存入operator_str &#123; operator_str += s[i]; number[index] = get_number(number_str); // 得到两个操作符之间的操作数，并存入数组 index++; number_str = ""; // 将字符串置为空，重新存入下一个操作数的字符串 &#125; if (i == length -1) // 得到表达式的最后一个操作数 &#123; number[index] = get_number(number_str); index++; &#125; &#125; int result = 0; // 计算结果 for (int i = 0; i &lt; index; i++) &#123; //todo 计算结果 if (i&lt;1) &#123; result += number[i]; &#125; else &#123; switch (operator_str[i-1]) &#123; case '+': result = result + number[i]; break; case '-': result = result - number[i]; break; case '*': result = result * number[i]; break; default: break; &#125; &#125; //cout &lt;&lt; number[i] &lt;&lt; endl; &#125; //for (int i = 0; i &lt; operator_str.length(); i++) //&#123; // cout &lt;&lt; operator_str[i] &lt;&lt; endl; //&#125; //cout &lt;&lt; "输入的字符串为:" &lt;&lt; s &lt;&lt; " 得到的数字为: " &lt;&lt; number &lt;&lt; endl; cout &lt;&lt; "Result = " &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125; 挺简单的题目，居然写了这么多！ (:3」∠) 太久没写了，写的有点丑¬¬，看来还是要多练习 (ง •̀•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python生成词云]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%2F</url>
      <content type="text"><![CDATA[Python如何生成词云最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P通过度娘发现可以用Python库来生成词云， So Let’s go! 用到的库WorldCloud 官网: https://amueller.github.io/word_cloud github: https://github.com/amueller/word_cloud 安装WordCloud通过PIP安装pip install wordcloud 下载WHL包安装当然可能通过PIP会安装出错，我们可以下WHL包手动安装 下载完成后，再使用PIP命令安装： pip install yourfilepath\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl 其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl。 使用WordlCloud安装完成后，就可以用了。可以先测试以下是否安装成功： from wordcould import WordCloud 如果没有报错，表示安装成功了。 源代码下面就是源码部分了:1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from wordcloud import WordCloudimport matplotlib.pyplot as pltfrom scipy.misc omport imread# 读入一个文件text = open('your text file.txt', 'r').read()# 读入图片bg_pic = imread('your picture.png')# 配置词云参数wc = WordCloud( # 设置背景色,我这里设置为了黑色 background_color = 'black', # 设置词云形状，就是之前读入的图片 mask = bg_pic, # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块 font_path = 'Sketch Fine Serif.otf')# 生成词云wordcloud = wc.generate(text)# 显示词云图片plt.imshow(wordcloud)plt.axis('off')plt.show()# 保存图片wordcloud.to_file('wordcloud.jpg') 生成的词云效果如图: 参数其中配置词云参数的时候，有多个参数可选： Parameters1font_path : string Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path. 1width : int (default=400) Width of the canvas. 1height : int (default=200) Height of canvas 1prefer_horizontal : float (default=0.90) The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.) 1mask : nd-array or None (default=None) If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!] 1scale : float (default=1) Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words. 1min_font_size : int (default=4) Smallest font size to use. Will stop when there is no more room in this size. 1font_step : int (default=1) Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit. 1max_words : number (default=200) The maximum number of words. 1stopwords : set of strings or None The words that will be eliminated. If None, the build-in STOPWORDS list will be used. 1background_color : color value (default=”black”) Background color for the word cloud image. 1max_font_size : int or None (default=None) Maximum font size for the largest word. If None, height of the image is used. 1mode : string (default=”RGB”) Transparent background will be generated when mode is “RGBA” and background_color is None. 1relative_scaling : float (default=.5) Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good. 1color_func : callable, default=None Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead. 1regexp : string or None (optional) Regular expression to split the input text into tokens in process_text. If None is specified, r”\w[\w’]+” is used. 1collocations : bool, default=True Whether to include collocations (bigrams) of two words. 1colormap : string or matplotlib colormap, default=”viridis” Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified. 1normalize_plurals : bool, default=True Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’. 以上就是所有可以配置的参数，可以根据需要来用。 End~ [1]: 图片出处: https://github.com/amueller/word_cloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python脚本抓取Bing美图]]></title>
      <url>%2F2017%2F03%2F23%2FPython3%E8%84%9A%E6%9C%AC%E6%8A%93%E5%8F%96Bing%E7%BE%8E%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[使用Python脚本下载Bing美图Bing首页每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。 Bing美图APIBing官方有两个API：xml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1json版： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1有了API就可以愉快地抓图了:D Python抓图至于为什么要用Python，前段时间学习了廖大的Python教程,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！ 用到的库 Requests 爬图 (更新于2018-04-04)这里我用了json版的API，使用requests的json()函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在images所对应的值里面。得到images的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值url来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上https:://www.bing.com，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-import requestsimport osimport timedef get_content(url): """ 得到API返回的JSON数据 :param url: API链接 :return: 返回的是一个字典 """ try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.json() except: print("ERROR")def get_img(url): """ 得到图片的内容 :param url: 图片的真实链接 :return: 返回的是byte类型的图片内容 """ try: r = requests.get(url) return r.content except: return Nonedef download(file_name, url): """ 根据得到的链接在指定位置保存图片 :param file_name: 要保存图片的位置 :param url: 图片的链接 :return: """ if os.path.exists(r'C:\Users\Freed\Pictures\bingwallpaper'): print('Find Dir...') else: print("File dir did not exist, make dir...") try: os.mkdir(r'C:\Users\Freed\Pictures\bingwallpaper') print('Make dir success') except: print('Failed in make dir') if os.path.exists(r'c:\users\freed\pictures\bingwallpaper\\' + file_name): print('Image downloaded already') else: img = get_img(url) with open(r'c:\users\freed\pictures\bingwallpaper\\' + file_name, 'wb') as f: f.write(img) print('Download success')if __name__ == '__main__': url = "https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1" content = get_content(url) url_dict = content['images'][0] download_url = 'https://www.bing.com' + url_dict['url'] file_name = str("BingWallPaper-" + time.strftime('%Y-%m-%d', time.localtime(time.time())) + '.jpg') download(file_name, download_url) 用Python命令运行文件即可。到此大功告成! :D]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
