<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[给出一个表达式，按照顺序求出表达式的值]]></title>
      <url>%2F2017%2F03%2F25%2F%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%2F</url>
      <content type="text"><![CDATA[按顺序求出表达式的值今天碰到一个题目：题目描述： 常规的表达式求值，我们都会根据计算的优先级来计算， 比如*、/的优先级就高于+、-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有/，只有(+,-和*)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入描述： 输入为一行字符串，即一个表达式。其中运算符只有+,-和*。参与计算的数字只有0-9。保证表达式是合法的，排列规则如样例所示。 输出描述 输出一个数，即表达式的值 输入例子 3+5*7 输出例子 56 刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的… C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * 输入字符串表达式，按照输入顺序求出表达式的结果 */#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;cmath&gt;using namespace std;// 字符串转数字int get_number(string num_str)&#123; stringstream stream; // 声明stringstram变量 int result = 0; int str_len = num_str.length(); stream &lt;&lt; num_str; stream &gt;&gt; result; return result;&#125;int main()&#123; string s; // 保存输入的字符串 cout &lt;&lt; "请输入要计算的表达式(不包含除):" &lt;&lt; endl; cin &gt;&gt; s; int number[100] = &#123; 0 &#125;; // 保存数字的数组 string operator_str; // 保存操作符的字符串 int length = s.length(); string number_str; // 保存每个操作符之前的字符串 int index = 0; // 标记保存数字的数组的指针 for (int i = 0; i &lt; length; i++) &#123; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') // 如果是数字，则存入 number_str &#123; number_str += s[i]; &#125; else // 如果是操作符，存入operator_str &#123; operator_str += s[i]; number[index] = get_number(number_str); // 得到两个操作符之间的操作数，并存入数组 index++; number_str = ""; // 将字符串置为空，重新存入下一个操作数的字符串 &#125; if (i == length -1) // 得到表达式的最后一个操作数 &#123; number[index] = get_number(number_str); index++; &#125; &#125; int result = 0; // 计算结果 for (int i = 0; i &lt; index; i++) &#123; //todo 计算结果 if (i&lt;1) &#123; result += number[i]; &#125; else &#123; switch (operator_str[i-1]) &#123; case '+': result = result + number[i]; break; case '-': result = result - number[i]; break; case '*': result = result * number[i]; break; default: break; &#125; &#125; //cout &lt;&lt; number[i] &lt;&lt; endl; &#125; //for (int i = 0; i &lt; operator_str.length(); i++) //&#123; // cout &lt;&lt; operator_str[i] &lt;&lt; endl; //&#125; //cout &lt;&lt; "输入的字符串为:" &lt;&lt; s &lt;&lt; " 得到的数字为: " &lt;&lt; number &lt;&lt; endl; cout &lt;&lt; "Result = " &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125; 挺简单的题目，居然写了这么多！ (:3」∠) 太久没写了，写的有点丑¬¬，看来还是要多练习 (ง •̀•́)ง End~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python生成词云]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%2F</url>
      <content type="text"><![CDATA[Python如何生成词云最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P通过度娘发现可以用Python库来生成词云， So Let’s go! 用到的库WorldCloud 官网: https://amueller.github.io/word_cloud github: https://github.com/amueller/word_cloud 安装WordCloud通过PIP安装pip install wordcloud 下载WHL包安装当然可能通过PIP会安装出错，我们可以下WHL包手动安装 下载完成后，再使用PIP命令安装： pip install yourfilepath\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl 其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl。 使用WordlCloud安装完成后，就可以用了。可以先测试以下是否安装成功： from wordcould import WordCloud 如果没有报错，表示安装成功了。 源代码下面就是源码部分了:1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from wordcloud import WordCloudimport matplotlib.pyplot as pltfrom scipy.misc omport imread# 读入一个文件text = open('your text file.txt', 'r').read()# 读入图片bg_pic = imread('your picture.png')# 配置词云参数wc = WordCloud( # 设置背景色,我这里设置为了黑色 background_color = 'black', # 设置词云形状，就是之前读入的图片 mask = bg_pic, # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块 font_path = 'Sketch Fine Serif.otf')# 生成词云wordcloud = wc.generate(text)# 显示词云图片plt.imshow(wordcloud)plt.axis('off')plt.show()# 保存图片wordcloud.to_file('wordcloud.jpg') 生成的词云效果如图: 参数其中配置词云参数的时候，有多个参数可选： Parameters1font_path : string Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path. 1width : int (default=400) Width of the canvas. 1height : int (default=200) Height of canvas 1prefer_horizontal : float (default=0.90) The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.) 1mask : nd-array or None (default=None) If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!] 1scale : float (default=1) Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words. 1min_font_size : int (default=4) Smallest font size to use. Will stop when there is no more room in this size. 1font_step : int (default=1) Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit. 1max_words : number (default=200) The maximum number of words. 1stopwords : set of strings or None The words that will be eliminated. If None, the build-in STOPWORDS list will be used. 1background_color : color value (default=”black”) Background color for the word cloud image. 1max_font_size : int or None (default=None) Maximum font size for the largest word. If None, height of the image is used. 1mode : string (default=”RGB”) Transparent background will be generated when mode is “RGBA” and background_color is None. 1relative_scaling : float (default=.5) Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good. 1color_func : callable, default=None Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead. 1regexp : string or None (optional) Regular expression to split the input text into tokens in process_text. If None is specified, r”\w[\w’]+” is used. 1collocations : bool, default=True Whether to include collocations (bigrams) of two words. 1colormap : string or matplotlib colormap, default=”viridis” Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified. 1normalize_plurals : bool, default=True Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’. 以上就是所有可以配置的参数，可以根据需要来用。 End~ [1]: 图片出处: https://github.com/amueller/word_cloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python脚本抓取Bing美图]]></title>
      <url>%2F2017%2F03%2F23%2FPython3%E8%84%9A%E6%9C%AC%E6%8A%93%E5%8F%96Bing%E7%BE%8E%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[使用Python脚本下载Bing美图Bing首页每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。 Bing美图APIBing官方有两个API：xml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1json版： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1有了API就可以愉快地抓图了:D Python抓图至于为什么要用Python，前段时间学习了廖大的Python教程,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！ 用到的库 Requests Beautiful Soup 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import requestsimport reimport timeimport osimport jsonfrom bs4 import BeautifulSoupdef downloadPic(file_name, picurl): # 判断文件夹是否存在，如果不存在就新建 if os.path.exists(r'C:\Users\Freed\Pictures\bingwallpaper'): print('Find dir already...') else: print('Dir not found, makdir...') os.mkdir(r'C:\Users\Freed\Pictures\bingwallpaper') print('success...') if os.path.exists(r'c:\users\freed\pictures\bingwallpaper\\' + file_name): print('downlaod already...') else: pic = getHtml(picurl) fp = open(r'c:\users\freed\pictures\bingwallpaper\\' + file_name, 'wb') fp.write(pic) fp.close() def getHtml(url): r = requests.get(url) return r.contenturl = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'json_str = getHtml(url) # 得到的是strjson_str = json_str.decode()print(type(json_str))#print(json_str)json_list = json_str.split(',') # 得到list#print(json_list)pic_head = 'http://s.cn.bing.net'json_url = ''json_url = json_url.join(json_list[3])picurl = json_url[7:-1]picurl = pic_head + picurlprint(picurl)# 设置图片名称file_name = str("BingWallPaper-" + time.strftime('%Y-%m-%d',time.localtime(time.time())) + '.jpg')downloadPic(file_name, picurl) 用Pthon命令运行文件即可。到此大功告成! :D]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
