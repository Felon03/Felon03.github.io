{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-03-25-2.jpg","path":"images/imagesource/17-03-25-2.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-04-27.jpg","path":"images/imagesource/17-04-27.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-05-28.jpg","path":"images/imagesource/17-05-28.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-06-23.jpg","path":"images/imagesource/17-06-23.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-08-04.jpg","path":"images/imagesource/17-08-04.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-08.png","path":"images/imagesource/19-01-08.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/bak.ico","path":"assets/bak.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"source/images/imagesource/17-07-08.jpg","path":"images/imagesource/17-07-08.jpg","modified":0,"renderable":0},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg.bak","path":"intro/404-bg.jpg.bak","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"source/images/imagesource/17-11-17/17-11-17-10.png","path":"images/imagesource/17-11-17/17-11-17-10.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-1.png","path":"images/imagesource/17-11-17/17-11-17-1.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-11.png","path":"images/imagesource/17-11-17/17-11-17-11.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-12.png","path":"images/imagesource/17-11-17/17-11-17-12.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-13.png","path":"images/imagesource/17-11-17/17-11-17-13.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-14.png","path":"images/imagesource/17-11-17/17-11-17-14.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-15.png","path":"images/imagesource/17-11-17/17-11-17-15.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-17.png","path":"images/imagesource/17-11-17/17-11-17-17.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-18.png","path":"images/imagesource/17-11-17/17-11-17-18.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-19.png","path":"images/imagesource/17-11-17/17-11-17-19.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-2.png","path":"images/imagesource/17-11-17/17-11-17-2.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-3.png","path":"images/imagesource/17-11-17/17-11-17-3.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-4.png","path":"images/imagesource/17-11-17/17-11-17-4.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-5.png","path":"images/imagesource/17-11-17/17-11-17-5.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-6.png","path":"images/imagesource/17-11-17/17-11-17-6.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-7.png","path":"images/imagesource/17-11-17/17-11-17-7.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-8.png","path":"images/imagesource/17-11-17/17-11-17-8.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-9.png","path":"images/imagesource/17-11-17/17-11-17-9.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-06-09.png","path":"images/imagesource/17-06-09.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-16.png","path":"images/imagesource/17-11-17/17-11-17-16.png","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/about-bg.jpg.bak","path":"intro/about-bg.jpg.bak","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg.bak","path":"intro/post-bg.jpg.bak","modified":0,"renderable":1},{"_id":"source/images/imagesource/17-03-23.jpg","path":"images/imagesource/17-03-23.jpg","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/index-bg.jpg.bak","path":"intro/index-bg.jpg.bak","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/imagesource/17-03-25-1.png","path":"images/imagesource/17-03-25-1.png","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-01-08.jpg","path":"images/bing/BingWallPaper-2019-01-08.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-1.png","path":"images/imagesource/19-01-16/2019-01-16-1.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-2.png","path":"images/imagesource/19-01-16/2019-01-16-2.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-3.png","path":"images/imagesource/19-01-16/2019-01-16-3.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-4.png","path":"images/imagesource/19-01-16/2019-01-16-4.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-5.png","path":"images/imagesource/19-01-16/2019-01-16-5.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-6.png","path":"images/imagesource/19-01-16/2019-01-16-6.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/TravisCI-Full-Color.png","path":"images/imagesource/19-01-16/TravisCI-Full-Color.png","modified":1,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-7.png","path":"images/imagesource/19-01-16/2019-01-16-7.png","modified":1,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-01-16.jpg","path":"images/bing/BingWallPaper-2019-01-16.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"d697f1c8029899ae45bf17bb998d12f3cfe42083","modified":1490180553191},{"_id":"source/404.md","hash":"ee4f2c0b95b9e96eac35bc62babdace37673b37f","modified":1546930283730},{"_id":"source/CNAME","hash":"ce6b68629115b85da6d080512d5aea0af7259520","modified":1546863478309},{"_id":"themes/archer/.eslintrc.json","hash":"5c79a54f29b1d32045e612fcb7379797d79ac380","modified":1546925008251},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1546925008251},{"_id":"themes/archer/.gitignore","hash":"d734edbdd316a19eae0ac2421256ac60dd61a1f8","modified":1546925008251},{"_id":"themes/archer/.prettierignore","hash":"075b20da2bb3dfa7932394363d63d98cbb0b7042","modified":1546925008251},{"_id":"themes/archer/.prettierrc.js","hash":"c77c76428fb4eefd727444d97fa2733a0c10286a","modified":1546925008251},{"_id":"themes/archer/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1546925008251},{"_id":"themes/archer/README.md","hash":"a166b2c840fdf215a38d205f33e4dc1a5f2f0769","modified":1546925008251},{"_id":"themes/archer/_config.yml","hash":"39da008ecdca3d3416c6feca9ec5f6649abe7db6","modified":1547129245934},{"_id":"themes/archer/gulpfile.js","hash":"ba7c6a88298900460ddd1649300b5672956902f9","modified":1546925008251},{"_id":"themes/archer/package.json","hash":"c07c94772d0e92e77788b0fe5beb3d44eb3c245f","modified":1546925008282},{"_id":"themes/archer/webpack.config.js","hash":"348da2932316c2789a3c0a3cf5efff0dd7cc4ffe","modified":1546925008329},{"_id":"themes/archer/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1546925008329},{"_id":"themes/archer/.git/FETCH_HEAD","hash":"5462550f59c8c520ef58e7b5a9507feedca89729","modified":1547542089692},{"_id":"source/_posts/C-Primer-第五版-练习-12-33.md","hash":"3f8e38444579d77f64ec81c936bd59ca1c4c84fa","modified":1546868688222},{"_id":"source/_posts/C-Primer-第五版-练习12-3.md","hash":"228a0aa4debac11b0ad7d9f874faf3e23e9ab989","modified":1546868688223},{"_id":"source/_posts/C-string输入问题.md","hash":"a8cd98b7af893cd3e7d90e15785f70871e75e442","modified":1546868688223},{"_id":"source/_posts/C-中的explicit关键字.md","hash":"189537f792895c17755a423227ff997301006dd0","modified":1546868688077},{"_id":"source/_posts/C-前置递增（递减）和后置递增（递减）运算符.md","hash":"0b311f090eec1dbb9aec8ecf03c70bb2e459472b","modified":1546868688079},{"_id":"source/_posts/LeetCode-19-Remove-Nth-Node-From-End-of-List.md","hash":"d9abba81fcc4a71641f8a9429975346e9b5e4e6e","modified":1515495304243},{"_id":"source/_posts/LeetCode-751-IP-to-CIDR.md","hash":"c1c51192883a8557084ef24d9d5b6bd62c212358","modified":1514533378453},{"_id":"source/_posts/Python3脚本抓取Bing美图.md","hash":"65508f2eb2dc4dc60a924088ff4dd2ff2b0153ba","modified":1546869520771},{"_id":"source/_posts/Python生成词云.md","hash":"c3fd26063ca163c9c393ac50fe153c833b201fd8","modified":1490428978361},{"_id":"source/_posts/UTF-8-码点.md","hash":"23fef0248c9797c03ad13ac7c51c630f16e496fe","modified":1546868688079},{"_id":"source/_posts/VSCode-Extensions.md","hash":"63af662fe653ede8c1bae8289398f732a3e02ca0","modified":1547434028410},{"_id":"source/_posts/Visual-Studio项目中集成Google-Test测试框架.md","hash":"6acc80123b5dbc604ca54b2e25c49f1930534d84","modified":1546868688079},{"_id":"source/_posts/hello-world.md","hash":"b220940ab3440f91d73e9d161d67f8ac93db00d8","modified":1490350737240},{"_id":"source/_posts/【每周一坑】杨辉三角形.md","hash":"3e310e6026b3001602bf30e83dc58f792d207636","modified":1495936005628},{"_id":"source/_posts/【每周一坑】校验文件哈希.md","hash":"3a5b5d77cbcaee13a0aa854d1487e356fb1a76d6","modified":1497255754226},{"_id":"source/_posts/【每周一坑】求乘积最大.md","hash":"a8ddf2dac5eb26658a851b2ec7d3e1f97315b26f","modified":1501843942542},{"_id":"source/_posts/【每周一坑】注册表单验证.md","hash":"276e90c9141b00736c796bb5a151ec6d26d28209","modified":1507879000787},{"_id":"source/_posts/【每周一坑】矩阵旋转.md","hash":"10b05397d0576b5842bb585a81d58eeba8090fbc","modified":1504698905627},{"_id":"source/_posts/【每周一坑】神奇的九宫格.md","hash":"eb56f1858f4ac65ae4934a377a32eab6f4b3de78","modified":1495786498005},{"_id":"source/_posts/【每周一坑】程序员的浪漫.md","hash":"c604eef1d1a03f48ca7a44cb143c14863501acb3","modified":1495934355982},{"_id":"source/_posts/【每周一坑】罗马数字转换.md","hash":"b10ffc3dd5102e2f58958a5ca39cefda1fbf0e7e","modified":1499496811323},{"_id":"source/_posts/【每周一坑】螺旋矩阵.md","hash":"38387aa86e785b045dffcbe0297ae81c1f7ae65d","modified":1498219306982},{"_id":"source/_posts/【每周一坑】阿姆斯特朗数.md","hash":"d510b4f83434bfe453cea844405854bb0f2e01c6","modified":1501845512589},{"_id":"source/_posts/二叉树相关问题-转载.md","hash":"b76a1d3242c2611e88605b04acf9a9a70ce1c4df","modified":1546867514786},{"_id":"source/_posts/【每周一坑】验证哥德巴赫猜想.md","hash":"68fc19deebf63d83d1e96e7603d823397e7c0af1","modified":1495937528872},{"_id":"source/_posts/函数返回数组指针或数组引用.md","hash":"6861d5c777625a502bbd5f6faeb3b7dffa010f2e","modified":1546868688079},{"_id":"source/_posts/给出一个表达式，按照顺序求出表达式的值.md","hash":"1d6e04fcf5e7f170d3cbea6049abcb3a1191b972","modified":1546868688080},{"_id":"source/about/index.md","hash":"5bead47f7c11523830f54b816c32d30255540359","modified":1546866030874},{"_id":"source/categories/index.md","hash":"884b68fc6f21e23f3549ded82f991e798fd0f469","modified":1546868761608},{"_id":"source/images/avatar.png","hash":"1ffd03678d665d958cd861afb37f192195fa32d1","modified":1468845243882},{"_id":"source/sitemap/index.md","hash":"1a565eb44a3bc6958fea328d89466ce753b90141","modified":1490105824891},{"_id":"source/tags/index.md","hash":"a1e5983fc1aaebf4d62bf11be0fe023637740661","modified":1546868782714},{"_id":"themes/archer/.git/config","hash":"494b308fa6da696490a7ac4f608965ab0c38dd59","modified":1546925008220},{"_id":"themes/archer/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1546925008204},{"_id":"themes/archer/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1546925002096},{"_id":"themes/archer/.git/index","hash":"f9b89e5f758ba2eb9fb661eb222942570151cfc3","modified":1546925065233},{"_id":"themes/archer/.git/packed-refs","hash":"9e7b96bcd614b00cfff141bb305f3db36b4d55ca","modified":1546925008204},{"_id":"themes/archer/.git/shallow","hash":"a348fab820e88d801db0d6877198f89aa953bca0","modified":1546925005620},{"_id":"themes/archer/dev/archer.sh","hash":"9474c501c1c55f47f02cccdd9e2039498ebc5e43","modified":1546925008251},{"_id":"themes/archer/docs/README-en.md","hash":"e4fff6fc13f3296c2b168ab220f847192bf1273b","modified":1546925008251},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c10293eb8ccad5d02412a1369ec1c7e77516b929","modified":1546925008251},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"522434202e5e810b3c7f9591eb3a4451a4e485f0","modified":1546925008251},{"_id":"themes/archer/languages/default.yml","hash":"c6e36691ded2a5e5939c67bf3c47104664ea56c6","modified":1546925008251},{"_id":"themes/archer/languages/en.yml","hash":"de8fe8ad1967854586fee2214094c4992dd05278","modified":1546925008251},{"_id":"themes/archer/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1546925008267},{"_id":"themes/archer/layout/index.ejs","hash":"c9ae77cd8f7b862d23137a7b4eb5eb01b558ed33","modified":1546925008282},{"_id":"themes/archer/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1546925008282},{"_id":"themes/archer/layout/layout.ejs","hash":"fffd1188977f74d19e2f9d267d085dddc9c6778e","modified":1546925008282},{"_id":"themes/archer/layout/site-meta.ejs","hash":"a9d85607fc7da51bb9becff7fe2f07a8b4fbc915","modified":1546925008282},{"_id":"themes/archer/layout/post.ejs","hash":"f14b49c920a3afe8d9aa4cb1d843faf43d07c72e","modified":1546925008282},{"_id":"source/images/imagesource/17-03-25-2.jpg","hash":"d39c83dad6ca202f658a5080c8410cb6784312aa","modified":1490423572282},{"_id":"source/images/imagesource/17-04-27.jpg","hash":"c88c5a4e690fd2b00258308aa9ae559cf5ad50f1","modified":1493278660887},{"_id":"source/images/imagesource/17-05-28.jpg","hash":"8078c9bb635146749c2356ce09d4e488f872ca41","modified":1495937462100},{"_id":"source/images/imagesource/17-06-23.jpg","hash":"6efbfd2fbea3d57fa766e7eba8c842b9a7bedaae","modified":1498218318108},{"_id":"source/images/imagesource/17-08-04.jpg","hash":"ee945fff8e14b14d59359289f08b8f1d7f36821b","modified":1501843234420},{"_id":"source/images/imagesource/19-01-08.png","hash":"4e5e64367f7763266febadd4acc817d043c36dbc","modified":1546956064965},{"_id":"themes/archer/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1546925002096},{"_id":"themes/archer/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1546925002096},{"_id":"themes/archer/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1546925002111},{"_id":"themes/archer/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1546925002111},{"_id":"themes/archer/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1546925002111},{"_id":"themes/archer/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1546925002127},{"_id":"themes/archer/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1546925002127},{"_id":"themes/archer/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1546925002127},{"_id":"themes/archer/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1546925002143},{"_id":"themes/archer/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1546925002143},{"_id":"themes/archer/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1546925002143},{"_id":"themes/archer/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1546925002143},{"_id":"themes/archer/.git/logs/HEAD","hash":"c2ed6b4be21de5ebe06d7c3dffa4f5dd8be81514","modified":1546925008220},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"7d1c5dbbc89b03b9e764e71aedb3f9567bed49bf","modified":1546925008251},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"ce7449948855556971a7353d4bfc7e8cd1b49634","modified":1546925008251},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"1ee1770c446ffe4d489db8d216981f473da4addc","modified":1546925008251},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"21765ec5abc9a65513e6bff57cb021d3b3852d35","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"a90bd2b089b335b141a6a0d8dee9a9cde60fdc5b","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"5ebc82012a83f29483c6ae6bc375045e4236be12","modified":1547103120245},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"b343f5a4c8bba1c71f3229390ed83a8679c2f375","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"af76b1a18a63934e83b078bf5f9f886e972a0ceb","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"065f8d6c4aae6782e6819815911f7feb6402a4ec","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"5dadba1c15454e25740982b59ef382686f3c6e51","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1546925008267},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"e1b4893af2b18f502bad1b552c3f3381ecc3021f","modified":1546925008267},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1546925008282},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1546925008282},{"_id":"themes/archer/source/assets/bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1546925008282},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1546925008282},{"_id":"themes/archer/source/assets/favicon.ico","hash":"9c8bfe8304dca970178f51b8cf9aa5408e4df891","modified":1546818124000},{"_id":"themes/archer/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1546925008282},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1546925008298},{"_id":"themes/archer/source/css/mobile.css","hash":"770d2ffb986a814c5e5662d28d2ec38864d8b1a0","modified":1546925008298},{"_id":"themes/archer/source/css/style.css","hash":"49f5d23b1e24e73016efdd8a6b70964a45a601db","modified":1546925008298},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1546925008298},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1546925008298},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"57c16afc4ef40f714fa4fda78f1e4ee038b318f9","modified":1500599702294},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"6f18a92bbe8bed93113449ed6ff8d148c1e7565a","modified":1546925008314},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1546925008314},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1546925008314},{"_id":"themes/archer/src/js/browser.js","hash":"35ea55f62c0f251817c46da0153f70aec323be3d","modified":1546925008314},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1546925008314},{"_id":"themes/archer/src/js/fancybox.js","hash":"701720a4c56fb09d78ef3494fd3a88b4e2cde238","modified":1546925008314},{"_id":"themes/archer/src/js/init.js","hash":"0cf1eb883b87590a771b687431cc5180064d13cd","modified":1546925008314},{"_id":"themes/archer/src/js/initSidebar.js","hash":"e27d52b4ccb9502836570a0673f6b656f9ce3661","modified":1546925008314},{"_id":"themes/archer/src/js/main.js","hash":"673e19867b5ecf65b0c9c6579d40be587d0e8211","modified":1546925008314},{"_id":"themes/archer/src/js/mobile.js","hash":"cfc37862242d5b7bd17028269436d3bc42e142e8","modified":1546925008314},{"_id":"themes/archer/src/js/scroll.js","hash":"83f0885f2673234c911d84a56fcaaa020cdcc3e6","modified":1546925008314},{"_id":"themes/archer/src/js/search.js","hash":"ef6533c876831377542a57f447550689144a6b71","modified":1546925008314},{"_id":"themes/archer/src/js/share.js","hash":"83a8ad056039cc673b939f47d69ad56337abc382","modified":1546925008314},{"_id":"themes/archer/src/js/sidebar.js","hash":"f2a5ec38766b3f48e3b043b84029f9da878d1c1a","modified":1546925008314},{"_id":"themes/archer/src/js/tag.js","hash":"a868118bb0daf8902b63c48792797def36b9469a","modified":1546925008314},{"_id":"themes/archer/src/js/toc.js","hash":"5c4db488dc2d80315064c6832eecfb39017a8104","modified":1546925008314},{"_id":"themes/archer/src/js/util.js","hash":"7bec5b1ff8ee91f58d084c47e0ed3908b27adef7","modified":1546925008314},{"_id":"themes/archer/src/scss/_common.scss","hash":"05162d1562d4b141d9bad44c37b0b736371d8b08","modified":1546925008314},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"c6347bf137e80bb0c5b6368488ebd634c299016a","modified":1546925008314},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"fb6a1349bab25b65cf89b47e136d958d10947533","modified":1546925008314},{"_id":"themes/archer/src/scss/_variables.scss","hash":"2264c9b671643b3c64e002f968a75355e4091b61","modified":1546925008329},{"_id":"themes/archer/src/scss/mobile.scss","hash":"0a00e55e8b8d9551eed5966f53d8a6580b816dc5","modified":1546925008329},{"_id":"themes/archer/src/scss/style.scss","hash":"03bca94e57bc44723f8b73bb653f3e002b4b08a8","modified":1546925008329},{"_id":"source/images/imagesource/17-07-08.jpg","hash":"77b1420469d95dc44725a4a2b58d758788487a72","modified":1499496742729},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546925008267},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1546925008298},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1546925008298},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1546925008298},{"_id":"themes/archer/source/intro/404-bg.jpg.bak","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1546864743474},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1546925008314},{"_id":"source/images/imagesource/17-11-17/17-11-17-10.png","hash":"1f4f28d04c87e1c59a5dec5424a797c294dd9e85","modified":1510900424225},{"_id":"source/images/imagesource/17-11-17/17-11-17-1.png","hash":"7f50f4c5eadb21b235025ecb46b1fe7e729e643d","modified":1510897982096},{"_id":"source/images/imagesource/17-11-17/17-11-17-11.png","hash":"c59a8f5246ad69cf54816ab8d6bac6f24307c158","modified":1510900823816},{"_id":"source/images/imagesource/17-11-17/17-11-17-12.png","hash":"0be73a6feb1e842f719fcb58eefc79ff7860f7bd","modified":1510901101138},{"_id":"source/images/imagesource/17-11-17/17-11-17-13.png","hash":"30608ba4948767ee479fc6c7786821313f4f9b9e","modified":1510901331108},{"_id":"source/images/imagesource/17-11-17/17-11-17-14.png","hash":"2ccbb9ad0a1b735a63fc709a34f88d943f9480b0","modified":1510901393960},{"_id":"source/images/imagesource/17-11-17/17-11-17-15.png","hash":"d98350de39ce3d11ced2a895b66f30abb2afe626","modified":1510901505746},{"_id":"source/images/imagesource/17-11-17/17-11-17-17.png","hash":"34671fb79859da8ea4fa5f24c44014e3e261d01d","modified":1510902463205},{"_id":"source/images/imagesource/17-11-17/17-11-17-18.png","hash":"2f346b4ae1b638695a0a1836c1d0eec3d608a06a","modified":1510902785618},{"_id":"source/images/imagesource/17-11-17/17-11-17-19.png","hash":"316eef52efd7aa15a0a6235575a6507965a2d6d0","modified":1510904356031},{"_id":"source/images/imagesource/17-11-17/17-11-17-2.png","hash":"fe7ac32c219f8715bcf6f9f078c45a0622be8874","modified":1510898262314},{"_id":"source/images/imagesource/17-11-17/17-11-17-3.png","hash":"caf5090ac3b0fce9c3129303626186019e3e7e1d","modified":1510898824020},{"_id":"source/images/imagesource/17-11-17/17-11-17-4.png","hash":"4d247dbe07a773598cf5565fa9841ce4bc1950b6","modified":1510898865271},{"_id":"source/images/imagesource/17-11-17/17-11-17-5.png","hash":"e8b342adf7dde2f18adae32881407e279f31379c","modified":1510898959732},{"_id":"source/images/imagesource/17-11-17/17-11-17-6.png","hash":"5fc15c3d9a3852e9a58bd5c51da9170e6787e4d3","modified":1510899717140},{"_id":"source/images/imagesource/17-11-17/17-11-17-7.png","hash":"c17a47924fd2d370f56c465f6639b1c431f5aeb3","modified":1510899858467},{"_id":"source/images/imagesource/17-11-17/17-11-17-8.png","hash":"fce6707121dd112795714df07b700c01a733c9e4","modified":1510900153794},{"_id":"source/images/imagesource/17-11-17/17-11-17-9.png","hash":"937e4b2b5ecf7813f477b1dafbf0944e6f039658","modified":1510900375064},{"_id":"themes/archer/.git/objects/pack/pack-d73684174f8bcbec2ac96f72a5ec54f7093a0552.idx","hash":"8aa802c165d6310e49daa1b55f837db7b9ef1e29","modified":1546925007860},{"_id":"themes/archer/.git/refs/heads/master","hash":"a348fab820e88d801db0d6877198f89aa953bca0","modified":1546925008220},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"244a4c71b862e6385a6de1e83a4975418a8c6fe7","modified":1546925008267},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1546925008267},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1546925008267},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1546925008267},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"f1f785de72e1f7056da8fdb12c85523d20a0b6b0","modified":1546925008267},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1546925008267},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"9cd4798cdcd712cc01c9e797adbb4810649310d4","modified":1546925008282},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"4281841e5bbb5e1a83c3ebf6506dab057e1fe6b9","modified":1546925008282},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"c5ce643a06a2103aa4ac0d8279c024f90886d37f","modified":1546925008282},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"e710acbc85e1cc5ae0e7ab5b5899837b9f222b97","modified":1546925008282},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1546925008282},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1546925008282},{"_id":"themes/archer/package-lock.json","hash":"f3eae5d3878f7761231613b74be88173d3047c0c","modified":1546925008282},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"55c33bd49880ccaaa2f5d4dff44470886c3f3633","modified":1546925008314},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"08594f05f6ed238a7b79d48ebc1ff1e5c9deec46","modified":1546925008314},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"82a04b6ebb684a87f486cac8f08619ecb52605fd","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"4d4713ec4b766a60577546af9f98eb721c4a63cd","modified":1546925008329},{"_id":"source/images/imagesource/17-06-09.png","hash":"4ec8fa57b1e15c9f5b9b021da5492d3b9e965e4d","modified":1497005189782},{"_id":"source/images/imagesource/17-11-17/17-11-17-16.png","hash":"261abc9693a15f0009bc9fd08fa246293e9e25f7","modified":1510901856394},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1546925008251},{"_id":"themes/archer/source/intro/about-bg.jpg.bak","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1546864743477},{"_id":"themes/archer/source/intro/post-bg.jpg.bak","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1546864743499},{"_id":"themes/archer/.git/logs/refs/heads/master","hash":"c2ed6b4be21de5ebe06d7c3dffa4f5dd8be81514","modified":1546925008220},{"_id":"themes/archer/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1546925008204},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"46d315718d86e9701573df2e39299895d8ca193c","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"a1163d481627864e9dda441c4c356169cd33a3a1","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"b3cf7523d8e91fce92cd6a118e308632047cc7b3","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"1e4510959f51b5d4d3c5781468c77d25546ce905","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"b6db1d4a29c34e1b834c54ca076b8084ceac4885","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"c623385d72ce12fa403f5384ded79c3897d0fc9f","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"30a3b9165c97bac6f6c795e598408639f5d9670a","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"28b97b11f17d57a258747bb0facae0ad1911f9d5","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"0691ca23bf6eabef65ff054c7710ec7432e4022c","modified":1546925008329},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b41904da65b1128510d28a57142298bfd844f7f5","modified":1546925008329},{"_id":"source/images/imagesource/17-03-23.jpg","hash":"2c384536f5c8ee9c8266362a0472fe46846edc07","modified":1490331222897},{"_id":"themes/archer/source/intro/index-bg.jpg.bak","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1546864743496},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"ab07b2fe6becaa95081a1c4fa8d3a052ffe178a1","modified":1490587685092},{"_id":"themes/archer/.git/logs/refs/remotes/origin/HEAD","hash":"c2ed6b4be21de5ebe06d7c3dffa4f5dd8be81514","modified":1546925008204},{"_id":"source/images/imagesource/17-03-25-1.png","hash":"0d52efafdf810859c9c11627b58ba4168bab3bc8","modified":1490426784569},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"ee0f7f1f419493b8fe2290e71b36ee121067ff39","modified":1546865290103},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"f1f40e89d1bc519b364136ec8fac8ad39865e903","modified":1494485511714},{"_id":"themes/archer/.git/objects/pack/pack-d73684174f8bcbec2ac96f72a5ec54f7093a0552.pack","hash":"740b4dac1e8e6e791d4c86d9f65862cc6eaca5ce","modified":1546925007860},{"_id":"source/images/background.jpg","hash":"d7db27a39ef107c8911a4e5eae302268393a7039","modified":1487837267797},{"_id":"public/atom.xml","hash":"b86544abcbbb044f25ff16603cbb86f6f14dad90","modified":1547647866601},{"_id":"public/search.xml","hash":"b08e80fb3de5e0d08c75f7fabe2bd3dcb0a9bb9d","modified":1547647866913},{"_id":"public/sitemap.xml","hash":"cd200086158cb0a8bf9f6e2a91bd62fbcdc15af6","modified":1547647866601},{"_id":"public/404.html","hash":"09b0c8b4b13f27e48d71782fb07b1f268bc6c1d6","modified":1547647868326},{"_id":"public/content.json","hash":"928863600cbd42c8f17e2dedae6d47fc8d748886","modified":1547647871069},{"_id":"public/tags/index.html","hash":"1649f6fb221daa9a56e9bcfed72047a3f9dd877e","modified":1547647871241},{"_id":"public/categories/index.html","hash":"ba6346c7d83b11f978c1aaf68d49494691220317","modified":1547647868326},{"_id":"public/sitemap/index.html","hash":"2519cd6840f5fae261093dcea87c3aaef6d30347","modified":1547647871241},{"_id":"public/archives/index.html","hash":"62952e4681f14b39527acfdef94a3d08f69b7952","modified":1547647871384},{"_id":"public/archives/page/2/index.html","hash":"091dc9ad6ed3a4e97be480c776e0e55bf7ca49c3","modified":1547647871384},{"_id":"public/archives/page/3/index.html","hash":"7315e298e91d8bc78f49a5b5c0e254d7cc63f95d","modified":1547647871384},{"_id":"public/archives/2017/page/2/index.html","hash":"2b3fd60a802343ae82803dae3996dd107bcb9829","modified":1547647871384},{"_id":"public/archives/2017/page/3/index.html","hash":"0ba90068f52a156e7c277f3ce6bafc218a676145","modified":1547647871384},{"_id":"public/archives/2017/index.html","hash":"f822025372bb2716684de4d42794177cb24058f5","modified":1547647871384},{"_id":"public/archives/2017/03/index.html","hash":"0e0213f16cddd3c407005e74c4100c42a31a7b1a","modified":1547647871384},{"_id":"public/archives/2017/04/index.html","hash":"0abab6b6750637033753440970a749726aed6c8c","modified":1547647871384},{"_id":"public/archives/2017/07/index.html","hash":"a759aa4cf70c2c60ff70e6450f3de7f8549e64ac","modified":1547647871384},{"_id":"public/archives/2017/08/index.html","hash":"a79f5d73bc74a582fb90e346b34c3070717242d8","modified":1547647871384},{"_id":"public/archives/2017/09/index.html","hash":"4117a5e22ce3d268d50839c2a7c2cef62c4bd9bc","modified":1547647871384},{"_id":"public/archives/2017/10/index.html","hash":"577ffe71c4010424673804e5d40e696d50c9a81f","modified":1547647871384},{"_id":"public/archives/2017/11/index.html","hash":"7050da6f5ccc1c9f97590203c884ecb27a6d7e15","modified":1547647871384},{"_id":"public/archives/2017/12/index.html","hash":"e2eda202f3b0717d123f2f896ccf5e24a2f0c014","modified":1547647871384},{"_id":"public/archives/2018/index.html","hash":"28ebe0e62f145e8e657768de54969278d1883821","modified":1547647871384},{"_id":"public/archives/2019/index.html","hash":"5e43484f313aa7aa2abffe33b122490ceae37eba","modified":1547647871399},{"_id":"public/archives/2018/01/index.html","hash":"28ebe0e62f145e8e657768de54969278d1883821","modified":1547647871384},{"_id":"public/archives/2019/01/index.html","hash":"5e43484f313aa7aa2abffe33b122490ceae37eba","modified":1547647871399},{"_id":"public/categories/CPP/index.html","hash":"f4668fe85e6bebd8367c8c5479eb1f364a12901d","modified":1547647871384},{"_id":"public/categories/LeetCode/index.html","hash":"2d8860d597b9e73d305abbb4d66d363c14d28fca","modified":1547647871384},{"_id":"public/archives/2017/05/index.html","hash":"1c209c5f530fd579c0256a7ae4b2aec6d6b6a104","modified":1547647871384},{"_id":"public/archives/2017/06/index.html","hash":"b733a48b00aed2894a139252398b1ebbce6fcb1a","modified":1547647871384},{"_id":"public/categories/Python/index.html","hash":"7693ecc7206583a6d6a9b68d9a7568c4cf63582e","modified":1547647871384},{"_id":"public/categories/Development/index.html","hash":"dd64231faf4c15774390a5a20aac9a5ee5dcf63c","modified":1547647871384},{"_id":"public/categories/Python/page/2/index.html","hash":"363ca6ba8606b0cb55eb0a3ad1ee5816aacdaae5","modified":1547647871384},{"_id":"public/categories/helloworld/index.html","hash":"f5b8b2178365cc78a710f33b81de12bd8107c2d5","modified":1547647871384},{"_id":"public/tags/C-Primer/index.html","hash":"28598c04be22da3522dbed3597b0285aa372c52e","modified":1547647871384},{"_id":"public/categories/DataStructure/index.html","hash":"9ee89a50189cc3763cad7b0007b9ce3b88397dd5","modified":1547647871384},{"_id":"public/tags/String/index.html","hash":"02e2f5552845f5da480884aeb4f90308cee2cc1c","modified":1547647871384},{"_id":"public/tags/C/index.html","hash":"799b2fd40c0ceac84334a2102df8b350b3d752bf","modified":1547647871384},{"_id":"public/tags/LeetCode/index.html","hash":"2d8860d597b9e73d305abbb4d66d363c14d28fca","modified":1547647871384},{"_id":"public/tags/vector/index.html","hash":"9fa4c9a727669af57323a158114c0c55c898b363","modified":1547647871384},{"_id":"public/tags/Python/index.html","hash":"4d1c67ea785dc177be4ae29aceb804347cfc950d","modified":1547647871384},{"_id":"public/tags/词云/index.html","hash":"bc8ca6345334a83531074c55a9f70c963431f681","modified":1547647871384},{"_id":"public/tags/UTF-8/index.html","hash":"7779c1210e9a340a7ddc950a92cb719d39bf48f3","modified":1547647871384},{"_id":"public/tags/VSCode/index.html","hash":"dd64231faf4c15774390a5a20aac9a5ee5dcf63c","modified":1547647871384},{"_id":"public/tags/IDE/index.html","hash":"7050da6f5ccc1c9f97590203c884ecb27a6d7e15","modified":1547647871384},{"_id":"public/tags/helloworld/index.html","hash":"f5b8b2178365cc78a710f33b81de12bd8107c2d5","modified":1547647871384},{"_id":"public/tags/正则表达式/index.html","hash":"9bb68b580e5aa88ddec077bd028e644344769aaf","modified":1547647871384},{"_id":"public/tags/BinaryTree/index.html","hash":"9ee89a50189cc3763cad7b0007b9ce3b88397dd5","modified":1547647871384},{"_id":"public/tags/每周一坑/index.html","hash":"d3275bdbdbfb2617d2af7643c4e82fe2a81fcab9","modified":1547647871399},{"_id":"public/about/index.html","hash":"01f25e4248109872b5e8418dafcfae58a7bb2cbd","modified":1547647871399},{"_id":"public/2018/01/09/LeetCode-19-Remove-Nth-Node-From-End-of-List/index.html","hash":"5a82c0beb5a2ceec084fee285994361b08e4eca6","modified":1547647871399},{"_id":"public/2019/01/08/VSCode-Extensions/index.html","hash":"6394197f88650124b92883ac18bba79c5cba6d38","modified":1547647871399},{"_id":"public/2017/12/29/LeetCode-751-IP-to-CIDR/index.html","hash":"63edc7583673e7cf176585ce9dd23aab4c641691","modified":1547647871399},{"_id":"public/2017/11/17/Visual-Studio项目中集成Google-Test测试框架/index.html","hash":"bd7a36550b7b41f1c6df6df120ea553561357de7","modified":1547647871399},{"_id":"public/2017/10/09/二叉树相关问题-转载/index.html","hash":"cbbe8b0205eea4c06c57942960c30dea79f5b272","modified":1547647871399},{"_id":"public/2017/10/09/UTF-8-码点/index.html","hash":"97b5fac542d435b424902b83ec07f28283d19148","modified":1547647871399},{"_id":"public/2017/10/13/【每周一坑】注册表单验证/index.html","hash":"bc2092d89453102bf94180ac92f14984d0d7e637","modified":1547647871399},{"_id":"public/2017/09/06/【每周一坑】矩阵旋转/index.html","hash":"e7ac0e400b182778c70066cd36c7aea15b3b892c","modified":1547647871399},{"_id":"public/2017/08/04/【每周一坑】阿姆斯特朗数/index.html","hash":"457af3fc89cc0a0649f2cc186742a2c36bb48a6f","modified":1547647871399},{"_id":"public/2017/07/08/【每周一坑】罗马数字转换/index.html","hash":"dbda438fb45abf00fbac22e2bd7a1ed546387720","modified":1547647871399},{"_id":"public/2017/06/07/C-Primer-第五版-练习-12-33/index.html","hash":"ef4dd8011de787e18eb29acb565cde9e585bc451","modified":1547647871399},{"_id":"public/2017/06/23/【每周一坑】螺旋矩阵/index.html","hash":"5a4da8df006a6180f95f351415a3e6cff72a8428","modified":1547647871399},{"_id":"public/2017/06/09/【每周一坑】校验文件哈希/index.html","hash":"c0eae879422d34532e38526ab9f6a02c3749a230","modified":1547647871399},{"_id":"public/2017/06/15/C-中的explicit关键字/index.html","hash":"1812c59c070195e700b7d57f0c8d46397e19dc6d","modified":1547647871399},{"_id":"public/2017/05/28/【每周一坑】验证哥德巴赫猜想/index.html","hash":"4bd12776aad042b6bcf4a1a04f4dc05010715f39","modified":1547647871399},{"_id":"public/2017/05/15/【每周一坑】神奇的九宫格/index.html","hash":"f3e31448282de2b3328ba941567f72a5202b44fb","modified":1547647871399},{"_id":"public/2017/04/27/【每周一坑】程序员的浪漫/index.html","hash":"73dbb2df260a7873e520711049918dd5a3347d88","modified":1547647871399},{"_id":"public/2017/04/15/函数返回数组指针或数组引用/index.html","hash":"6f049d1192c8742b2d414dd82b00305d06408a3c","modified":1547647871399},{"_id":"public/2017/04/07/C-前置递增（递减）和后置递增（递减）运算符/index.html","hash":"dbe14dc851610e7b446869064f1c4f76e7860a8f","modified":1547647871399},{"_id":"public/2017/03/31/C-string输入问题/index.html","hash":"80130d613dee2b70022400b3c3f62ed3c8b2eb03","modified":1547647871399},{"_id":"public/2017/03/25/给出一个表达式，按照顺序求出表达式的值/index.html","hash":"421701055c00051e21fb108896f31552ad0b0eeb","modified":1547647871399},{"_id":"public/2017/05/03/【每周一坑】求乘积最大/index.html","hash":"79f49819e1a6630adaf8d0b65c1660a50697ccb2","modified":1547647871399},{"_id":"public/2017/05/26/C-Primer-第五版-练习12-3/index.html","hash":"0d820fdd411ff6b3d97041ca99b8af89c0552ead","modified":1547647871399},{"_id":"public/2017/05/19/【每周一坑】杨辉三角形/index.html","hash":"7503e941cab538e9140dc5d9f3d34716e5c90566","modified":1547647871399},{"_id":"public/2017/03/25/Python生成词云/index.html","hash":"9d3eb0c09639f799fc4e2e2c092491af5f56e0df","modified":1547647871399},{"_id":"public/2017/03/23/Python3脚本抓取Bing美图/index.html","hash":"bbd43b723a3088666b31e19790e3fcbf1eb0ef1f","modified":1547647871399},{"_id":"public/2017/03/21/hello-world/index.html","hash":"b63787d48ab448ef3f4200a69c2373ebf87dd16e","modified":1547647871399},{"_id":"public/index.html","hash":"4af0cf7543dd721d560e661e57c82b577e0dc76c","modified":1547647871399},{"_id":"public/page/2/index.html","hash":"039b802dcc7f6e87428a282999a276945263a901","modified":1547647871399},{"_id":"public/page/3/index.html","hash":"78f3e9ffc6fe6ff494fce8429c8f659f69adcbea","modified":1547647871399},{"_id":"public/tags/每周一坑/page/2/index.html","hash":"01a31957e28a7b9eb3b01a46d879b6f751781a44","modified":1547647871399},{"_id":"public/images/avatar.png","hash":"1ffd03678d665d958cd861afb37f192195fa32d1","modified":1546999618730},{"_id":"public/CNAME","hash":"ce6b68629115b85da6d080512d5aea0af7259520","modified":1546999618730},{"_id":"public/images/imagesource/17-06-23.jpg","hash":"6efbfd2fbea3d57fa766e7eba8c842b9a7bedaae","modified":1546999618730},{"_id":"public/images/imagesource/17-03-25-2.jpg","hash":"d39c83dad6ca202f658a5080c8410cb6784312aa","modified":1546999618730},{"_id":"public/images/imagesource/17-08-04.jpg","hash":"ee945fff8e14b14d59359289f08b8f1d7f36821b","modified":1546999618730},{"_id":"public/images/imagesource/19-01-08.png","hash":"4e5e64367f7763266febadd4acc817d043c36dbc","modified":1546999618730},{"_id":"public/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1546999618730},{"_id":"public/assets/bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1546999618730},{"_id":"public/images/imagesource/17-04-27.jpg","hash":"c88c5a4e690fd2b00258308aa9ae559cf5ad50f1","modified":1546999618730},{"_id":"public/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1546999618730},{"_id":"public/images/imagesource/17-05-28.jpg","hash":"8078c9bb635146749c2356ce09d4e488f872ca41","modified":1546999618730},{"_id":"public/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1546999618730},{"_id":"public/assets/favicon.ico","hash":"9c8bfe8304dca970178f51b8cf9aa5408e4df891","modified":1546999618730},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1546999618730},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1546999618730},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1546999618730},{"_id":"public/intro/404-bg.jpg","hash":"57c16afc4ef40f714fa4fda78f1e4ee038b318f9","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-10.png","hash":"1f4f28d04c87e1c59a5dec5424a797c294dd9e85","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-12.png","hash":"0be73a6feb1e842f719fcb58eefc79ff7860f7bd","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-1.png","hash":"7f50f4c5eadb21b235025ecb46b1fe7e729e643d","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-13.png","hash":"30608ba4948767ee479fc6c7786821313f4f9b9e","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-11.png","hash":"c59a8f5246ad69cf54816ab8d6bac6f24307c158","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-14.png","hash":"2ccbb9ad0a1b735a63fc709a34f88d943f9480b0","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-15.png","hash":"d98350de39ce3d11ced2a895b66f30abb2afe626","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-18.png","hash":"2f346b4ae1b638695a0a1836c1d0eec3d608a06a","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-19.png","hash":"316eef52efd7aa15a0a6235575a6507965a2d6d0","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-3.png","hash":"caf5090ac3b0fce9c3129303626186019e3e7e1d","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-17.png","hash":"34671fb79859da8ea4fa5f24c44014e3e261d01d","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-4.png","hash":"4d247dbe07a773598cf5565fa9841ce4bc1950b6","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-2.png","hash":"fe7ac32c219f8715bcf6f9f078c45a0622be8874","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-5.png","hash":"e8b342adf7dde2f18adae32881407e279f31379c","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-9.png","hash":"937e4b2b5ecf7813f477b1dafbf0944e6f039658","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-6.png","hash":"5fc15c3d9a3852e9a58bd5c51da9170e6787e4d3","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-7.png","hash":"c17a47924fd2d370f56c465f6639b1c431f5aeb3","modified":1546999618730},{"_id":"public/images/imagesource/17-11-17/17-11-17-8.png","hash":"fce6707121dd112795714df07b700c01a733c9e4","modified":1546999618730},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"fb0ff0949c9179447690e049aaced1ee0615941b","modified":1546999618746},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1546999618746},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1546999618777},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1546999618777},{"_id":"public/intro/404-bg.jpg.bak","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1546999618777},{"_id":"public/images/imagesource/17-07-08.jpg","hash":"77b1420469d95dc44725a4a2b58d758788487a72","modified":1546999618777},{"_id":"public/images/imagesource/17-11-17/17-11-17-16.png","hash":"261abc9693a15f0009bc9fd08fa246293e9e25f7","modified":1546999618777},{"_id":"public/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1546999618964},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1546999618964},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1546999618980},{"_id":"public/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1546999618980},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1546999618980},{"_id":"public/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1546999618980},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1546999618980},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"001e6cc7c8f14dd9c544942410cea2dda5fe5387","modified":1546999618980},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"5244731131a647d230c1d80731171191adc7e2a8","modified":1546999618980},{"_id":"public/images/imagesource/17-06-09.png","hash":"4ec8fa57b1e15c9f5b9b021da5492d3b9e965e4d","modified":1546999619214},{"_id":"public/intro/post-bg.jpg.bak","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1546999619214},{"_id":"public/intro/about-bg.jpg.bak","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1546999619214},{"_id":"public/assets/algolia/algoliasearch.js","hash":"f0e3215b0553fcc11715d655e35cbc8dea9bae85","modified":1546999621585},{"_id":"public/images/imagesource/17-03-23.jpg","hash":"2c384536f5c8ee9c8266362a0472fe46846edc07","modified":1546999621652},{"_id":"public/intro/post-bg.jpg","hash":"ab07b2fe6becaa95081a1c4fa8d3a052ffe178a1","modified":1546999621652},{"_id":"public/intro/index-bg.jpg.bak","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1546999621714},{"_id":"public/images/imagesource/17-03-25-1.png","hash":"0d52efafdf810859c9c11627b58ba4168bab3bc8","modified":1546999621745},{"_id":"public/intro/index-bg.jpg","hash":"ee0f7f1f419493b8fe2290e71b36ee121067ff39","modified":1546999621808},{"_id":"public/intro/about-bg.jpg","hash":"f1f40e89d1bc519b364136ec8fac8ad39865e903","modified":1546999621808},{"_id":"public/images/background.jpg","hash":"d7db27a39ef107c8911a4e5eae302268393a7039","modified":1546999621823},{"_id":"source/images/bing/BingWallPaper-2019-01-08.jpg","hash":"37aab6fbaa550db66847ada43f270a196142c8fd","modified":1546916416358},{"_id":"public/images/bing/BingWallPaper-2019-01-08.jpg","hash":"37aab6fbaa550db66847ada43f270a196142c8fd","modified":1547003127101},{"_id":"source/google2e409c2d3b4ed9c8.html","hash":"12d2a7d5c00d8aea5a62539288068082b5934035","modified":1547017951784},{"_id":"public/google2e409c2d3b4ed9c8.html","hash":"cbb7a138ad874a65d90f26265801869edf42a35d","modified":1547018028623},{"_id":"source/_posts/Hexo-Travis-CI-auto-deploy.md","hash":"da2e1e5a03f6c39092be6f3548233cdf83bcab3c","modified":1547624447013},{"_id":"source/images/imagesource/19-01-16/2019-01-16-1.png","hash":"f1e63a5b3bf7b4fca891e2a6e4f8a35016223d45","modified":1547619260969},{"_id":"source/images/imagesource/19-01-16/2019-01-16-2.png","hash":"92b412858e9e7cbbdb7129e0ccef95f1181081ff","modified":1547619803851},{"_id":"source/images/imagesource/19-01-16/2019-01-16-3.png","hash":"f1aa869a297332fecac9253af18531e757e1b1c0","modified":1547620941317},{"_id":"source/images/imagesource/19-01-16/2019-01-16-4.png","hash":"e29c988d233a84eee395ae453f390f0d51b1b0da","modified":1547621162416},{"_id":"source/images/imagesource/19-01-16/2019-01-16-5.png","hash":"430dbec89c4e01e16b7e98fcaed1954a6837a5a9","modified":1547621319079},{"_id":"source/images/imagesource/19-01-16/2019-01-16-6.png","hash":"2e9ba5be898b2bbfffd6cc496ea02786fa67e699","modified":1547621636784},{"_id":"source/images/imagesource/19-01-16/TravisCI-Full-Color.png","hash":"28b210ec069326d1914b54186854e278b874e08e","modified":1547623528076},{"_id":"source/images/imagesource/19-01-16/2019-01-16-7.png","hash":"82eecba0cd84dd751a4a0bcfbaaaa564ea0e38d4","modified":1547622765418},{"_id":"source/images/bing/BingWallPaper-2019-01-16.jpg","hash":"b842db9b6f6ce36b3fdfdde2b6b67235ffe86e91","modified":1547607606860},{"_id":"public/categories/Tech/index.html","hash":"e12e03c8631f1a7036edf51cf9de42f5709149f8","modified":1547647871415},{"_id":"public/tags/Travis-CI/index.html","hash":"e12e03c8631f1a7036edf51cf9de42f5709149f8","modified":1547647871415},{"_id":"public/tags/Hexo/index.html","hash":"e12e03c8631f1a7036edf51cf9de42f5709149f8","modified":1547647871415},{"_id":"public/2019/01/16/Hexo-Travis-CI-auto-deploy/index.html","hash":"9d49900bdfbafc1f6661e2beb4e2660b625c2e9f","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-1.png","hash":"f1e63a5b3bf7b4fca891e2a6e4f8a35016223d45","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-2.png","hash":"92b412858e9e7cbbdb7129e0ccef95f1181081ff","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-3.png","hash":"f1aa869a297332fecac9253af18531e757e1b1c0","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-4.png","hash":"e29c988d233a84eee395ae453f390f0d51b1b0da","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-5.png","hash":"430dbec89c4e01e16b7e98fcaed1954a6837a5a9","modified":1547647871415},{"_id":"public/images/imagesource/19-01-16/2019-01-16-6.png","hash":"2e9ba5be898b2bbfffd6cc496ea02786fa67e699","modified":1547647871430},{"_id":"public/images/imagesource/19-01-16/TravisCI-Full-Color.png","hash":"28b210ec069326d1914b54186854e278b874e08e","modified":1547647871430},{"_id":"public/images/imagesource/19-01-16/2019-01-16-7.png","hash":"82eecba0cd84dd751a4a0bcfbaaaa564ea0e38d4","modified":1547647871430},{"_id":"public/images/bing/BingWallPaper-2019-01-16.jpg","hash":"b842db9b6f6ce36b3fdfdde2b6b67235ffe86e91","modified":1547647874482}],"Category":[{"name":"CPP","_id":"cjqojmlv00006swqc19in2rhk"},{"name":"LeetCode","_id":"cjqojmlwb000qswqcn51rol97"},{"name":"Python","_id":"cjqojmlwq0011swqc582myis1"},{"name":"Development","_id":"cjqojmlx6001gswqcm941r7p0"},{"name":"helloworld","_id":"cjqojmlxm001pswqcwy10ajpi"},{"name":"DataStructure","_id":"cjqojmly10026swqcuuboxrrd"},{"name":"Tech","_id":"cjqz9kud70001m8qcniy18kzw"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n\t<title>404 - FreedomLy</title>\n\t<meta name=\"description\" content=\"404������ҳ�治���ڣ�\">\n\t<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\t<meta name=\"robots\" content=\"all\" />\n\t<meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n\t<title>404 - FreedomLy</title>\n\t<meta name=\"description\" content=\"404������ҳ�治���ڣ�\">\n\t<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\t<meta name=\"robots\" content=\"all\" />\n\t<meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2017-03-22T11:02:33.191Z","updated":"2017-03-22T11:02:33.191Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjqojmlsu0000swqcp63lm6yf","content":"<!DOCTYPE HTML>\n<html>\n<head>\n\t<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>404 - FreedomLy</title>\n\t<meta name=\"description\" content=\"404������ҳ�治���ڣ�\">\n\t<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n\t<meta name=\"robots\" content=\"all\">\n\t<meta name=\"robots\" content=\"index,follow\"><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</head>\n<body>\n\t<!-- hexo-inject:begin --><!-- hexo-inject:end --><script type=\"text/javascript\" src=\"http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js\" charset=\"utf-8\"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n\t<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>404 - FreedomLy</title>\n\t<meta name=\"description\" content=\"404������ҳ�治���ڣ�\">\n\t<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\t<meta name=\"robots\" content=\"all\" />\n\t<meta name=\"robots\" content=\"index,follow\"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</head>\n<body>\n\t<!-- hexo-inject:begin --><!-- hexo-inject:end --><script type=\"text/javascript\" src=\"http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js\" charset=\"utf-8\"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</body>\n</html>"},{"layout":"404","title":"404","description":"Oops! Page not found...","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"404\"\ndescription: \"Oops! Page not found...\"\n---","date":"2019-01-08T06:51:23.730Z","updated":"2019-01-08T06:51:23.730Z","path":"404.html","comments":1,"_id":"cjqojmlt90001swqcp22jp8gu","content":"","excerpt":"","more":""},{"title":"关于","date":"2017-03-21T14:16:45.000Z","layout":"about","_content":"---\nName: Feilong Jiang\nBirthday: 1993-10-03\nLocation: Hangzhou, Zhejiang, China\nContact me: <Freedom.JFL@gmail.com>， <Freedom.JFL@live.com>\n\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n> 所谓眼泪啊 \n是流出来就能把辛酸和悲伤都冲走的好东西\n可等你们有一天长大成人就会明白\n人生中还有眼泪也冲刷不干净的巨大悲伤\n还有痛苦让你们即使想哭也不能流泪\n所以真正坚强的人\n都是越想哭反而笑得越大声\n怀揣着一切痛苦和悲伤\n即使如此也要带着它们笑着前行\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-03-21 22:16:45\nlayout: about\n# type: \"about\"\n# comments: true\n---\n---\nName: Feilong Jiang\nBirthday: 1993-10-03\nLocation: Hangzhou, Zhejiang, China\nContact me: <Freedom.JFL@gmail.com>， <Freedom.JFL@live.com>\n\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n> 所谓眼泪啊 \n是流出来就能把辛酸和悲伤都冲走的好东西\n可等你们有一天长大成人就会明白\n人生中还有眼泪也冲刷不干净的巨大悲伤\n还有痛苦让你们即使想哭也不能流泪\n所以真正坚强的人\n都是越想哭反而笑得越大声\n怀揣着一切痛苦和悲伤\n即使如此也要带着它们笑着前行\n\n\n","updated":"2019-01-07T13:00:30.874Z","path":"about/index.html","comments":1,"_id":"cjqojmlv00003swqc3lbo2a71","content":"<hr>\n<p>Name: Feilong Jiang<br>Birthday: 1993-10-03<br>Location: Hangzhou, Zhejiang, China<br>Contact me: <a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#70;&#114;&#x65;&#101;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#76;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#114;&#x65;&#101;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#76;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a>， <a href=\"&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#70;&#x72;&#101;&#x65;&#x64;&#111;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#x72;&#101;&#x65;&#x64;&#111;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;</a></p>\n<hr>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"500\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\"><br></iframe>\n\n\n\n\n<blockquote>\n<p>所谓眼泪啊<br>是流出来就能把辛酸和悲伤都冲走的好东西<br>可等你们有一天长大成人就会明白<br>人生中还有眼泪也冲刷不干净的巨大悲伤<br>还有痛苦让你们即使想哭也不能流泪<br>所以真正坚强的人<br>都是越想哭反而笑得越大声<br>怀揣着一切痛苦和悲伤<br>即使如此也要带着它们笑着前行</p>\n</blockquote>\n","excerpt":"","more":"<hr>\n<p>Name: Feilong Jiang<br>Birthday: 1993-10-03<br>Location: Hangzhou, Zhejiang, China<br>Contact me: <a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#70;&#114;&#x65;&#101;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#76;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#114;&#x65;&#101;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#76;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a>， <a href=\"&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#70;&#x72;&#101;&#x65;&#x64;&#111;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#x72;&#101;&#x65;&#x64;&#111;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;</a></p>\n<hr>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\"><br></iframe>\n\n\n\n\n<blockquote>\n<p>所谓眼泪啊<br>是流出来就能把辛酸和悲伤都冲走的好东西<br>可等你们有一天长大成人就会明白<br>人生中还有眼泪也冲刷不干净的巨大悲伤<br>还有痛苦让你们即使想哭也不能流泪<br>所以真正坚强的人<br>都是越想哭反而笑得越大声<br>怀揣着一切痛苦和悲伤<br>即使如此也要带着它们笑着前行</p>\n</blockquote>\n"},{"title":"文章分类","date":"2019-01-07T13:45:34.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-01-07 21:45:34\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-01-07T13:46:01.608Z","path":"categories/index.html","layout":"page","_id":"cjqojmlv00005swqc9hsqqdp1","content":"","excerpt":"","more":""},{"title":"sitemap","date":"2017-03-21T14:17:04.000Z","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2017-03-21 22:17:04\n---\n","updated":"2017-03-21T14:17:04.891Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"cjqojmlvg0009swqcphrd3z9l","content":"","excerpt":"","more":""},{"title":"标签","date":"2017-03-21T14:15:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-03-21 22:15:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-01-07T13:46:22.714Z","path":"tags/index.html","layout":"page","_id":"cjqojmlvg000bswqc3fdsxblo","content":"","excerpt":"","more":""}],"Post":[{"title":"C++ Primer 第五版 练习 12.33","date":"2017-06-07T14:39:56.000Z","comments":1,"_content":"\nC++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——**文本查询程序**。\n<!--more-->\n\n## 文本查询程序\n\n> 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。\n\n## 文本查询程序设计\n\n设计两个类：`TextQuery`和`QueryResult`\n其中`TextQuery`用来生成每个单词对应的行号以及进行相关的查询操作；\n`QuerResult`用来保存查询结果，通过其成员函数`print()`输出查询结果。\n\n## 查询程序的实现\n\nQuery.h\n```C++\n#pragma once\n/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，\n   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，\n   返回一个shared_ptr，指向QueryResult对象中的文件\n*/\n\n#include\"12.22.h\"\n// 定义了StrBlob类的头文件\nusing std::shared_ptr;\n\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<set>\n\n// 为了定义函数query的返回类型，这个定义是必须的\nclass QueryResult;\nclass TextQuery {\npublic:\n\tTextQuery(std::ifstream&);\n\tQueryResult query(const string&) const;\n\nprivate:\n \t// 输入文件\n\tshared_ptr<StrBlob> file;\t\t\t\t\t\t   \n\t// 每个单词到它所在行号的映射\n\tstd::map<std::string, \n\t\tshared_ptr<std::set<StrBlob::size_type>>> wordmap;\n};\n\nclass QueryResult {\n\tusing qr_iter = std::set<StrBlob::size_type>::iterator;\n\tfriend std::ostream &print(std::ostream&, QueryResult&);\n\npublic:\n\tQueryResult(string s, shared_ptr<std::set<StrBlob::size_type>> l, shared_ptr<StrBlob> f) :\n\t\tword(s), lines(l), file(f) {}\n\n\tqr_iter begin() const { return lines->begin(); }\n\tqr_iter end() const { return lines->end(); }\n\n\tshared_ptr<StrBlob> get_file() const { return file; }\n\nprivate:\n\t// 查询单词\n\tstring word;\n\t// 出现的行号\n\tshared_ptr<std::set<StrBlob::size_type>> lines;\n\t // 输入文件\n\tshared_ptr<StrBlob> file;\n};\n\nstd::ostream &print(std::ostream &os, QueryResult &query_result);\n\n```\n\nQuery.cpp\n```C++\n#include \"Query.h\"\n#include<iterator>\n#include<sstream>\n#include<algorithm>\n\n//读取输入文件并建立单词到行号的映射\nTextQuery::TextQuery(std::ifstream &ifs) : file(new StrBlob)\n{\n\t// 保存行号\n\tStrBlob::size_type line_no{ 0 };\n\t// 对文件中的每一行\n\tfor (string line; std::getline(ifs, line); ++line_no)\n\t{\n\t\t// 保存此行文本\n\t\tfile->push_back(line);\n\t\t // 将文本分解为单词\n\t\tstd::istringstream stream(line);\n\t\t// 对行中每个单词\n\t\tfor (string text, word; stream >> text; word.clear())\n\t\t{\n\t\t\t// 去除单词中的标点符号\n\t\t\tstd::remove_copy_if(text.begin(), text.end(),\n\t\t\t\tstd::back_inserter(word), ispunct);\n\t\t\t// 如果单词不在wordmap中，以之为下标在wordmap中添加一项\n\t\t\tauto &lines = wordmap[word];\n\t\t\t// 第一次遇到这个单词时，lines的指针为空\n\t\t\t// 分配一个新的set\n\t\t\tif (!lines) lines.reset(new std::set<StrBlob::size_type>);\n\t\t\t// 将此行号插入set中\n\t\t\tlines->insert(line_no);\n\t\t}\n\t}\n}\n\nQueryResult TextQuery::query(const string &sought) const\n{\n\t// 如果未找到sought，将返回一个指向此set的指针\n\tstatic shared_ptr<std::set<StrBlob::size_type>>\n\t\tnodata(new std::set< StrBlob::size_type>);\n\t// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中\n\tauto found = wordmap.find(sought);\n\tif (found != wordmap.end())\n\t\t// 找到单词\n\t\treturn QueryResult(sought, found->second, file);\n\telse\n\t\t// 未找到\n\t\treturn QueryResult(sought, nodata, file);\n}\n\nstd::ostream & print(std::ostream &os, QueryResult &query_result)\n{\n\t// TODO: 在此处插入 return 语句\n\t// 如果找到了单词，打印出现次数和所有出现的位置\n\tos << query_result.word << \" occurs \" << query_result.lines->size() << \" \"\n\t\t<< (query_result.lines->size() > 1 ? \"times.\" : \"time.\") << std::endl;\n\n\t// 打印单词出现的每一行\n\tfor (auto it = query_result.begin(); it != query_result.end(); ++it)\n\t{\n\t\tConstStrBlobPtr p(*query_result.file, *it);\n\t\tos << \"\\t(line \" << *it + 1 << \") \" << p.deref() << std::endl;\n\t}\n\treturn os;\n}\n```\n\n## 测试\nQuery_test.cpp\n```C++\n#include\"12.33.h\"\n\nvoid runQueries(std::ifstream &ifs)\n{\n\tTextQuery text_query(ifs);\n\tdo\n\t{\n\t\tstd::cout << \"Enter word to look for or q to quit: \";\n\t\tstring word;\n\t\tif (!(std::cin >> word) || word == \"q\") break;\n\t\tprint(std::cout, text_query.query(word)) << std::endl;\n\t} while (true);\n}\n\nint main()\n{\n\tstd::ifstream ifs(\"data/story.txt\");\n\trunQueries(ifs);\n\n\treturn 0;\n}\n```\n\n## 总结\n这里用到了之前几节定义的`StrBlob`来代替`vector<string>`来保存每一行的内容。\n算是一个比较综合的练习了。刚开始做没什么思路，多亏了[GayHub](https://github.com/pezy/CppPrimer)（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!\n(ง •̀_•́)ง \n\n\n\nEnd~\n\n---","source":"_posts/C-Primer-第五版-练习-12-33.md","raw":"---\ntitle: C++ Primer 第五版 练习 12.33\ndate: 2017-06-07 22:39:56\ncategory: CPP\ntags: C++ Primer\ncomments: true\n---\n\nC++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——**文本查询程序**。\n<!--more-->\n\n## 文本查询程序\n\n> 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。\n\n## 文本查询程序设计\n\n设计两个类：`TextQuery`和`QueryResult`\n其中`TextQuery`用来生成每个单词对应的行号以及进行相关的查询操作；\n`QuerResult`用来保存查询结果，通过其成员函数`print()`输出查询结果。\n\n## 查询程序的实现\n\nQuery.h\n```C++\n#pragma once\n/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，\n   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，\n   返回一个shared_ptr，指向QueryResult对象中的文件\n*/\n\n#include\"12.22.h\"\n// 定义了StrBlob类的头文件\nusing std::shared_ptr;\n\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<set>\n\n// 为了定义函数query的返回类型，这个定义是必须的\nclass QueryResult;\nclass TextQuery {\npublic:\n\tTextQuery(std::ifstream&);\n\tQueryResult query(const string&) const;\n\nprivate:\n \t// 输入文件\n\tshared_ptr<StrBlob> file;\t\t\t\t\t\t   \n\t// 每个单词到它所在行号的映射\n\tstd::map<std::string, \n\t\tshared_ptr<std::set<StrBlob::size_type>>> wordmap;\n};\n\nclass QueryResult {\n\tusing qr_iter = std::set<StrBlob::size_type>::iterator;\n\tfriend std::ostream &print(std::ostream&, QueryResult&);\n\npublic:\n\tQueryResult(string s, shared_ptr<std::set<StrBlob::size_type>> l, shared_ptr<StrBlob> f) :\n\t\tword(s), lines(l), file(f) {}\n\n\tqr_iter begin() const { return lines->begin(); }\n\tqr_iter end() const { return lines->end(); }\n\n\tshared_ptr<StrBlob> get_file() const { return file; }\n\nprivate:\n\t// 查询单词\n\tstring word;\n\t// 出现的行号\n\tshared_ptr<std::set<StrBlob::size_type>> lines;\n\t // 输入文件\n\tshared_ptr<StrBlob> file;\n};\n\nstd::ostream &print(std::ostream &os, QueryResult &query_result);\n\n```\n\nQuery.cpp\n```C++\n#include \"Query.h\"\n#include<iterator>\n#include<sstream>\n#include<algorithm>\n\n//读取输入文件并建立单词到行号的映射\nTextQuery::TextQuery(std::ifstream &ifs) : file(new StrBlob)\n{\n\t// 保存行号\n\tStrBlob::size_type line_no{ 0 };\n\t// 对文件中的每一行\n\tfor (string line; std::getline(ifs, line); ++line_no)\n\t{\n\t\t// 保存此行文本\n\t\tfile->push_back(line);\n\t\t // 将文本分解为单词\n\t\tstd::istringstream stream(line);\n\t\t// 对行中每个单词\n\t\tfor (string text, word; stream >> text; word.clear())\n\t\t{\n\t\t\t// 去除单词中的标点符号\n\t\t\tstd::remove_copy_if(text.begin(), text.end(),\n\t\t\t\tstd::back_inserter(word), ispunct);\n\t\t\t// 如果单词不在wordmap中，以之为下标在wordmap中添加一项\n\t\t\tauto &lines = wordmap[word];\n\t\t\t// 第一次遇到这个单词时，lines的指针为空\n\t\t\t// 分配一个新的set\n\t\t\tif (!lines) lines.reset(new std::set<StrBlob::size_type>);\n\t\t\t// 将此行号插入set中\n\t\t\tlines->insert(line_no);\n\t\t}\n\t}\n}\n\nQueryResult TextQuery::query(const string &sought) const\n{\n\t// 如果未找到sought，将返回一个指向此set的指针\n\tstatic shared_ptr<std::set<StrBlob::size_type>>\n\t\tnodata(new std::set< StrBlob::size_type>);\n\t// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中\n\tauto found = wordmap.find(sought);\n\tif (found != wordmap.end())\n\t\t// 找到单词\n\t\treturn QueryResult(sought, found->second, file);\n\telse\n\t\t// 未找到\n\t\treturn QueryResult(sought, nodata, file);\n}\n\nstd::ostream & print(std::ostream &os, QueryResult &query_result)\n{\n\t// TODO: 在此处插入 return 语句\n\t// 如果找到了单词，打印出现次数和所有出现的位置\n\tos << query_result.word << \" occurs \" << query_result.lines->size() << \" \"\n\t\t<< (query_result.lines->size() > 1 ? \"times.\" : \"time.\") << std::endl;\n\n\t// 打印单词出现的每一行\n\tfor (auto it = query_result.begin(); it != query_result.end(); ++it)\n\t{\n\t\tConstStrBlobPtr p(*query_result.file, *it);\n\t\tos << \"\\t(line \" << *it + 1 << \") \" << p.deref() << std::endl;\n\t}\n\treturn os;\n}\n```\n\n## 测试\nQuery_test.cpp\n```C++\n#include\"12.33.h\"\n\nvoid runQueries(std::ifstream &ifs)\n{\n\tTextQuery text_query(ifs);\n\tdo\n\t{\n\t\tstd::cout << \"Enter word to look for or q to quit: \";\n\t\tstring word;\n\t\tif (!(std::cin >> word) || word == \"q\") break;\n\t\tprint(std::cout, text_query.query(word)) << std::endl;\n\t} while (true);\n}\n\nint main()\n{\n\tstd::ifstream ifs(\"data/story.txt\");\n\trunQueries(ifs);\n\n\treturn 0;\n}\n```\n\n## 总结\n这里用到了之前几节定义的`StrBlob`来代替`vector<string>`来保存每一行的内容。\n算是一个比较综合的练习了。刚开始做没什么思路，多亏了[GayHub](https://github.com/pezy/CppPrimer)（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!\n(ง •̀_•́)ง \n\n\n\nEnd~\n\n---","slug":"C-Primer-第五版-练习-12-33","published":1,"updated":"2019-01-07T13:44:48.222Z","layout":"post","photos":[],"link":"","_id":"cjqojmlv00002swqcl7hfoxr1","content":"<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。<br><a id=\"more\"></a></p>\n<h2 id=\"文本查询程序\"><a href=\"#文本查询程序\" class=\"headerlink\" title=\"文本查询程序\"></a>文本查询程序</h2><blockquote>\n<p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p>\n</blockquote>\n<h2 id=\"文本查询程序设计\"><a href=\"#文本查询程序设计\" class=\"headerlink\" title=\"文本查询程序设计\"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p>\n<h2 id=\"查询程序的实现\"><a href=\"#查询程序的实现\" class=\"headerlink\" title=\"查询程序的实现\"></a>查询程序的实现</h2><p>Query.h<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"comment\">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</span></div><div class=\"line\">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</div><div class=\"line\">   返回一个shared_ptr，指向QueryResult对象中的文件</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"12.22.h\"</span></span></div><div class=\"line\"><span class=\"comment\">// 定义了StrBlob类的头文件</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 为了定义函数query的返回类型，这个定义是必须的</span></div><div class=\"line\"><span class=\"keyword\">class</span> QueryResult;</div><div class=\"line\"><span class=\"keyword\">class</span> TextQuery &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\tTextQuery(<span class=\"built_in\">std</span>::ifstream&amp;);</div><div class=\"line\">\t<span class=\"function\">QueryResult <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\"> \t<span class=\"comment\">// 输入文件</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;\t\t\t\t\t\t   </div><div class=\"line\">\t<span class=\"comment\">// 每个单词到它所在行号的映射</span></div><div class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, </div><div class=\"line\">\t\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> QueryResult &#123;</div><div class=\"line\">\t<span class=\"keyword\">using</span> qr_iter = <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;::iterator;</div><div class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\tQueryResult(<span class=\"built_in\">string</span> s, <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; f) :</div><div class=\"line\">\t\tword(s), lines(l), file(f) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;begin(); &#125;</div><div class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;end(); &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; get_file() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> file; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">\t<span class=\"comment\">// 查询单词</span></div><div class=\"line\">\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t<span class=\"comment\">// 出现的行号</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</div><div class=\"line\">\t <span class=\"comment\">// 输入文件</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>Query.cpp<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Query.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取输入文件并建立单词到行号的映射</span></div><div class=\"line\">TextQuery::TextQuery(<span class=\"built_in\">std</span>::ifstream &amp;ifs) : file(<span class=\"keyword\">new</span> StrBlob)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// 保存行号</span></div><div class=\"line\">\tStrBlob::size_type line_no&#123; <span class=\"number\">0</span> &#125;;</div><div class=\"line\">\t<span class=\"comment\">// 对文件中的每一行</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> line; <span class=\"built_in\">std</span>::getline(ifs, line); ++line_no)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 保存此行文本</span></div><div class=\"line\">\t\tfile-&gt;push_back(line);</div><div class=\"line\">\t\t <span class=\"comment\">// 将文本分解为单词</span></div><div class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">stream</span><span class=\"params\">(line)</span></span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 对行中每个单词</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> text, word; stream &gt;&gt; text; word.clear())</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 去除单词中的标点符号</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">std</span>::remove_copy_if(text.begin(), text.end(),</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">std</span>::back_inserter(word), <span class=\"built_in\">ispunct</span>);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">auto</span> &amp;lines = wordmap[word];</div><div class=\"line\">\t\t\t<span class=\"comment\">// 第一次遇到这个单词时，lines的指针为空</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 分配一个新的set</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!lines) lines.reset(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 将此行号插入set中</span></div><div class=\"line\">\t\t\tlines-&gt;insert(line_no);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">QueryResult TextQuery::query(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;sought) <span class=\"keyword\">const</span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// 如果未找到sought，将返回一个指向此set的指针</span></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;</div><div class=\"line\">\t\tnodata(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt; StrBlob::size_type&gt;);</div><div class=\"line\">\t<span class=\"comment\">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></div><div class=\"line\">\t<span class=\"keyword\">auto</span> found = wordmap.find(sought);</div><div class=\"line\">\t<span class=\"keyword\">if</span> (found != wordmap.end())</div><div class=\"line\">\t\t<span class=\"comment\">// 找到单词</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, found-&gt;second, file);</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t<span class=\"comment\">// 未找到</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, nodata, file);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp; <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在此处插入 return 语句</span></div><div class=\"line\">\t<span class=\"comment\">// 如果找到了单词，打印出现次数和所有出现的位置</span></div><div class=\"line\">\tos &lt;&lt; query_result.word &lt;&lt; <span class=\"string\">\" occurs \"</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class=\"string\">\" \"</span></div><div class=\"line\">\t\t&lt;&lt; (query_result.lines-&gt;size() &gt; <span class=\"number\">1</span> ? <span class=\"string\">\"times.\"</span> : <span class=\"string\">\"time.\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 打印单词出现的每一行</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"function\">ConstStrBlobPtr <span class=\"title\">p</span><span class=\"params\">(*query_result.file, *it)</span></span>;</div><div class=\"line\">\t\tos &lt;&lt; <span class=\"string\">\"\\t(line \"</span> &lt;&lt; *it + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">\") \"</span> &lt;&lt; p.deref() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> os;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>Query_test.cpp<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"12.33.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runQueries</span><span class=\"params\">(<span class=\"built_in\">std</span>::ifstream &amp;ifs)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"function\">TextQuery <span class=\"title\">text_query</span><span class=\"params\">(ifs)</span></span>;</div><div class=\"line\">\t<span class=\"keyword\">do</span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter word to look for or q to quit: \"</span>;</div><div class=\"line\">\t\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (!(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; word) || word == <span class=\"string\">\"q\"</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\tprint(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>, text_query.query(word)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(<span class=\"string\">\"data/story.txt\"</span>)</span></span>;</div><div class=\"line\">\trunQueries(ifs);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href=\"https://github.com/pezy/CppPrimer\" target=\"_blank\" rel=\"external\">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p>\n<p>End~</p>\n<hr>\n","excerpt":"<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。<br>","more":"</p>\n<h2 id=\"文本查询程序\"><a href=\"#文本查询程序\" class=\"headerlink\" title=\"文本查询程序\"></a>文本查询程序</h2><blockquote>\n<p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p>\n</blockquote>\n<h2 id=\"文本查询程序设计\"><a href=\"#文本查询程序设计\" class=\"headerlink\" title=\"文本查询程序设计\"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p>\n<h2 id=\"查询程序的实现\"><a href=\"#查询程序的实现\" class=\"headerlink\" title=\"查询程序的实现\"></a>查询程序的实现</h2><p>Query.h<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"comment\">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</div><div class=\"line\">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</div><div class=\"line\">   返回一个shared_ptr，指向QueryResult对象中的文件</div><div class=\"line\">*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"12.22.h\"</span></span></div><div class=\"line\"><span class=\"comment\">// 定义了StrBlob类的头文件</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 为了定义函数query的返回类型，这个定义是必须的</span></div><div class=\"line\"><span class=\"keyword\">class</span> QueryResult;</div><div class=\"line\"><span class=\"keyword\">class</span> TextQuery &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\tTextQuery(<span class=\"built_in\">std</span>::ifstream&amp;);</div><div class=\"line\">\t<span class=\"function\">QueryResult <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\"> \t<span class=\"comment\">// 输入文件</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;\t\t\t\t\t\t   </div><div class=\"line\">\t<span class=\"comment\">// 每个单词到它所在行号的映射</span></div><div class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, </div><div class=\"line\">\t\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> QueryResult &#123;</div><div class=\"line\">\t<span class=\"keyword\">using</span> qr_iter = <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;::iterator;</div><div class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\tQueryResult(<span class=\"built_in\">string</span> s, <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; f) :</div><div class=\"line\">\t\tword(s), lines(l), file(f) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;begin(); &#125;</div><div class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;end(); &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; get_file() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> file; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">\t<span class=\"comment\">// 查询单词</span></div><div class=\"line\">\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t<span class=\"comment\">// 出现的行号</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</div><div class=\"line\">\t <span class=\"comment\">// 输入文件</span></div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>Query.cpp<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Query.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取输入文件并建立单词到行号的映射</span></div><div class=\"line\">TextQuery::TextQuery(<span class=\"built_in\">std</span>::ifstream &amp;ifs) : file(<span class=\"keyword\">new</span> StrBlob)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// 保存行号</span></div><div class=\"line\">\tStrBlob::size_type line_no&#123; <span class=\"number\">0</span> &#125;;</div><div class=\"line\">\t<span class=\"comment\">// 对文件中的每一行</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> line; <span class=\"built_in\">std</span>::getline(ifs, line); ++line_no)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 保存此行文本</span></div><div class=\"line\">\t\tfile-&gt;push_back(line);</div><div class=\"line\">\t\t <span class=\"comment\">// 将文本分解为单词</span></div><div class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">stream</span><span class=\"params\">(line)</span></span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 对行中每个单词</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> text, word; stream &gt;&gt; text; word.clear())</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 去除单词中的标点符号</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">std</span>::remove_copy_if(text.begin(), text.end(),</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">std</span>::back_inserter(word), <span class=\"built_in\">ispunct</span>);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">auto</span> &amp;lines = wordmap[word];</div><div class=\"line\">\t\t\t<span class=\"comment\">// 第一次遇到这个单词时，lines的指针为空</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 分配一个新的set</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!lines) lines.reset(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 将此行号插入set中</span></div><div class=\"line\">\t\t\tlines-&gt;insert(line_no);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">QueryResult TextQuery::query(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;sought) <span class=\"keyword\">const</span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// 如果未找到sought，将返回一个指向此set的指针</span></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;</div><div class=\"line\">\t\tnodata(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt; StrBlob::size_type&gt;);</div><div class=\"line\">\t<span class=\"comment\">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></div><div class=\"line\">\t<span class=\"keyword\">auto</span> found = wordmap.find(sought);</div><div class=\"line\">\t<span class=\"keyword\">if</span> (found != wordmap.end())</div><div class=\"line\">\t\t<span class=\"comment\">// 找到单词</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, found-&gt;second, file);</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t<span class=\"comment\">// 未找到</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, nodata, file);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">ostream &amp; <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在此处插入 return 语句</span></div><div class=\"line\">\t<span class=\"comment\">// 如果找到了单词，打印出现次数和所有出现的位置</span></div><div class=\"line\">\tos &lt;&lt; query_result.word &lt;&lt; <span class=\"string\">\" occurs \"</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class=\"string\">\" \"</span></div><div class=\"line\">\t\t&lt;&lt; (query_result.lines-&gt;size() &gt; <span class=\"number\">1</span> ? <span class=\"string\">\"times.\"</span> : <span class=\"string\">\"time.\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 打印单词出现的每一行</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"function\">ConstStrBlobPtr <span class=\"title\">p</span><span class=\"params\">(*query_result.file, *it)</span></span>;</div><div class=\"line\">\t\tos &lt;&lt; <span class=\"string\">\"\\t(line \"</span> &lt;&lt; *it + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">\") \"</span> &lt;&lt; p.deref() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> os;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>Query_test.cpp<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"12.33.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runQueries</span><span class=\"params\">(<span class=\"built_in\">std</span>::ifstream &amp;ifs)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"function\">TextQuery <span class=\"title\">text_query</span><span class=\"params\">(ifs)</span></span>;</div><div class=\"line\">\t<span class=\"keyword\">do</span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter word to look for or q to quit: \"</span>;</div><div class=\"line\">\t\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (!(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; word) || word == <span class=\"string\">\"q\"</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\tprint(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>, text_query.query(word)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">ifs</span><span class=\"params\">(<span class=\"string\">\"data/story.txt\"</span>)</span></span>;</div><div class=\"line\">\trunQueries(ifs);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href=\"https://github.com/pezy/CppPrimer\">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p>\n<p>End~</p>\n<hr>"},{"title":"C++ Primer 第五版 练习12.3","date":"2017-05-26T06:27:11.000Z","comments":1,"_content":"\n## 问题\n\nStrBlob需要const版本的`push_back`和`pop_back`吗？如果需要，添加进去。否则，解释为什么不需要。\n\n<!--more-->\n\n## 定义StrBlob类\n\n首先，定义**StrBlob**类。类的定义如下：\n\n```C++\n\n/* StrBlob.h */\n/* 编写你自己的StrBlob类，包含const版本的front和back */\n#pragma once\n#include<vector>\n#include<string>\n#include<initializer_list>\n#include<memory>\n#include<exception>\n\nusing std::vector;\nusing std::string;\n\nclass StrBlob {\npublic:\n    using size_type = vector<string>::size_type;\n    StrBlob() : data(std::make_shared<vector<string>>()) {}\n    StrBlob(std::initializer_list<string> il)\n        : data(std::make_shared<vector<string>>(il)) {}\n    size_type size() cosnt { return data->size(); }\n    bool empty() const { return data->empty(); }\n    // 添加和删除元素\n    void push_back(const string &t) { data->push_back(t); }\n    void pop_back()\n    {\n       check(0, \"pop_back on empty StrBlob\");\n       data->pop_back();\n    }\n    // 元素访问\n    string &front()\n    {\n        // 如果vector为空，check会抛出一个异常\n       check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    const string &front() const\n    {\n        check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    string &back()\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\n    const string &back() const\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\nprivate:\n    void check(size_type i, const string &msg) const\n    {\n    if (i >= data->size())\n        throw std::out_of_range(msg);\n    }\nprivate:\n    std::shared_ptr<vector<string>> data;\n\n```\n\n## 测试\n\n### 非const StrBlob对象\n\n根据**StrBlob**的定义，我们来测试一下：\n首先声明一个**StrBlob**对象**b1**：\n\n    StrBlob b1 = {\"a\", \"an\", \"the\"};        // 非const对象\n\n然后分别对**b1**调用`push_back()`和`pop_back()`：\n\n    b1.push_back(\"test\");       // 向b1添加元素test\n\n此时**b1**保存的内容是 **a**, **an**, **the**, **test**;\n接着就是\n\n     b1.pop_back();         // 删除刚刚添加的元素\n\n此时**b1**保存的内容是 **a**, **an**, **the**;\n可以看到，我们定义的非const的**StrBlob**对象进行`push_back()`和`pop_back()`操作是没有问题的。\n\n### const StrBlob对象\n\n上面的操作都很顺利，那么当我们声明一个const **StrBlob**对象会怎么样呢？\n接下来，我们声明一个const类型的**StrBlob**对象：\n\n    const StrBlob cb = {\"a\", \"an\", \"the\"};       // const 对象\n \n同样的，我们对**cb**调用`push_back()`和`pop_back()`，看看会发生什么：\n\n    cb.push_back(\"test\");       // 向cb添加元素test\n运行一下程序，就会报错：\n> *Error C2662 “void StrBlob::push_back(const std::string &)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n\n    cb.pop_back();           // 删除元素\n\n在运行程序，同样也会报错：\n> *Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n原因是我们在定义**StrBlob**类时，`push_back()`和`pop_back()`并没有添const版本。\n那么，自然而然地，我们将添加const版本的`push_back()`和`pop_back()`，在StrBlob.h中添加以下代码:\n\n```C++\n\n/* StrBlob.h */\n...\nvoid push_back(const string &t) { data->push_back(t); }\nvoid pop_back()\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n// 添加const类型的push_back()和pop_back()\nvoid push_back(const string &t) const \n{\n    data->push_back(t);\n}\nvoid pop_back() const\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n...\n\n```\n\n再运行一下程序，通过了，并且输出和之前非const版本的一样。\n\n## 讨论\n\n那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？\n\n如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的`push_back()`和`pop_back()`是必须的。但是要注意的是：\n\n**我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向`vector<string>`的智能指针；但由于类的封装，在使用者看来，数据成员是`vector<string>`，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是`vector<string>`的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像`push_back()`和`pop_back()`这样会改变智能指针所指向的`vector<string>`内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用`push_back()`和`pop_back()`成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。**\n\n通过以上的考虑，我认为**StrBlob**不需要const版本的`push_back`和`pop_back`。\n\n\n## 参考资料\n\n [1]:  [豆瓣 - 大家来讨论一下 exercise 12.3](https://www.douban.com/group/topic/61573279/)\n [2]:  [Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?](https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi)\n\n\n\n\nEnd~\n\n---\n","source":"_posts/C-Primer-第五版-练习12-3.md","raw":"---\ntitle: C++ Primer 第五版 练习12.3\ndate: 2017-05-26 14:27:11\ncategory: CPP\ntags: C++ Primer\ncomments: true\n---\n\n## 问题\n\nStrBlob需要const版本的`push_back`和`pop_back`吗？如果需要，添加进去。否则，解释为什么不需要。\n\n<!--more-->\n\n## 定义StrBlob类\n\n首先，定义**StrBlob**类。类的定义如下：\n\n```C++\n\n/* StrBlob.h */\n/* 编写你自己的StrBlob类，包含const版本的front和back */\n#pragma once\n#include<vector>\n#include<string>\n#include<initializer_list>\n#include<memory>\n#include<exception>\n\nusing std::vector;\nusing std::string;\n\nclass StrBlob {\npublic:\n    using size_type = vector<string>::size_type;\n    StrBlob() : data(std::make_shared<vector<string>>()) {}\n    StrBlob(std::initializer_list<string> il)\n        : data(std::make_shared<vector<string>>(il)) {}\n    size_type size() cosnt { return data->size(); }\n    bool empty() const { return data->empty(); }\n    // 添加和删除元素\n    void push_back(const string &t) { data->push_back(t); }\n    void pop_back()\n    {\n       check(0, \"pop_back on empty StrBlob\");\n       data->pop_back();\n    }\n    // 元素访问\n    string &front()\n    {\n        // 如果vector为空，check会抛出一个异常\n       check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    const string &front() const\n    {\n        check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    string &back()\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\n    const string &back() const\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\nprivate:\n    void check(size_type i, const string &msg) const\n    {\n    if (i >= data->size())\n        throw std::out_of_range(msg);\n    }\nprivate:\n    std::shared_ptr<vector<string>> data;\n\n```\n\n## 测试\n\n### 非const StrBlob对象\n\n根据**StrBlob**的定义，我们来测试一下：\n首先声明一个**StrBlob**对象**b1**：\n\n    StrBlob b1 = {\"a\", \"an\", \"the\"};        // 非const对象\n\n然后分别对**b1**调用`push_back()`和`pop_back()`：\n\n    b1.push_back(\"test\");       // 向b1添加元素test\n\n此时**b1**保存的内容是 **a**, **an**, **the**, **test**;\n接着就是\n\n     b1.pop_back();         // 删除刚刚添加的元素\n\n此时**b1**保存的内容是 **a**, **an**, **the**;\n可以看到，我们定义的非const的**StrBlob**对象进行`push_back()`和`pop_back()`操作是没有问题的。\n\n### const StrBlob对象\n\n上面的操作都很顺利，那么当我们声明一个const **StrBlob**对象会怎么样呢？\n接下来，我们声明一个const类型的**StrBlob**对象：\n\n    const StrBlob cb = {\"a\", \"an\", \"the\"};       // const 对象\n \n同样的，我们对**cb**调用`push_back()`和`pop_back()`，看看会发生什么：\n\n    cb.push_back(\"test\");       // 向cb添加元素test\n运行一下程序，就会报错：\n> *Error C2662 “void StrBlob::push_back(const std::string &)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n\n    cb.pop_back();           // 删除元素\n\n在运行程序，同样也会报错：\n> *Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n原因是我们在定义**StrBlob**类时，`push_back()`和`pop_back()`并没有添const版本。\n那么，自然而然地，我们将添加const版本的`push_back()`和`pop_back()`，在StrBlob.h中添加以下代码:\n\n```C++\n\n/* StrBlob.h */\n...\nvoid push_back(const string &t) { data->push_back(t); }\nvoid pop_back()\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n// 添加const类型的push_back()和pop_back()\nvoid push_back(const string &t) const \n{\n    data->push_back(t);\n}\nvoid pop_back() const\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n...\n\n```\n\n再运行一下程序，通过了，并且输出和之前非const版本的一样。\n\n## 讨论\n\n那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？\n\n如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的`push_back()`和`pop_back()`是必须的。但是要注意的是：\n\n**我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向`vector<string>`的智能指针；但由于类的封装，在使用者看来，数据成员是`vector<string>`，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是`vector<string>`的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像`push_back()`和`pop_back()`这样会改变智能指针所指向的`vector<string>`内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用`push_back()`和`pop_back()`成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。**\n\n通过以上的考虑，我认为**StrBlob**不需要const版本的`push_back`和`pop_back`。\n\n\n## 参考资料\n\n [1]:  [豆瓣 - 大家来讨论一下 exercise 12.3](https://www.douban.com/group/topic/61573279/)\n [2]:  [Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?](https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi)\n\n\n\n\nEnd~\n\n---\n","slug":"C-Primer-第五版-练习12-3","published":1,"updated":"2019-01-07T13:44:48.223Z","layout":"post","photos":[],"link":"","_id":"cjqojmlv00004swqczs0pu55v","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>StrBlob需要const版本的<code>push_back</code>和<code>pop_back</code>吗？如果需要，添加进去。否则，解释为什么不需要。</p>\n<a id=\"more\"></a>\n<h2 id=\"定义StrBlob类\"><a href=\"#定义StrBlob类\" class=\"headerlink\" title=\"定义StrBlob类\"></a>定义StrBlob类</h2><p>首先，定义<strong>StrBlob</strong>类。类的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></div><div class=\"line\"><span class=\"comment\">/* 编写你自己的StrBlob类，包含const版本的front和back */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;initializer_list&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;exception&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> StrBlob &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"keyword\">using</span> size_type = <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;::size_type;</div><div class=\"line\">    StrBlob() : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</div><div class=\"line\">    StrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">string</span>&gt; il)</div><div class=\"line\">        : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</div><div class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> cosnt </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</div><div class=\"line\">    <span class=\"comment\">// 添加和删除元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">       data-&gt;pop_back();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 元素访问</span></div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果vector为空，check会抛出一个异常</span></div><div class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= data-&gt;size())</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; data;</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"非const-StrBlob对象\"><a href=\"#非const-StrBlob对象\" class=\"headerlink\" title=\"非const StrBlob对象\"></a>非const StrBlob对象</h3><p>根据<strong>StrBlob</strong>的定义，我们来测试一下：<br>首先声明一个<strong>StrBlob</strong>对象<strong>b1</strong>：</p>\n<pre><code>StrBlob b1 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};        // 非const对象\n</code></pre><p>然后分别对<strong>b1</strong>调用<code>push_back()</code>和<code>pop_back()</code>：</p>\n<pre><code>b1.push_back(&quot;test&quot;);       // 向b1添加元素test\n</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>, <strong>test</strong>;<br>接着就是</p>\n<pre><code>b1.pop_back();         // 删除刚刚添加的元素\n</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>;<br>可以看到，我们定义的非const的<strong>StrBlob</strong>对象进行<code>push_back()</code>和<code>pop_back()</code>操作是没有问题的。</p>\n<h3 id=\"const-StrBlob对象\"><a href=\"#const-StrBlob对象\" class=\"headerlink\" title=\"const StrBlob对象\"></a>const StrBlob对象</h3><p>上面的操作都很顺利，那么当我们声明一个const <strong>StrBlob</strong>对象会怎么样呢？<br>接下来，我们声明一个const类型的<strong>StrBlob</strong>对象：</p>\n<pre><code>const StrBlob cb = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};       // const 对象\n</code></pre><p>同样的，我们对<strong>cb</strong>调用<code>push_back()</code>和<code>pop_back()</code>，看看会发生什么：</p>\n<pre><code>cb.push_back(&quot;test&quot;);       // 向cb添加元素test\n</code></pre><p>运行一下程序，就会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<pre><code>cb.pop_back();           // 删除元素\n</code></pre><p>在运行程序，同样也会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<p>原因是我们在定义<strong>StrBlob</strong>类时，<code>push_back()</code>和<code>pop_back()</code>并没有添const版本。<br>那么，自然而然地，我们将添加const版本的<code>push_back()</code>和<code>pop_back()</code>，在StrBlob.h中添加以下代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 添加const类型的push_back()和pop_back()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> <span class=\"keyword\">const</span> </span></div><div class=\"line\">&#123;</div><div class=\"line\">    data-&gt;push_back(t);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>再运行一下程序，通过了，并且输出和之前非const版本的一样。</p>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？</p>\n<p>如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的<code>push_back()</code>和<code>pop_back()</code>是必须的。但是要注意的是：</p>\n<p><strong>我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向<code>vector&lt;string&gt;</code>的智能指针；但由于类的封装，在使用者看来，数据成员是<code>vector&lt;string&gt;</code>，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是<code>vector&lt;string&gt;</code>的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像<code>push_back()</code>和<code>pop_back()</code>这样会改变智能指针所指向的<code>vector&lt;string&gt;</code>内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用<code>push_back()</code>和<code>pop_back()</code>成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。</string></strong></p>\n<p>通过以上的考虑，我认为<strong>StrBlob</strong>不需要const版本的<code>push_back</code>和<code>pop_back</code>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p> [1]:  <a href=\"https://www.douban.com/group/topic/61573279/\" target=\"_blank\" rel=\"external\">豆瓣 - 大家来讨论一下 exercise 12.3</a><br> [2]:  <a href=\"https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi\" target=\"_blank\" rel=\"external\">Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?</a></p>\n<p>End~</p>\n<hr>\n","excerpt":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>StrBlob需要const版本的<code>push_back</code>和<code>pop_back</code>吗？如果需要，添加进去。否则，解释为什么不需要。</p>","more":"<h2 id=\"定义StrBlob类\"><a href=\"#定义StrBlob类\" class=\"headerlink\" title=\"定义StrBlob类\"></a>定义StrBlob类</h2><p>首先，定义<strong>StrBlob</strong>类。类的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></div><div class=\"line\"><span class=\"comment\">/* 编写你自己的StrBlob类，包含const版本的front和back */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;initializer_list&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;exception&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> StrBlob &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"keyword\">using</span> size_type = <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;::size_type;</div><div class=\"line\">    StrBlob() : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</div><div class=\"line\">    StrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">string</span>&gt; il)</div><div class=\"line\">        : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</div><div class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> cosnt </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</div><div class=\"line\">    <span class=\"comment\">// 添加和删除元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">       data-&gt;pop_back();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 元素访问</span></div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 如果vector为空，check会抛出一个异常</span></div><div class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= data-&gt;size())</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; data;</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"非const-StrBlob对象\"><a href=\"#非const-StrBlob对象\" class=\"headerlink\" title=\"非const StrBlob对象\"></a>非const StrBlob对象</h3><p>根据<strong>StrBlob</strong>的定义，我们来测试一下：<br>首先声明一个<strong>StrBlob</strong>对象<strong>b1</strong>：</p>\n<pre><code>StrBlob b1 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};        // 非const对象\n</code></pre><p>然后分别对<strong>b1</strong>调用<code>push_back()</code>和<code>pop_back()</code>：</p>\n<pre><code>b1.push_back(&quot;test&quot;);       // 向b1添加元素test\n</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>, <strong>test</strong>;<br>接着就是</p>\n<pre><code>b1.pop_back();         // 删除刚刚添加的元素\n</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>;<br>可以看到，我们定义的非const的<strong>StrBlob</strong>对象进行<code>push_back()</code>和<code>pop_back()</code>操作是没有问题的。</p>\n<h3 id=\"const-StrBlob对象\"><a href=\"#const-StrBlob对象\" class=\"headerlink\" title=\"const StrBlob对象\"></a>const StrBlob对象</h3><p>上面的操作都很顺利，那么当我们声明一个const <strong>StrBlob</strong>对象会怎么样呢？<br>接下来，我们声明一个const类型的<strong>StrBlob</strong>对象：</p>\n<pre><code>const StrBlob cb = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};       // const 对象\n</code></pre><p>同样的，我们对<strong>cb</strong>调用<code>push_back()</code>和<code>pop_back()</code>，看看会发生什么：</p>\n<pre><code>cb.push_back(&quot;test&quot;);       // 向cb添加元素test\n</code></pre><p>运行一下程序，就会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<pre><code>cb.pop_back();           // 删除元素\n</code></pre><p>在运行程序，同样也会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<p>原因是我们在定义<strong>StrBlob</strong>类时，<code>push_back()</code>和<code>pop_back()</code>并没有添const版本。<br>那么，自然而然地，我们将添加const版本的<code>push_back()</code>和<code>pop_back()</code>，在StrBlob.h中添加以下代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 添加const类型的push_back()和pop_back()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> <span class=\"keyword\">const</span> </div><div class=\"line\"></span>&#123;</div><div class=\"line\">    data-&gt;push_back(t);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>再运行一下程序，通过了，并且输出和之前非const版本的一样。</p>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？</p>\n<p>如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的<code>push_back()</code>和<code>pop_back()</code>是必须的。但是要注意的是：</p>\n<p><strong>我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向<code>vector&lt;string&gt;</code>的智能指针；但由于类的封装，在使用者看来，数据成员是<code>vector&lt;string&gt;</code>，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是<code>vector&lt;string&gt;</code>的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像<code>push_back()</code>和<code>pop_back()</code>这样会改变智能指针所指向的<code>vector&lt;string&gt;</code>内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用<code>push_back()</code>和<code>pop_back()</code>成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。</strong></p>\n<p>通过以上的考虑，我认为<strong>StrBlob</strong>不需要const版本的<code>push_back</code>和<code>pop_back</code>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p> [1]:  <a href=\"https://www.douban.com/group/topic/61573279/\">豆瓣 - 大家来讨论一下 exercise 12.3</a><br> [2]:  <a href=\"https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi\">Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?</a></p>\n<p>End~</p>\n<hr>"},{"title":"C++ string输入问题","date":"2017-03-31T06:38:28.000Z","comments":1,"_content":"\n## 问题描述\n\n> 使用cin读入一组字符串并存入一个vector对象\n\n<!--more-->\n\n## 代码实现\n使用如下代码\n```c++\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n/*用cin读入一组字符串并把它们存入一个vector对象*/\nint main()\n{\n\tvector<string> text;\n\tstring word;\n\twhile (getline(cin, word))\n\t{\n\t\ttext.push_back(word);\n\t}\n\tcout << \"[\";\n\tfor (auto i : text)\n\t\tif (i == text.back())\n\t\t\tcout << i;\n\t\telse\n\t\t\tcout << i << \",\";\n\tcout << \"]\";\n\n\treturn 0;\n}\n```\n\n在运行测试时发现了一个问题：\n当输入为\n\n> aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)\n\n按回车后发现输出卡出了，并不会输出所输入的字符串\n\n当输入为\n> aa ss dd qq ww ee\n^Z(换行后的^Z)\n\n就可以正确输出了\n\n## 解决办法\n百思不得其解，遂百度之。\n看到了两种解释，感觉都有道理，就都贴上来好了\n1.\n\n> 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin>>调用立即返回，cin状态为eof，while退出。\n\n2.\n\n> windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。\n\n意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。\n","source":"_posts/C-string输入问题.md","raw":"---\ntitle: C++ string输入问题\ndate: 2017-03-31 14:38:28\ncategory: CPP\ntags:\n- C++\n- String\n- vector\ncomments: true\n---\n\n## 问题描述\n\n> 使用cin读入一组字符串并存入一个vector对象\n\n<!--more-->\n\n## 代码实现\n使用如下代码\n```c++\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n/*用cin读入一组字符串并把它们存入一个vector对象*/\nint main()\n{\n\tvector<string> text;\n\tstring word;\n\twhile (getline(cin, word))\n\t{\n\t\ttext.push_back(word);\n\t}\n\tcout << \"[\";\n\tfor (auto i : text)\n\t\tif (i == text.back())\n\t\t\tcout << i;\n\t\telse\n\t\t\tcout << i << \",\";\n\tcout << \"]\";\n\n\treturn 0;\n}\n```\n\n在运行测试时发现了一个问题：\n当输入为\n\n> aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)\n\n按回车后发现输出卡出了，并不会输出所输入的字符串\n\n当输入为\n> aa ss dd qq ww ee\n^Z(换行后的^Z)\n\n就可以正确输出了\n\n## 解决办法\n百思不得其解，遂百度之。\n看到了两种解释，感觉都有道理，就都贴上来好了\n1.\n\n> 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin>>调用立即返回，cin状态为eof，while退出。\n\n2.\n\n> windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。\n\n意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。\n","slug":"C-string输入问题","published":1,"updated":"2019-01-07T13:44:48.223Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvg0008swqce6ibfsqa","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><blockquote>\n<p>使用cin读入一组字符串并存入一个vector对象</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>使用如下代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*用cin读入一组字符串并把它们存入一个vector对象*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; text;</div><div class=\"line\">\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (getline(<span class=\"built_in\">cin</span>, word))</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttext.push_back(word);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : text)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i == text.back())</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\",\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"]\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行测试时发现了一个问题：<br>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)</p>\n</blockquote>\n<p>按回车后发现输出卡出了，并不会输出所输入的字符串</p>\n<p>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee<br>^Z(换行后的^Z)</p>\n</blockquote>\n<p>就可以正确输出了</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>百思不得其解，遂百度之。<br>看到了两种解释，感觉都有道理，就都贴上来好了<br>1.</p>\n<blockquote>\n<p>因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。</p>\n</blockquote>\n<p>2.</p>\n<blockquote>\n<p>windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。</p>\n</blockquote>\n<p>意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。</p>\n","excerpt":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><blockquote>\n<p>使用cin读入一组字符串并存入一个vector对象</p>\n</blockquote>","more":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>使用如下代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*用cin读入一组字符串并把它们存入一个vector对象*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; text;</div><div class=\"line\">\t<span class=\"built_in\">string</span> word;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (getline(<span class=\"built_in\">cin</span>, word))</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttext.push_back(word);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : text)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i == text.back())</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\",\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"]\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行测试时发现了一个问题：<br>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)</p>\n</blockquote>\n<p>按回车后发现输出卡出了，并不会输出所输入的字符串</p>\n<p>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee<br>^Z(换行后的^Z)</p>\n</blockquote>\n<p>就可以正确输出了</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>百思不得其解，遂百度之。<br>看到了两种解释，感觉都有道理，就都贴上来好了<br>1.</p>\n<blockquote>\n<p>因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。</p>\n</blockquote>\n<p>2.</p>\n<blockquote>\n<p>windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。</p>\n</blockquote>\n<p>意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。</p>"},{"title":"C++中的explicit关键字","date":"2017-06-15T08:19:33.000Z","comments":1,"_content":"\n## 隐式的类类型转换\n\n在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：\n> 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作**转换构造函数(converting constructor)**\n\n<!--more-->\n也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。\n\n## 转换示例\n\n下面就给出一个例子，一个类的构造函数可以被用于隐式转换：\n\n```c++\nclass Foo {\npublic:\n\t// 单形参构造函数，可以用作隐式转换\n\tFoo(int foo) : m_foo(foo) {}\n\n\tint getFoo() { return m_foo; }\n\nprivate:\n\tint m_foo;\n};\n\n// 定义一个函数，接受Foo类型的形参\nvoid Bar(Foo foo)\n{\n\tint i = foo.getFoo();\n}\n\n// 主函数\nint main()\n{\n\tBar(42);\n\n\treturn 0;\n}\n```\n可以看到在`main`函数中，传入`Bar`的并不是一个`Foo`的对象，而是内置类型`int`，但类`Foo`的构造函数接受一个`int`，因此这个构造函数可以用来将参数转换成正确的类型。\n\n## 使用explicit抑制构造函数定义的隐式转换\n\n为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个**explicit**关键字：\n\n```c++\nexplicit Foo(int foo) : m_foo(foo) {}\n```\n\n这样就可以有效防止隐式转换。之前在`main`函数中`Bar(42)`就会报错：\n> void Bar(Foo): 无法将参数1从\"int\"转换为\"Foo\"\n\n进行如下修改，对传入的`int`进行显式转换\n```c++\nBar(Foo(42))\n```\n这样就不会报错了。使用**explicit**关键字的原因是为了防止预想之外的情况发生。\n下面举个例子（感觉不太合适）：\n> 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&)，然后调用print(3)。我们期望它能输出\"3\"，但是它实际上输出的是一个长度为3的空string。\n\n## 结论\n\n关于**explicit**的结论：\n\n - 关键字**explicit**只对一个实参的构造函数有效\n - 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为**explicit**的\n - 只能在类内声明构造函数时使用**explicit**关键字，在类外部定义式不应重复\n\n当我们用**explicit**关键字声明构造函数时，它将只能以直接初始化的形式(例如`string s(\"Hello\")`)使用。而且编译器将不会在自动转换过程中使用改构造函数。\n\n如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为**explicit**的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。\n\n## 参考资料\n\n[1]: [Stack OverFlow - What does the explicit keyword mean?](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163)\n\n\nEnd~\n\n---","source":"_posts/C-中的explicit关键字.md","raw":"---\ntitle: C++中的explicit关键字\ndate: 2017-06-15 16:19:33\ncategory: CPP\ntags: C++\ncomments: true\n---\n\n## 隐式的类类型转换\n\n在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：\n> 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作**转换构造函数(converting constructor)**\n\n<!--more-->\n也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。\n\n## 转换示例\n\n下面就给出一个例子，一个类的构造函数可以被用于隐式转换：\n\n```c++\nclass Foo {\npublic:\n\t// 单形参构造函数，可以用作隐式转换\n\tFoo(int foo) : m_foo(foo) {}\n\n\tint getFoo() { return m_foo; }\n\nprivate:\n\tint m_foo;\n};\n\n// 定义一个函数，接受Foo类型的形参\nvoid Bar(Foo foo)\n{\n\tint i = foo.getFoo();\n}\n\n// 主函数\nint main()\n{\n\tBar(42);\n\n\treturn 0;\n}\n```\n可以看到在`main`函数中，传入`Bar`的并不是一个`Foo`的对象，而是内置类型`int`，但类`Foo`的构造函数接受一个`int`，因此这个构造函数可以用来将参数转换成正确的类型。\n\n## 使用explicit抑制构造函数定义的隐式转换\n\n为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个**explicit**关键字：\n\n```c++\nexplicit Foo(int foo) : m_foo(foo) {}\n```\n\n这样就可以有效防止隐式转换。之前在`main`函数中`Bar(42)`就会报错：\n> void Bar(Foo): 无法将参数1从\"int\"转换为\"Foo\"\n\n进行如下修改，对传入的`int`进行显式转换\n```c++\nBar(Foo(42))\n```\n这样就不会报错了。使用**explicit**关键字的原因是为了防止预想之外的情况发生。\n下面举个例子（感觉不太合适）：\n> 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&)，然后调用print(3)。我们期望它能输出\"3\"，但是它实际上输出的是一个长度为3的空string。\n\n## 结论\n\n关于**explicit**的结论：\n\n - 关键字**explicit**只对一个实参的构造函数有效\n - 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为**explicit**的\n - 只能在类内声明构造函数时使用**explicit**关键字，在类外部定义式不应重复\n\n当我们用**explicit**关键字声明构造函数时，它将只能以直接初始化的形式(例如`string s(\"Hello\")`)使用。而且编译器将不会在自动转换过程中使用改构造函数。\n\n如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为**explicit**的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。\n\n## 参考资料\n\n[1]: [Stack OverFlow - What does the explicit keyword mean?](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163)\n\n\nEnd~\n\n---","slug":"C-中的explicit关键字","published":1,"updated":"2019-01-07T13:44:48.077Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvg000aswqcu1htuswu","content":"<h2 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p>\n<blockquote>\n<p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p>\n<h2 id=\"转换示例\"><a href=\"#转换示例\" class=\"headerlink\" title=\"转换示例\"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Foo &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\t<span class=\"comment\">// 单形参构造函数，可以用作隐式转换</span></div><div class=\"line\">\tFoo(<span class=\"keyword\">int</span> foo) : m_foo(foo) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_foo; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">\t<span class=\"keyword\">int</span> m_foo;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个函数，接受Foo类型的形参</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">(Foo foo)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = foo.getFoo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 主函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tBar(<span class=\"number\">42</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p>\n<h2 id=\"使用explicit抑制构造函数定义的隐式转换\"><a href=\"#使用explicit抑制构造函数定义的隐式转换\" class=\"headerlink\" title=\"使用explicit抑制构造函数定义的隐式转换\"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">explicit Foo(int foo) : m_foo(foo) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p>\n<blockquote>\n<p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p>\n</blockquote>\n<p>进行如下修改，对传入的<code>int</code>进行显式转换<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bar(Foo(<span class=\"number\">42</span>))</div></pre></td></tr></table></figure></p>\n<p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p>\n<blockquote>\n<p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p>\n</blockquote>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p>\n<ul>\n<li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li>\n<li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li>\n<li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li>\n</ul>\n<p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p>\n<p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163\" target=\"_blank\" rel=\"external\">Stack OverFlow - What does the explicit keyword mean?</a></p>\n<p>End~</p>\n<hr>\n","excerpt":"<h2 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p>\n<blockquote>\n<p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p>\n</blockquote>","more":"<p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p>\n<h2 id=\"转换示例\"><a href=\"#转换示例\" class=\"headerlink\" title=\"转换示例\"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Foo &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">\t<span class=\"comment\">// 单形参构造函数，可以用作隐式转换</span></div><div class=\"line\">\tFoo(<span class=\"keyword\">int</span> foo) : m_foo(foo) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_foo; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">\t<span class=\"keyword\">int</span> m_foo;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义一个函数，接受Foo类型的形参</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">(Foo foo)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = foo.getFoo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 主函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tBar(<span class=\"number\">42</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p>\n<h2 id=\"使用explicit抑制构造函数定义的隐式转换\"><a href=\"#使用explicit抑制构造函数定义的隐式转换\" class=\"headerlink\" title=\"使用explicit抑制构造函数定义的隐式转换\"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">explicit Foo(int foo) : m_foo(foo) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p>\n<blockquote>\n<p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p>\n</blockquote>\n<p>进行如下修改，对传入的<code>int</code>进行显式转换<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bar(Foo(<span class=\"number\">42</span>))</div></pre></td></tr></table></figure></p>\n<p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p>\n<blockquote>\n<p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p>\n</blockquote>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p>\n<ul>\n<li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li>\n<li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li>\n<li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li>\n</ul>\n<p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p>\n<p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163\">Stack OverFlow - What does the explicit keyword mean?</a></p>\n<p>End~</p>\n<hr>"},{"title":"C++前置递增（递减）和后置递增（递减）运算符","date":"2017-04-07T10:31:16.000Z","comments":1,"_content":"\n在做C++ primer 第五版课后习题4.31时遇到一个问题：\n> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。\n\n<!--more-->\n\n源程序代码如下：\n```c++\nvector<int>::size_type cnt = ivec.size();\n// 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0;\n                    ix != ivec.size(); ++ix, --cnt)\n    ivec[ix] = cnt;\n```\n可以看到源程序用的是前置递增和递减运算符\n我根据源代码写了一下可运行的版本：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ++ix, --cnt)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n然后根据题目的意思，使用了后置版本的递增和递减运算符：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ix++, cnt--)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n结果一样啊喂！(＃°Д°)\n哪里需要修改了(╯‵□′)╯︵┻━┻\n各种百度没有没百度到，突然想起来可以找课后练习答案啊！\n找到了结果，还以为我错了，没想到答案居然是...\n\n> We use prefix and not postfix, just because of the **Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary**.\nSo, it's just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: \n```c++\nfor(vector<int>::size_type ix = 0; ix != ivec.size(); ix++, cnt--)  \n    ivec[ix] = cnt; \n```\n> This is not an appropriate example to discuss the difference of prefix and postfix.\n\n果然不是我的问题 ( •̀ ω •́ )\n\n","source":"_posts/C-前置递增（递减）和后置递增（递减）运算符.md","raw":"---\ntitle: C++前置递增（递减）和后置递增（递减）运算符\ndate: 2017-04-07 18:31:16\ncategory: CPP\ntags: C++\ncomments: true\n\n---\n\n在做C++ primer 第五版课后习题4.31时遇到一个问题：\n> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。\n\n<!--more-->\n\n源程序代码如下：\n```c++\nvector<int>::size_type cnt = ivec.size();\n// 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0;\n                    ix != ivec.size(); ++ix, --cnt)\n    ivec[ix] = cnt;\n```\n可以看到源程序用的是前置递增和递减运算符\n我根据源代码写了一下可运行的版本：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ++ix, --cnt)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n然后根据题目的意思，使用了后置版本的递增和递减运算符：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ix++, cnt--)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n结果一样啊喂！(＃°Д°)\n哪里需要修改了(╯‵□′)╯︵┻━┻\n各种百度没有没百度到，突然想起来可以找课后练习答案啊！\n找到了结果，还以为我错了，没想到答案居然是...\n\n> We use prefix and not postfix, just because of the **Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary**.\nSo, it's just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: \n```c++\nfor(vector<int>::size_type ix = 0; ix != ivec.size(); ix++, cnt--)  \n    ivec[ix] = cnt; \n```\n> This is not an appropriate example to discuss the difference of prefix and postfix.\n\n果然不是我的问题 ( •̀ ω •́ )\n\n","slug":"C-前置递增（递减）和后置递增（递减）运算符","published":1,"updated":"2019-01-07T13:44:48.079Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvg000cswqcavrvhzl4","content":"<p>在做C++ primer 第五版课后习题4.31时遇到一个问题：</p>\n<blockquote>\n<p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>源程序代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\"><span class=\"comment\">// 将把从size到1的值赋给ivec的元素</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>;</div><div class=\"line\">                    ix != ivec.size(); ++ix, --cnt)</div><div class=\"line\">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>\n<p>可以看到源程序用的是前置递增和递减运算符<br>我根据源代码写了一下可运行的版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(<span class=\"number\">10</span>, <span class=\"number\">0</span>);        <span class=\"comment\">// 初始化ivec</span></div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </div><div class=\"line\">\t                    ix != ivec.size(); ++ix, --cnt)</div><div class=\"line\">\t\tivec[ix] = cnt;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>然后根据题目的意思，使用了后置版本的递增和递减运算符：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(<span class=\"number\">10</span>, <span class=\"number\">0</span>);        <span class=\"comment\">// 初始化ivec</span></div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </div><div class=\"line\">\t                    ix != ivec.size(); ix++, cnt--)</div><div class=\"line\">\t\tivec[ix] = cnt;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>结果一样啊喂！(＃°Д°)<br>哪里需要修改了(╯‵□′)╯︵┻━┻<br>各种百度没有没百度到，突然想起来可以找课后练习答案啊！<br>找到了结果，还以为我错了，没想到答案居然是…</p>\n<blockquote>\n<p>We use prefix and not postfix, just because of the <strong>Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary</strong>.<br>So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; ix != ivec.size(); ix++, cnt--)  </div><div class=\"line\">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>\n<p>This is not an appropriate example to discuss the difference of prefix and postfix.</p>\n</blockquote>\n<p>果然不是我的问题 ( •̀ ω •́ )</p>\n","excerpt":"<p>在做C++ primer 第五版课后习题4.31时遇到一个问题：</p>\n<blockquote>\n<p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。</p>\n</blockquote>","more":"<p>源程序代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\"><span class=\"comment\">// 将把从size到1的值赋给ivec的元素</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>;</div><div class=\"line\">                    ix != ivec.size(); ++ix, --cnt)</div><div class=\"line\">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>\n<p>可以看到源程序用的是前置递增和递减运算符<br>我根据源代码写了一下可运行的版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(<span class=\"number\">10</span>, <span class=\"number\">0</span>);        <span class=\"comment\">// 初始化ivec</span></div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </div><div class=\"line\">\t                    ix != ivec.size(); ++ix, --cnt)</div><div class=\"line\">\t\tivec[ix] = cnt;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>然后根据题目的意思，使用了后置版本的递增和递减运算符：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(<span class=\"number\">10</span>, <span class=\"number\">0</span>);        <span class=\"comment\">// 初始化ivec</span></div><div class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </div><div class=\"line\">\t                    ix != ivec.size(); ix++, cnt--)</div><div class=\"line\">\t\tivec[ix] = cnt;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>结果一样啊喂！(＃°Д°)<br>哪里需要修改了(╯‵□′)╯︵┻━┻<br>各种百度没有没百度到，突然想起来可以找课后练习答案啊！<br>找到了结果，还以为我错了，没想到答案居然是…</p>\n<blockquote>\n<p>We use prefix and not postfix, just because of the <strong>Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary</strong>.<br>So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; ix != ivec.size(); ix++, cnt--)  </div><div class=\"line\">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>\n<p>This is not an appropriate example to discuss the difference of prefix and postfix.</p>\n</blockquote>\n<p>果然不是我的问题 ( •̀ ω •́ )</p>"},{"title":"LeetCode 19. Remove Nth Node From End of List","date":"2018-01-09T10:46:44.000Z","comments":1,"_content":"\n## Problem\n\nGive a linked list, remove the $n^{th}$ node from the end of list and return its head.\n\n<!--more-->\n\n### Example\n\n> Given linked list: **1->2->3->4->5**, and **n = 2**\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.\n\n### Note\n\nGiven *n* will always be valid.\nTry do this in one pass.\n\n## Answer\n\n### 单链表结构定义\n\n```c++\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n```\n\n### 普通方法(遍历两次链表)\n\n先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：\n\n```c++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        int cnt = 0;\n        ListNode *p1 = head, *p2 = head;\n\n        while (p1)\n        {\n            ++cnt;\n            p1 = p1->next;\n        }\n\n        int j = 0;\n        if (cnt == n) return head->next;\n        while (j < cnt - n - 1)\n        {\n            j++;\n            p2 = p2->next;\n        }\n        auto tmp = p2->next;\n        p2->next = p2->next->next;\n        delete tmp;\n        return head;\n    }\n};\n```\n\n### New Meta(使用二级指针，遍历一次链表)\n\n```c++\nclass Solution{\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        // 利用二级指针删除元素\n        ListNode **t1 = &head, *t2 = head;\n\n        // 将t2向后移动n位，此时t2的位置在len(head) - n\n        for (int i = 1; i < n; ++i)\n            t2 = t2->next;\n        // 当t2的下一个节点不为空时，开始移动t1\n        while (t2->next)\n        {\n            // t1指向下一个元素指针的地址\n            t1 = &((*t1)->next);\n            t2 = t2->next;\n        }\n        // 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址\n        // 因此我们需要删除该元素,并使t1指向下一个元素指针的地址\n        auto tmp = *t1;\n        *t1 = (*t1)->next;\n\n        delete tmp;\n        return head;\n    }\n};\n```\n\n使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。","source":"_posts/LeetCode-19-Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: LeetCode 19. Remove Nth Node From End of List\ndate: 2018-01-09 18:46:44\ncategory: LeetCode\ntags: LeetCode\ncomments: true\n---\n\n## Problem\n\nGive a linked list, remove the $n^{th}$ node from the end of list and return its head.\n\n<!--more-->\n\n### Example\n\n> Given linked list: **1->2->3->4->5**, and **n = 2**\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.\n\n### Note\n\nGiven *n* will always be valid.\nTry do this in one pass.\n\n## Answer\n\n### 单链表结构定义\n\n```c++\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n```\n\n### 普通方法(遍历两次链表)\n\n先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：\n\n```c++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        int cnt = 0;\n        ListNode *p1 = head, *p2 = head;\n\n        while (p1)\n        {\n            ++cnt;\n            p1 = p1->next;\n        }\n\n        int j = 0;\n        if (cnt == n) return head->next;\n        while (j < cnt - n - 1)\n        {\n            j++;\n            p2 = p2->next;\n        }\n        auto tmp = p2->next;\n        p2->next = p2->next->next;\n        delete tmp;\n        return head;\n    }\n};\n```\n\n### New Meta(使用二级指针，遍历一次链表)\n\n```c++\nclass Solution{\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        // 利用二级指针删除元素\n        ListNode **t1 = &head, *t2 = head;\n\n        // 将t2向后移动n位，此时t2的位置在len(head) - n\n        for (int i = 1; i < n; ++i)\n            t2 = t2->next;\n        // 当t2的下一个节点不为空时，开始移动t1\n        while (t2->next)\n        {\n            // t1指向下一个元素指针的地址\n            t1 = &((*t1)->next);\n            t2 = t2->next;\n        }\n        // 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址\n        // 因此我们需要删除该元素,并使t1指向下一个元素指针的地址\n        auto tmp = *t1;\n        *t1 = (*t1)->next;\n\n        delete tmp;\n        return head;\n    }\n};\n```\n\n使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。","slug":"LeetCode-19-Remove-Nth-Node-From-End-of-List","published":1,"updated":"2018-01-09T10:55:04.243Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvv000gswqcz4qhkwle","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Give a linked list, remove the $n^{th}$ node from the end of list and return its head.</p>\n<a id=\"more\"></a>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><blockquote>\n<p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong>n = 2</strong><br>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><p>Given <em>n</em> will always be valid.<br>Try do this in one pass.</p>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><h3 id=\"单链表结构定义\"><a href=\"#单链表结构定义\" class=\"headerlink\" title=\"单链表结构定义\"></a>单链表结构定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Definition for singly-linked list.</span></div><div class=\"line\"><span class=\"keyword\">struct</span> ListNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    ListNode *next;</div><div class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"普通方法-遍历两次链表\"><a href=\"#普通方法-遍历两次链表\" class=\"headerlink\" title=\"普通方法(遍历两次链表)\"></a>普通方法(遍历两次链表)</h3><p>先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">        ListNode *p1 = head, *p2 = head;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (p1)</div><div class=\"line\">        &#123;</div><div class=\"line\">            ++cnt;</div><div class=\"line\">            p1 = p1-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cnt == n) <span class=\"keyword\">return</span> head-&gt;next;</div><div class=\"line\">        <span class=\"keyword\">while</span> (j &lt; cnt - n - <span class=\"number\">1</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            j++;</div><div class=\"line\">            p2 = p2-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">auto</span> tmp = p2-&gt;next;</div><div class=\"line\">        p2-&gt;next = p2-&gt;next-&gt;next;</div><div class=\"line\">        <span class=\"keyword\">delete</span> tmp;</div><div class=\"line\">        <span class=\"keyword\">return</span> head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"New-Meta-使用二级指针，遍历一次链表\"><a href=\"#New-Meta-使用二级指针，遍历一次链表\" class=\"headerlink\" title=\"New Meta(使用二级指针，遍历一次链表)\"></a>New Meta(使用二级指针，遍历一次链表)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 利用二级指针删除元素</span></div><div class=\"line\">        ListNode **t1 = &amp;head, *t2 = head;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 将t2向后移动n位，此时t2的位置在len(head) - n</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</div><div class=\"line\">            t2 = t2-&gt;next;</div><div class=\"line\">        <span class=\"comment\">// 当t2的下一个节点不为空时，开始移动t1</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (t2-&gt;next)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// t1指向下一个元素指针的地址</span></div><div class=\"line\">            t1 = &amp;((*t1)-&gt;next);</div><div class=\"line\">            t2 = t2-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址</span></div><div class=\"line\">        <span class=\"comment\">// 因此我们需要删除该元素,并使t1指向下一个元素指针的地址</span></div><div class=\"line\">        <span class=\"keyword\">auto</span> tmp = *t1;</div><div class=\"line\">        *t1 = (*t1)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">delete</span> tmp;</div><div class=\"line\">        <span class=\"keyword\">return</span> head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。</p>\n","excerpt":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Give a linked list, remove the $n^{th}$ node from the end of list and return its head.</p>","more":"<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><blockquote>\n<p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong>n = 2</strong><br>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><p>Given <em>n</em> will always be valid.<br>Try do this in one pass.</p>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><h3 id=\"单链表结构定义\"><a href=\"#单链表结构定义\" class=\"headerlink\" title=\"单链表结构定义\"></a>单链表结构定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Definition for singly-linked list.</span></div><div class=\"line\"><span class=\"keyword\">struct</span> ListNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    ListNode *next;</div><div class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"普通方法-遍历两次链表\"><a href=\"#普通方法-遍历两次链表\" class=\"headerlink\" title=\"普通方法(遍历两次链表)\"></a>普通方法(遍历两次链表)</h3><p>先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">        ListNode *p1 = head, *p2 = head;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (p1)</div><div class=\"line\">        &#123;</div><div class=\"line\">            ++cnt;</div><div class=\"line\">            p1 = p1-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cnt == n) <span class=\"keyword\">return</span> head-&gt;next;</div><div class=\"line\">        <span class=\"keyword\">while</span> (j &lt; cnt - n - <span class=\"number\">1</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            j++;</div><div class=\"line\">            p2 = p2-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">auto</span> tmp = p2-&gt;next;</div><div class=\"line\">        p2-&gt;next = p2-&gt;next-&gt;next;</div><div class=\"line\">        <span class=\"keyword\">delete</span> tmp;</div><div class=\"line\">        <span class=\"keyword\">return</span> head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"New-Meta-使用二级指针，遍历一次链表\"><a href=\"#New-Meta-使用二级指针，遍历一次链表\" class=\"headerlink\" title=\"New Meta(使用二级指针，遍历一次链表)\"></a>New Meta(使用二级指针，遍历一次链表)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 利用二级指针删除元素</span></div><div class=\"line\">        ListNode **t1 = &amp;head, *t2 = head;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 将t2向后移动n位，此时t2的位置在len(head) - n</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</div><div class=\"line\">            t2 = t2-&gt;next;</div><div class=\"line\">        <span class=\"comment\">// 当t2的下一个节点不为空时，开始移动t1</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (t2-&gt;next)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// t1指向下一个元素指针的地址</span></div><div class=\"line\">            t1 = &amp;((*t1)-&gt;next);</div><div class=\"line\">            t2 = t2-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址</span></div><div class=\"line\">        <span class=\"comment\">// 因此我们需要删除该元素,并使t1指向下一个元素指针的地址</span></div><div class=\"line\">        <span class=\"keyword\">auto</span> tmp = *t1;</div><div class=\"line\">        *t1 = (*t1)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">delete</span> tmp;</div><div class=\"line\">        <span class=\"keyword\">return</span> head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。</p>"},{"title":"LeetCode 751. IP to CIDR","date":"2017-12-29T07:09:13.000Z","comments":1,"_content":"\n## Problem\nGiven a start IP address `ip` and a number of ips we need to cover `n`, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\n\nA CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: \"123.45.67.89/20\". That prefix length \"20\" represents the number of common prefix bits in the specified range.\n\n<!--more-->\n\n### Example 1\n\n> **Input:** ip = \"255.0.0.7\", n = 10\n**Output:** [\"255.0.0.7/32\", \"255,0.0.8/29\", \"255.0.0.16/32\"]\n**Explanation:**\nThe initial ip address, when convered to binary, look like this (spaces added for clarity):\n255.0.0.7 -> 1111111 00000000 00000000 00000111\nThe address \"255.0.0.7/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just this one address.\n\n> The address \"255.0.0.8/29\" specifies all address with a common prefix of 29 bits to the given address:\n255.0.0.8 -> 11111111 00000000 0000000 00001000\nAddress with common prefix of 29 bits are:\n11111111 00000000 00000000 00001000\n11111111 00000000 00000000 00001001\n11111111 00000000 00000000 00001010\n11111111 00000000 00000000 00001011\n11111111 00000000 00000000 00001100\n11111111 00000000 00000000 00001101\n11111111 00000000 00000000 00001110\n11111111 00000000 00000000 00001111\n\n> The address \"255.0.0.16/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just 11111111 00000000 00000000 00010000\n\n> In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\n\n> There were other representations, such as:\n[\"255.0.0.7/32\", \"\"255.0.0.8/30\", \"255.0.0.12/30\", \"255.0.0.16/32\"],\nbut our answer was the shortest possible.\n\n> Also note that a representation beginning with say, \"255.0.0.7/30\" would be incorrect,\nbecause it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100\nthat are outside the specified range.\n\n### Note\n\n 1. `ip` will be a valid IPv4 address.\n 2. Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.\n 3. `n` will be an integer in the range `[1, 1000]`.\n\n\n## Answer\n\n这个问题是在给定的起始IP地址，求最少的[CIDR][1]正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。\n\n先说明一下`255.255.0.8/29`中29的含义：\n一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。\n\n比如我们以`255.0.0.7`开始，覆盖30个地址，那么就有：\n> 255.0.0.7/32\n只有一个IP地址 剩余30 - 1 = 29\n\n> 接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改\n则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21\n\n> 8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改\n则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5\n\n\n> 接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改\n则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1\n\n> 那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖\n至此可以得到最少的CIDR。\n\n### 实现代码\n\n将IP转为数字:\n\n```c++\nvector<string> split(const string &str, char delim)\n{\n    stringstream ss(str);\n    string word;\n    vector<string> ret;\n    while (getline(ss, word, delim))\n    {\n        ret.emplace_back(word);\n    }\n    return ret;\n}\n\nint ip2Num(const string &ip)\n{\n    vector<string> vec = split(ip, '.');\n    int num = 0;\n    num = static_cast<int>(stoi(vec[0));\n    num = num << 8 | static_cast<int>(stoi(vec[1]));\n    num = num << 8 | static_cast<int>(stoi(vec[2]));\n    num = num << 8 | static_cast<int>(stoi(vec[3]));\n    return num;\n}\n```\n\n数字转换为IP\n```c++\nstring num2Ip(int num)\n{\n    vector<string> vec;\n    for (int i = 0; i < 4; ++i)\n    {\n        vec.emplace_back(to_string(num & 0xff));\n        num >>= 8;\n    }\n    string ret;\n    ret.append(vec[3] + '.');\n    ret.append(vec[2] + '.');\n    ret.append(vec[1] + '.');\n    ret.append(vec[0]);\n    return ret;\n}\n```\n\n主函数\n```c++\nvector<string> ipToCIDR(string ip, int range)\n{\n    vector<string> ret;\n    unsigned num = ip2Num(ip);\n    \n    while (range)\n    {\n        int weight = 1;\n        int i = 0;\n        while (i < 32)\n        {\n            weight <<= 1;\n            if ((1 << i & num) || (weight > range))\n                break;\n            ++i;\n        }\n        weight >>= 1;\n        range -= weight;\n        ret.emplace_back(num2Ip(num) + \"/\" + to_string(32 - i));\n        num += weight;\n    }\n    return ret;\n}\n```\n\n[1]: https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR","source":"_posts/LeetCode-751-IP-to-CIDR.md","raw":"---\ntitle: LeetCode 751. IP to CIDR\ndate: 2017-12-29 15:09:13\ncategory: LeetCode\ntags: LeetCode\ncomments: true\n---\n\n## Problem\nGiven a start IP address `ip` and a number of ips we need to cover `n`, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\n\nA CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: \"123.45.67.89/20\". That prefix length \"20\" represents the number of common prefix bits in the specified range.\n\n<!--more-->\n\n### Example 1\n\n> **Input:** ip = \"255.0.0.7\", n = 10\n**Output:** [\"255.0.0.7/32\", \"255,0.0.8/29\", \"255.0.0.16/32\"]\n**Explanation:**\nThe initial ip address, when convered to binary, look like this (spaces added for clarity):\n255.0.0.7 -> 1111111 00000000 00000000 00000111\nThe address \"255.0.0.7/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just this one address.\n\n> The address \"255.0.0.8/29\" specifies all address with a common prefix of 29 bits to the given address:\n255.0.0.8 -> 11111111 00000000 0000000 00001000\nAddress with common prefix of 29 bits are:\n11111111 00000000 00000000 00001000\n11111111 00000000 00000000 00001001\n11111111 00000000 00000000 00001010\n11111111 00000000 00000000 00001011\n11111111 00000000 00000000 00001100\n11111111 00000000 00000000 00001101\n11111111 00000000 00000000 00001110\n11111111 00000000 00000000 00001111\n\n> The address \"255.0.0.16/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just 11111111 00000000 00000000 00010000\n\n> In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\n\n> There were other representations, such as:\n[\"255.0.0.7/32\", \"\"255.0.0.8/30\", \"255.0.0.12/30\", \"255.0.0.16/32\"],\nbut our answer was the shortest possible.\n\n> Also note that a representation beginning with say, \"255.0.0.7/30\" would be incorrect,\nbecause it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100\nthat are outside the specified range.\n\n### Note\n\n 1. `ip` will be a valid IPv4 address.\n 2. Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.\n 3. `n` will be an integer in the range `[1, 1000]`.\n\n\n## Answer\n\n这个问题是在给定的起始IP地址，求最少的[CIDR][1]正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。\n\n先说明一下`255.255.0.8/29`中29的含义：\n一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。\n\n比如我们以`255.0.0.7`开始，覆盖30个地址，那么就有：\n> 255.0.0.7/32\n只有一个IP地址 剩余30 - 1 = 29\n\n> 接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改\n则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21\n\n> 8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改\n则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5\n\n\n> 接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改\n则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1\n\n> 那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖\n至此可以得到最少的CIDR。\n\n### 实现代码\n\n将IP转为数字:\n\n```c++\nvector<string> split(const string &str, char delim)\n{\n    stringstream ss(str);\n    string word;\n    vector<string> ret;\n    while (getline(ss, word, delim))\n    {\n        ret.emplace_back(word);\n    }\n    return ret;\n}\n\nint ip2Num(const string &ip)\n{\n    vector<string> vec = split(ip, '.');\n    int num = 0;\n    num = static_cast<int>(stoi(vec[0));\n    num = num << 8 | static_cast<int>(stoi(vec[1]));\n    num = num << 8 | static_cast<int>(stoi(vec[2]));\n    num = num << 8 | static_cast<int>(stoi(vec[3]));\n    return num;\n}\n```\n\n数字转换为IP\n```c++\nstring num2Ip(int num)\n{\n    vector<string> vec;\n    for (int i = 0; i < 4; ++i)\n    {\n        vec.emplace_back(to_string(num & 0xff));\n        num >>= 8;\n    }\n    string ret;\n    ret.append(vec[3] + '.');\n    ret.append(vec[2] + '.');\n    ret.append(vec[1] + '.');\n    ret.append(vec[0]);\n    return ret;\n}\n```\n\n主函数\n```c++\nvector<string> ipToCIDR(string ip, int range)\n{\n    vector<string> ret;\n    unsigned num = ip2Num(ip);\n    \n    while (range)\n    {\n        int weight = 1;\n        int i = 0;\n        while (i < 32)\n        {\n            weight <<= 1;\n            if ((1 << i & num) || (weight > range))\n                break;\n            ++i;\n        }\n        weight >>= 1;\n        range -= weight;\n        ret.emplace_back(num2Ip(num) + \"/\" + to_string(32 - i));\n        num += weight;\n    }\n    return ret;\n}\n```\n\n[1]: https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR","slug":"LeetCode-751-IP-to-CIDR","published":1,"updated":"2017-12-29T07:42:58.453Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvv000iswqcdxwyhzzo","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>\n<p>A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p>\n<a id=\"more\"></a>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h3><blockquote>\n<p><strong>Input:</strong> ip = “255.0.0.7”, n = 10<br><strong>Output:</strong> [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]<br><strong>Explanation:</strong><br>The initial ip address, when convered to binary, look like this (spaces added for clarity):<br>255.0.0.7 -&gt; 1111111 00000000 00000000 00000111<br>The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just this one address.</p>\n<p>The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:<br>255.0.0.8 -&gt; 11111111 00000000 0000000 00001000<br>Address with common prefix of 29 bits are:<br>11111111 00000000 00000000 00001000<br>11111111 00000000 00000000 00001001<br>11111111 00000000 00000000 00001010<br>11111111 00000000 00000000 00001011<br>11111111 00000000 00000000 00001100<br>11111111 00000000 00000000 00001101<br>11111111 00000000 00000000 00001110<br>11111111 00000000 00000000 00001111</p>\n<p>The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just 11111111 00000000 00000000 00010000</p>\n<p>In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</p>\n<p>There were other representations, such as:<br>[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],<br>but our answer was the shortest possible.</p>\n<p>Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,<br>because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100<br>that are outside the specified range.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><ol>\n<li><code>ip</code> will be a valid IPv4 address.</li>\n<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>\n<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>\n</ol>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><p>这个问题是在给定的起始IP地址，求最少的<a href=\"https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&amp;fromid=3695195&amp;fromtitle=CIDR\" target=\"_blank\" rel=\"external\">CIDR</a>正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。</p>\n<p>先说明一下<code>255.255.0.8/29</code>中29的含义：<br>一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。</p>\n<p>比如我们以<code>255.0.0.7</code>开始，覆盖30个地址，那么就有：</p>\n<blockquote>\n<p>255.0.0.7/32<br>只有一个IP地址 剩余30 - 1 = 29</p>\n<p>接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改<br>则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21</p>\n<p>8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改<br>则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5</p>\n<p>接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改<br>则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1</p>\n<p>那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖<br>至此可以得到最少的CIDR。</p>\n</blockquote>\n<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p>将IP转为数字:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; split(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str, <span class=\"keyword\">char</span> delim)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(str)</span></span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> word;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</div><div class=\"line\">    <span class=\"keyword\">while</span> (getline(ss, word, delim))</div><div class=\"line\">    &#123;</div><div class=\"line\">        ret.emplace_back(word);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ip2Num</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;ip)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec = split(ip, <span class=\"string\">'.'</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">    num = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">0</span>));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">1</span>]));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">2</span>]));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">3</span>]));</div><div class=\"line\">    <span class=\"keyword\">return</span> num;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数字转换为IP<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">num2Ip</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i)</div><div class=\"line\">    &#123;</div><div class=\"line\">        vec.emplace_back(to_string(num &amp; <span class=\"number\">0xff</span>));</div><div class=\"line\">        num &gt;&gt;= <span class=\"number\">8</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">string</span> ret;</div><div class=\"line\">    ret.append(vec[<span class=\"number\">3</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">2</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">1</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主函数<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ipToCIDR(<span class=\"built_in\">string</span> ip, <span class=\"keyword\">int</span> range)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> num = ip2Num(ip);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">while</span> (range)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> weight = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">32</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            weight &lt;&lt;= <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">1</span> &lt;&lt; i &amp; num) || (weight &gt; range))</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            ++i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        weight &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">        range -= weight;</div><div class=\"line\">        ret.emplace_back(num2Ip(num) + <span class=\"string\">\"/\"</span> + to_string(<span class=\"number\">32</span> - i));</div><div class=\"line\">        num += weight;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>\n<p>A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p>","more":"<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h3><blockquote>\n<p><strong>Input:</strong> ip = “255.0.0.7”, n = 10<br><strong>Output:</strong> [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]<br><strong>Explanation:</strong><br>The initial ip address, when convered to binary, look like this (spaces added for clarity):<br>255.0.0.7 -&gt; 1111111 00000000 00000000 00000111<br>The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just this one address.</p>\n<p>The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:<br>255.0.0.8 -&gt; 11111111 00000000 0000000 00001000<br>Address with common prefix of 29 bits are:<br>11111111 00000000 00000000 00001000<br>11111111 00000000 00000000 00001001<br>11111111 00000000 00000000 00001010<br>11111111 00000000 00000000 00001011<br>11111111 00000000 00000000 00001100<br>11111111 00000000 00000000 00001101<br>11111111 00000000 00000000 00001110<br>11111111 00000000 00000000 00001111</p>\n<p>The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just 11111111 00000000 00000000 00010000</p>\n<p>In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</p>\n<p>There were other representations, such as:<br>[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],<br>but our answer was the shortest possible.</p>\n<p>Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,<br>because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100<br>that are outside the specified range.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><ol>\n<li><code>ip</code> will be a valid IPv4 address.</li>\n<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>\n<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>\n</ol>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><p>这个问题是在给定的起始IP地址，求最少的<a href=\"https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&amp;fromid=3695195&amp;fromtitle=CIDR\">CIDR</a>正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。</p>\n<p>先说明一下<code>255.255.0.8/29</code>中29的含义：<br>一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。</p>\n<p>比如我们以<code>255.0.0.7</code>开始，覆盖30个地址，那么就有：</p>\n<blockquote>\n<p>255.0.0.7/32<br>只有一个IP地址 剩余30 - 1 = 29</p>\n<p>接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改<br>则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21</p>\n<p>8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改<br>则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5</p>\n<p>接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改<br>则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1</p>\n<p>那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖<br>至此可以得到最少的CIDR。</p>\n</blockquote>\n<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p>将IP转为数字:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; split(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str, <span class=\"keyword\">char</span> delim)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(str)</span></span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> word;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</div><div class=\"line\">    <span class=\"keyword\">while</span> (getline(ss, word, delim))</div><div class=\"line\">    &#123;</div><div class=\"line\">        ret.emplace_back(word);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ip2Num</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;ip)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec = split(ip, <span class=\"string\">'.'</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">    num = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">0</span>));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">1</span>]));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">2</span>]));</div><div class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">3</span>]));</div><div class=\"line\">    <span class=\"keyword\">return</span> num;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数字转换为IP<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">num2Ip</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i)</div><div class=\"line\">    &#123;</div><div class=\"line\">        vec.emplace_back(to_string(num &amp; <span class=\"number\">0xff</span>));</div><div class=\"line\">        num &gt;&gt;= <span class=\"number\">8</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">string</span> ret;</div><div class=\"line\">    ret.append(vec[<span class=\"number\">3</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">2</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">1</span>] + <span class=\"string\">'.'</span>);</div><div class=\"line\">    ret.append(vec[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主函数<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ipToCIDR(<span class=\"built_in\">string</span> ip, <span class=\"keyword\">int</span> range)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> num = ip2Num(ip);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">while</span> (range)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> weight = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">32</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            weight &lt;&lt;= <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">1</span> &lt;&lt; i &amp; num) || (weight &gt; range))</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            ++i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        weight &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">        range -= weight;</div><div class=\"line\">        ret.emplace_back(num2Ip(num) + <span class=\"string\">\"/\"</span> + to_string(<span class=\"number\">32</span> - i));</div><div class=\"line\">        num += weight;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"Python生成词云","date":"2017-03-25T07:02:21.000Z","comments":1,"_content":"![wordcloud](/images/imagesource/17-03-25-1.png )\n\n## Python如何生成词云\n最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P\n通过度娘发现可以用Python库来生成词云， So Let's go!\n<!--more-->\n\n### 用到的库\n#### WorldCloud\n- 官网: https://amueller.github.io/word_cloud\n- github: https://github.com/amueller/word_cloud \n\n\n### 安装WordCloud\n\n#### 通过PIP安装\n\n    pip install wordcloud\n#### 下载WHL包安装\n当然可能通过PIP会安装出错，我们可以下[WHL包](http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud)手动安装\n\n下载完成后，再使用PIP命令安装：\n\n    pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n    \n其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是`wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl`。\n\n### 使用WordlCloud\n安装完成后，就可以用了。可以先测试以下是否安装成功：\n\n    from wordcould import WordCloud\n如果没有报错，表示安装成功了。\n\n#### 源代码\n下面就是源码部分了:\n``` python\n# -*- coding: utf-8 -*-\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\nfrom scipy.misc omport imread\n\n# 读入一个文件\ntext = open('your text file.txt', 'r').read()\n# 读入图片\nbg_pic = imread('your picture.png')\n# 配置词云参数\nwc = WordCloud(\n    # 设置背景色,我这里设置为了黑色\n    background_color = 'black',\n    # 设置词云形状，就是之前读入的图片\n    mask = bg_pic,\n    # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块\n    font_path = 'Sketch Fine Serif.otf'\n)\n# 生成词云\nwordcloud = wc.generate(text)\n# 显示词云图片\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.show()\n# 保存图片\nwordcloud.to_file('wordcloud.jpg')\n```\n\n生成的词云效果如图:\n![my wordcloud](/images/imagesource/17-03-25-2.jpg)\n#### 参数\n\n其中配置词云参数的时候，有多个参数可选：\n\nParameters\n```\nfont_path : string\n```\n> Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.\n\n```\nwidth : int (default=400)\n```\n> Width of the canvas.\n\n```\nheight : int (default=200)\n```\n> Height of canvas\n\n```\nprefer_horizontal : float (default=0.90)\n```\n> The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal < 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)\n\n```\nmask : nd-array or None (default=None)\n```\n> If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]\n\n```\nscale : float (default=1)\n```\n> Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.\n\n```\nmin_font_size : int (default=4)\n```\n> Smallest font size to use. Will stop when there is no more room in this size.\n\n```\nfont_step : int (default=1)\n```\n> Step size for the font. font_step > 1 might speed up computation but give a worse fit.\n\n```\nmax_words : number (default=200)\n```\n> The maximum number of words.\n\n```\nstopwords : set of strings or None\n```\n> The words that will be eliminated. If None, the build-in STOPWORDS list will be used.\n\n```\nbackground_color : color value (default=”black”)\n```\n> Background color for the word cloud image.\n\n```\nmax_font_size : int or None (default=None)\n```\n> Maximum font size for the largest word. If None, height of the image is used.\n\n```\nmode : string (default=”RGB”)\n```\n> Transparent background will be generated when mode is “RGBA” and background_color is None.\n\n```\nrelative_scaling : float (default=.5)\n```\n> Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.\n\n```\ncolor_func : callable, default=None\n```\n> Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.\n\n```\nregexp : string or None (optional)\n```\n> Regular expression to split the input text into tokens in process_text. If None is specified, r\"\\w[\\w']+\" is used.\n\n```\ncollocations : bool, default=True\n```\n> Whether to include collocations (bigrams) of two words.\n\n```\ncolormap : string or matplotlib colormap, default=”viridis”\n```\n> Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.\n\n```\nnormalize_plurals : bool, default=True\n```\n> Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.\n\n以上就是所有可以配置的参数，可以根据需要来用。\n\nEnd~\n\n---\n[1]: 图片出处: https://github.com/amueller/word_cloud\n\n","source":"_posts/Python生成词云.md","raw":"---\ntitle: Python生成词云\ndate: 2017-03-25 15:02:21\ncategory: Python\ntags: \n- Python\n- 词云\ncomments: true\n---\n![wordcloud](/images/imagesource/17-03-25-1.png )\n\n## Python如何生成词云\n最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P\n通过度娘发现可以用Python库来生成词云， So Let's go!\n<!--more-->\n\n### 用到的库\n#### WorldCloud\n- 官网: https://amueller.github.io/word_cloud\n- github: https://github.com/amueller/word_cloud \n\n\n### 安装WordCloud\n\n#### 通过PIP安装\n\n    pip install wordcloud\n#### 下载WHL包安装\n当然可能通过PIP会安装出错，我们可以下[WHL包](http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud)手动安装\n\n下载完成后，再使用PIP命令安装：\n\n    pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n    \n其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是`wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl`。\n\n### 使用WordlCloud\n安装完成后，就可以用了。可以先测试以下是否安装成功：\n\n    from wordcould import WordCloud\n如果没有报错，表示安装成功了。\n\n#### 源代码\n下面就是源码部分了:\n``` python\n# -*- coding: utf-8 -*-\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\nfrom scipy.misc omport imread\n\n# 读入一个文件\ntext = open('your text file.txt', 'r').read()\n# 读入图片\nbg_pic = imread('your picture.png')\n# 配置词云参数\nwc = WordCloud(\n    # 设置背景色,我这里设置为了黑色\n    background_color = 'black',\n    # 设置词云形状，就是之前读入的图片\n    mask = bg_pic,\n    # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块\n    font_path = 'Sketch Fine Serif.otf'\n)\n# 生成词云\nwordcloud = wc.generate(text)\n# 显示词云图片\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.show()\n# 保存图片\nwordcloud.to_file('wordcloud.jpg')\n```\n\n生成的词云效果如图:\n![my wordcloud](/images/imagesource/17-03-25-2.jpg)\n#### 参数\n\n其中配置词云参数的时候，有多个参数可选：\n\nParameters\n```\nfont_path : string\n```\n> Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.\n\n```\nwidth : int (default=400)\n```\n> Width of the canvas.\n\n```\nheight : int (default=200)\n```\n> Height of canvas\n\n```\nprefer_horizontal : float (default=0.90)\n```\n> The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal < 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)\n\n```\nmask : nd-array or None (default=None)\n```\n> If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]\n\n```\nscale : float (default=1)\n```\n> Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.\n\n```\nmin_font_size : int (default=4)\n```\n> Smallest font size to use. Will stop when there is no more room in this size.\n\n```\nfont_step : int (default=1)\n```\n> Step size for the font. font_step > 1 might speed up computation but give a worse fit.\n\n```\nmax_words : number (default=200)\n```\n> The maximum number of words.\n\n```\nstopwords : set of strings or None\n```\n> The words that will be eliminated. If None, the build-in STOPWORDS list will be used.\n\n```\nbackground_color : color value (default=”black”)\n```\n> Background color for the word cloud image.\n\n```\nmax_font_size : int or None (default=None)\n```\n> Maximum font size for the largest word. If None, height of the image is used.\n\n```\nmode : string (default=”RGB”)\n```\n> Transparent background will be generated when mode is “RGBA” and background_color is None.\n\n```\nrelative_scaling : float (default=.5)\n```\n> Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.\n\n```\ncolor_func : callable, default=None\n```\n> Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.\n\n```\nregexp : string or None (optional)\n```\n> Regular expression to split the input text into tokens in process_text. If None is specified, r\"\\w[\\w']+\" is used.\n\n```\ncollocations : bool, default=True\n```\n> Whether to include collocations (bigrams) of two words.\n\n```\ncolormap : string or matplotlib colormap, default=”viridis”\n```\n> Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.\n\n```\nnormalize_plurals : bool, default=True\n```\n> Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.\n\n以上就是所有可以配置的参数，可以根据需要来用。\n\nEnd~\n\n---\n[1]: 图片出处: https://github.com/amueller/word_cloud\n\n","slug":"Python生成词云","published":1,"updated":"2017-03-25T08:02:58.361Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvv000nswqcpnnmf4vp","content":"<p><img src=\"/images/imagesource/17-03-25-1.png\" alt=\"wordcloud\"></p>\n<h2 id=\"Python如何生成词云\"><a href=\"#Python如何生成词云\" class=\"headerlink\" title=\"Python如何生成词云\"></a>Python如何生成词云</h2><p>最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P<br>通过度娘发现可以用Python库来生成词云， So Let’s go!<br><a id=\"more\"></a></p>\n<h3 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h3><h4 id=\"WorldCloud\"><a href=\"#WorldCloud\" class=\"headerlink\" title=\"WorldCloud\"></a>WorldCloud</h4><ul>\n<li>官网: <a href=\"https://amueller.github.io/word_cloud\" target=\"_blank\" rel=\"external\">https://amueller.github.io/word_cloud</a></li>\n<li>github: <a href=\"https://github.com/amueller/word_cloud\" target=\"_blank\" rel=\"external\">https://github.com/amueller/word_cloud</a> </li>\n</ul>\n<h3 id=\"安装WordCloud\"><a href=\"#安装WordCloud\" class=\"headerlink\" title=\"安装WordCloud\"></a>安装WordCloud</h3><h4 id=\"通过PIP安装\"><a href=\"#通过PIP安装\" class=\"headerlink\" title=\"通过PIP安装\"></a>通过PIP安装</h4><pre><code>pip install wordcloud\n</code></pre><h4 id=\"下载WHL包安装\"><a href=\"#下载WHL包安装\" class=\"headerlink\" title=\"下载WHL包安装\"></a>下载WHL包安装</h4><p>当然可能通过PIP会安装出错，我们可以下<a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\" target=\"_blank\" rel=\"external\">WHL包</a>手动安装</p>\n<p>下载完成后，再使用PIP命令安装：</p>\n<pre><code>pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n</code></pre><p>其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是<code>wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code>。</p>\n<h3 id=\"使用WordlCloud\"><a href=\"#使用WordlCloud\" class=\"headerlink\" title=\"使用WordlCloud\"></a>使用WordlCloud</h3><p>安装完成后，就可以用了。可以先测试以下是否安装成功：</p>\n<pre><code>from wordcould import WordCloud\n</code></pre><p>如果没有报错，表示安装成功了。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>下面就是源码部分了:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"><span class=\"keyword\">from</span> scipy.misc omport imread</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 读入一个文件</span></div><div class=\"line\">text = open(<span class=\"string\">'your text file.txt'</span>, <span class=\"string\">'r'</span>).read()</div><div class=\"line\"><span class=\"comment\"># 读入图片</span></div><div class=\"line\">bg_pic = imread(<span class=\"string\">'your picture.png'</span>)</div><div class=\"line\"><span class=\"comment\"># 配置词云参数</span></div><div class=\"line\">wc = WordCloud(</div><div class=\"line\">    <span class=\"comment\"># 设置背景色,我这里设置为了黑色</span></div><div class=\"line\">    background_color = <span class=\"string\">'black'</span>,</div><div class=\"line\">    <span class=\"comment\"># 设置词云形状，就是之前读入的图片</span></div><div class=\"line\">    mask = bg_pic,</div><div class=\"line\">    <span class=\"comment\"># 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块</span></div><div class=\"line\">    font_path = <span class=\"string\">'Sketch Fine Serif.otf'</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\"># 生成词云</span></div><div class=\"line\">wordcloud = wc.generate(text)</div><div class=\"line\"><span class=\"comment\"># 显示词云图片</span></div><div class=\"line\">plt.imshow(wordcloud)</div><div class=\"line\">plt.axis(<span class=\"string\">'off'</span>)</div><div class=\"line\">plt.show()</div><div class=\"line\"><span class=\"comment\"># 保存图片</span></div><div class=\"line\">wordcloud.to_file(<span class=\"string\">'wordcloud.jpg'</span>)</div></pre></td></tr></table></figure></p>\n<p>生成的词云效果如图:<br><img src=\"/images/imagesource/17-03-25-2.jpg\" alt=\"my wordcloud\"></p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>其中配置词云参数的时候，有多个参数可选：</p>\n<p>Parameters<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">font_path : string</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">width : int (default=400)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Width of the canvas.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">height : int (default=200)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Height of canvas</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">prefer_horizontal : float (default=0.90)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mask : nd-array or None (default=None)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scale : float (default=1)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">min_font_size : int (default=4)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Smallest font size to use. Will stop when there is no more room in this size.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">font_step : int (default=1)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max_words : number (default=200)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The maximum number of words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">stopwords : set of strings or None</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The words that will be eliminated. If None, the build-in STOPWORDS list will be used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">background_color : color value (default=”black”)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Background color for the word cloud image.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max_font_size : int or None (default=None)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Maximum font size for the largest word. If None, height of the image is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mode : string (default=”RGB”)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Transparent background will be generated when mode is “RGBA” and background_color is None.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">relative_scaling : float (default=.5)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">color_func : callable, default=None</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">regexp : string or None (optional)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Regular expression to split the input text into tokens in process_text. If None is specified, r”\\w[\\w’]+” is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">collocations : bool, default=True</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to include collocations (bigrams) of two words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">colormap : string or matplotlib colormap, default=”viridis”</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">normalize_plurals : bool, default=True</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.</p>\n</blockquote>\n<p>以上就是所有可以配置的参数，可以根据需要来用。</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"https://github.com/amueller/word_cloud\" target=\"_blank\" rel=\"external\">https://github.com/amueller/word_cloud</a></p>\n","excerpt":"<p><img src=\"/images/imagesource/17-03-25-1.png\" alt=\"wordcloud\"></p>\n<h2 id=\"Python如何生成词云\"><a href=\"#Python如何生成词云\" class=\"headerlink\" title=\"Python如何生成词云\"></a>Python如何生成词云</h2><p>最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P<br>通过度娘发现可以用Python库来生成词云， So Let’s go!<br>","more":"</p>\n<h3 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h3><h4 id=\"WorldCloud\"><a href=\"#WorldCloud\" class=\"headerlink\" title=\"WorldCloud\"></a>WorldCloud</h4><ul>\n<li>官网: <a href=\"https://amueller.github.io/word_cloud\">https://amueller.github.io/word_cloud</a></li>\n<li>github: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a> </li>\n</ul>\n<h3 id=\"安装WordCloud\"><a href=\"#安装WordCloud\" class=\"headerlink\" title=\"安装WordCloud\"></a>安装WordCloud</h3><h4 id=\"通过PIP安装\"><a href=\"#通过PIP安装\" class=\"headerlink\" title=\"通过PIP安装\"></a>通过PIP安装</h4><pre><code>pip install wordcloud\n</code></pre><h4 id=\"下载WHL包安装\"><a href=\"#下载WHL包安装\" class=\"headerlink\" title=\"下载WHL包安装\"></a>下载WHL包安装</h4><p>当然可能通过PIP会安装出错，我们可以下<a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\">WHL包</a>手动安装</p>\n<p>下载完成后，再使用PIP命令安装：</p>\n<pre><code>pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n</code></pre><p>其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是<code>wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code>。</p>\n<h3 id=\"使用WordlCloud\"><a href=\"#使用WordlCloud\" class=\"headerlink\" title=\"使用WordlCloud\"></a>使用WordlCloud</h3><p>安装完成后，就可以用了。可以先测试以下是否安装成功：</p>\n<pre><code>from wordcould import WordCloud\n</code></pre><p>如果没有报错，表示安装成功了。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>下面就是源码部分了:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"><span class=\"keyword\">from</span> scipy.misc omport imread</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 读入一个文件</span></div><div class=\"line\">text = open(<span class=\"string\">'your text file.txt'</span>, <span class=\"string\">'r'</span>).read()</div><div class=\"line\"><span class=\"comment\"># 读入图片</span></div><div class=\"line\">bg_pic = imread(<span class=\"string\">'your picture.png'</span>)</div><div class=\"line\"><span class=\"comment\"># 配置词云参数</span></div><div class=\"line\">wc = WordCloud(</div><div class=\"line\">    <span class=\"comment\"># 设置背景色,我这里设置为了黑色</span></div><div class=\"line\">    background_color = <span class=\"string\">'black'</span>,</div><div class=\"line\">    <span class=\"comment\"># 设置词云形状，就是之前读入的图片</span></div><div class=\"line\">    mask = bg_pic,</div><div class=\"line\">    <span class=\"comment\"># 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块</span></div><div class=\"line\">    font_path = <span class=\"string\">'Sketch Fine Serif.otf'</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\"># 生成词云</span></div><div class=\"line\">wordcloud = wc.generate(text)</div><div class=\"line\"><span class=\"comment\"># 显示词云图片</span></div><div class=\"line\">plt.imshow(wordcloud)</div><div class=\"line\">plt.axis(<span class=\"string\">'off'</span>)</div><div class=\"line\">plt.show()</div><div class=\"line\"><span class=\"comment\"># 保存图片</span></div><div class=\"line\">wordcloud.to_file(<span class=\"string\">'wordcloud.jpg'</span>)</div></pre></td></tr></table></figure></p>\n<p>生成的词云效果如图:<br><img src=\"/images/imagesource/17-03-25-2.jpg\" alt=\"my wordcloud\"></p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>其中配置词云参数的时候，有多个参数可选：</p>\n<p>Parameters<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">font_path : string</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">width : int (default=400)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Width of the canvas.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">height : int (default=200)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Height of canvas</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">prefer_horizontal : float (default=0.90)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mask : nd-array or None (default=None)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scale : float (default=1)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">min_font_size : int (default=4)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Smallest font size to use. Will stop when there is no more room in this size.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">font_step : int (default=1)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max_words : number (default=200)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The maximum number of words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">stopwords : set of strings or None</div></pre></td></tr></table></figure>\n<blockquote>\n<p>The words that will be eliminated. If None, the build-in STOPWORDS list will be used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">background_color : color value (default=”black”)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Background color for the word cloud image.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max_font_size : int or None (default=None)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Maximum font size for the largest word. If None, height of the image is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mode : string (default=”RGB”)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Transparent background will be generated when mode is “RGBA” and background_color is None.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">relative_scaling : float (default=.5)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">color_func : callable, default=None</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">regexp : string or None (optional)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Regular expression to split the input text into tokens in process_text. If None is specified, r”\\w[\\w’]+” is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">collocations : bool, default=True</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to include collocations (bigrams) of two words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">colormap : string or matplotlib colormap, default=”viridis”</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">normalize_plurals : bool, default=True</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.</p>\n</blockquote>\n<p>以上就是所有可以配置的参数，可以根据需要来用。</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a></p>"},{"title":"Python脚本抓取Bing美图","date":"2017-03-23T06:26:18.000Z","comments":1,"_content":"![post_background](http://api.dujin.org/bing/1920.php)\n\n# 使用Python脚本下载Bing美图\n\n[Bing首页](https://cn.bing.com)每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。\n<!--more-->\n\n## Bing美图API\n\nBing官方有两个API：\nxml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&n=1\njson版： http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n有了API就可以愉快地抓图了:D\n\n## Python抓图\n\n至于为什么要用Python，前段时间学习了廖大的[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000),算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！\n\n## 用到的库\n\n - [Requests](http://cn.python-requests.org/zh_CN/latest/index.html)\n\n## 爬图 (更新于2018-04-04)\n\n这里我用了json版的API，使用`requests`的`json()`函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在`images`所对应的值里面。得到`images`的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值`url`来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上`https:://www.bing.com`，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。\n\n## 源代码\n\n```python\n\n# -*- coding: utf-8 -*-\nimport requests\nimport os\nimport time\n\n\ndef get_content(url):\n    \"\"\"\n    得到API返回的JSON数据\n    :param url: API链接\n    :return: 返回的是一个字典\n    \"\"\"\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.json()\n    except:\n        print(\"ERROR\")\n\n\ndef get_img(url):\n    \"\"\"\n    得到图片的内容\n    :param url: 图片的真实链接\n    :return: 返回的是byte类型的图片内容\n    \"\"\"\n    try:\n        r = requests.get(url)\n        return r.content\n    except:\n        return None\n\n\ndef download(file_name, url):\n    \"\"\"\n    根据得到的链接在指定位置保存图片\n    :param file_name: 要保存图片的位置\n    :param url: 图片的链接\n    :return: \n    \"\"\"\n    if os.path.exists(r'C:\\Users\\Freed\\Pictures\\bingwallpaper'):\n        print('Find Dir...')\n    else:\n        print(\"File dir did not exist, make dir...\")\n        try:\n            os.mkdir(r'C:\\Users\\Freed\\Pictures\\bingwallpaper')\n            print('Make dir success')\n        except:\n            print('Failed in make dir')\n    if os.path.exists(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name):\n        print('Image downloaded already')\n    else:\n        img = get_img(url)\n        with open(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name,\n                  'wb') as f:\n            f.write(img)\n        print('Download success')\n\n\nif __name__ == '__main__':\n    url = \"https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n    content = get_content(url)\n    url_dict = content['images'][0]\n    download_url = 'https://www.bing.com' + url_dict['url']\n\n    file_name = str(\"BingWallPaper-\" + time.strftime('%Y-%m-%d',\n                                                     time.localtime(time.time())) + '.jpg')\n    download(file_name, download_url)\n```\n\n用Python命令运行文件即可。\n到此大功告成!  :D\n","source":"_posts/Python3脚本抓取Bing美图.md","raw":"---\ntitle: Python脚本抓取Bing美图\ndate: 2017-03-23 14:26:18\ncategory: Python\ntags: Python\ncomments: true\n---\n![post_background](http://api.dujin.org/bing/1920.php)\n\n# 使用Python脚本下载Bing美图\n\n[Bing首页](https://cn.bing.com)每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。\n<!--more-->\n\n## Bing美图API\n\nBing官方有两个API：\nxml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&n=1\njson版： http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n有了API就可以愉快地抓图了:D\n\n## Python抓图\n\n至于为什么要用Python，前段时间学习了廖大的[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000),算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！\n\n## 用到的库\n\n - [Requests](http://cn.python-requests.org/zh_CN/latest/index.html)\n\n## 爬图 (更新于2018-04-04)\n\n这里我用了json版的API，使用`requests`的`json()`函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在`images`所对应的值里面。得到`images`的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值`url`来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上`https:://www.bing.com`，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。\n\n## 源代码\n\n```python\n\n# -*- coding: utf-8 -*-\nimport requests\nimport os\nimport time\n\n\ndef get_content(url):\n    \"\"\"\n    得到API返回的JSON数据\n    :param url: API链接\n    :return: 返回的是一个字典\n    \"\"\"\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.json()\n    except:\n        print(\"ERROR\")\n\n\ndef get_img(url):\n    \"\"\"\n    得到图片的内容\n    :param url: 图片的真实链接\n    :return: 返回的是byte类型的图片内容\n    \"\"\"\n    try:\n        r = requests.get(url)\n        return r.content\n    except:\n        return None\n\n\ndef download(file_name, url):\n    \"\"\"\n    根据得到的链接在指定位置保存图片\n    :param file_name: 要保存图片的位置\n    :param url: 图片的链接\n    :return: \n    \"\"\"\n    if os.path.exists(r'C:\\Users\\Freed\\Pictures\\bingwallpaper'):\n        print('Find Dir...')\n    else:\n        print(\"File dir did not exist, make dir...\")\n        try:\n            os.mkdir(r'C:\\Users\\Freed\\Pictures\\bingwallpaper')\n            print('Make dir success')\n        except:\n            print('Failed in make dir')\n    if os.path.exists(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name):\n        print('Image downloaded already')\n    else:\n        img = get_img(url)\n        with open(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name,\n                  'wb') as f:\n            f.write(img)\n        print('Download success')\n\n\nif __name__ == '__main__':\n    url = \"https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n    content = get_content(url)\n    url_dict = content['images'][0]\n    download_url = 'https://www.bing.com' + url_dict['url']\n\n    file_name = str(\"BingWallPaper-\" + time.strftime('%Y-%m-%d',\n                                                     time.localtime(time.time())) + '.jpg')\n    download(file_name, download_url)\n```\n\n用Python命令运行文件即可。\n到此大功告成!  :D\n","slug":"Python3脚本抓取Bing美图","published":1,"updated":"2019-01-07T13:58:40.771Z","layout":"post","photos":[],"link":"","_id":"cjqojmlvv000pswqcol24byzi","content":"<p><img src=\"http://api.dujin.org/bing/1920.php\" alt=\"post_background\"></p>\n<h1 id=\"使用Python脚本下载Bing美图\"><a href=\"#使用Python脚本下载Bing美图\" class=\"headerlink\" title=\"使用Python脚本下载Bing美图\"></a>使用Python脚本下载Bing美图</h1><p><a href=\"https://cn.bing.com\" target=\"_blank\" rel=\"external\">Bing首页</a>每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。<br><a id=\"more\"></a></p>\n<h2 id=\"Bing美图API\"><a href=\"#Bing美图API\" class=\"headerlink\" title=\"Bing美图API\"></a>Bing美图API</h2><p>Bing官方有两个API：<br>xml版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1\" target=\"_blank\" rel=\"external\">http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1</a><br>json版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\" target=\"_blank\" rel=\"external\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a><br>有了API就可以愉快地抓图了:D</p>\n<h2 id=\"Python抓图\"><a href=\"#Python抓图\" class=\"headerlink\" title=\"Python抓图\"></a>Python抓图</h2><p>至于为什么要用Python，前段时间学习了廖大的<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"external\">Python教程</a>,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！</p>\n<h2 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h2><ul>\n<li><a href=\"http://cn.python-requests.org/zh_CN/latest/index.html\" target=\"_blank\" rel=\"external\">Requests</a></li>\n</ul>\n<h2 id=\"爬图-更新于2018-04-04\"><a href=\"#爬图-更新于2018-04-04\" class=\"headerlink\" title=\"爬图 (更新于2018-04-04)\"></a>爬图 (更新于2018-04-04)</h2><p>这里我用了json版的API，使用<code>requests</code>的<code>json()</code>函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在<code>images</code>所对应的值里面。得到<code>images</code>的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值<code>url</code>来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上<code>https:://www.bing.com</code>，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_content</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    得到API返回的JSON数据</div><div class=\"line\">    :param url: API链接</div><div class=\"line\">    :return: 返回的是一个字典</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        r = requests.get(url)</div><div class=\"line\">        r.raise_for_status()</div><div class=\"line\">        r.encoding = r.apparent_encoding</div><div class=\"line\">        <span class=\"keyword\">return</span> r.json()</div><div class=\"line\">    <span class=\"keyword\">except</span>:</div><div class=\"line\">        print(<span class=\"string\">\"ERROR\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_img</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    得到图片的内容</div><div class=\"line\">    :param url: 图片的真实链接</div><div class=\"line\">    :return: 返回的是byte类型的图片内容</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        r = requests.get(url)</div><div class=\"line\">        <span class=\"keyword\">return</span> r.content</div><div class=\"line\">    <span class=\"keyword\">except</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span><span class=\"params\">(file_name, url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    根据得到的链接在指定位置保存图片</div><div class=\"line\">    :param file_name: 要保存图片的位置</div><div class=\"line\">    :param url: 图片的链接</div><div class=\"line\">    :return: </div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r'C:\\Users\\Freed\\Pictures\\bingwallpaper'</span>):</div><div class=\"line\">        print(<span class=\"string\">'Find Dir...'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        print(<span class=\"string\">\"File dir did not exist, make dir...\"</span>)</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            os.mkdir(<span class=\"string\">r'C:\\Users\\Freed\\Pictures\\bingwallpaper'</span>)</div><div class=\"line\">            print(<span class=\"string\">'Make dir success'</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            print(<span class=\"string\">'Failed in make dir'</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r'c:\\users\\freed\\pictures\\bingwallpaper\\\\'</span> + file_name):</div><div class=\"line\">        print(<span class=\"string\">'Image downloaded already'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        img = get_img(url)</div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">r'c:\\users\\freed\\pictures\\bingwallpaper\\\\'</span> + file_name,</div><div class=\"line\">                  <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(img)</div><div class=\"line\">        print(<span class=\"string\">'Download success'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    url = <span class=\"string\">\"https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\"</span></div><div class=\"line\">    content = get_content(url)</div><div class=\"line\">    url_dict = content[<span class=\"string\">'images'</span>][<span class=\"number\">0</span>]</div><div class=\"line\">    download_url = <span class=\"string\">'https://www.bing.com'</span> + url_dict[<span class=\"string\">'url'</span>]</div><div class=\"line\"></div><div class=\"line\">    file_name = str(<span class=\"string\">\"BingWallPaper-\"</span> + time.strftime(<span class=\"string\">'%Y-%m-%d'</span>,</div><div class=\"line\">                                                     time.localtime(time.time())) + <span class=\"string\">'.jpg'</span>)</div><div class=\"line\">    download(file_name, download_url)</div></pre></td></tr></table></figure>\n<p>用Python命令运行文件即可。<br>到此大功告成!  :D</p>\n","excerpt":"<p><img src=\"http://api.dujin.org/bing/1920.php\" alt=\"post_background\"></p>\n<h1 id=\"使用Python脚本下载Bing美图\"><a href=\"#使用Python脚本下载Bing美图\" class=\"headerlink\" title=\"使用Python脚本下载Bing美图\"></a>使用Python脚本下载Bing美图</h1><p><a href=\"https://cn.bing.com\">Bing首页</a>每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。<br>","more":"</p>\n<h2 id=\"Bing美图API\"><a href=\"#Bing美图API\" class=\"headerlink\" title=\"Bing美图API\"></a>Bing美图API</h2><p>Bing官方有两个API：<br>xml版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1</a><br>json版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a><br>有了API就可以愉快地抓图了:D</p>\n<h2 id=\"Python抓图\"><a href=\"#Python抓图\" class=\"headerlink\" title=\"Python抓图\"></a>Python抓图</h2><p>至于为什么要用Python，前段时间学习了廖大的<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\">Python教程</a>,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！</p>\n<h2 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h2><ul>\n<li><a href=\"http://cn.python-requests.org/zh_CN/latest/index.html\">Requests</a></li>\n</ul>\n<h2 id=\"爬图-更新于2018-04-04\"><a href=\"#爬图-更新于2018-04-04\" class=\"headerlink\" title=\"爬图 (更新于2018-04-04)\"></a>爬图 (更新于2018-04-04)</h2><p>这里我用了json版的API，使用<code>requests</code>的<code>json()</code>函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在<code>images</code>所对应的值里面。得到<code>images</code>的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值<code>url</code>来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上<code>https:://www.bing.com</code>，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_content</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    得到API返回的JSON数据</div><div class=\"line\">    :param url: API链接</div><div class=\"line\">    :return: 返回的是一个字典</div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        r = requests.get(url)</div><div class=\"line\">        r.raise_for_status()</div><div class=\"line\">        r.encoding = r.apparent_encoding</div><div class=\"line\">        <span class=\"keyword\">return</span> r.json()</div><div class=\"line\">    <span class=\"keyword\">except</span>:</div><div class=\"line\">        print(<span class=\"string\">\"ERROR\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_img</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    得到图片的内容</div><div class=\"line\">    :param url: 图片的真实链接</div><div class=\"line\">    :return: 返回的是byte类型的图片内容</div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        r = requests.get(url)</div><div class=\"line\">        <span class=\"keyword\">return</span> r.content</div><div class=\"line\">    <span class=\"keyword\">except</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span><span class=\"params\">(file_name, url)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    根据得到的链接在指定位置保存图片</div><div class=\"line\">    :param file_name: 要保存图片的位置</div><div class=\"line\">    :param url: 图片的链接</div><div class=\"line\">    :return: </div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r'C:\\Users\\Freed\\Pictures\\bingwallpaper'</span>):</div><div class=\"line\">        print(<span class=\"string\">'Find Dir...'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        print(<span class=\"string\">\"File dir did not exist, make dir...\"</span>)</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            os.mkdir(<span class=\"string\">r'C:\\Users\\Freed\\Pictures\\bingwallpaper'</span>)</div><div class=\"line\">            print(<span class=\"string\">'Make dir success'</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            print(<span class=\"string\">'Failed in make dir'</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r'c:\\users\\freed\\pictures\\bingwallpaper\\\\'</span> + file_name):</div><div class=\"line\">        print(<span class=\"string\">'Image downloaded already'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        img = get_img(url)</div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">r'c:\\users\\freed\\pictures\\bingwallpaper\\\\'</span> + file_name,</div><div class=\"line\">                  <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(img)</div><div class=\"line\">        print(<span class=\"string\">'Download success'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    url = <span class=\"string\">\"https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\"</span></div><div class=\"line\">    content = get_content(url)</div><div class=\"line\">    url_dict = content[<span class=\"string\">'images'</span>][<span class=\"number\">0</span>]</div><div class=\"line\">    download_url = <span class=\"string\">'https://www.bing.com'</span> + url_dict[<span class=\"string\">'url'</span>]</div><div class=\"line\"></div><div class=\"line\">    file_name = str(<span class=\"string\">\"BingWallPaper-\"</span> + time.strftime(<span class=\"string\">'%Y-%m-%d'</span>,</div><div class=\"line\">                                                     time.localtime(time.time())) + <span class=\"string\">'.jpg'</span>)</div><div class=\"line\">    download(file_name, download_url)</div></pre></td></tr></table></figure>\n<p>用Python命令运行文件即可。<br>到此大功告成!  :D</p>"},{"title":"UTF-8 码点","date":"2017-10-09T02:34:48.000Z","comments":1,"_content":"\nUTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：\n<!--more-->\n\n | 码点范围    | 码点位数    |  字节1  |字节2|字节3|字节4|\n |:-----------:|:--:         |:--:     |:--: |:--: |:--: |\n |U+0000~U+007F|7            |0xxxxxxx |     |     |     |\n |U+0080~U+07FF|11           |110xxxxx |10xxxxxx|    |    |\n |U+0800~U+FFFF|16           |1110xxxx |10xxxxxx|10xxxxxx| |\n |U+10000~U+10FFFF| 21       |11110xxx |10xxxxxx|10xxxxxx|10xxxxxx|\n \n 1000 0000 -> 80\n 1100 0000 -> C0\n 1110 0000 -> E0\n 1111 0000 -> F0\n \n 1111 1111 -> FF\n 0011 1111 -> 3F\n \n e.g. U+20AC 0x0800 < 0x20AC < 0xFFFF\n 所以0x20AC有16位码点,编成三字节\n 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即\n 0010 0000 1010 1100\n 将其分成三组：\n 0010， 000010， 101100\n 加上前缀：\n 1110 0010, 1000 0010, 1010 1100\n 则得到 0xE2, 0x82, 0xAC\n \n 10 0000 1010 1100 >> 12 -> 10 -> 0000 0010\n 0000 0010 & 1111 1111 -> 0000 0010\n 1110 0000 | 0000 0010 -> 1110 0010 -> 0xE2\n \n 10 0000 1010 1100 >> 6 -> 1000 0010\n 1000 0010 & 0011 1111 -> 0000 0010\n 1000 0000 | 0000 0010 -> 1000 0010 -> 0x82\n \n 10 0000 1010 1100 & 00 0000 1111 1111 -> 00 0000 1010 1100\n 00 0000 1000 0000 | 00 0000 1010 1100 -> 1010 1100 -> 0xAC\n\n 代码表示(C):\n\n``` c\n// u <= 0x007F\nPUTC(c, u & 0xFF);\n\n// u <= 0x07FF\nPUTC(c, 0xC0 | ((u >> 6) & 0xFF));\nPUTC(c, 0x80 | (u & 0x3F);\n\n// u <= 0xFFFF\nPUTC(c, 0xE0 | ((u >> 12) & 0xFF));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n\n// u <= 0x10FFFF\nPUTC(c, 0xF0 | ((u >> 18) & 0xFF));\nPUTC(c, 0x80 | ((u >> 12) & 0x3F));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n```\n\n---","source":"_posts/UTF-8-码点.md","raw":"---\ntitle: UTF-8 码点\ndate: 2017-10-09 10:34:48\ncategory: CPP\ntags: UTF-8\ncomments: true\n---\n\nUTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：\n<!--more-->\n\n | 码点范围    | 码点位数    |  字节1  |字节2|字节3|字节4|\n |:-----------:|:--:         |:--:     |:--: |:--: |:--: |\n |U+0000~U+007F|7            |0xxxxxxx |     |     |     |\n |U+0080~U+07FF|11           |110xxxxx |10xxxxxx|    |    |\n |U+0800~U+FFFF|16           |1110xxxx |10xxxxxx|10xxxxxx| |\n |U+10000~U+10FFFF| 21       |11110xxx |10xxxxxx|10xxxxxx|10xxxxxx|\n \n 1000 0000 -> 80\n 1100 0000 -> C0\n 1110 0000 -> E0\n 1111 0000 -> F0\n \n 1111 1111 -> FF\n 0011 1111 -> 3F\n \n e.g. U+20AC 0x0800 < 0x20AC < 0xFFFF\n 所以0x20AC有16位码点,编成三字节\n 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即\n 0010 0000 1010 1100\n 将其分成三组：\n 0010， 000010， 101100\n 加上前缀：\n 1110 0010, 1000 0010, 1010 1100\n 则得到 0xE2, 0x82, 0xAC\n \n 10 0000 1010 1100 >> 12 -> 10 -> 0000 0010\n 0000 0010 & 1111 1111 -> 0000 0010\n 1110 0000 | 0000 0010 -> 1110 0010 -> 0xE2\n \n 10 0000 1010 1100 >> 6 -> 1000 0010\n 1000 0010 & 0011 1111 -> 0000 0010\n 1000 0000 | 0000 0010 -> 1000 0010 -> 0x82\n \n 10 0000 1010 1100 & 00 0000 1111 1111 -> 00 0000 1010 1100\n 00 0000 1000 0000 | 00 0000 1010 1100 -> 1010 1100 -> 0xAC\n\n 代码表示(C):\n\n``` c\n// u <= 0x007F\nPUTC(c, u & 0xFF);\n\n// u <= 0x07FF\nPUTC(c, 0xC0 | ((u >> 6) & 0xFF));\nPUTC(c, 0x80 | (u & 0x3F);\n\n// u <= 0xFFFF\nPUTC(c, 0xE0 | ((u >> 12) & 0xFF));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n\n// u <= 0x10FFFF\nPUTC(c, 0xF0 | ((u >> 18) & 0xFF));\nPUTC(c, 0x80 | ((u >> 12) & 0x3F));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n```\n\n---","slug":"UTF-8-码点","published":1,"updated":"2019-01-07T13:44:48.079Z","layout":"post","photos":[],"link":"","_id":"cjqojmlwb000tswqc1fk4pigk","content":"<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：<br><a id=\"more\"></a></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">码点范围</th>\n<th style=\"text-align:center\">码点位数</th>\n<th style=\"text-align:center\">字节1</th>\n<th style=\"text-align:center\">字节2</th>\n<th style=\"text-align:center\">字节3</th>\n<th style=\"text-align:center\">字节4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">U+0000~U+007F</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0xxxxxxx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+0080~U+07FF</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">110xxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+0800~U+FFFF</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">1110xxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+10000~U+10FFFF</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">11110xxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p>\n<p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p>\n<p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p>\n<p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p>\n<p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p>\n<p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p>\n<p> 代码表示(C):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u &lt;= 0x007F</span></div><div class=\"line\">PUTC(c, u &amp; <span class=\"number\">0xFF</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0x07FF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xC0</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0xFFFF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xE0</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0x10FFFF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xF0</span> | ((u &gt;&gt; <span class=\"number\">18</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：<br>","more":"</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">码点范围</th>\n<th style=\"text-align:center\">码点位数</th>\n<th style=\"text-align:center\">字节1</th>\n<th style=\"text-align:center\">字节2</th>\n<th style=\"text-align:center\">字节3</th>\n<th style=\"text-align:center\">字节4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">U+0000~U+007F</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0xxxxxxx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+0080~U+07FF</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">110xxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+0800~U+FFFF</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">1110xxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+10000~U+10FFFF</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">11110xxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n<td style=\"text-align:center\">10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p>\n<p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p>\n<p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p>\n<p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p>\n<p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p>\n<p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p>\n<p> 代码表示(C):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u &lt;= 0x007F</span></div><div class=\"line\">PUTC(c, u &amp; <span class=\"number\">0xFF</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0x07FF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xC0</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0xFFFF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xE0</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// u &lt;= 0x10FFFF</span></div><div class=\"line\">PUTC(c, <span class=\"number\">0xF0</span> | ((u &gt;&gt; <span class=\"number\">18</span>) &amp; <span class=\"number\">0xFF</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</div><div class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</div></pre></td></tr></table></figure>\n<hr>"},{"title":"VSCode 常用插件记录","date":"2019-01-08T13:50:16.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-01-08.jpg","_content":"\n![vscode](/images/imagesource/19-01-08.png)\n诈尸更新~~🤣🤣🤣\n这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。\n<!--more-->\n\nVSCode 下载地址：[Visual Studio Code](https://code.visualstudio.com/)\n\n## 语言相关\n\n### C/C++\n\n推荐微软官方推出的 [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)插件，支持智能提示和debug，很方便。\n\n如何在 VSCode 上配置 C/C++ 环境可以参考知乎[Visual Studio Code如何编写运行C、C++？](https://www.zhihu.com/question/30315894/answer/154979413) 这个问题下的高赞回答。\n\n通过 [vscode-fileheader](https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader) 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。\n\n### Python\n\n同样推荐微软官方的 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件。本来是民间大神写的，后来被微软收编了。只要安装好 [Python](https://www.python.org/downloads/) 环境，然后再装这个插件，写起 Python 代码来美滋滋！\n\n同时再推荐 [Visual Studio IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。\n\n## 文章书写\n\n### Markdown\n\nVSCode 对 Markdown 也有很好的支持。推荐如下几个插件：\n\n1. [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。\n2. [Markdown Preview Enhanced](https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced)，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。\n\n### LaTeX\n\nVSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 [TeX Live](https://www.tug.org/texlive/) 作为 TeX 环境。有了 TeX 环境后，再安装 [LaTeX Workshop](https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop) 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。\n\n同时推荐 [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。\n\n## 美化相关\n\nVSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。\n\n### 主题\n\n1. [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)，一款仿照 Atom 的 One Dark 主题\n2. [Material Theme](https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme)，Google Material Design 风格的主题，有多种颜色可以选择\n\n### 图标\n\n这里只推荐一个，个人最喜欢的一套图标 [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。\n\n### 字体\n\nVSCode 同时支持自定义字体，个人的字体设置为 `'Consolas', '思源黑体 Regular', monospace`，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。\n\n## 其他\n\n### HTML 文件预览\n\n写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 [View In Browser](https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser)，通过快捷键 `Ctrl+F1` 即可在默认的浏览器中预览 HTML 文档了。\n\n### GitHub\n\n[GitHub](https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github) 插件支持 GitHub pull/push 等源代码相关操作。\n\n### 代码运行\n\n[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。\n\n### 语言环境\n\n新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如[简体中文](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans)，安装完成后重新加载即可使用中文界面。其他语言同理。\n\n### 同步设置\n\n[Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 [GitHub Gist](https://gist.github.com/) 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。\n\n\n以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。","source":"_posts/VSCode-Extensions.md","raw":"---\ntitle: VSCode 常用插件记录\ndate: 2019-01-08 21:50:16\ncategory: Development\ntags: VSCode\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-01-08.jpg\n---\n\n![vscode](/images/imagesource/19-01-08.png)\n诈尸更新~~🤣🤣🤣\n这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。\n<!--more-->\n\nVSCode 下载地址：[Visual Studio Code](https://code.visualstudio.com/)\n\n## 语言相关\n\n### C/C++\n\n推荐微软官方推出的 [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)插件，支持智能提示和debug，很方便。\n\n如何在 VSCode 上配置 C/C++ 环境可以参考知乎[Visual Studio Code如何编写运行C、C++？](https://www.zhihu.com/question/30315894/answer/154979413) 这个问题下的高赞回答。\n\n通过 [vscode-fileheader](https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader) 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。\n\n### Python\n\n同样推荐微软官方的 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件。本来是民间大神写的，后来被微软收编了。只要安装好 [Python](https://www.python.org/downloads/) 环境，然后再装这个插件，写起 Python 代码来美滋滋！\n\n同时再推荐 [Visual Studio IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。\n\n## 文章书写\n\n### Markdown\n\nVSCode 对 Markdown 也有很好的支持。推荐如下几个插件：\n\n1. [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。\n2. [Markdown Preview Enhanced](https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced)，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。\n\n### LaTeX\n\nVSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 [TeX Live](https://www.tug.org/texlive/) 作为 TeX 环境。有了 TeX 环境后，再安装 [LaTeX Workshop](https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop) 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。\n\n同时推荐 [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。\n\n## 美化相关\n\nVSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。\n\n### 主题\n\n1. [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)，一款仿照 Atom 的 One Dark 主题\n2. [Material Theme](https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme)，Google Material Design 风格的主题，有多种颜色可以选择\n\n### 图标\n\n这里只推荐一个，个人最喜欢的一套图标 [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。\n\n### 字体\n\nVSCode 同时支持自定义字体，个人的字体设置为 `'Consolas', '思源黑体 Regular', monospace`，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。\n\n## 其他\n\n### HTML 文件预览\n\n写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 [View In Browser](https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser)，通过快捷键 `Ctrl+F1` 即可在默认的浏览器中预览 HTML 文档了。\n\n### GitHub\n\n[GitHub](https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github) 插件支持 GitHub pull/push 等源代码相关操作。\n\n### 代码运行\n\n[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。\n\n### 语言环境\n\n新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如[简体中文](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans)，安装完成后重新加载即可使用中文界面。其他语言同理。\n\n### 同步设置\n\n[Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 [GitHub Gist](https://gist.github.com/) 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。\n\n\n以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。","slug":"VSCode-Extensions","published":1,"updated":"2019-01-14T02:47:08.410Z","_id":"cjqojmlwq000vswqcdmakblyy","layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/imagesource/19-01-08.png\" alt=\"vscode\"><br>诈尸更新~~🤣🤣🤣<br>这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。<br><a id=\"more\"></a></p>\n<p>VSCode 下载地址：<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"external\">Visual Studio Code</a></p>\n<h2 id=\"语言相关\"><a href=\"#语言相关\" class=\"headerlink\" title=\"语言相关\"></a>语言相关</h2><h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><p>推荐微软官方推出的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\" target=\"_blank\" rel=\"external\">C/C++</a>插件，支持智能提示和debug，很方便。</p>\n<p>如何在 VSCode 上配置 C/C++ 环境可以参考知乎<a href=\"https://www.zhihu.com/question/30315894/answer/154979413\" target=\"_blank\" rel=\"external\">Visual Studio Code如何编写运行C、C++？</a> 这个问题下的高赞回答。</p>\n<p>通过 <a href=\"https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader\" target=\"_blank\" rel=\"external\">vscode-fileheader</a> 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>同样推荐微软官方的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-python.python\" target=\"_blank\" rel=\"external\">Python</a> 插件。本来是民间大神写的，后来被微软收编了。只要安装好 <a href=\"https://www.python.org/downloads/\" target=\"_blank\" rel=\"external\">Python</a> 环境，然后再装这个插件，写起 Python 代码来美滋滋！</p>\n<p>同时再推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode\" target=\"_blank\" rel=\"external\">Visual Studio IntelliCode</a> 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。</p>\n<h2 id=\"文章书写\"><a href=\"#文章书写\" class=\"headerlink\" title=\"文章书写\"></a>文章书写</h2><h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><p>VSCode 对 Markdown 也有很好的支持。推荐如下几个插件：</p>\n<ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\" target=\"_blank\" rel=\"external\">Markdown All in One</a>，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced\" target=\"_blank\" rel=\"external\">Markdown Preview Enhanced</a>，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。</li>\n</ol>\n<h3 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"LaTeX\"></a>LaTeX</h3><p>VSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 <a href=\"https://www.tug.org/texlive/\" target=\"_blank\" rel=\"external\">TeX Live</a> 作为 TeX 环境。有了 TeX 环境后，再安装 <a href=\"https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop\" target=\"_blank\" rel=\"external\">LaTeX Workshop</a> 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。</p>\n<p>同时推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\" target=\"_blank\" rel=\"external\">Code Spell Checker</a>，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。</p>\n<h2 id=\"美化相关\"><a href=\"#美化相关\" class=\"headerlink\" title=\"美化相关\"></a>美化相关</h2><p>VSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme\" target=\"_blank\" rel=\"external\">One Dark Pro</a>，一款仿照 Atom 的 One Dark 主题</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme\" target=\"_blank\" rel=\"external\">Material Theme</a>，Google Material Design 风格的主题，有多种颜色可以选择</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p>这里只推荐一个，个人最喜欢的一套图标 <a href=\"https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme\" target=\"_blank\" rel=\"external\">Material Icon Theme</a>，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。</p>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>VSCode 同时支持自定义字体，个人的字体设置为 <code>&#39;Consolas&#39;, &#39;思源黑体 Regular&#39;, monospace</code>，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"HTML-文件预览\"><a href=\"#HTML-文件预览\" class=\"headerlink\" title=\"HTML 文件预览\"></a>HTML 文件预览</h3><p>写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 <a href=\"https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser\" target=\"_blank\" rel=\"external\">View In Browser</a>，通过快捷键 <code>Ctrl+F1</code> 即可在默认的浏览器中预览 HTML 文档了。</p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github\" target=\"_blank\" rel=\"external\">GitHub</a> 插件支持 GitHub pull/push 等源代码相关操作。</p>\n<h3 id=\"代码运行\"><a href=\"#代码运行\" class=\"headerlink\" title=\"代码运行\"></a>代码运行</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\" target=\"_blank\" rel=\"external\">Code Runner</a> 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。</p>\n<h3 id=\"语言环境\"><a href=\"#语言环境\" class=\"headerlink\" title=\"语言环境\"></a>语言环境</h3><p>新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如<a href=\"https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans\" target=\"_blank\" rel=\"external\">简体中文</a>，安装完成后重新加载即可使用中文界面。其他语言同理。</p>\n<h3 id=\"同步设置\"><a href=\"#同步设置\" class=\"headerlink\" title=\"同步设置\"></a>同步设置</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\" target=\"_blank\" rel=\"external\">Settings Sync</a> 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 <a href=\"https://gist.github.com/\" target=\"_blank\" rel=\"external\">GitHub Gist</a> 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。</p>\n<p>以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。</p>\n","excerpt":"<p><img src=\"/images/imagesource/19-01-08.png\" alt=\"vscode\"><br>诈尸更新~~🤣🤣🤣<br>这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。<br>","more":"</p>\n<p>VSCode 下载地址：<a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></p>\n<h2 id=\"语言相关\"><a href=\"#语言相关\" class=\"headerlink\" title=\"语言相关\"></a>语言相关</h2><h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><p>推荐微软官方推出的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">C/C++</a>插件，支持智能提示和debug，很方便。</p>\n<p>如何在 VSCode 上配置 C/C++ 环境可以参考知乎<a href=\"https://www.zhihu.com/question/30315894/answer/154979413\">Visual Studio Code如何编写运行C、C++？</a> 这个问题下的高赞回答。</p>\n<p>通过 <a href=\"https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader\">vscode-fileheader</a> 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>同样推荐微软官方的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-python.python\">Python</a> 插件。本来是民间大神写的，后来被微软收编了。只要安装好 <a href=\"https://www.python.org/downloads/\">Python</a> 环境，然后再装这个插件，写起 Python 代码来美滋滋！</p>\n<p>同时再推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode\">Visual Studio IntelliCode</a> 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。</p>\n<h2 id=\"文章书写\"><a href=\"#文章书写\" class=\"headerlink\" title=\"文章书写\"></a>文章书写</h2><h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><p>VSCode 对 Markdown 也有很好的支持。推荐如下几个插件：</p>\n<ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\">Markdown All in One</a>，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced\">Markdown Preview Enhanced</a>，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。</li>\n</ol>\n<h3 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"LaTeX\"></a>LaTeX</h3><p>VSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 <a href=\"https://www.tug.org/texlive/\">TeX Live</a> 作为 TeX 环境。有了 TeX 环境后，再安装 <a href=\"https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop\">LaTeX Workshop</a> 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。</p>\n<p>同时推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\">Code Spell Checker</a>，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。</p>\n<h2 id=\"美化相关\"><a href=\"#美化相关\" class=\"headerlink\" title=\"美化相关\"></a>美化相关</h2><p>VSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme\">One Dark Pro</a>，一款仿照 Atom 的 One Dark 主题</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme\">Material Theme</a>，Google Material Design 风格的主题，有多种颜色可以选择</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p>这里只推荐一个，个人最喜欢的一套图标 <a href=\"https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme\">Material Icon Theme</a>，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。</p>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>VSCode 同时支持自定义字体，个人的字体设置为 <code>&#39;Consolas&#39;, &#39;思源黑体 Regular&#39;, monospace</code>，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"HTML-文件预览\"><a href=\"#HTML-文件预览\" class=\"headerlink\" title=\"HTML 文件预览\"></a>HTML 文件预览</h3><p>写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 <a href=\"https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser\">View In Browser</a>，通过快捷键 <code>Ctrl+F1</code> 即可在默认的浏览器中预览 HTML 文档了。</p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github\">GitHub</a> 插件支持 GitHub pull/push 等源代码相关操作。</p>\n<h3 id=\"代码运行\"><a href=\"#代码运行\" class=\"headerlink\" title=\"代码运行\"></a>代码运行</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\">Code Runner</a> 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。</p>\n<h3 id=\"语言环境\"><a href=\"#语言环境\" class=\"headerlink\" title=\"语言环境\"></a>语言环境</h3><p>新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如<a href=\"https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans\">简体中文</a>，安装完成后重新加载即可使用中文界面。其他语言同理。</p>\n<h3 id=\"同步设置\"><a href=\"#同步设置\" class=\"headerlink\" title=\"同步设置\"></a>同步设置</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\">Settings Sync</a> 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 <a href=\"https://gist.github.com/\">GitHub Gist</a> 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。</p>\n<p>以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。</p>"},{"title":"Visual Studio项目中集成Google Test测试框架","date":"2017-11-17T07:22:38.000Z","comments":1,"_content":"\n本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。\n\n<!--more-->\n\n## VS2015下配置Google Test\n\n### 下载Google Test\n\n[Google Test][1]是Google旗下的一个单元测试框架。下载地址在[Release][2]中，在release页面下，有它的历史版本，我们下载最新的即可。\n\n解压下载的文件，可以看到两个文件夹，这里我们要用的是**googletest**文件夹下的内容，其他的可以不用管。\n\n![googletest](/images/imagesource/17-11-17/17-11-17-1.png)\n\n解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的**include**和**src**。其中**include**用于配置项目时添加到包含目录中；**src**是Google Test框架的源码。\n\n![src&include](/images/imagesource/17-11-17/17-11-17-2.png)\n\n### 配置Google Test(2018-04-04更新)\n\n感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇[博客][6]。\n\n下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。\n\n#### 新建项目\n\n打开VS2105，**新建项目->Win32控制台应用程序**，我们将项目名称设置为SimpleTest。然后选择**空项目**，完成即可。\n\n![newproject](/images/imagesource/17-11-17/17-11-17-3.png)\n![newproject1](/images/imagesource/17-11-17/17-11-17-4.png)\n\n我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：\n\n```c++\n// simple_math.h\n#pragma once\n#include  <cmath>\n\ndouble square(double num)\n{\n\treturn pow(num, 2);\n}\n\n\n// simple_math.cpp\n#include \"simple_math.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tauto ans = square(10);\n\treturn 0;\n}\n```\n\n我们在`simple_math.h`中定义了一个`square`函数，返回传入的参数的平方值。并在`simple_math.cpp`中调用了该函数。可以按**Ctrl+F5**来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。\n\n#### 配置Google Test\n\n接下来我们右键最上面的**解决方案**，选择**添加->新建项目->Win32项目**，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择**静态库**，取消预编译头，然后点击完成。\n\n![googletestproject](/images/imagesource/17-11-17/17-11-17-6.png)\n\n现在解决方案下面有两个项目，一个是我们之前创建的项目**SimpleTest**，一个是刚刚创建的**GoogleTest**。\n\n![project2](/images/imagesource/17-11-17/17-11-17-7.png)\n\n下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。**右键GoogleTest->属性->配置属性->VC++目录->包含目录**，我们在包含目录中添加Google Test相关文件。我们**googletest文件夹**和googletest目录下的**include**文件夹都添加进去，然后点击确定。\n\n![includefile](/images/imagesource/17-11-17/17-11-17-8.png)\n\n接着再给GoogleTest项目添加源文件。**右键GoogleTest的源文件->添加->现有项**，把之前提到的**src**目录下的**gtest_main.cc**和**gtest-all.cc**添加进去。\n\n![addfile](/images/imagesource/17-11-17/17-11-17-9.png)\n\n现在GoogleTest项目下有两个源文件。\n\n![sourcefiles](/images/imagesource/17-11-17/17-11-17-10.png)\n\n#### 生成静态库\n\n上述配置完成后，我们**右键GoogleTest->生成**，就可以生成GoogleTest的静态库了。\n\n![build](/images/imagesource/17-11-17/17-11-17-11.png)\n\n#### 添加单元测试\n\n下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目**UnittestSimpleTest**，**右键解决方案->添加->新建项目->Win32控制台应用程序**，选择空项目，然后完成即可。\n\n现在我们的解决方案中共有三个项目：**GoogleTest，SimpleTest，UnittestSimpleTest**。\n\n![project3](/images/imagesource/17-11-17/17-11-17-12.png)\n\n同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。\n\n![includepath](/images/imagesource/17-11-17/17-11-17-13.png)\n\n添加完包含目录后，再为其添加引用：**右键UnittestSimpleTest->添加->引用**，将**GoogleTest**和**SimpleTest**全勾上\n\n![references](/images/imagesource/17-11-17/17-11-17-14.png)\n\n单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。\n\n![references1](/images/imagesource/17-11-17/17-11-17-15.png)\n\n#### 新建测试\n\n我们现在可以添加源文件，编写单元测试了。新建一个源文件**test.cpp**，编写代码如下：\n```c++\n// test.cpp\n#include \"simple_math.h\"\n#include \"gtest/gtest.h\"\n\nTEST(testSquare, mySquareTest)\n{\n\tEXPECT_EQ(100, square(10));\n}\n```\n然后我们将UnittestSimpleTest作为启动项目（**右键项目->设为启动项目**），然后运行即可。运行结果如图所示。\n\n![result](/images/imagesource/17-11-17/17-11-17-16.png)\n\n## 将现有的项目作为引用添加到其他项目中\n\n在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。\n\n![errorlnk2019](/images/imagesource/17-11-17/17-11-17-17.png)\n\n百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为**静态库**给新的项目引用，解决方法如下：**右键项目->属性->配置属性->常规**，将目标文件扩展名改为**.lib**，然后在下面的项目默认值中的**配置类型**改为**静态库**。\n\n![buildall](/images/imagesource/17-11-17/17-11-17-18.png)\n\n然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：\n\n![result1](/images/imagesource/17-11-17/17-11-17-19.png)\n\n在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。\n\n## 参考链接\n\n1. [C++ TUTORIAL - GOOGLE TEST (GTEST)][3]\n2. [带你玩转Visual Studio——带你发布自己的工程库][4]\n3. [带你玩转Visual Studio——带你多工程开发][5]\n4. [GTEST基础学习][6]\n\n  [1]: https://github.com/google/googletest \"Google Test\"\n  [2]: https://github.com/google/googletest/releases \"Google Test Release\"\n  [3]: http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php \"GTEST\"\n  [4]: http://blog.csdn.net/luoweifu/article/details/48895765 \"发布自己的程序库\"\n  [5]: http://blog.csdn.net/luoweifu/article/details/48915347 \"多工程开发\"\n  [6]: https://blog.csdn.net/lywzgzl/article/details/52203558 \"GTEST基础学习\"\n","source":"_posts/Visual-Studio项目中集成Google-Test测试框架.md","raw":"---\ntitle: Visual Studio项目中集成Google Test测试框架\ndate: 2017-11-17 15:22:38\ncategory: CPP\ntags: [C++, IDE]\ncomments: true\n---\n\n本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。\n\n<!--more-->\n\n## VS2015下配置Google Test\n\n### 下载Google Test\n\n[Google Test][1]是Google旗下的一个单元测试框架。下载地址在[Release][2]中，在release页面下，有它的历史版本，我们下载最新的即可。\n\n解压下载的文件，可以看到两个文件夹，这里我们要用的是**googletest**文件夹下的内容，其他的可以不用管。\n\n![googletest](/images/imagesource/17-11-17/17-11-17-1.png)\n\n解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的**include**和**src**。其中**include**用于配置项目时添加到包含目录中；**src**是Google Test框架的源码。\n\n![src&include](/images/imagesource/17-11-17/17-11-17-2.png)\n\n### 配置Google Test(2018-04-04更新)\n\n感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇[博客][6]。\n\n下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。\n\n#### 新建项目\n\n打开VS2105，**新建项目->Win32控制台应用程序**，我们将项目名称设置为SimpleTest。然后选择**空项目**，完成即可。\n\n![newproject](/images/imagesource/17-11-17/17-11-17-3.png)\n![newproject1](/images/imagesource/17-11-17/17-11-17-4.png)\n\n我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：\n\n```c++\n// simple_math.h\n#pragma once\n#include  <cmath>\n\ndouble square(double num)\n{\n\treturn pow(num, 2);\n}\n\n\n// simple_math.cpp\n#include \"simple_math.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tauto ans = square(10);\n\treturn 0;\n}\n```\n\n我们在`simple_math.h`中定义了一个`square`函数，返回传入的参数的平方值。并在`simple_math.cpp`中调用了该函数。可以按**Ctrl+F5**来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。\n\n#### 配置Google Test\n\n接下来我们右键最上面的**解决方案**，选择**添加->新建项目->Win32项目**，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择**静态库**，取消预编译头，然后点击完成。\n\n![googletestproject](/images/imagesource/17-11-17/17-11-17-6.png)\n\n现在解决方案下面有两个项目，一个是我们之前创建的项目**SimpleTest**，一个是刚刚创建的**GoogleTest**。\n\n![project2](/images/imagesource/17-11-17/17-11-17-7.png)\n\n下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。**右键GoogleTest->属性->配置属性->VC++目录->包含目录**，我们在包含目录中添加Google Test相关文件。我们**googletest文件夹**和googletest目录下的**include**文件夹都添加进去，然后点击确定。\n\n![includefile](/images/imagesource/17-11-17/17-11-17-8.png)\n\n接着再给GoogleTest项目添加源文件。**右键GoogleTest的源文件->添加->现有项**，把之前提到的**src**目录下的**gtest_main.cc**和**gtest-all.cc**添加进去。\n\n![addfile](/images/imagesource/17-11-17/17-11-17-9.png)\n\n现在GoogleTest项目下有两个源文件。\n\n![sourcefiles](/images/imagesource/17-11-17/17-11-17-10.png)\n\n#### 生成静态库\n\n上述配置完成后，我们**右键GoogleTest->生成**，就可以生成GoogleTest的静态库了。\n\n![build](/images/imagesource/17-11-17/17-11-17-11.png)\n\n#### 添加单元测试\n\n下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目**UnittestSimpleTest**，**右键解决方案->添加->新建项目->Win32控制台应用程序**，选择空项目，然后完成即可。\n\n现在我们的解决方案中共有三个项目：**GoogleTest，SimpleTest，UnittestSimpleTest**。\n\n![project3](/images/imagesource/17-11-17/17-11-17-12.png)\n\n同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。\n\n![includepath](/images/imagesource/17-11-17/17-11-17-13.png)\n\n添加完包含目录后，再为其添加引用：**右键UnittestSimpleTest->添加->引用**，将**GoogleTest**和**SimpleTest**全勾上\n\n![references](/images/imagesource/17-11-17/17-11-17-14.png)\n\n单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。\n\n![references1](/images/imagesource/17-11-17/17-11-17-15.png)\n\n#### 新建测试\n\n我们现在可以添加源文件，编写单元测试了。新建一个源文件**test.cpp**，编写代码如下：\n```c++\n// test.cpp\n#include \"simple_math.h\"\n#include \"gtest/gtest.h\"\n\nTEST(testSquare, mySquareTest)\n{\n\tEXPECT_EQ(100, square(10));\n}\n```\n然后我们将UnittestSimpleTest作为启动项目（**右键项目->设为启动项目**），然后运行即可。运行结果如图所示。\n\n![result](/images/imagesource/17-11-17/17-11-17-16.png)\n\n## 将现有的项目作为引用添加到其他项目中\n\n在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。\n\n![errorlnk2019](/images/imagesource/17-11-17/17-11-17-17.png)\n\n百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为**静态库**给新的项目引用，解决方法如下：**右键项目->属性->配置属性->常规**，将目标文件扩展名改为**.lib**，然后在下面的项目默认值中的**配置类型**改为**静态库**。\n\n![buildall](/images/imagesource/17-11-17/17-11-17-18.png)\n\n然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：\n\n![result1](/images/imagesource/17-11-17/17-11-17-19.png)\n\n在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。\n\n## 参考链接\n\n1. [C++ TUTORIAL - GOOGLE TEST (GTEST)][3]\n2. [带你玩转Visual Studio——带你发布自己的工程库][4]\n3. [带你玩转Visual Studio——带你多工程开发][5]\n4. [GTEST基础学习][6]\n\n  [1]: https://github.com/google/googletest \"Google Test\"\n  [2]: https://github.com/google/googletest/releases \"Google Test Release\"\n  [3]: http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php \"GTEST\"\n  [4]: http://blog.csdn.net/luoweifu/article/details/48895765 \"发布自己的程序库\"\n  [5]: http://blog.csdn.net/luoweifu/article/details/48915347 \"多工程开发\"\n  [6]: https://blog.csdn.net/lywzgzl/article/details/52203558 \"GTEST基础学习\"\n","slug":"Visual-Studio项目中集成Google-Test测试框架","published":1,"updated":"2019-01-07T13:44:48.079Z","layout":"post","photos":[],"link":"","_id":"cjqojmlwq000yswqcn023vi47","content":"<p>本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"VS2015下配置Google-Test\"><a href=\"#VS2015下配置Google-Test\" class=\"headerlink\" title=\"VS2015下配置Google Test\"></a>VS2015下配置Google Test</h2><h3 id=\"下载Google-Test\"><a href=\"#下载Google-Test\" class=\"headerlink\" title=\"下载Google Test\"></a>下载Google Test</h3><p><a href=\"https://github.com/google/googletest\" title=\"Google Test\" target=\"_blank\" rel=\"external\">Google Test</a>是Google旗下的一个单元测试框架。下载地址在<a href=\"https://github.com/google/googletest/releases\" title=\"Google Test Release\" target=\"_blank\" rel=\"external\">Release</a>中，在release页面下，有它的历史版本，我们下载最新的即可。</p>\n<p>解压下载的文件，可以看到两个文件夹，这里我们要用的是<strong>googletest</strong>文件夹下的内容，其他的可以不用管。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-1.png\" alt=\"googletest\"></p>\n<p>解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的<strong>include</strong>和<strong>src</strong>。其中<strong>include</strong>用于配置项目时添加到包含目录中；<strong>src</strong>是Google Test框架的源码。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-2.png\" alt=\"src&amp;include\"></p>\n<h3 id=\"配置Google-Test-2018-04-04更新\"><a href=\"#配置Google-Test-2018-04-04更新\" class=\"headerlink\" title=\"配置Google Test(2018-04-04更新)\"></a>配置Google Test(2018-04-04更新)</h3><p>感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇<a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\" target=\"_blank\" rel=\"external\">博客</a>。</p>\n<p>下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。</p>\n<h4 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h4><p>打开VS2105，<strong>新建项目-&gt;Win32控制台应用程序</strong>，我们将项目名称设置为SimpleTest。然后选择<strong>空项目</strong>，完成即可。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-3.png\" alt=\"newproject\"><br><img src=\"/images/imagesource/17-11-17/17-11-17-4.png\" alt=\"newproject1\"></p>\n<p>我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// simple_math.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(num, <span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// simple_math.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"simple_math.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">auto</span> ans = square(<span class=\"number\">10</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在<code>simple_math.h</code>中定义了一个<code>square</code>函数，返回传入的参数的平方值。并在<code>simple_math.cpp</code>中调用了该函数。可以按<strong>Ctrl+F5</strong>来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。</p>\n<h4 id=\"配置Google-Test\"><a href=\"#配置Google-Test\" class=\"headerlink\" title=\"配置Google Test\"></a>配置Google Test</h4><p>接下来我们右键最上面的<strong>解决方案</strong>，选择<strong>添加-&gt;新建项目-&gt;Win32项目</strong>，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择<strong>静态库</strong>，取消预编译头，然后点击完成。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-6.png\" alt=\"googletestproject\"></p>\n<p>现在解决方案下面有两个项目，一个是我们之前创建的项目<strong>SimpleTest</strong>，一个是刚刚创建的<strong>GoogleTest</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-7.png\" alt=\"project2\"></p>\n<p>下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。<strong>右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</strong>，我们在包含目录中添加Google Test相关文件。我们<strong>googletest文件夹</strong>和googletest目录下的<strong>include</strong>文件夹都添加进去，然后点击确定。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-8.png\" alt=\"includefile\"></p>\n<p>接着再给GoogleTest项目添加源文件。<strong>右键GoogleTest的源文件-&gt;添加-&gt;现有项</strong>，把之前提到的<strong>src</strong>目录下的<strong>gtest_main.cc</strong>和<strong>gtest-all.cc</strong>添加进去。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-9.png\" alt=\"addfile\"></p>\n<p>现在GoogleTest项目下有两个源文件。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-10.png\" alt=\"sourcefiles\"></p>\n<h4 id=\"生成静态库\"><a href=\"#生成静态库\" class=\"headerlink\" title=\"生成静态库\"></a>生成静态库</h4><p>上述配置完成后，我们<strong>右键GoogleTest-&gt;生成</strong>，就可以生成GoogleTest的静态库了。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-11.png\" alt=\"build\"></p>\n<h4 id=\"添加单元测试\"><a href=\"#添加单元测试\" class=\"headerlink\" title=\"添加单元测试\"></a>添加单元测试</h4><p>下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目<strong>UnittestSimpleTest</strong>，<strong>右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序</strong>，选择空项目，然后完成即可。</p>\n<p>现在我们的解决方案中共有三个项目：<strong>GoogleTest，SimpleTest，UnittestSimpleTest</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-12.png\" alt=\"project3\"></p>\n<p>同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-13.png\" alt=\"includepath\"></p>\n<p>添加完包含目录后，再为其添加引用：<strong>右键UnittestSimpleTest-&gt;添加-&gt;引用</strong>，将<strong>GoogleTest</strong>和<strong>SimpleTest</strong>全勾上</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-14.png\" alt=\"references\"></p>\n<p>单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-15.png\" alt=\"references1\"></p>\n<h4 id=\"新建测试\"><a href=\"#新建测试\" class=\"headerlink\" title=\"新建测试\"></a>新建测试</h4><p>我们现在可以添加源文件，编写单元测试了。新建一个源文件<strong>test.cpp</strong>，编写代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// test.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"simple_math.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"gtest/gtest.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">TEST(testSquare, mySquareTest)</div><div class=\"line\">&#123;</div><div class=\"line\">\tEXPECT_EQ(<span class=\"number\">100</span>, square(<span class=\"number\">10</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们将UnittestSimpleTest作为启动项目（<strong>右键项目-&gt;设为启动项目</strong>），然后运行即可。运行结果如图所示。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-16.png\" alt=\"result\"></p>\n<h2 id=\"将现有的项目作为引用添加到其他项目中\"><a href=\"#将现有的项目作为引用添加到其他项目中\" class=\"headerlink\" title=\"将现有的项目作为引用添加到其他项目中\"></a>将现有的项目作为引用添加到其他项目中</h2><p>在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-17.png\" alt=\"errorlnk2019\"></p>\n<p>百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为<strong>静态库</strong>给新的项目引用，解决方法如下：<strong>右键项目-&gt;属性-&gt;配置属性-&gt;常规</strong>，将目标文件扩展名改为<strong>.lib</strong>，然后在下面的项目默认值中的<strong>配置类型</strong>改为<strong>静态库</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-18.png\" alt=\"buildall\"></p>\n<p>然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-19.png\" alt=\"result1\"></p>\n<p>在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php\" title=\"GTEST\" target=\"_blank\" rel=\"external\">C++ TUTORIAL - GOOGLE TEST (GTEST)</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48895765\" title=\"发布自己的程序库\" target=\"_blank\" rel=\"external\">带你玩转Visual Studio——带你发布自己的工程库</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48915347\" title=\"多工程开发\" target=\"_blank\" rel=\"external\">带你玩转Visual Studio——带你多工程开发</a></li>\n<li><a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\" target=\"_blank\" rel=\"external\">GTEST基础学习</a></li>\n</ol>\n","excerpt":"<p>本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。</p>","more":"<h2 id=\"VS2015下配置Google-Test\"><a href=\"#VS2015下配置Google-Test\" class=\"headerlink\" title=\"VS2015下配置Google Test\"></a>VS2015下配置Google Test</h2><h3 id=\"下载Google-Test\"><a href=\"#下载Google-Test\" class=\"headerlink\" title=\"下载Google Test\"></a>下载Google Test</h3><p><a href=\"https://github.com/google/googletest\" title=\"Google Test\">Google Test</a>是Google旗下的一个单元测试框架。下载地址在<a href=\"https://github.com/google/googletest/releases\" title=\"Google Test Release\">Release</a>中，在release页面下，有它的历史版本，我们下载最新的即可。</p>\n<p>解压下载的文件，可以看到两个文件夹，这里我们要用的是<strong>googletest</strong>文件夹下的内容，其他的可以不用管。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-1.png\" alt=\"googletest\"></p>\n<p>解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的<strong>include</strong>和<strong>src</strong>。其中<strong>include</strong>用于配置项目时添加到包含目录中；<strong>src</strong>是Google Test框架的源码。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-2.png\" alt=\"src&amp;include\"></p>\n<h3 id=\"配置Google-Test-2018-04-04更新\"><a href=\"#配置Google-Test-2018-04-04更新\" class=\"headerlink\" title=\"配置Google Test(2018-04-04更新)\"></a>配置Google Test(2018-04-04更新)</h3><p>感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇<a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">博客</a>。</p>\n<p>下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。</p>\n<h4 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h4><p>打开VS2105，<strong>新建项目-&gt;Win32控制台应用程序</strong>，我们将项目名称设置为SimpleTest。然后选择<strong>空项目</strong>，完成即可。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-3.png\" alt=\"newproject\"><br><img src=\"/images/imagesource/17-11-17/17-11-17-4.png\" alt=\"newproject1\"></p>\n<p>我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// simple_math.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(num, <span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// simple_math.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"simple_math.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">auto</span> ans = square(<span class=\"number\">10</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在<code>simple_math.h</code>中定义了一个<code>square</code>函数，返回传入的参数的平方值。并在<code>simple_math.cpp</code>中调用了该函数。可以按<strong>Ctrl+F5</strong>来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。</p>\n<h4 id=\"配置Google-Test\"><a href=\"#配置Google-Test\" class=\"headerlink\" title=\"配置Google Test\"></a>配置Google Test</h4><p>接下来我们右键最上面的<strong>解决方案</strong>，选择<strong>添加-&gt;新建项目-&gt;Win32项目</strong>，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择<strong>静态库</strong>，取消预编译头，然后点击完成。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-6.png\" alt=\"googletestproject\"></p>\n<p>现在解决方案下面有两个项目，一个是我们之前创建的项目<strong>SimpleTest</strong>，一个是刚刚创建的<strong>GoogleTest</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-7.png\" alt=\"project2\"></p>\n<p>下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。<strong>右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</strong>，我们在包含目录中添加Google Test相关文件。我们<strong>googletest文件夹</strong>和googletest目录下的<strong>include</strong>文件夹都添加进去，然后点击确定。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-8.png\" alt=\"includefile\"></p>\n<p>接着再给GoogleTest项目添加源文件。<strong>右键GoogleTest的源文件-&gt;添加-&gt;现有项</strong>，把之前提到的<strong>src</strong>目录下的<strong>gtest_main.cc</strong>和<strong>gtest-all.cc</strong>添加进去。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-9.png\" alt=\"addfile\"></p>\n<p>现在GoogleTest项目下有两个源文件。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-10.png\" alt=\"sourcefiles\"></p>\n<h4 id=\"生成静态库\"><a href=\"#生成静态库\" class=\"headerlink\" title=\"生成静态库\"></a>生成静态库</h4><p>上述配置完成后，我们<strong>右键GoogleTest-&gt;生成</strong>，就可以生成GoogleTest的静态库了。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-11.png\" alt=\"build\"></p>\n<h4 id=\"添加单元测试\"><a href=\"#添加单元测试\" class=\"headerlink\" title=\"添加单元测试\"></a>添加单元测试</h4><p>下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目<strong>UnittestSimpleTest</strong>，<strong>右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序</strong>，选择空项目，然后完成即可。</p>\n<p>现在我们的解决方案中共有三个项目：<strong>GoogleTest，SimpleTest，UnittestSimpleTest</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-12.png\" alt=\"project3\"></p>\n<p>同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-13.png\" alt=\"includepath\"></p>\n<p>添加完包含目录后，再为其添加引用：<strong>右键UnittestSimpleTest-&gt;添加-&gt;引用</strong>，将<strong>GoogleTest</strong>和<strong>SimpleTest</strong>全勾上</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-14.png\" alt=\"references\"></p>\n<p>单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-15.png\" alt=\"references1\"></p>\n<h4 id=\"新建测试\"><a href=\"#新建测试\" class=\"headerlink\" title=\"新建测试\"></a>新建测试</h4><p>我们现在可以添加源文件，编写单元测试了。新建一个源文件<strong>test.cpp</strong>，编写代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// test.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"simple_math.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"gtest/gtest.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">TEST(testSquare, mySquareTest)</div><div class=\"line\">&#123;</div><div class=\"line\">\tEXPECT_EQ(<span class=\"number\">100</span>, square(<span class=\"number\">10</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们将UnittestSimpleTest作为启动项目（<strong>右键项目-&gt;设为启动项目</strong>），然后运行即可。运行结果如图所示。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-16.png\" alt=\"result\"></p>\n<h2 id=\"将现有的项目作为引用添加到其他项目中\"><a href=\"#将现有的项目作为引用添加到其他项目中\" class=\"headerlink\" title=\"将现有的项目作为引用添加到其他项目中\"></a>将现有的项目作为引用添加到其他项目中</h2><p>在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-17.png\" alt=\"errorlnk2019\"></p>\n<p>百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为<strong>静态库</strong>给新的项目引用，解决方法如下：<strong>右键项目-&gt;属性-&gt;配置属性-&gt;常规</strong>，将目标文件扩展名改为<strong>.lib</strong>，然后在下面的项目默认值中的<strong>配置类型</strong>改为<strong>静态库</strong>。</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-18.png\" alt=\"buildall\"></p>\n<p>然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：</p>\n<p><img src=\"/images/imagesource/17-11-17/17-11-17-19.png\" alt=\"result1\"></p>\n<p>在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php\" title=\"GTEST\">C++ TUTORIAL - GOOGLE TEST (GTEST)</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48895765\" title=\"发布自己的程序库\">带你玩转Visual Studio——带你发布自己的工程库</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48915347\" title=\"多工程开发\">带你玩转Visual Studio——带你多工程开发</a></li>\n<li><a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">GTEST基础学习</a></li>\n</ol>"},{"title":"Hello World","comments":1,"_content":"![background](/images/background.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategory: helloworld\ntag: helloworld\ncomments: true\n---\n![background](/images/background.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-03-21T13:41:15.653Z","updated":"2017-03-24T10:18:57.240Z","layout":"post","photos":[],"link":"","_id":"cjqojmlwq0010swqctvb2l9uz","content":"<p><img src=\"/images/background.jpg\" alt=\"background\"><br>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p><img src=\"/images/background.jpg\" alt=\"background\"><br>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"【每周一坑】杨辉三角形","date":"2017-05-19T06:28:26.000Z","comments":1,"_content":"\n## 问题描述\n\n**本周题目**\n> 杨辉三角形，也称帕斯卡三角，其定义为：\n顶端是1，视为(row0).\n第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).\n以此类推\n第2行(row2)：0+1=1; 1+1=2; 1+0=1.\n第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.\n\n<!--more-->\n\n根据上述方法可产生杨辉三角。如下所示：\n\n```ptyhon\nn = 0              1                     \nn = 1            1   1                   \nn = 2          1   2   1                 \nn = 3        1   3   3   1               \nn = 4      1   4   6   4   1             \nn = 5    1   5   10  10  5   1           \nn = ...         ...  ...                             \n```\n\n根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 `Invalid query`。\n\n示例代码：\n```python\ndef yang_hui(m, n):\n    '''\n    >>>yang_hui(1, 1)\n    1\n    >>>yang_hui(3,2)\n    3\n    >>>yang_hui(1,4)\n    Invalid query\n    '''\n```\n\n**附加题**\n生成杨辉三角形\n定义一个函数，传入M<1000,生成前M行杨辉三角形。\n示例代码：\n\n```python\ndef generate_yh(m):\n    '''\n    generate_yh(3):\n    1\n    1 1\n    1 2 1\n    '''\n```\n\n\n## 思路\n根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：`N > M`时，返回的应该是 `Invalidquery`。还有 `n=0` 或 `n=m`     时，返回的值应该为1.\n要求第(M,N)个数字，可以用递归的方式来求得：\n```python\nyang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n## Python实现\n**yang_hui(m,n):**\n```python\n# 输出杨辉三角中第m行第n列的数值\ndef yang_hui(m, n):\n    if n and n > m:\n        return  \"Invalid query!\"\n    if n == 0 or n == m:\n        return  1\n    return yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n**triangles(m):**\n```python\n打印输出杨辉三角\ndef triangles(m):\n    ret = [1]\n    while m:\n        yield ret\n        for i in range(1,len(ret)):\n            ret[i] = pre[i] + pre[i-1]\n        ret.append(1)\n        pre = ret[:]\n        m = m - 1\n```\n\n在生成杨辉三角的时候，用到了**生成器(generator)**。generator在执行过程中，遇到`yield`语句就返回，再次执行时从上次返回的`yield`语句处继续执行。\n**普通函数和generator函数的区别：**\n普通函数调用直接返回结果：\n```python\n>>> r = abs(6)\n>>> r\n6\n```\ngenerator函数的“调用”实际返回一个generator对象：\n```python\n>>> g = fib(6)\n>>> g\n<generator object fib at 0x1022ef498>\n```\n关于generator，可以参考[这里](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0)。\n\n\n**测试**\n```python\n# 测试\nif __name__ == '__main__':\n    print(yang_hui(0, 0))\n    print(yang_hui(1, 1))\n    print(yang_hui(1, 2))\n    print(yang_hui(6, 3))\n    print(yang_hui(4, 9))\n    \n    # 打印杨辉三角\n    triangle = triangles(10)\n    for i in triangle:\n        print(i)\n```\n\n## 输出结果\n输出结果如下：\n> 1\n1\nInvalid query\n20\nInvalid query\n[1]\n[1, 1]\n[1, 2, 1]\n[1, 3, 3, 1]\n[1, 4, 6, 4, 1]\n[1, 5, 10, 10, 5, 1]\n[1, 6, 15, 20, 15, 6, 1]\n[1, 7, 21, 35, 35, 21, 7, 1]\n[1, 8, 28, 56, 70, 56, 28, 8, 1]\n[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n\nEnd~\n\n---","source":"_posts/【每周一坑】杨辉三角形.md","raw":"---\ntitle: 【每周一坑】杨辉三角形\ndate: 2017-05-19 14:28:26\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n## 问题描述\n\n**本周题目**\n> 杨辉三角形，也称帕斯卡三角，其定义为：\n顶端是1，视为(row0).\n第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).\n以此类推\n第2行(row2)：0+1=1; 1+1=2; 1+0=1.\n第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.\n\n<!--more-->\n\n根据上述方法可产生杨辉三角。如下所示：\n\n```ptyhon\nn = 0              1                     \nn = 1            1   1                   \nn = 2          1   2   1                 \nn = 3        1   3   3   1               \nn = 4      1   4   6   4   1             \nn = 5    1   5   10  10  5   1           \nn = ...         ...  ...                             \n```\n\n根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 `Invalid query`。\n\n示例代码：\n```python\ndef yang_hui(m, n):\n    '''\n    >>>yang_hui(1, 1)\n    1\n    >>>yang_hui(3,2)\n    3\n    >>>yang_hui(1,4)\n    Invalid query\n    '''\n```\n\n**附加题**\n生成杨辉三角形\n定义一个函数，传入M<1000,生成前M行杨辉三角形。\n示例代码：\n\n```python\ndef generate_yh(m):\n    '''\n    generate_yh(3):\n    1\n    1 1\n    1 2 1\n    '''\n```\n\n\n## 思路\n根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：`N > M`时，返回的应该是 `Invalidquery`。还有 `n=0` 或 `n=m`     时，返回的值应该为1.\n要求第(M,N)个数字，可以用递归的方式来求得：\n```python\nyang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n## Python实现\n**yang_hui(m,n):**\n```python\n# 输出杨辉三角中第m行第n列的数值\ndef yang_hui(m, n):\n    if n and n > m:\n        return  \"Invalid query!\"\n    if n == 0 or n == m:\n        return  1\n    return yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n**triangles(m):**\n```python\n打印输出杨辉三角\ndef triangles(m):\n    ret = [1]\n    while m:\n        yield ret\n        for i in range(1,len(ret)):\n            ret[i] = pre[i] + pre[i-1]\n        ret.append(1)\n        pre = ret[:]\n        m = m - 1\n```\n\n在生成杨辉三角的时候，用到了**生成器(generator)**。generator在执行过程中，遇到`yield`语句就返回，再次执行时从上次返回的`yield`语句处继续执行。\n**普通函数和generator函数的区别：**\n普通函数调用直接返回结果：\n```python\n>>> r = abs(6)\n>>> r\n6\n```\ngenerator函数的“调用”实际返回一个generator对象：\n```python\n>>> g = fib(6)\n>>> g\n<generator object fib at 0x1022ef498>\n```\n关于generator，可以参考[这里](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0)。\n\n\n**测试**\n```python\n# 测试\nif __name__ == '__main__':\n    print(yang_hui(0, 0))\n    print(yang_hui(1, 1))\n    print(yang_hui(1, 2))\n    print(yang_hui(6, 3))\n    print(yang_hui(4, 9))\n    \n    # 打印杨辉三角\n    triangle = triangles(10)\n    for i in triangle:\n        print(i)\n```\n\n## 输出结果\n输出结果如下：\n> 1\n1\nInvalid query\n20\nInvalid query\n[1]\n[1, 1]\n[1, 2, 1]\n[1, 3, 3, 1]\n[1, 4, 6, 4, 1]\n[1, 5, 10, 10, 5, 1]\n[1, 6, 15, 20, 15, 6, 1]\n[1, 7, 21, 35, 35, 21, 7, 1]\n[1, 8, 28, 56, 70, 56, 28, 8, 1]\n[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n\nEnd~\n\n---","slug":"【每周一坑】杨辉三角形","published":1,"updated":"2017-05-28T01:46:45.628Z","layout":"post","photos":[],"link":"","_id":"cjqojmlwq0014swqc5a558ede","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>杨辉三角形，也称帕斯卡三角，其定义为：<br>顶端是1，视为(row0).<br>第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).<br>以此类推<br>第2行(row2)：0+1=1; 1+1=2; 1+0=1.<br>第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>根据上述方法可产生杨辉三角。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">n = 0              1                     </div><div class=\"line\">n = 1            1   1                   </div><div class=\"line\">n = 2          1   2   1                 </div><div class=\"line\">n = 3        1   3   3   1               </div><div class=\"line\">n = 4      1   4   6   4   1             </div><div class=\"line\">n = 5    1   5   10  10  5   1           </div><div class=\"line\">n = ...         ...  ...</div></pre></td></tr></table></figure>\n<p>根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 <code>Invalid query</code>。</p>\n<p>示例代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span><span class=\"params\">(m, n)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</span></div><div class=\"line\">    &gt;&gt;&gt;yang_hui(1, 1)</div><div class=\"line\">    1</div><div class=\"line\">    &gt;&gt;&gt;yang_hui(3,2)</div><div class=\"line\">    3</div><div class=\"line\">    &gt;&gt;&gt;yang_hui(1,4)</div><div class=\"line\">    Invalid query</div><div class=\"line\">    '''</div></pre></td></tr></table></figure></p>\n<p><strong>附加题</strong><br>生成杨辉三角形<br>定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。<br>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_yh</span><span class=\"params\">(m)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</span></div><div class=\"line\">    generate_yh(3):</div><div class=\"line\">    1</div><div class=\"line\">    1 1</div><div class=\"line\">    1 2 1</div><div class=\"line\">    '''</div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：<code>N &gt; M</code>时，返回的应该是 <code>Invalidquery</code>。还有 <code>n=0</code> 或 <code>n=m</code>     时，返回的值应该为1.<br>要求第(M,N)个数字，可以用递归的方式来求得：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yang_hui(m, n) = yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</div></pre></td></tr></table></figure></p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><p><strong>yang_hui(m,n):</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 输出杨辉三角中第m行第n列的数值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span><span class=\"params\">(m, n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n <span class=\"keyword\">and</span> n &gt; m:</div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"string\">\"Invalid query!\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> <span class=\"keyword\">or</span> n == m:</div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</div></pre></td></tr></table></figure></p>\n<p><strong>triangles(m):</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">打印输出杨辉三角</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">triangles</span><span class=\"params\">(m)</span>:</span></div><div class=\"line\">    ret = [<span class=\"number\">1</span>]</div><div class=\"line\">    <span class=\"keyword\">while</span> m:</div><div class=\"line\">        <span class=\"keyword\">yield</span> ret</div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(ret)):</div><div class=\"line\">            ret[i] = pre[i] + pre[i<span class=\"number\">-1</span>]</div><div class=\"line\">        ret.append(<span class=\"number\">1</span>)</div><div class=\"line\">        pre = ret[:]</div><div class=\"line\">        m = m - <span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<p>在生成杨辉三角的时候，用到了<strong>生成器(generator)</strong>。generator在执行过程中，遇到<code>yield</code>语句就返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br><strong>普通函数和generator函数的区别：</strong><br>普通函数调用直接返回结果：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = abs(<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r</div><div class=\"line\"><span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>generator函数的“调用”实际返回一个generator对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = fib(<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g</div><div class=\"line\">&lt;generator object fib at <span class=\"number\">0x1022ef498</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>关于generator，可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p><strong>测试</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(yang_hui(<span class=\"number\">0</span>, <span class=\"number\">0</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">1</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">4</span>, <span class=\"number\">9</span>))</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\"># 打印杨辉三角</span></div><div class=\"line\">    triangle = triangles(<span class=\"number\">10</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> triangle:</div><div class=\"line\">        print(i)</div></pre></td></tr></table></figure></p>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>输出结果如下：</p>\n<blockquote>\n<p>1<br>1<br>Invalid query<br>20<br>Invalid query<br>[1]<br>[1, 1]<br>[1, 2, 1]<br>[1, 3, 3, 1]<br>[1, 4, 6, 4, 1]<br>[1, 5, 10, 10, 5, 1]<br>[1, 6, 15, 20, 15, 6, 1]<br>[1, 7, 21, 35, 35, 21, 7, 1]<br>[1, 8, 28, 56, 70, 56, 28, 8, 1]<br>[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</p>\n</blockquote>\n<p>End~</p>\n<hr>\n","excerpt":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>杨辉三角形，也称帕斯卡三角，其定义为：<br>顶端是1，视为(row0).<br>第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).<br>以此类推<br>第2行(row2)：0+1=1; 1+1=2; 1+0=1.<br>第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.</p>\n</blockquote>","more":"<p>根据上述方法可产生杨辉三角。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">n = 0              1                     </div><div class=\"line\">n = 1            1   1                   </div><div class=\"line\">n = 2          1   2   1                 </div><div class=\"line\">n = 3        1   3   3   1               </div><div class=\"line\">n = 4      1   4   6   4   1             </div><div class=\"line\">n = 5    1   5   10  10  5   1           </div><div class=\"line\">n = ...         ...  ...</div></pre></td></tr></table></figure>\n<p>根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 <code>Invalid query</code>。</p>\n<p>示例代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span><span class=\"params\">(m, n)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</div><div class=\"line\">    &gt;&gt;&gt;yang_hui(1, 1)</div><div class=\"line\">    1</div><div class=\"line\">    &gt;&gt;&gt;yang_hui(3,2)</div><div class=\"line\">    3</div><div class=\"line\">    &gt;&gt;&gt;yang_hui(1,4)</div><div class=\"line\">    Invalid query</div><div class=\"line\">    '''</span></div></pre></td></tr></table></figure></p>\n<p><strong>附加题</strong><br>生成杨辉三角形<br>定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。<br>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_yh</span><span class=\"params\">(m)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</div><div class=\"line\">    generate_yh(3):</div><div class=\"line\">    1</div><div class=\"line\">    1 1</div><div class=\"line\">    1 2 1</div><div class=\"line\">    '''</span></div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：<code>N &gt; M</code>时，返回的应该是 <code>Invalidquery</code>。还有 <code>n=0</code> 或 <code>n=m</code>     时，返回的值应该为1.<br>要求第(M,N)个数字，可以用递归的方式来求得：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yang_hui(m, n) = yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</div></pre></td></tr></table></figure></p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><p><strong>yang_hui(m,n):</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 输出杨辉三角中第m行第n列的数值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span><span class=\"params\">(m, n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n <span class=\"keyword\">and</span> n &gt; m:</div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"string\">\"Invalid query!\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> <span class=\"keyword\">or</span> n == m:</div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</div></pre></td></tr></table></figure></p>\n<p><strong>triangles(m):</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">打印输出杨辉三角</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">triangles</span><span class=\"params\">(m)</span>:</span></div><div class=\"line\">    ret = [<span class=\"number\">1</span>]</div><div class=\"line\">    <span class=\"keyword\">while</span> m:</div><div class=\"line\">        <span class=\"keyword\">yield</span> ret</div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(ret)):</div><div class=\"line\">            ret[i] = pre[i] + pre[i<span class=\"number\">-1</span>]</div><div class=\"line\">        ret.append(<span class=\"number\">1</span>)</div><div class=\"line\">        pre = ret[:]</div><div class=\"line\">        m = m - <span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<p>在生成杨辉三角的时候，用到了<strong>生成器(generator)</strong>。generator在执行过程中，遇到<code>yield</code>语句就返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br><strong>普通函数和generator函数的区别：</strong><br>普通函数调用直接返回结果：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = abs(<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r</div><div class=\"line\"><span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>generator函数的“调用”实际返回一个generator对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = fib(<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g</div><div class=\"line\">&lt;generator object fib at <span class=\"number\">0x1022ef498</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>关于generator，可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0\">这里</a>。</p>\n<p><strong>测试</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(yang_hui(<span class=\"number\">0</span>, <span class=\"number\">0</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">1</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</div><div class=\"line\">    print(yang_hui(<span class=\"number\">4</span>, <span class=\"number\">9</span>))</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\"># 打印杨辉三角</span></div><div class=\"line\">    triangle = triangles(<span class=\"number\">10</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> triangle:</div><div class=\"line\">        print(i)</div></pre></td></tr></table></figure></p>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>输出结果如下：</p>\n<blockquote>\n<p>1<br>1<br>Invalid query<br>20<br>Invalid query<br>[1]<br>[1, 1]<br>[1, 2, 1]<br>[1, 3, 3, 1]<br>[1, 4, 6, 4, 1]<br>[1, 5, 10, 10, 5, 1]<br>[1, 6, 15, 20, 15, 6, 1]<br>[1, 7, 21, 35, 35, 21, 7, 1]<br>[1, 8, 28, 56, 70, 56, 28, 8, 1]<br>[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</p>\n</blockquote>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】校验文件哈希","date":"2017-06-09T11:18:25.000Z","comments":1,"_content":"\n![hash](/images/imagesource/17-06-09.png )\n\n我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。\n早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。\n\n<!--more-->\n\n## 问题\n\n> 请使用Python写一个小程序，用来计算指定文件的哈希值。\n\n**附加题**\n> 可以指定哈希加密算法，并让程序尽可能简单易用。\n\n## 思路\n\n问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库[【每周一坑】程序员的浪漫](https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/),具体用法在之前的文章中也讲过了。\n\n## Python实现\n\n### 计算哈希值的函数\n\n```python\n# 计算哈希值\ndef generate_hash(file):\n    with open(file, 'rb') as f:\n        s = f.read()\n        md5 = hashlib.md5(s).hexdigest()  # 生成MD5\n        sha1 = hashlib.sha1(s).hexdigest()  # 生成SHA1\n        sha256 = hashlib.sha256(s).hexdigest()  # 生成SHA256\n        sha512 = hashlib.sha512(s).hexdigest()  # 生成SHA512\n    return md5, sha1, sha256, sha512\n```\n\n### 可以指定哈希加密算法的函数\n\n```python\n# 计算哈希值\ndef generate_hash_type(file, hash_type):\n     with open(file, 'rb') as f:\n        s = f.read()\n        if hash_type.lower() == 'md5':\n            hash_res = hashlib.md5(s).hexdigest()\n        elif hash_type.lower() == 'sha1':\n            hash_res = hashlib.sha1(s).hexdigest()\n        elif hash_type.lower() == 'sha256':\n            hash_res = hashlib.sha256(s).hexdigest()\n        elif hash_type.lower() == 'sha512':\n            hash_res = hashlib.sha512(s).hexdigest()\n         else:\n            print(\"Hash type error!\")\n            hash_res = \"Type Error\"\n    return hash_type, hash_res\n```\n\n### 测试程序\n\n```python\nif __name__ == '__main__':\n    file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split())\n    md = generate_hash_type(file_path, hash_t)\n    print(md,'\\n')\n    md = generate_hash(file_path)\n    for i in md:\n        print(i)\n```\n\n最后别忘了引入**hashlib**库:\n\n```python\nimport hashlib\n```\n\n还有设置编码格式以防万一\n\n```python\n# -*- coding: utf-8 -*-\n```\n\n## 测试\n\n这里我使用的是[Python官网](https://www.python.org/)下载的*python-3.6.1-amd64.exe*做的测试，官网也给出了它的md5哈希值，方便校验。\n首先是用`generate_hash()`函数，分别生成**md5**,**sha1**,**sha256**和**sha512**的校验码：\n\n```python\n>>> please enter the path of the file:\n>>> 文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe\n```\n\n输出结果为：\n> \n**md5**  \nad69fdacde90f2ce8286c279b11ca188\n**sha1**  \nbf54252c4065b20f4a111cc39cf5215fb1edccff  \n**sha256**  \n591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8\n**sha512**  \nf0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7\nb9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873\n\n然后是输入路径+指定加密算法：\n\n```python\n>>> please enter the path of the file and hash type:\n>>> C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe md5\n```\n\n输出结果为：\n> ('md5', 'ad69fdacde90f2ce8286c279b11ca188')\n\n再来看看官网给出的md5：\n> ad69fdacde90f2ce8286c279b11ca188\n\n和程序计算的结果一致。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】校验文件哈希.md","raw":"---\ntitle: 【每周一坑】校验文件哈希\ndate: 2017-06-09 19:18:25\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![hash](/images/imagesource/17-06-09.png )\n\n我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。\n早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。\n\n<!--more-->\n\n## 问题\n\n> 请使用Python写一个小程序，用来计算指定文件的哈希值。\n\n**附加题**\n> 可以指定哈希加密算法，并让程序尽可能简单易用。\n\n## 思路\n\n问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库[【每周一坑】程序员的浪漫](https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/),具体用法在之前的文章中也讲过了。\n\n## Python实现\n\n### 计算哈希值的函数\n\n```python\n# 计算哈希值\ndef generate_hash(file):\n    with open(file, 'rb') as f:\n        s = f.read()\n        md5 = hashlib.md5(s).hexdigest()  # 生成MD5\n        sha1 = hashlib.sha1(s).hexdigest()  # 生成SHA1\n        sha256 = hashlib.sha256(s).hexdigest()  # 生成SHA256\n        sha512 = hashlib.sha512(s).hexdigest()  # 生成SHA512\n    return md5, sha1, sha256, sha512\n```\n\n### 可以指定哈希加密算法的函数\n\n```python\n# 计算哈希值\ndef generate_hash_type(file, hash_type):\n     with open(file, 'rb') as f:\n        s = f.read()\n        if hash_type.lower() == 'md5':\n            hash_res = hashlib.md5(s).hexdigest()\n        elif hash_type.lower() == 'sha1':\n            hash_res = hashlib.sha1(s).hexdigest()\n        elif hash_type.lower() == 'sha256':\n            hash_res = hashlib.sha256(s).hexdigest()\n        elif hash_type.lower() == 'sha512':\n            hash_res = hashlib.sha512(s).hexdigest()\n         else:\n            print(\"Hash type error!\")\n            hash_res = \"Type Error\"\n    return hash_type, hash_res\n```\n\n### 测试程序\n\n```python\nif __name__ == '__main__':\n    file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split())\n    md = generate_hash_type(file_path, hash_t)\n    print(md,'\\n')\n    md = generate_hash(file_path)\n    for i in md:\n        print(i)\n```\n\n最后别忘了引入**hashlib**库:\n\n```python\nimport hashlib\n```\n\n还有设置编码格式以防万一\n\n```python\n# -*- coding: utf-8 -*-\n```\n\n## 测试\n\n这里我使用的是[Python官网](https://www.python.org/)下载的*python-3.6.1-amd64.exe*做的测试，官网也给出了它的md5哈希值，方便校验。\n首先是用`generate_hash()`函数，分别生成**md5**,**sha1**,**sha256**和**sha512**的校验码：\n\n```python\n>>> please enter the path of the file:\n>>> 文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe\n```\n\n输出结果为：\n> \n**md5**  \nad69fdacde90f2ce8286c279b11ca188\n**sha1**  \nbf54252c4065b20f4a111cc39cf5215fb1edccff  \n**sha256**  \n591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8\n**sha512**  \nf0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7\nb9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873\n\n然后是输入路径+指定加密算法：\n\n```python\n>>> please enter the path of the file and hash type:\n>>> C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe md5\n```\n\n输出结果为：\n> ('md5', 'ad69fdacde90f2ce8286c279b11ca188')\n\n再来看看官网给出的md5：\n> ad69fdacde90f2ce8286c279b11ca188\n\n和程序计算的结果一致。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】校验文件哈希","published":1,"updated":"2017-06-12T08:22:34.226Z","layout":"post","photos":[],"link":"","_id":"cjqojmlx60017swqckxhxigsd","content":"<p><img src=\"/images/imagesource/17-06-09.png\" alt=\"hash\"></p>\n<p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p>\n<a id=\"more\"></a>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>可以指定哈希加密算法，并让程序尽可能简单易用。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href=\"https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/\">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><h3 id=\"计算哈希值的函数\"><a href=\"#计算哈希值的函数\" class=\"headerlink\" title=\"计算哈希值的函数\"></a>计算哈希值的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 计算哈希值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash</span><span class=\"params\">(file)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> open(file, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        s = f.read()</div><div class=\"line\">        md5 = hashlib.md5(s).hexdigest()  <span class=\"comment\"># 生成MD5</span></div><div class=\"line\">        sha1 = hashlib.sha1(s).hexdigest()  <span class=\"comment\"># 生成SHA1</span></div><div class=\"line\">        sha256 = hashlib.sha256(s).hexdigest()  <span class=\"comment\"># 生成SHA256</span></div><div class=\"line\">        sha512 = hashlib.sha512(s).hexdigest()  <span class=\"comment\"># 生成SHA512</span></div><div class=\"line\">    <span class=\"keyword\">return</span> md5, sha1, sha256, sha512</div></pre></td></tr></table></figure>\n<h3 id=\"可以指定哈希加密算法的函数\"><a href=\"#可以指定哈希加密算法的函数\" class=\"headerlink\" title=\"可以指定哈希加密算法的函数\"></a>可以指定哈希加密算法的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 计算哈希值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash_type</span><span class=\"params\">(file, hash_type)</span>:</span></div><div class=\"line\">     <span class=\"keyword\">with</span> open(file, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        s = f.read()</div><div class=\"line\">        <span class=\"keyword\">if</span> hash_type.lower() == <span class=\"string\">'md5'</span>:</div><div class=\"line\">            hash_res = hashlib.md5(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha1'</span>:</div><div class=\"line\">            hash_res = hashlib.sha1(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha256'</span>:</div><div class=\"line\">            hash_res = hashlib.sha256(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha512'</span>:</div><div class=\"line\">            hash_res = hashlib.sha512(s).hexdigest()</div><div class=\"line\">         <span class=\"keyword\">else</span>:</div><div class=\"line\">            print(<span class=\"string\">\"Hash type error!\"</span>)</div><div class=\"line\">            hash_res = <span class=\"string\">\"Type Error\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> hash_type, hash_res</div></pre></td></tr></table></figure>\n<h3 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    file_path, hash_t = map(str, input(<span class=\"string\">'Please enter the path of the file and hash type:'</span>).split())</div><div class=\"line\">    md = generate_hash_type(file_path, hash_t)</div><div class=\"line\">    print(md,<span class=\"string\">'\\n'</span>)</div><div class=\"line\">    md = generate_hash(file_path)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> md:</div><div class=\"line\">        print(i)</div></pre></td></tr></table></figure>\n<p>最后别忘了引入<strong>hashlib</strong>库:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> hashlib</div></pre></td></tr></table></figure>\n<p>还有设置编码格式以防万一</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这里我使用的是<a href=\"https://www.python.org/\" target=\"_blank\" rel=\"external\">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file:</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p>\n</blockquote>\n<p>然后是输入路径+指定加密算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file <span class=\"keyword\">and</span> hash type:</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe md5</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p>\n</blockquote>\n<p>再来看看官网给出的md5：</p>\n<blockquote>\n<p>ad69fdacde90f2ce8286c279b11ca188</p>\n</blockquote>\n<p>和程序计算的结果一致。</p>\n<p>End~</p>\n<hr>\n","excerpt":"<p><img src=\"/images/imagesource/17-06-09.png\" alt=\"hash\"></p>\n<p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>可以指定哈希加密算法，并让程序尽可能简单易用。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href=\"https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/\">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><h3 id=\"计算哈希值的函数\"><a href=\"#计算哈希值的函数\" class=\"headerlink\" title=\"计算哈希值的函数\"></a>计算哈希值的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 计算哈希值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash</span><span class=\"params\">(file)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> open(file, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        s = f.read()</div><div class=\"line\">        md5 = hashlib.md5(s).hexdigest()  <span class=\"comment\"># 生成MD5</span></div><div class=\"line\">        sha1 = hashlib.sha1(s).hexdigest()  <span class=\"comment\"># 生成SHA1</span></div><div class=\"line\">        sha256 = hashlib.sha256(s).hexdigest()  <span class=\"comment\"># 生成SHA256</span></div><div class=\"line\">        sha512 = hashlib.sha512(s).hexdigest()  <span class=\"comment\"># 生成SHA512</span></div><div class=\"line\">    <span class=\"keyword\">return</span> md5, sha1, sha256, sha512</div></pre></td></tr></table></figure>\n<h3 id=\"可以指定哈希加密算法的函数\"><a href=\"#可以指定哈希加密算法的函数\" class=\"headerlink\" title=\"可以指定哈希加密算法的函数\"></a>可以指定哈希加密算法的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 计算哈希值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash_type</span><span class=\"params\">(file, hash_type)</span>:</span></div><div class=\"line\">     <span class=\"keyword\">with</span> open(file, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        s = f.read()</div><div class=\"line\">        <span class=\"keyword\">if</span> hash_type.lower() == <span class=\"string\">'md5'</span>:</div><div class=\"line\">            hash_res = hashlib.md5(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha1'</span>:</div><div class=\"line\">            hash_res = hashlib.sha1(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha256'</span>:</div><div class=\"line\">            hash_res = hashlib.sha256(s).hexdigest()</div><div class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">'sha512'</span>:</div><div class=\"line\">            hash_res = hashlib.sha512(s).hexdigest()</div><div class=\"line\">         <span class=\"keyword\">else</span>:</div><div class=\"line\">            print(<span class=\"string\">\"Hash type error!\"</span>)</div><div class=\"line\">            hash_res = <span class=\"string\">\"Type Error\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> hash_type, hash_res</div></pre></td></tr></table></figure>\n<h3 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    file_path, hash_t = map(str, input(<span class=\"string\">'Please enter the path of the file and hash type:'</span>).split())</div><div class=\"line\">    md = generate_hash_type(file_path, hash_t)</div><div class=\"line\">    print(md,<span class=\"string\">'\\n'</span>)</div><div class=\"line\">    md = generate_hash(file_path)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> md:</div><div class=\"line\">        print(i)</div></pre></td></tr></table></figure>\n<p>最后别忘了引入<strong>hashlib</strong>库:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> hashlib</div></pre></td></tr></table></figure>\n<p>还有设置编码格式以防万一</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这里我使用的是<a href=\"https://www.python.org/\">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file:</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p>\n</blockquote>\n<p>然后是输入路径+指定加密算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file <span class=\"keyword\">and</span> hash type:</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe md5</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p>\n</blockquote>\n<p>再来看看官网给出的md5：</p>\n<blockquote>\n<p>ad69fdacde90f2ce8286c279b11ca188</p>\n</blockquote>\n<p>和程序计算的结果一致。</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】注册表单验证","date":"2017-10-13T07:01:08.000Z","comments":1,"_content":"\n用Python实现类似于网页表单信息验证的功能。\n\n基本要求：\n\n1. 需要输入邮箱地址、密码两项\n2. 邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格\n3. 密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）\n4. 重名验证\n\n<!--more-->\n\n思路：\n通过正则表达式来实现\n\n## 正则表达式\n\n### 正则表达式库\n\nPython中有正则表达式标准库，引入正则表达式库Re即可:\n\n```python\nimport re\n```\n\n由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。\n\n### 正则表达式特殊字符\n\n在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考[正则表达式-菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)。\n\n特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如`*`表示匹配某字符串零次或多次，如果想要匹配`*`，则需要转义，即匹配`\\*`，这样就是匹配`*`这个字符。正则表达式的特殊字符如下表所示：\n\n|特殊字符 | 描述 |\n|:--- |:-----|\n|\\$   |匹配输入字符串的结尾位置 |\n|()   |标记一个子表达式的开始和结束位置|\n|*    |匹配前面的子表达式零次或多次|\n|+    |匹配前面的子表达式一次或多次|\n|.    |匹配除换行符\\n之外的任何单字符|\n|[]   |标记一个中括号表达式的开始和结束位置|\n|?    |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符|\n|\\    |将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符|\n|^    |匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集|\n|{}   |标记限定符表达式的开始|\n|&#124;|指明两项之间的一个选择|\n\n## 验证邮箱\n\n```python\ncheckEmail = re.compile(r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)')\n```\n\n## 验证密码\n\n```python\ncheckPwd = re.compile(r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).{8,}$')\n```\n\n## 重名验证\n\n没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。\n\n```python\n# 打开存储邮箱地址的文档，如果不存在则新建\nif no os.path.exists('./users.txt'):\n    f = open('./users.txt', 'w')\n    f.close()\n    \n# 读取文本中的邮箱地址，存入一个list，后面验证重名时使用\nwith open('./users.txt', 'r') as f:\n    userName = f.readlines()\n\n# 验证重名\ndef check_email(email_address):\n    while not checkEmail.match(email_address):\n        email_address = input('邮箱地址格式不正确，请重新输入: ')\n    if email_address + '\\n' in userName:\n        email_address = input('邮箱地址已注册，请输入其他邮箱: ')\n        check_email(email_address)\n    else:\n        print('邮箱地址可用!')\n    return email_address\n```\n\n## 验证密码是否符合要求\n\n```python\ndef check_pwd(password):\n    while not checkPwd.match(password):\n        print('密码需要8位以上，包含大小写和数字。请重新输入。')\n        password = input('密码: ')\n    return password\n```\n\n\n## 主程序\n\n```python\n# check email address\nemailAdd = input('请输入邮箱地址: ')\nemailAdd = check_email(emailAdd)\nprint('邮箱地址: ', emailAdd)\n\n# check password\npwd = input('密码: ')\npwd = check_pwd(pwd)\n\n# 保存新注册的邮箱\nwith open('./users.txt', 'a') as f:\n    f.write(emailAdd + '\\n')\nprint('注册成功!')\n```\n\n---\n","source":"_posts/【每周一坑】注册表单验证.md","raw":"---\ntitle: 【每周一坑】注册表单验证\ndate: 2017-10-13 15:01:08\ncategory: Python\ntags: [每周一坑 ,正则表达式]\ncomments: true\n---\n\n用Python实现类似于网页表单信息验证的功能。\n\n基本要求：\n\n1. 需要输入邮箱地址、密码两项\n2. 邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格\n3. 密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）\n4. 重名验证\n\n<!--more-->\n\n思路：\n通过正则表达式来实现\n\n## 正则表达式\n\n### 正则表达式库\n\nPython中有正则表达式标准库，引入正则表达式库Re即可:\n\n```python\nimport re\n```\n\n由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。\n\n### 正则表达式特殊字符\n\n在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考[正则表达式-菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)。\n\n特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如`*`表示匹配某字符串零次或多次，如果想要匹配`*`，则需要转义，即匹配`\\*`，这样就是匹配`*`这个字符。正则表达式的特殊字符如下表所示：\n\n|特殊字符 | 描述 |\n|:--- |:-----|\n|\\$   |匹配输入字符串的结尾位置 |\n|()   |标记一个子表达式的开始和结束位置|\n|*    |匹配前面的子表达式零次或多次|\n|+    |匹配前面的子表达式一次或多次|\n|.    |匹配除换行符\\n之外的任何单字符|\n|[]   |标记一个中括号表达式的开始和结束位置|\n|?    |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符|\n|\\    |将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符|\n|^    |匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集|\n|{}   |标记限定符表达式的开始|\n|&#124;|指明两项之间的一个选择|\n\n## 验证邮箱\n\n```python\ncheckEmail = re.compile(r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)')\n```\n\n## 验证密码\n\n```python\ncheckPwd = re.compile(r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).{8,}$')\n```\n\n## 重名验证\n\n没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。\n\n```python\n# 打开存储邮箱地址的文档，如果不存在则新建\nif no os.path.exists('./users.txt'):\n    f = open('./users.txt', 'w')\n    f.close()\n    \n# 读取文本中的邮箱地址，存入一个list，后面验证重名时使用\nwith open('./users.txt', 'r') as f:\n    userName = f.readlines()\n\n# 验证重名\ndef check_email(email_address):\n    while not checkEmail.match(email_address):\n        email_address = input('邮箱地址格式不正确，请重新输入: ')\n    if email_address + '\\n' in userName:\n        email_address = input('邮箱地址已注册，请输入其他邮箱: ')\n        check_email(email_address)\n    else:\n        print('邮箱地址可用!')\n    return email_address\n```\n\n## 验证密码是否符合要求\n\n```python\ndef check_pwd(password):\n    while not checkPwd.match(password):\n        print('密码需要8位以上，包含大小写和数字。请重新输入。')\n        password = input('密码: ')\n    return password\n```\n\n\n## 主程序\n\n```python\n# check email address\nemailAdd = input('请输入邮箱地址: ')\nemailAdd = check_email(emailAdd)\nprint('邮箱地址: ', emailAdd)\n\n# check password\npwd = input('密码: ')\npwd = check_pwd(pwd)\n\n# 保存新注册的邮箱\nwith open('./users.txt', 'a') as f:\n    f.write(emailAdd + '\\n')\nprint('注册成功!')\n```\n\n---\n","slug":"【每周一坑】注册表单验证","published":1,"updated":"2017-10-13T07:16:40.787Z","layout":"post","photos":[],"link":"","_id":"cjqojmlx6001cswqcv35r3uxt","content":"<p>用Python实现类似于网页表单信息验证的功能。</p>\n<p>基本要求：</p>\n<ol>\n<li>需要输入邮箱地址、密码两项</li>\n<li>邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格</li>\n<li>密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）</li>\n<li>重名验证</li>\n</ol>\n<a id=\"more\"></a>\n<p>思路：<br>通过正则表达式来实现</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><h3 id=\"正则表达式库\"><a href=\"#正则表达式库\" class=\"headerlink\" title=\"正则表达式库\"></a>正则表达式库</h3><p>Python中有正则表达式标准库，引入正则表达式库Re即可:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div></pre></td></tr></table></figure>\n<p>由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。</p>\n<h3 id=\"正则表达式特殊字符\"><a href=\"#正则表达式特殊字符\" class=\"headerlink\" title=\"正则表达式特殊字符\"></a>正则表达式特殊字符</h3><p>在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考<a href=\"http://www.runoob.com/regexp/regexp-tutorial.html\" target=\"_blank\" rel=\"external\">正则表达式-菜鸟教程</a>。</p>\n<p>特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如<code>*</code>表示匹配某字符串零次或多次，如果想要匹配<code>*</code>，则需要转义，即匹配<code>\\*</code>，这样就是匹配<code>*</code>这个字符。正则表达式的特殊字符如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特殊字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">\\$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">()</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配除换行符\\n之外的任何单字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[]</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">标记限定符表达式的开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&#124;</td>\n<td style=\"text-align:left\">指明两项之间的一个选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">checkEmail = re.compile(<span class=\"string\">r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"验证密码\"><a href=\"#验证密码\" class=\"headerlink\" title=\"验证密码\"></a>验证密码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">checkPwd = re.compile(<span class=\"string\">r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"重名验证\"><a href=\"#重名验证\" class=\"headerlink\" title=\"重名验证\"></a>重名验证</h2><p>没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 打开存储邮箱地址的文档，如果不存在则新建</span></div><div class=\"line\"><span class=\"keyword\">if</span> no os.path.exists(<span class=\"string\">'./users.txt'</span>):</div><div class=\"line\">    f = open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\">    f.close()</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\"># 读取文本中的邮箱地址，存入一个list，后面验证重名时使用</span></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    userName = f.readlines()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 验证重名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_email</span><span class=\"params\">(email_address)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkEmail.match(email_address):</div><div class=\"line\">        email_address = input(<span class=\"string\">'邮箱地址格式不正确，请重新输入: '</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> email_address + <span class=\"string\">'\\n'</span> <span class=\"keyword\">in</span> userName:</div><div class=\"line\">        email_address = input(<span class=\"string\">'邮箱地址已注册，请输入其他邮箱: '</span>)</div><div class=\"line\">        check_email(email_address)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        print(<span class=\"string\">'邮箱地址可用!'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> email_address</div></pre></td></tr></table></figure>\n<h2 id=\"验证密码是否符合要求\"><a href=\"#验证密码是否符合要求\" class=\"headerlink\" title=\"验证密码是否符合要求\"></a>验证密码是否符合要求</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_pwd</span><span class=\"params\">(password)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkPwd.match(password):</div><div class=\"line\">        print(<span class=\"string\">'密码需要8位以上，包含大小写和数字。请重新输入。'</span>)</div><div class=\"line\">        password = input(<span class=\"string\">'密码: '</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> password</div></pre></td></tr></table></figure>\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># check email address</span></div><div class=\"line\">emailAdd = input(<span class=\"string\">'请输入邮箱地址: '</span>)</div><div class=\"line\">emailAdd = check_email(emailAdd)</div><div class=\"line\">print(<span class=\"string\">'邮箱地址: '</span>, emailAdd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># check password</span></div><div class=\"line\">pwd = input(<span class=\"string\">'密码: '</span>)</div><div class=\"line\">pwd = check_pwd(pwd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 保存新注册的邮箱</span></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(emailAdd + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">print(<span class=\"string\">'注册成功!'</span>)</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"<p>用Python实现类似于网页表单信息验证的功能。</p>\n<p>基本要求：</p>\n<ol>\n<li>需要输入邮箱地址、密码两项</li>\n<li>邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格</li>\n<li>密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）</li>\n<li>重名验证</li>\n</ol>","more":"<p>思路：<br>通过正则表达式来实现</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><h3 id=\"正则表达式库\"><a href=\"#正则表达式库\" class=\"headerlink\" title=\"正则表达式库\"></a>正则表达式库</h3><p>Python中有正则表达式标准库，引入正则表达式库Re即可:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div></pre></td></tr></table></figure>\n<p>由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。</p>\n<h3 id=\"正则表达式特殊字符\"><a href=\"#正则表达式特殊字符\" class=\"headerlink\" title=\"正则表达式特殊字符\"></a>正则表达式特殊字符</h3><p>在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考<a href=\"http://www.runoob.com/regexp/regexp-tutorial.html\">正则表达式-菜鸟教程</a>。</p>\n<p>特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如<code>*</code>表示匹配某字符串零次或多次，如果想要匹配<code>*</code>，则需要转义，即匹配<code>\\*</code>，这样就是匹配<code>*</code>这个字符。正则表达式的特殊字符如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特殊字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">\\$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">()</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配除换行符\\n之外的任何单字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[]</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">标记限定符表达式的开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&#124;</td>\n<td style=\"text-align:left\">指明两项之间的一个选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">checkEmail = re.compile(<span class=\"string\">r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"验证密码\"><a href=\"#验证密码\" class=\"headerlink\" title=\"验证密码\"></a>验证密码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">checkPwd = re.compile(<span class=\"string\">r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"重名验证\"><a href=\"#重名验证\" class=\"headerlink\" title=\"重名验证\"></a>重名验证</h2><p>没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 打开存储邮箱地址的文档，如果不存在则新建</span></div><div class=\"line\"><span class=\"keyword\">if</span> no os.path.exists(<span class=\"string\">'./users.txt'</span>):</div><div class=\"line\">    f = open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\">    f.close()</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\"># 读取文本中的邮箱地址，存入一个list，后面验证重名时使用</span></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    userName = f.readlines()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 验证重名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_email</span><span class=\"params\">(email_address)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkEmail.match(email_address):</div><div class=\"line\">        email_address = input(<span class=\"string\">'邮箱地址格式不正确，请重新输入: '</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> email_address + <span class=\"string\">'\\n'</span> <span class=\"keyword\">in</span> userName:</div><div class=\"line\">        email_address = input(<span class=\"string\">'邮箱地址已注册，请输入其他邮箱: '</span>)</div><div class=\"line\">        check_email(email_address)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        print(<span class=\"string\">'邮箱地址可用!'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> email_address</div></pre></td></tr></table></figure>\n<h2 id=\"验证密码是否符合要求\"><a href=\"#验证密码是否符合要求\" class=\"headerlink\" title=\"验证密码是否符合要求\"></a>验证密码是否符合要求</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_pwd</span><span class=\"params\">(password)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkPwd.match(password):</div><div class=\"line\">        print(<span class=\"string\">'密码需要8位以上，包含大小写和数字。请重新输入。'</span>)</div><div class=\"line\">        password = input(<span class=\"string\">'密码: '</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> password</div></pre></td></tr></table></figure>\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># check email address</span></div><div class=\"line\">emailAdd = input(<span class=\"string\">'请输入邮箱地址: '</span>)</div><div class=\"line\">emailAdd = check_email(emailAdd)</div><div class=\"line\">print(<span class=\"string\">'邮箱地址: '</span>, emailAdd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># check password</span></div><div class=\"line\">pwd = input(<span class=\"string\">'密码: '</span>)</div><div class=\"line\">pwd = check_pwd(pwd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 保存新注册的邮箱</span></div><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'./users.txt'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(emailAdd + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">print(<span class=\"string\">'注册成功!'</span>)</div></pre></td></tr></table></figure>\n<hr>"},{"title":"【每周一坑】求乘积最大","date":"2017-05-03T13:58:01.000Z","comments":1,"_content":"\n本周题目：\n> 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值\n\n示例：\n```python\ndef product(num):\n    '''\n    >>>product(312)\n    62\n    >>>product(1234)\n    492\n    >>>product(12345)\n    6170\n    >>>product(123456)\n    74070\n    '''\n```\n<!--more-->\n\n## 思路\n\n从头到尾遍历这个数字串，\n1. 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果\n2. 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果\n3. 以此类推...\n直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。\n\n可以将每一步求出的值存入初始值为0的`max_num`中，每次求出的值都与`max_num`比较，若大于`max_num`，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。\n\n\n## Python实现\n\n```python\n# coding: utf-8\ndef product(num):\n    i = 1               \n    max_num = 0\n    while i != len(str(num)):\n        num1 = int(str(num)[:i])\n        num2 = int(str(num)[i:])\n        result = num1 * num2\n        # result = int(str(num)[:i]) * int(str(num)[i:])\n        if result > max_num:\n            max_num = result\n        i += 1\n    return max_num\n\n# 测试\nprint(product(312))\nprint(product(1234))\nprint(product(12345))\nprint(product(123456))\n```\n\n## 输出结果\n结果为：\n> 62\n492\n6170\n74070\n\n结果与示例相符合\n\n## 附加题\n\n上述的题目感觉还是比较简单的，因此多了一个附加题：\n> 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。\n\n示例：\n```python\ndef product_2(num):\n  '''\n  >>>product_2(1234)\n  1312\n  >>>product_2(12345)\n  22412\n  >>>product_2(123456)\n  342002\n  '''\n```\n\n## 思路\n\n可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：[**itertools**](https://docs.python.org/3.6/library/itertools.html#module-itertools)。\n它属于Python标准库，今天用到的是[**permutations()**](https://docs.python.org/3.6/library/itertools.html#itertools.permutations)这个函数：\n> permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同\n返回p中任意取r个元素做排列的元组的迭代器\n\n例如：\n> permutations('ABCD', 2)\n\n返回的结果为：\n> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD\n\n有了这个函数，我们就可以完成附加题了\n\n## Python实现\n```python\n# coding: utf-8\nfrom itertools import permutations\n\n\ndef product_2(num):\n    i = 1\n    max_num = 0\n    for p in permutations(str(num)):\n        new_num = \"\".join(p)            # 排列后返回的是一个元组，通过join()来重新生成数字串\n        # print(new_num)\n        result = product(new_num)       # 就是上面的product()\n        if result > max_num:\n            max_num = result\n    return max_num\n    \n\n# 测试\nprint(product_2(1234))\nprint(product_2(12345))\nprint(product_2(123456))\n```\n## 输出结果\n结果为：\n>1312\n22412\n342002\n\n与示例一致\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】求乘积最大.md","raw":"---\ntitle: 【每周一坑】求乘积最大\ndate: 2017-05-03 21:58:01\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本周题目：\n> 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值\n\n示例：\n```python\ndef product(num):\n    '''\n    >>>product(312)\n    62\n    >>>product(1234)\n    492\n    >>>product(12345)\n    6170\n    >>>product(123456)\n    74070\n    '''\n```\n<!--more-->\n\n## 思路\n\n从头到尾遍历这个数字串，\n1. 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果\n2. 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果\n3. 以此类推...\n直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。\n\n可以将每一步求出的值存入初始值为0的`max_num`中，每次求出的值都与`max_num`比较，若大于`max_num`，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。\n\n\n## Python实现\n\n```python\n# coding: utf-8\ndef product(num):\n    i = 1               \n    max_num = 0\n    while i != len(str(num)):\n        num1 = int(str(num)[:i])\n        num2 = int(str(num)[i:])\n        result = num1 * num2\n        # result = int(str(num)[:i]) * int(str(num)[i:])\n        if result > max_num:\n            max_num = result\n        i += 1\n    return max_num\n\n# 测试\nprint(product(312))\nprint(product(1234))\nprint(product(12345))\nprint(product(123456))\n```\n\n## 输出结果\n结果为：\n> 62\n492\n6170\n74070\n\n结果与示例相符合\n\n## 附加题\n\n上述的题目感觉还是比较简单的，因此多了一个附加题：\n> 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。\n\n示例：\n```python\ndef product_2(num):\n  '''\n  >>>product_2(1234)\n  1312\n  >>>product_2(12345)\n  22412\n  >>>product_2(123456)\n  342002\n  '''\n```\n\n## 思路\n\n可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：[**itertools**](https://docs.python.org/3.6/library/itertools.html#module-itertools)。\n它属于Python标准库，今天用到的是[**permutations()**](https://docs.python.org/3.6/library/itertools.html#itertools.permutations)这个函数：\n> permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同\n返回p中任意取r个元素做排列的元组的迭代器\n\n例如：\n> permutations('ABCD', 2)\n\n返回的结果为：\n> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD\n\n有了这个函数，我们就可以完成附加题了\n\n## Python实现\n```python\n# coding: utf-8\nfrom itertools import permutations\n\n\ndef product_2(num):\n    i = 1\n    max_num = 0\n    for p in permutations(str(num)):\n        new_num = \"\".join(p)            # 排列后返回的是一个元组，通过join()来重新生成数字串\n        # print(new_num)\n        result = product(new_num)       # 就是上面的product()\n        if result > max_num:\n            max_num = result\n    return max_num\n    \n\n# 测试\nprint(product_2(1234))\nprint(product_2(12345))\nprint(product_2(123456))\n```\n## 输出结果\n结果为：\n>1312\n22412\n342002\n\n与示例一致\n\nEnd~\n\n---\n\n","slug":"【每周一坑】求乘积最大","published":1,"updated":"2017-08-04T10:52:22.542Z","layout":"post","photos":[],"link":"","_id":"cjqojmlx6001fswqchp262cal","content":"<p>本周题目：</p>\n<blockquote>\n<p>设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</span></div><div class=\"line\">    &gt;&gt;&gt;product(312)</div><div class=\"line\">    62</div><div class=\"line\">    &gt;&gt;&gt;product(1234)</div><div class=\"line\">    492</div><div class=\"line\">    &gt;&gt;&gt;product(12345)</div><div class=\"line\">    6170</div><div class=\"line\">    &gt;&gt;&gt;product(123456)</div><div class=\"line\">    74070</div><div class=\"line\">    '''</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>从头到尾遍历这个数字串，</p>\n<ol>\n<li>先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果</li>\n<li>然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果</li>\n<li>以此类推…<br>直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。</li>\n</ol>\n<p>可以将每一步求出的值存入初始值为0的<code>max_num</code>中，每次求出的值都与<code>max_num</code>比较，若大于<code>max_num</code>，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    i = <span class=\"number\">1</span>               </div><div class=\"line\">    max_num = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> i != len(str(num)):</div><div class=\"line\">        num1 = int(str(num)[:i])</div><div class=\"line\">        num2 = int(str(num)[i:])</div><div class=\"line\">        result = num1 * num2</div><div class=\"line\">        <span class=\"comment\"># result = int(str(num)[:i]) * int(str(num)[i:])</span></div><div class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</div><div class=\"line\">            max_num = result</div><div class=\"line\">        i += <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> max_num</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\">print(product(<span class=\"number\">312</span>))</div><div class=\"line\">print(product(<span class=\"number\">1234</span>))</div><div class=\"line\">print(product(<span class=\"number\">12345</span>))</div><div class=\"line\">print(product(<span class=\"number\">123456</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>62<br>492<br>6170<br>74070</p>\n</blockquote>\n<p>结果与示例相符合</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><p>上述的题目感觉还是比较简单的，因此多了一个附加题：</p>\n<blockquote>\n<p>输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">  <span class=\"string\">'''</span></div><div class=\"line\">  &gt;&gt;&gt;product_2(1234)</div><div class=\"line\">  1312</div><div class=\"line\">  &gt;&gt;&gt;product_2(12345)</div><div class=\"line\">  22412</div><div class=\"line\">  &gt;&gt;&gt;product_2(123456)</div><div class=\"line\">  342002</div><div class=\"line\">  '''</div></pre></td></tr></table></figure></p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：<a href=\"https://docs.python.org/3.6/library/itertools.html#module-itertools\" target=\"_blank\" rel=\"external\"><strong>itertools</strong></a>。<br>它属于Python标准库，今天用到的是<a href=\"https://docs.python.org/3.6/library/itertools.html#itertools.permutations\" target=\"_blank\" rel=\"external\"><strong>permutations()</strong></a>这个函数：</p>\n<blockquote>\n<p>permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同<br>返回p中任意取r个元素做排列的元组的迭代器</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>permutations(‘ABCD’, 2)</p>\n</blockquote>\n<p>返回的结果为：</p>\n<blockquote>\n<p>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</p>\n</blockquote>\n<p>有了这个函数，我们就可以完成附加题了</p>\n<h2 id=\"Python实现-1\"><a href=\"#Python实现-1\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    i = <span class=\"number\">1</span></div><div class=\"line\">    max_num = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> permutations(str(num)):</div><div class=\"line\">        new_num = <span class=\"string\">\"\"</span>.join(p)            <span class=\"comment\"># 排列后返回的是一个元组，通过join()来重新生成数字串</span></div><div class=\"line\">        <span class=\"comment\"># print(new_num)</span></div><div class=\"line\">        result = product(new_num)       <span class=\"comment\"># 就是上面的product()</span></div><div class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</div><div class=\"line\">            max_num = result</div><div class=\"line\">    <span class=\"keyword\">return</span> max_num</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\">print(product_2(<span class=\"number\">1234</span>))</div><div class=\"line\">print(product_2(<span class=\"number\">12345</span>))</div><div class=\"line\">print(product_2(<span class=\"number\">123456</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果-1\"><a href=\"#输出结果-1\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>1312<br>22412<br>342002</p>\n</blockquote>\n<p>与示例一致</p>\n<p>End~</p>\n<hr>\n","excerpt":"<p>本周题目：</p>\n<blockquote>\n<p>设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</div><div class=\"line\">    &gt;&gt;&gt;product(312)</div><div class=\"line\">    62</div><div class=\"line\">    &gt;&gt;&gt;product(1234)</div><div class=\"line\">    492</div><div class=\"line\">    &gt;&gt;&gt;product(12345)</div><div class=\"line\">    6170</div><div class=\"line\">    &gt;&gt;&gt;product(123456)</div><div class=\"line\">    74070</div><div class=\"line\">    '''</span></div></pre></td></tr></table></figure></p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>从头到尾遍历这个数字串，</p>\n<ol>\n<li>先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果</li>\n<li>然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果</li>\n<li>以此类推…<br>直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。</li>\n</ol>\n<p>可以将每一步求出的值存入初始值为0的<code>max_num</code>中，每次求出的值都与<code>max_num</code>比较，若大于<code>max_num</code>，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    i = <span class=\"number\">1</span>               </div><div class=\"line\">    max_num = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> i != len(str(num)):</div><div class=\"line\">        num1 = int(str(num)[:i])</div><div class=\"line\">        num2 = int(str(num)[i:])</div><div class=\"line\">        result = num1 * num2</div><div class=\"line\">        <span class=\"comment\"># result = int(str(num)[:i]) * int(str(num)[i:])</span></div><div class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</div><div class=\"line\">            max_num = result</div><div class=\"line\">        i += <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> max_num</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\">print(product(<span class=\"number\">312</span>))</div><div class=\"line\">print(product(<span class=\"number\">1234</span>))</div><div class=\"line\">print(product(<span class=\"number\">12345</span>))</div><div class=\"line\">print(product(<span class=\"number\">123456</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>62<br>492<br>6170<br>74070</p>\n</blockquote>\n<p>结果与示例相符合</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><p>上述的题目感觉还是比较简单的，因此多了一个附加题：</p>\n<blockquote>\n<p>输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">  <span class=\"string\">'''</div><div class=\"line\">  &gt;&gt;&gt;product_2(1234)</div><div class=\"line\">  1312</div><div class=\"line\">  &gt;&gt;&gt;product_2(12345)</div><div class=\"line\">  22412</div><div class=\"line\">  &gt;&gt;&gt;product_2(123456)</div><div class=\"line\">  342002</div><div class=\"line\">  '''</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：<a href=\"https://docs.python.org/3.6/library/itertools.html#module-itertools\"><strong>itertools</strong></a>。<br>它属于Python标准库，今天用到的是<a href=\"https://docs.python.org/3.6/library/itertools.html#itertools.permutations\"><strong>permutations()</strong></a>这个函数：</p>\n<blockquote>\n<p>permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同<br>返回p中任意取r个元素做排列的元组的迭代器</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>permutations(‘ABCD’, 2)</p>\n</blockquote>\n<p>返回的结果为：</p>\n<blockquote>\n<p>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</p>\n</blockquote>\n<p>有了这个函数，我们就可以完成附加题了</p>\n<h2 id=\"Python实现-1\"><a href=\"#Python实现-1\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    i = <span class=\"number\">1</span></div><div class=\"line\">    max_num = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> permutations(str(num)):</div><div class=\"line\">        new_num = <span class=\"string\">\"\"</span>.join(p)            <span class=\"comment\"># 排列后返回的是一个元组，通过join()来重新生成数字串</span></div><div class=\"line\">        <span class=\"comment\"># print(new_num)</span></div><div class=\"line\">        result = product(new_num)       <span class=\"comment\"># 就是上面的product()</span></div><div class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</div><div class=\"line\">            max_num = result</div><div class=\"line\">    <span class=\"keyword\">return</span> max_num</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\">print(product_2(<span class=\"number\">1234</span>))</div><div class=\"line\">print(product_2(<span class=\"number\">12345</span>))</div><div class=\"line\">print(product_2(<span class=\"number\">123456</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果-1\"><a href=\"#输出结果-1\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>1312<br>22412<br>342002</p>\n</blockquote>\n<p>与示例一致</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】矩阵旋转","date":"2017-09-06T11:46:37.000Z","comments":1,"_content":"\n本次的题目是关于矩阵旋转的\n<!--more-->\n\n## 问题\n\n> 给定一个N*N的矩阵(N>=0)，将其顺时针旋转90°。输出旋转后的矩阵。\n举例：\n1 2 3\n4 5 6\n7 8 9\n旋转后输出的结果应该是：\n7 4 1\n8 5 2\n9 6 3\n\n## 附加要求\n\n> 在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。\n\n## 解法\n\n### 1. 使用额外的空间\n\n顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。\n> 如： \n1 2 3\n4 5 6\n7 8 9\n取出每一列作为新的行：\n1 4 7\n2 5 8\n3 6 9\n再将每一行反转就得到了：\n7 4 1\n8 5 2\n9 6 3\n\n代码如下：\n\n```python\ndef rotate(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: List(List(int))\n    \"\"\"\n    res = []\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix[0])):\n        l = []\n        for subList in matrix:\n            l.append(subList[i])\n        l.reverse()\n        res.append(l)\n    return res\n```\n\n### 2. 在原矩阵上进行操作\n\n旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 ([原博客][1])\n\n代码如下：\n\n```python\n'''\n将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照\n对角线对称交换以后再进行反转后得到的\n'''\ndef rotate1(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: matrix\n    \"\"\"\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix)):\n        j = i + 1\n        while j < len(matrix[0]):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            j += 1\n    for i in range(len(matrix)):\n        # print(matrix[i])\n        matrix[i].reverse()\n        # print(matrix[i])\n    # matrix.reverse()\n    # print(matrix)\n    return matrix\n```\n\n[1]: http://blog.csdn.net/lion19930924/article/details/51661248\n\n## 参考资料\n\n[CSDN Blog -- 二维数组旋转90度(by @lynne233)](http://blog.csdn.net/lion19930924/article/details/51661248)\n\nEnd~\n\n---\n","source":"_posts/【每周一坑】矩阵旋转.md","raw":"---\ntitle: 【每周一坑】矩阵旋转\ndate: 2017-09-06 19:46:37\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本次的题目是关于矩阵旋转的\n<!--more-->\n\n## 问题\n\n> 给定一个N*N的矩阵(N>=0)，将其顺时针旋转90°。输出旋转后的矩阵。\n举例：\n1 2 3\n4 5 6\n7 8 9\n旋转后输出的结果应该是：\n7 4 1\n8 5 2\n9 6 3\n\n## 附加要求\n\n> 在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。\n\n## 解法\n\n### 1. 使用额外的空间\n\n顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。\n> 如： \n1 2 3\n4 5 6\n7 8 9\n取出每一列作为新的行：\n1 4 7\n2 5 8\n3 6 9\n再将每一行反转就得到了：\n7 4 1\n8 5 2\n9 6 3\n\n代码如下：\n\n```python\ndef rotate(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: List(List(int))\n    \"\"\"\n    res = []\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix[0])):\n        l = []\n        for subList in matrix:\n            l.append(subList[i])\n        l.reverse()\n        res.append(l)\n    return res\n```\n\n### 2. 在原矩阵上进行操作\n\n旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 ([原博客][1])\n\n代码如下：\n\n```python\n'''\n将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照\n对角线对称交换以后再进行反转后得到的\n'''\ndef rotate1(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: matrix\n    \"\"\"\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix)):\n        j = i + 1\n        while j < len(matrix[0]):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            j += 1\n    for i in range(len(matrix)):\n        # print(matrix[i])\n        matrix[i].reverse()\n        # print(matrix[i])\n    # matrix.reverse()\n    # print(matrix)\n    return matrix\n```\n\n[1]: http://blog.csdn.net/lion19930924/article/details/51661248\n\n## 参考资料\n\n[CSDN Blog -- 二维数组旋转90度(by @lynne233)](http://blog.csdn.net/lion19930924/article/details/51661248)\n\nEnd~\n\n---\n","slug":"【每周一坑】矩阵旋转","published":1,"updated":"2017-09-06T11:55:05.627Z","layout":"post","photos":[],"link":"","_id":"cjqojmlxm001kswqc0yaej6za","content":"<p>本次的题目是关于矩阵旋转的<br><a id=\"more\"></a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<h2 id=\"附加要求\"><a href=\"#附加要求\" class=\"headerlink\" title=\"附加要求\"></a>附加要求</h2><blockquote>\n<p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p>\n</blockquote>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><h3 id=\"1-使用额外的空间\"><a href=\"#1-使用额外的空间\" class=\"headerlink\" title=\"1. 使用额外的空间\"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p>\n<blockquote>\n<p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(matrix)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    :param matrix: List(List(int))</div><div class=\"line\">    :return: List(List(int))</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    res = []</div><div class=\"line\">    <span class=\"keyword\">if</span> len(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> matrix</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix[<span class=\"number\">0</span>])):</div><div class=\"line\">        l = []</div><div class=\"line\">        <span class=\"keyword\">for</span> subList <span class=\"keyword\">in</span> matrix:</div><div class=\"line\">            l.append(subList[i])</div><div class=\"line\">        l.reverse()</div><div class=\"line\">        res.append(l)</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div></pre></td></tr></table></figure>\n<h3 id=\"2-在原矩阵上进行操作\"><a href=\"#2-在原矩阵上进行操作\" class=\"headerlink\" title=\"2. 在原矩阵上进行操作\"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\" target=\"_blank\" rel=\"external\">原博客</a>)</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'''</span></div><div class=\"line\">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</div><div class=\"line\">对角线对称交换以后再进行反转后得到的</div><div class=\"line\">'''</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate1</span><span class=\"params\">(matrix)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    :param matrix: List(List(int))</div><div class=\"line\">    :return: matrix</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> len(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> matrix</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix)):</div><div class=\"line\">        j = i + <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(matrix[<span class=\"number\">0</span>]):</div><div class=\"line\">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</div><div class=\"line\">            j += <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix)):</div><div class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></div><div class=\"line\">        matrix[i].reverse()</div><div class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></div><div class=\"line\">    <span class=\"comment\"># matrix.reverse()</span></div><div class=\"line\">    <span class=\"comment\"># print(matrix)</span></div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\" target=\"_blank\" rel=\"external\">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p>\n<p>End~</p>\n<hr>\n","excerpt":"<p>本次的题目是关于矩阵旋转的<br>","more":"</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<h2 id=\"附加要求\"><a href=\"#附加要求\" class=\"headerlink\" title=\"附加要求\"></a>附加要求</h2><blockquote>\n<p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p>\n</blockquote>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><h3 id=\"1-使用额外的空间\"><a href=\"#1-使用额外的空间\" class=\"headerlink\" title=\"1. 使用额外的空间\"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p>\n<blockquote>\n<p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(matrix)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    :param matrix: List(List(int))</div><div class=\"line\">    :return: List(List(int))</div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    res = []</div><div class=\"line\">    <span class=\"keyword\">if</span> len(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> matrix</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix[<span class=\"number\">0</span>])):</div><div class=\"line\">        l = []</div><div class=\"line\">        <span class=\"keyword\">for</span> subList <span class=\"keyword\">in</span> matrix:</div><div class=\"line\">            l.append(subList[i])</div><div class=\"line\">        l.reverse()</div><div class=\"line\">        res.append(l)</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div></pre></td></tr></table></figure>\n<h3 id=\"2-在原矩阵上进行操作\"><a href=\"#2-在原矩阵上进行操作\" class=\"headerlink\" title=\"2. 在原矩阵上进行操作\"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">原博客</a>)</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'''</div><div class=\"line\">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</div><div class=\"line\">对角线对称交换以后再进行反转后得到的</div><div class=\"line\">'''</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate1</span><span class=\"params\">(matrix)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    :param matrix: List(List(int))</div><div class=\"line\">    :return: matrix</div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> len(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> matrix</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix)):</div><div class=\"line\">        j = i + <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(matrix[<span class=\"number\">0</span>]):</div><div class=\"line\">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</div><div class=\"line\">            j += <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix)):</div><div class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></div><div class=\"line\">        matrix[i].reverse()</div><div class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></div><div class=\"line\">    <span class=\"comment\"># matrix.reverse()</span></div><div class=\"line\">    <span class=\"comment\"># print(matrix)</span></div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】程序员的浪漫","date":"2017-04-27T07:39:22.000Z","comments":1,"_content":"\n![wordcloud](/images/imagesource/17-04-27.jpg )\n\n关注了**Crossin的编程教室**，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。\n\n问题如下：\n\n在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：\n> 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'\n\n在此给出4个选项\n\n1. 我们在一起吧\n2. 我选择原谅你\n3. 别说话，吻我\n4. 多喝热水\n\n使用科学的方法算出说的是什么。\n<!--more-->\n\n## 思路\n\n其实思路也挺简单，hashlib里有MD5模块，只需调用\n>hashlib.md5(\"要生成MD5的字符串\")\n\n即可生成。\n\n而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：\n>base64.b64decode(\"已知的字符串\")\n\n即可得到解码后的内容。\n\n\n最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。\n\n## Python实现\n\n``` python\nimport base64, hashlib      # 引入需要使用的库\n\nanswer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'   # 问题中的字符串\ncheckStr = {'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'}     # 将选项存入字典，后面使用\n\ndef main():\n    for x in checkStr:      # 遍历字典中的个字符串\n        md5 = hashlib.md5(x.encode('utf-8'))        # 使用hashlib.md5()进行编码\n        md5_byte = bytes(md5.hexdigest().encode('utf-8'))       # base64.decode()得到的是bytes类型的，\n\t\t # 无法直接与string比较，这里把string类型的md5转换成bytes类型的\n        b64_byte = base64.decode(answer)\n        if md5_byte == b64_byte:\n            print('The answer is', x)\n            \n\nif __name__ == '__main__':\n    main()\n\n```\n\n## 输出结果\n\n万！万！没！想！到！ 结果居然是....\n\n> 多喝热水\n\n说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧...\n\n然而...\n\n\n\n\n\n\n\n和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭\n\n\n\nEnd~\n\n---\n[1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\n\n","source":"_posts/【每周一坑】程序员的浪漫.md","raw":"---\ntitle: 【每周一坑】程序员的浪漫\ndate: 2017-04-27 15:39:22\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![wordcloud](/images/imagesource/17-04-27.jpg )\n\n关注了**Crossin的编程教室**，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。\n\n问题如下：\n\n在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：\n> 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'\n\n在此给出4个选项\n\n1. 我们在一起吧\n2. 我选择原谅你\n3. 别说话，吻我\n4. 多喝热水\n\n使用科学的方法算出说的是什么。\n<!--more-->\n\n## 思路\n\n其实思路也挺简单，hashlib里有MD5模块，只需调用\n>hashlib.md5(\"要生成MD5的字符串\")\n\n即可生成。\n\n而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：\n>base64.b64decode(\"已知的字符串\")\n\n即可得到解码后的内容。\n\n\n最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。\n\n## Python实现\n\n``` python\nimport base64, hashlib      # 引入需要使用的库\n\nanswer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'   # 问题中的字符串\ncheckStr = {'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'}     # 将选项存入字典，后面使用\n\ndef main():\n    for x in checkStr:      # 遍历字典中的个字符串\n        md5 = hashlib.md5(x.encode('utf-8'))        # 使用hashlib.md5()进行编码\n        md5_byte = bytes(md5.hexdigest().encode('utf-8'))       # base64.decode()得到的是bytes类型的，\n\t\t # 无法直接与string比较，这里把string类型的md5转换成bytes类型的\n        b64_byte = base64.decode(answer)\n        if md5_byte == b64_byte:\n            print('The answer is', x)\n            \n\nif __name__ == '__main__':\n    main()\n\n```\n\n## 输出结果\n\n万！万！没！想！到！ 结果居然是....\n\n> 多喝热水\n\n说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧...\n\n然而...\n\n\n\n\n\n\n\n和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭\n\n\n\nEnd~\n\n---\n[1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\n\n","slug":"【每周一坑】程序员的浪漫","published":1,"updated":"2017-05-28T01:19:15.982Z","layout":"post","photos":[],"link":"","_id":"cjqojmlxm001nswqcrgda3tw8","content":"<p><img src=\"/images/imagesource/17-04-27.jpg\" alt=\"wordcloud\"></p>\n<p>关注了<strong>Crossin的编程教室</strong>，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。</p>\n<p>问题如下：</p>\n<p>在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：</p>\n<blockquote>\n<p>‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n’</p>\n</blockquote>\n<p>在此给出4个选项</p>\n<ol>\n<li>我们在一起吧</li>\n<li>我选择原谅你</li>\n<li>别说话，吻我</li>\n<li>多喝热水</li>\n</ol>\n<p>使用科学的方法算出说的是什么。<br><a id=\"more\"></a></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>其实思路也挺简单，hashlib里有MD5模块，只需调用</p>\n<blockquote>\n<p>hashlib.md5(“要生成MD5的字符串”)</p>\n</blockquote>\n<p>即可生成。</p>\n<p>而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：</p>\n<blockquote>\n<p>base64.b64decode(“已知的字符串”)</p>\n</blockquote>\n<p>即可得到解码后的内容。</p>\n<p>最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> base64, hashlib      <span class=\"comment\"># 引入需要使用的库</span></div><div class=\"line\"></div><div class=\"line\">answer = <span class=\"string\">'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'</span>   <span class=\"comment\"># 问题中的字符串</span></div><div class=\"line\">checkStr = &#123;<span class=\"string\">'我们在一起吧'</span>, <span class=\"string\">'我选择原谅你'</span>, <span class=\"string\">'别说话，吻我'</span>, <span class=\"string\">'多喝热水'</span>&#125;     <span class=\"comment\"># 将选项存入字典，后面使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> checkStr:      <span class=\"comment\"># 遍历字典中的个字符串</span></div><div class=\"line\">        md5 = hashlib.md5(x.encode(<span class=\"string\">'utf-8'</span>))        <span class=\"comment\"># 使用hashlib.md5()进行编码</span></div><div class=\"line\">        md5_byte = bytes(md5.hexdigest().encode(<span class=\"string\">'utf-8'</span>))       <span class=\"comment\"># base64.decode()得到的是bytes类型的，</span></div><div class=\"line\">\t\t <span class=\"comment\"># 无法直接与string比较，这里把string类型的md5转换成bytes类型的</span></div><div class=\"line\">        b64_byte = base64.decode(answer)</div><div class=\"line\">        <span class=\"keyword\">if</span> md5_byte == b64_byte:</div><div class=\"line\">            print(<span class=\"string\">'The answer is'</span>, x)</div><div class=\"line\">            </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>万！万！没！想！到！ 结果居然是….</p>\n<blockquote>\n<p>多喝热水</p>\n</blockquote>\n<p>说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧…</p>\n<p>然而…</p>\n<p>和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\" target=\"_blank\" rel=\"external\">http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA</a></p>\n","excerpt":"<p><img src=\"/images/imagesource/17-04-27.jpg\" alt=\"wordcloud\"></p>\n<p>关注了<strong>Crossin的编程教室</strong>，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。</p>\n<p>问题如下：</p>\n<p>在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：</p>\n<blockquote>\n<p>‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n’</p>\n</blockquote>\n<p>在此给出4个选项</p>\n<ol>\n<li>我们在一起吧</li>\n<li>我选择原谅你</li>\n<li>别说话，吻我</li>\n<li>多喝热水</li>\n</ol>\n<p>使用科学的方法算出说的是什么。<br>","more":"</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>其实思路也挺简单，hashlib里有MD5模块，只需调用</p>\n<blockquote>\n<p>hashlib.md5(“要生成MD5的字符串”)</p>\n</blockquote>\n<p>即可生成。</p>\n<p>而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：</p>\n<blockquote>\n<p>base64.b64decode(“已知的字符串”)</p>\n</blockquote>\n<p>即可得到解码后的内容。</p>\n<p>最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> base64, hashlib      <span class=\"comment\"># 引入需要使用的库</span></div><div class=\"line\"></div><div class=\"line\">answer = <span class=\"string\">'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'</span>   <span class=\"comment\"># 问题中的字符串</span></div><div class=\"line\">checkStr = &#123;<span class=\"string\">'我们在一起吧'</span>, <span class=\"string\">'我选择原谅你'</span>, <span class=\"string\">'别说话，吻我'</span>, <span class=\"string\">'多喝热水'</span>&#125;     <span class=\"comment\"># 将选项存入字典，后面使用</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> checkStr:      <span class=\"comment\"># 遍历字典中的个字符串</span></div><div class=\"line\">        md5 = hashlib.md5(x.encode(<span class=\"string\">'utf-8'</span>))        <span class=\"comment\"># 使用hashlib.md5()进行编码</span></div><div class=\"line\">        md5_byte = bytes(md5.hexdigest().encode(<span class=\"string\">'utf-8'</span>))       <span class=\"comment\"># base64.decode()得到的是bytes类型的，</span></div><div class=\"line\">\t\t <span class=\"comment\"># 无法直接与string比较，这里把string类型的md5转换成bytes类型的</span></div><div class=\"line\">        b64_byte = base64.decode(answer)</div><div class=\"line\">        <span class=\"keyword\">if</span> md5_byte == b64_byte:</div><div class=\"line\">            print(<span class=\"string\">'The answer is'</span>, x)</div><div class=\"line\">            </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>万！万！没！想！到！ 结果居然是….</p>\n<blockquote>\n<p>多喝热水</p>\n</blockquote>\n<p>说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧…</p>\n<p>然而…</p>\n<p>和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\">http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA</a></p>"},{"title":"【每周一坑】神奇的九宫格","date":"2017-05-15T14:09:03.000Z","comments":1,"_content":"\n本周题目：\n>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。\n\n\n示例：\n```python\ndef Jiugongge():\n    '''\n    >>> Jiugongge()\n    4 9 2\n    3 5 7\n    8 1 6\n    '''\n```\n\n<!--more-->\n\n附加题：\n\n>给定一个正整数 N（N >= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。\n\n比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。\n## 思路\n\n在解决问题之前，要先了解一个东西 —— \"幻方\"。\nWiki上给出的中文定义：\n>**幻方**(Magic Square)，有时又称**魔方**（该称呼现一般指立方体的魔术方块）或**纵横图**，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。\n\n>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M\\_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有\n$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$\n\n$N$阶幻方的解题思路分为三种情况：\n1. $N$为奇数\n2. $N$为4的倍数\n3. $N$为其他偶数\n\n### 1. $N$为奇数\n\n - 将$1$放在第一行中间一列；\n - 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；\n - 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；\n - 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。\n\n### 2. $N$为$4$的倍数\n采用对称元素交换法。首先把数$1$到$n\\*n$按从上至下、从左至又的顺序填入矩阵。\n然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。\n\n### 3. $N$为非$4$的倍数的偶数(即$4n+2$)\n首先把大方阵分解为$4$个奇数字方阵。\n按上述奇数幻方给分解的4个子方阵对应赋值,其中：\n上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$\n即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$\n四个子矩阵由小到大排列方式为\n\n$$\n        \\begin{bmatrix}\n        1 & 3 \\\\\n        4 & 2 \\\\\n        \\end{bmatrix}\n$$\n\n然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中\n$k = n//2，t=(n-2)//4$。\n\n## Python实现\n```python\n# n为奇数\ndef oddN():\n    # 构造二维列表\n    lst = [[0 for i in range(n)] for i in range(n)]\n    # 初始化列表位置\n    x, y = 0, n//2\n    for num in range(1, n*n+1):\n        lst[x][y] = num\n        xa, ya = x-1, y+1\n        # 回绕情况\n        if xa < 0:\n            xa = n-1\n        if ya > n-1:\n            ya = 0\n        # 占位情况\n        if lst[xa][ya] != 0:\n            x = x+1\n            if x > n-1:\n                x = 0\n        else:\n            x, y = xa, ya\n    return lst\n    \n# n为4的倍数\ndef fourN(n):\n    # 初始化列表\n    lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)]\n    # 交换对角线位置\n    for i in range(n//2):\n        lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i]\n        lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i]\n    return lst\n\n# n为非4倍数的偶数\n# 累加子矩阵\ndef acc(p, lst):\n    # print(lst)\n    for row in lst:\n        for index in range(len(row)):\n            row[index] += p\n\n    return lst\n\n\ndef fourNplus2(n):\n    m = n // 2\n    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)\n    B = acc(m ** 2, B)\n    C = acc(m ** 2 * 2, C)\n    D = acc(m ** 2 * 3, D)\n    for row_index in range(len(A)):\n        A[row_index].extend(C[row_index])\n        D[row_index].extend(B[row_index])\n    # 合并子矩阵\n    matrix = A + D\n    t = (n - 2) // 4\n    # 列交换\n    for col_index in range(len(matrix[0])):\n        if col_index < t or col_index > n - t:\n            for row_index in range(len(matrix) // 2):\n                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\\n                    matrix[row_index + m][col_index], matrix[row_index][col_index]\n                # 交换特殊位置\n    matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0]\n    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]\n    return matrix\n```\n\n\nEnd~\n\n---","source":"_posts/【每周一坑】神奇的九宫格.md","raw":"---\ntitle: 【每周一坑】神奇的九宫格\ndate: 2017-05-15 22:09:03\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本周题目：\n>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。\n\n\n示例：\n```python\ndef Jiugongge():\n    '''\n    >>> Jiugongge()\n    4 9 2\n    3 5 7\n    8 1 6\n    '''\n```\n\n<!--more-->\n\n附加题：\n\n>给定一个正整数 N（N >= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。\n\n比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。\n## 思路\n\n在解决问题之前，要先了解一个东西 —— \"幻方\"。\nWiki上给出的中文定义：\n>**幻方**(Magic Square)，有时又称**魔方**（该称呼现一般指立方体的魔术方块）或**纵横图**，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。\n\n>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M\\_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有\n$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$\n\n$N$阶幻方的解题思路分为三种情况：\n1. $N$为奇数\n2. $N$为4的倍数\n3. $N$为其他偶数\n\n### 1. $N$为奇数\n\n - 将$1$放在第一行中间一列；\n - 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；\n - 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；\n - 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。\n\n### 2. $N$为$4$的倍数\n采用对称元素交换法。首先把数$1$到$n\\*n$按从上至下、从左至又的顺序填入矩阵。\n然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。\n\n### 3. $N$为非$4$的倍数的偶数(即$4n+2$)\n首先把大方阵分解为$4$个奇数字方阵。\n按上述奇数幻方给分解的4个子方阵对应赋值,其中：\n上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$\n即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$\n四个子矩阵由小到大排列方式为\n\n$$\n        \\begin{bmatrix}\n        1 & 3 \\\\\n        4 & 2 \\\\\n        \\end{bmatrix}\n$$\n\n然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中\n$k = n//2，t=(n-2)//4$。\n\n## Python实现\n```python\n# n为奇数\ndef oddN():\n    # 构造二维列表\n    lst = [[0 for i in range(n)] for i in range(n)]\n    # 初始化列表位置\n    x, y = 0, n//2\n    for num in range(1, n*n+1):\n        lst[x][y] = num\n        xa, ya = x-1, y+1\n        # 回绕情况\n        if xa < 0:\n            xa = n-1\n        if ya > n-1:\n            ya = 0\n        # 占位情况\n        if lst[xa][ya] != 0:\n            x = x+1\n            if x > n-1:\n                x = 0\n        else:\n            x, y = xa, ya\n    return lst\n    \n# n为4的倍数\ndef fourN(n):\n    # 初始化列表\n    lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)]\n    # 交换对角线位置\n    for i in range(n//2):\n        lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i]\n        lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i]\n    return lst\n\n# n为非4倍数的偶数\n# 累加子矩阵\ndef acc(p, lst):\n    # print(lst)\n    for row in lst:\n        for index in range(len(row)):\n            row[index] += p\n\n    return lst\n\n\ndef fourNplus2(n):\n    m = n // 2\n    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)\n    B = acc(m ** 2, B)\n    C = acc(m ** 2 * 2, C)\n    D = acc(m ** 2 * 3, D)\n    for row_index in range(len(A)):\n        A[row_index].extend(C[row_index])\n        D[row_index].extend(B[row_index])\n    # 合并子矩阵\n    matrix = A + D\n    t = (n - 2) // 4\n    # 列交换\n    for col_index in range(len(matrix[0])):\n        if col_index < t or col_index > n - t:\n            for row_index in range(len(matrix) // 2):\n                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\\n                    matrix[row_index + m][col_index], matrix[row_index][col_index]\n                # 交换特殊位置\n    matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0]\n    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]\n    return matrix\n```\n\n\nEnd~\n\n---","slug":"【每周一坑】神奇的九宫格","published":1,"updated":"2017-05-26T08:14:58.005Z","layout":"post","photos":[],"link":"","_id":"cjqojmlxm001qswqc3qt6hcvp","content":"<p>本周题目：</p>\n<blockquote>\n<p>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Jiugongge</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</span></div><div class=\"line\">    &gt;&gt;&gt; Jiugongge()</div><div class=\"line\">    4 9 2</div><div class=\"line\">    3 5 7</div><div class=\"line\">    8 1 6</div><div class=\"line\">    '''</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>附加题：</p>\n<blockquote>\n<p>给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。</p>\n</blockquote>\n<p>比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>在解决问题之前，要先了解一个东西 —— “幻方”。<br>Wiki上给出的中文定义：</p>\n<blockquote>\n<p><strong>幻方</strong>(Magic Square)，有时又称<strong>魔方</strong>（该称呼现一般指立方体的魔术方块）或<strong>纵横图</strong>，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。</p>\n<p>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有<br>$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$</p>\n</blockquote>\n<p>$N$阶幻方的解题思路分为三种情况：</p>\n<ol>\n<li>$N$为奇数</li>\n<li>$N$为4的倍数</li>\n<li>$N$为其他偶数</li>\n</ol>\n<h3 id=\"1-N-为奇数\"><a href=\"#1-N-为奇数\" class=\"headerlink\" title=\"1. $N$为奇数\"></a>1. $N$为奇数</h3><ul>\n<li>将$1$放在第一行中间一列；</li>\n<li>从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；</li>\n<li>如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；</li>\n<li>如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。</li>\n</ul>\n<h3 id=\"2-N-为-4-的倍数\"><a href=\"#2-N-为-4-的倍数\" class=\"headerlink\" title=\"2. $N$为$4$的倍数\"></a>2. $N$为$4$的倍数</h3><p>采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。<br>然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。</p>\n<h3 id=\"3-N-为非-4-的倍数的偶数-即-4n-2\"><a href=\"#3-N-为非-4-的倍数的偶数-即-4n-2\" class=\"headerlink\" title=\"3. $N$为非$4$的倍数的偶数(即$4n+2$)\"></a>3. $N$为非$4$的倍数的偶数(即$4n+2$)</h3><p>首先把大方阵分解为$4$个奇数字方阵。<br>按上述奇数幻方给分解的4个子方阵对应赋值,其中：<br>上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$<br>即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$<br>四个子矩阵由小到大排列方式为</p>\n<p>$$<br>        \\begin{bmatrix}<br>        1 &amp; 3 \\<br>        4 &amp; 2 \\<br>        \\end{bmatrix}<br>$$</p>\n<p>然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中<br>$k = n//2，t=(n-2)//4$。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># n为奇数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddN</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 构造二维列表</span></div><div class=\"line\">    lst = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"comment\"># 初始化列表位置</span></div><div class=\"line\">    x, y = <span class=\"number\">0</span>, n//<span class=\"number\">2</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n*n+<span class=\"number\">1</span>):</div><div class=\"line\">        lst[x][y] = num</div><div class=\"line\">        xa, ya = x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span></div><div class=\"line\">        <span class=\"comment\"># 回绕情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> xa &lt; <span class=\"number\">0</span>:</div><div class=\"line\">            xa = n<span class=\"number\">-1</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ya &gt; n<span class=\"number\">-1</span>:</div><div class=\"line\">            ya = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"comment\"># 占位情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> lst[xa][ya] != <span class=\"number\">0</span>:</div><div class=\"line\">            x = x+<span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">if</span> x &gt; n<span class=\"number\">-1</span>:</div><div class=\"line\">                x = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            x, y = xa, ya</div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\"># n为4的倍数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourN</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 初始化列表</span></div><div class=\"line\">    lst = [[i+j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list(range(<span class=\"number\">1</span>,n*n+<span class=\"number\">1</span>))[::n]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"comment\"># 交换对角线位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</div><div class=\"line\">        lst[i][i],lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i] = lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i],lst[i][i]</div><div class=\"line\">        lst[i][n<span class=\"number\">-1</span>-i],lst[n<span class=\"number\">-1</span>-i][i] = lst[n<span class=\"number\">-1</span>-i][i],lst[i][n<span class=\"number\">-1</span>-i]</div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># n为非4倍数的偶数</span></div><div class=\"line\"><span class=\"comment\"># 累加子矩阵</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">acc</span><span class=\"params\">(p, lst)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># print(lst)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> lst:</div><div class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(len(row)):</div><div class=\"line\">            row[index] += p</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourNplus2</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    m = n // <span class=\"number\">2</span></div><div class=\"line\">    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)</div><div class=\"line\">    B = acc(m ** <span class=\"number\">2</span>, B)</div><div class=\"line\">    C = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">2</span>, C)</div><div class=\"line\">    D = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">3</span>, D)</div><div class=\"line\">    <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> range(len(A)):</div><div class=\"line\">        A[row_index].extend(C[row_index])</div><div class=\"line\">        D[row_index].extend(B[row_index])</div><div class=\"line\">    <span class=\"comment\"># 合并子矩阵</span></div><div class=\"line\">    matrix = A + D</div><div class=\"line\">    t = (n - <span class=\"number\">2</span>) // <span class=\"number\">4</span></div><div class=\"line\">    <span class=\"comment\"># 列交换</span></div><div class=\"line\">    <span class=\"keyword\">for</span> col_index <span class=\"keyword\">in</span> range(len(matrix[<span class=\"number\">0</span>])):</div><div class=\"line\">        <span class=\"keyword\">if</span> col_index &lt; t <span class=\"keyword\">or</span> col_index &gt; n - t:</div><div class=\"line\">            <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> range(len(matrix) // <span class=\"number\">2</span>):</div><div class=\"line\">                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\</div><div class=\"line\">                    matrix[row_index + m][col_index], matrix[row_index][col_index]</div><div class=\"line\">                <span class=\"comment\"># 交换特殊位置</span></div><div class=\"line\">    matrix[t][<span class=\"number\">0</span>], matrix[m + t][<span class=\"number\">0</span>] = matrix[m + t][<span class=\"number\">0</span>], matrix[t][<span class=\"number\">0</span>]</div><div class=\"line\">    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]</div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div></pre></td></tr></table></figure>\n<p>End~</p>\n<hr>\n","excerpt":"<p>本周题目：</p>\n<blockquote>\n<p>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Jiugongge</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"string\">'''</div><div class=\"line\">    &gt;&gt;&gt; Jiugongge()</div><div class=\"line\">    4 9 2</div><div class=\"line\">    3 5 7</div><div class=\"line\">    8 1 6</div><div class=\"line\">    '''</span></div></pre></td></tr></table></figure></p>","more":"<p>附加题：</p>\n<blockquote>\n<p>给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。</p>\n</blockquote>\n<p>比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>在解决问题之前，要先了解一个东西 —— “幻方”。<br>Wiki上给出的中文定义：</p>\n<blockquote>\n<p><strong>幻方</strong>(Magic Square)，有时又称<strong>魔方</strong>（该称呼现一般指立方体的魔术方块）或<strong>纵横图</strong>，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。</p>\n<p>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有<br>$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$</p>\n</blockquote>\n<p>$N$阶幻方的解题思路分为三种情况：</p>\n<ol>\n<li>$N$为奇数</li>\n<li>$N$为4的倍数</li>\n<li>$N$为其他偶数</li>\n</ol>\n<h3 id=\"1-N-为奇数\"><a href=\"#1-N-为奇数\" class=\"headerlink\" title=\"1. $N$为奇数\"></a>1. $N$为奇数</h3><ul>\n<li>将$1$放在第一行中间一列；</li>\n<li>从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；</li>\n<li>如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；</li>\n<li>如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。</li>\n</ul>\n<h3 id=\"2-N-为-4-的倍数\"><a href=\"#2-N-为-4-的倍数\" class=\"headerlink\" title=\"2. $N$为$4$的倍数\"></a>2. $N$为$4$的倍数</h3><p>采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。<br>然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。</p>\n<h3 id=\"3-N-为非-4-的倍数的偶数-即-4n-2\"><a href=\"#3-N-为非-4-的倍数的偶数-即-4n-2\" class=\"headerlink\" title=\"3. $N$为非$4$的倍数的偶数(即$4n+2$)\"></a>3. $N$为非$4$的倍数的偶数(即$4n+2$)</h3><p>首先把大方阵分解为$4$个奇数字方阵。<br>按上述奇数幻方给分解的4个子方阵对应赋值,其中：<br>上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$<br>即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$<br>四个子矩阵由小到大排列方式为</p>\n<p>$$<br>        \\begin{bmatrix}<br>        1 &amp; 3 \\<br>        4 &amp; 2 \\<br>        \\end{bmatrix}<br>$$</p>\n<p>然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中<br>$k = n//2，t=(n-2)//4$。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># n为奇数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddN</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 构造二维列表</span></div><div class=\"line\">    lst = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"comment\"># 初始化列表位置</span></div><div class=\"line\">    x, y = <span class=\"number\">0</span>, n//<span class=\"number\">2</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n*n+<span class=\"number\">1</span>):</div><div class=\"line\">        lst[x][y] = num</div><div class=\"line\">        xa, ya = x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span></div><div class=\"line\">        <span class=\"comment\"># 回绕情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> xa &lt; <span class=\"number\">0</span>:</div><div class=\"line\">            xa = n<span class=\"number\">-1</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ya &gt; n<span class=\"number\">-1</span>:</div><div class=\"line\">            ya = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"comment\"># 占位情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> lst[xa][ya] != <span class=\"number\">0</span>:</div><div class=\"line\">            x = x+<span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">if</span> x &gt; n<span class=\"number\">-1</span>:</div><div class=\"line\">                x = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            x, y = xa, ya</div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\"># n为4的倍数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourN</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 初始化列表</span></div><div class=\"line\">    lst = [[i+j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list(range(<span class=\"number\">1</span>,n*n+<span class=\"number\">1</span>))[::n]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"comment\"># 交换对角线位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</div><div class=\"line\">        lst[i][i],lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i] = lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i],lst[i][i]</div><div class=\"line\">        lst[i][n<span class=\"number\">-1</span>-i],lst[n<span class=\"number\">-1</span>-i][i] = lst[n<span class=\"number\">-1</span>-i][i],lst[i][n<span class=\"number\">-1</span>-i]</div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># n为非4倍数的偶数</span></div><div class=\"line\"><span class=\"comment\"># 累加子矩阵</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">acc</span><span class=\"params\">(p, lst)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># print(lst)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> lst:</div><div class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(len(row)):</div><div class=\"line\">            row[index] += p</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> lst</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourNplus2</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    m = n // <span class=\"number\">2</span></div><div class=\"line\">    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)</div><div class=\"line\">    B = acc(m ** <span class=\"number\">2</span>, B)</div><div class=\"line\">    C = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">2</span>, C)</div><div class=\"line\">    D = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">3</span>, D)</div><div class=\"line\">    <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> range(len(A)):</div><div class=\"line\">        A[row_index].extend(C[row_index])</div><div class=\"line\">        D[row_index].extend(B[row_index])</div><div class=\"line\">    <span class=\"comment\"># 合并子矩阵</span></div><div class=\"line\">    matrix = A + D</div><div class=\"line\">    t = (n - <span class=\"number\">2</span>) // <span class=\"number\">4</span></div><div class=\"line\">    <span class=\"comment\"># 列交换</span></div><div class=\"line\">    <span class=\"keyword\">for</span> col_index <span class=\"keyword\">in</span> range(len(matrix[<span class=\"number\">0</span>])):</div><div class=\"line\">        <span class=\"keyword\">if</span> col_index &lt; t <span class=\"keyword\">or</span> col_index &gt; n - t:</div><div class=\"line\">            <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> range(len(matrix) // <span class=\"number\">2</span>):</div><div class=\"line\">                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\</div><div class=\"line\">                    matrix[row_index + m][col_index], matrix[row_index][col_index]</div><div class=\"line\">                <span class=\"comment\"># 交换特殊位置</span></div><div class=\"line\">    matrix[t][<span class=\"number\">0</span>], matrix[m + t][<span class=\"number\">0</span>] = matrix[m + t][<span class=\"number\">0</span>], matrix[t][<span class=\"number\">0</span>]</div><div class=\"line\">    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]</div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div></pre></td></tr></table></figure>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】罗马数字转换","date":"2017-07-08T06:38:47.000Z","comments":1,"_content":"\n![roman](/images/imagesource/17-07-08.jpg)\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。\n\n罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：\n\n1. 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3\n2. 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12\n3. 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9\n4. 在一个数的上面画一条横线，表示这个数曾1000倍\n\n<!--more-->\n\n**常见罗马字符表**\n\n数字|罗马字符|数字|罗马字符\n:-:|:-:|:--:|:--:|\n1|Ⅰ|2|Ⅱ\n3|Ⅲ|4|Ⅳ\n5|Ⅴ|6|Ⅵ\n7|Ⅶ|8|Ⅷ\n9|Ⅸ|10|Ⅹ\n40|XL|50|L\n90|XC|100|C\n400|CD|500|D\n900|CM|1000|M\n2000|MM|2500|MMD\n\n## 问题\n\n编写一个罗马数字和阿拉伯数字的转换器：\n> 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980\n\n**附加题**\n\n> 给定一个小于3999的整数，将其转换为罗马数\n\n示例：\n\n```python\ndef romanToInt(s):\n    # your code\n    return i\n\nassert romanToInt('III') == 3\nassert romanToInt('IV') == 4\nassert romanToInt('VI') == 6\nassert romanToInt('XIX') == 19\nassert romanToInt('XX') == 20\nassert romaToInt('XLV') == 45\nassert romanToInt('MCMLXXX') == 1980\n```\n\n## 思路\n\n### 罗马数转阿拉伯数\n\n根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要**注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况**。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，**左边的罗马数均比右边的小**，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以**将罗马数字符反转**，然后从头遍历，如果**当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字**。\n\n> 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：\n1. 第一位是X，表示10，pre = 0，res = 0 + 10\n2. 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10\n3. 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10\n4. 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50\n5. 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000\n6. 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100\n7. 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000\n\n经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确\n\n### 阿拉伯数(整数)转罗马数\n\n将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0\n\n> 如1980，(res表示结果):\n1. 1980 // 1000 = 1, res += M, 1980 % 1000 = 980\n2. 980 // 900 = 1, res += CM, 980 % 900 = 80\n3. 80 // 50 = 1, res += L, 80 % 50 = 30\n4. 30 // 10 = 3, res += 3*X, 30 % 10 = 0\n\n经过上述步骤即可得整数1980 = MCMLXXX\n\n## Python实现\n\n```python\n# -*- coding: utf-8 -*-\n# 罗马数字转换\n# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC\n# 400CCC;CD 500D 900CM 1000M 2500MMD\n\n# e.g.\n# 3->III\n# 4->IV\n# 6->VI\n# 19->XIX\n# 45->XLV\n# 999->CMXCIX\n# 1980->MCMLXXX\n# 3999->MMMCMXCIX\n\n# 罗马转数字\ndef roman_to_int(s):\n    roman_int_dic = {\n        'I': 1, 'V': 5, 'X': 10,\n        'L': 50, 'C': 100, 'D': 500,\n        'M': 1000\n    }\n    s = s[::-1]\n    res, pre = 0, 0\n    for x in s:\n        if roman_int_dic[x] >= pre:\n            res += roman_int_dic[x]\n            pre = roman_int_dic[x]\n        else:\n            res -= roman_int_dic[x]\n            pre = roman_int_dic[x]\n    return res\n \n\n# 数字转罗马\ndef int_to_roman(i):\n    dic = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'\n    }\n    res = \"\"\n    for k in dic:\n        if i != 0:\n            res += i // k * dic[k]\n            i %= k\n    return res\n\n\n# 测试\nif __name__ == '__main__':\n    result = roman_to_int('MMMCMXCIX')\n    print(result)\n\n    int_res = int_to_roman(3999)\n    print(int_res)\n\n    result = roman_to_int('MCMLXXX')\n    print(result)\n\n    int_res = int_to_roman(1980)\n    print(int_res)\n\n    assert roman_to_int('III') == 3\n    assert roman_to_int('IV') == 4\n    assert roman_to_int('VI') == 6\n    assert roman_to_int('XIX') == 19\n    assert roman_to_int('XLV') == 45\n    assert roman_to_int('MCMLXXX') == 1980\n    assert roman_to_int('CMXCIX') == 999\n    print(\"OK\")\n```\n\n## 测试\n\n输出结果\n\n```python\n>>> roman_to_int('MMMCMXCIX')\n3999\n\n>>> int_to_roman(3999)\nMMMCMXCIX\n\n>>> roman_to_int(MCMLXXX)\n1980\n\n>>> int_to_roman(1980)\nMCMLXXX\n```\n\n结果与要求一致\n\nEnd~\n\n---\n","source":"_posts/【每周一坑】罗马数字转换.md","raw":"---\ntitle: 【每周一坑】罗马数字转换\ndate: 2017-07-08 14:38:47\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![roman](/images/imagesource/17-07-08.jpg)\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。\n\n罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：\n\n1. 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3\n2. 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12\n3. 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9\n4. 在一个数的上面画一条横线，表示这个数曾1000倍\n\n<!--more-->\n\n**常见罗马字符表**\n\n数字|罗马字符|数字|罗马字符\n:-:|:-:|:--:|:--:|\n1|Ⅰ|2|Ⅱ\n3|Ⅲ|4|Ⅳ\n5|Ⅴ|6|Ⅵ\n7|Ⅶ|8|Ⅷ\n9|Ⅸ|10|Ⅹ\n40|XL|50|L\n90|XC|100|C\n400|CD|500|D\n900|CM|1000|M\n2000|MM|2500|MMD\n\n## 问题\n\n编写一个罗马数字和阿拉伯数字的转换器：\n> 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980\n\n**附加题**\n\n> 给定一个小于3999的整数，将其转换为罗马数\n\n示例：\n\n```python\ndef romanToInt(s):\n    # your code\n    return i\n\nassert romanToInt('III') == 3\nassert romanToInt('IV') == 4\nassert romanToInt('VI') == 6\nassert romanToInt('XIX') == 19\nassert romanToInt('XX') == 20\nassert romaToInt('XLV') == 45\nassert romanToInt('MCMLXXX') == 1980\n```\n\n## 思路\n\n### 罗马数转阿拉伯数\n\n根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要**注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况**。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，**左边的罗马数均比右边的小**，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以**将罗马数字符反转**，然后从头遍历，如果**当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字**。\n\n> 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：\n1. 第一位是X，表示10，pre = 0，res = 0 + 10\n2. 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10\n3. 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10\n4. 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50\n5. 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000\n6. 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100\n7. 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000\n\n经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确\n\n### 阿拉伯数(整数)转罗马数\n\n将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0\n\n> 如1980，(res表示结果):\n1. 1980 // 1000 = 1, res += M, 1980 % 1000 = 980\n2. 980 // 900 = 1, res += CM, 980 % 900 = 80\n3. 80 // 50 = 1, res += L, 80 % 50 = 30\n4. 30 // 10 = 3, res += 3*X, 30 % 10 = 0\n\n经过上述步骤即可得整数1980 = MCMLXXX\n\n## Python实现\n\n```python\n# -*- coding: utf-8 -*-\n# 罗马数字转换\n# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC\n# 400CCC;CD 500D 900CM 1000M 2500MMD\n\n# e.g.\n# 3->III\n# 4->IV\n# 6->VI\n# 19->XIX\n# 45->XLV\n# 999->CMXCIX\n# 1980->MCMLXXX\n# 3999->MMMCMXCIX\n\n# 罗马转数字\ndef roman_to_int(s):\n    roman_int_dic = {\n        'I': 1, 'V': 5, 'X': 10,\n        'L': 50, 'C': 100, 'D': 500,\n        'M': 1000\n    }\n    s = s[::-1]\n    res, pre = 0, 0\n    for x in s:\n        if roman_int_dic[x] >= pre:\n            res += roman_int_dic[x]\n            pre = roman_int_dic[x]\n        else:\n            res -= roman_int_dic[x]\n            pre = roman_int_dic[x]\n    return res\n \n\n# 数字转罗马\ndef int_to_roman(i):\n    dic = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'\n    }\n    res = \"\"\n    for k in dic:\n        if i != 0:\n            res += i // k * dic[k]\n            i %= k\n    return res\n\n\n# 测试\nif __name__ == '__main__':\n    result = roman_to_int('MMMCMXCIX')\n    print(result)\n\n    int_res = int_to_roman(3999)\n    print(int_res)\n\n    result = roman_to_int('MCMLXXX')\n    print(result)\n\n    int_res = int_to_roman(1980)\n    print(int_res)\n\n    assert roman_to_int('III') == 3\n    assert roman_to_int('IV') == 4\n    assert roman_to_int('VI') == 6\n    assert roman_to_int('XIX') == 19\n    assert roman_to_int('XLV') == 45\n    assert roman_to_int('MCMLXXX') == 1980\n    assert roman_to_int('CMXCIX') == 999\n    print(\"OK\")\n```\n\n## 测试\n\n输出结果\n\n```python\n>>> roman_to_int('MMMCMXCIX')\n3999\n\n>>> int_to_roman(3999)\nMMMCMXCIX\n\n>>> roman_to_int(MCMLXXX)\n1980\n\n>>> int_to_roman(1980)\nMCMLXXX\n```\n\n结果与要求一致\n\nEnd~\n\n---\n","slug":"【每周一坑】罗马数字转换","published":1,"updated":"2017-07-08T06:53:31.323Z","layout":"post","photos":[],"link":"","_id":"cjqojmlxm001uswqcinxeqsnf","content":"<p><img src=\"/images/imagesource/17-07-08.jpg\" alt=\"roman\"></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p>\n<p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p>\n<ol>\n<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li>\n<li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li>\n<li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li>\n<li>在一个数的上面画一条横线，表示这个数曾1000倍</li>\n</ol>\n<a id=\"more\"></a>\n<p><strong>常见罗马字符表</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数字</th>\n<th style=\"text-align:center\">罗马字符</th>\n<th style=\"text-align:center\">数字</th>\n<th style=\"text-align:center\">罗马字符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Ⅰ</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Ⅱ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">Ⅲ</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">Ⅳ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Ⅴ</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">Ⅵ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">Ⅶ</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">Ⅷ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">Ⅸ</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">Ⅹ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">XL</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">90</td>\n<td style=\"text-align:center\">XC</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">CD</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">900</td>\n<td style=\"text-align:center\">CM</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">M</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">MM</td>\n<td style=\"text-align:center\">2500</td>\n<td style=\"text-align:center\">MMD</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p>\n<blockquote>\n<p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>给定一个小于3999的整数，将其转换为罗马数</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># your code</span></div><div class=\"line\">    <span class=\"keyword\">return</span> i</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'III'</span>) == <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'IV'</span>) == <span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'VI'</span>) == <span class=\"number\">6</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'XIX'</span>) == <span class=\"number\">19</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'XX'</span>) == <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romaToInt(<span class=\"string\">'XLV'</span>) == <span class=\"number\">45</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'MCMLXXX'</span>) == <span class=\"number\">1980</span></div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"罗马数转阿拉伯数\"><a href=\"#罗马数转阿拉伯数\" class=\"headerlink\" title=\"罗马数转阿拉伯数\"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p>\n<blockquote>\n<p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p>\n<ol>\n<li>第一位是X，表示10，pre = 0，res = 0 + 10</li>\n<li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li>\n<li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li>\n<li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li>\n<li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li>\n<li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li>\n<li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li>\n</ol>\n</blockquote>\n<p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p>\n<h3 id=\"阿拉伯数-整数-转罗马数\"><a href=\"#阿拉伯数-整数-转罗马数\" class=\"headerlink\" title=\"阿拉伯数(整数)转罗马数\"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p>\n<blockquote>\n<p>如1980，(res表示结果):</p>\n<ol>\n<li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li>\n<li>980 // 900 = 1, res += CM, 980 % 900 = 80</li>\n<li>80 // 50 = 1, res += L, 80 % 50 = 30</li>\n<li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li>\n</ol>\n</blockquote>\n<p>经过上述步骤即可得整数1980 = MCMLXXX</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"comment\"># 罗马数字转换</span></div><div class=\"line\"><span class=\"comment\"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></div><div class=\"line\"><span class=\"comment\"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># e.g.</span></div><div class=\"line\"><span class=\"comment\"># 3-&gt;III</span></div><div class=\"line\"><span class=\"comment\"># 4-&gt;IV</span></div><div class=\"line\"><span class=\"comment\"># 6-&gt;VI</span></div><div class=\"line\"><span class=\"comment\"># 19-&gt;XIX</span></div><div class=\"line\"><span class=\"comment\"># 45-&gt;XLV</span></div><div class=\"line\"><span class=\"comment\"># 999-&gt;CMXCIX</span></div><div class=\"line\"><span class=\"comment\"># 1980-&gt;MCMLXXX</span></div><div class=\"line\"><span class=\"comment\"># 3999-&gt;MMMCMXCIX</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 罗马转数字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">roman_to_int</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">    roman_int_dic = &#123;</div><div class=\"line\">        <span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'V'</span>: <span class=\"number\">5</span>, <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</div><div class=\"line\">        <span class=\"string\">'L'</span>: <span class=\"number\">50</span>, <span class=\"string\">'C'</span>: <span class=\"number\">100</span>, <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</div><div class=\"line\">        <span class=\"string\">'M'</span>: <span class=\"number\">1000</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    s = s[::<span class=\"number\">-1</span>]</div><div class=\"line\">    res, pre = <span class=\"number\">0</span>, <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> s:</div><div class=\"line\">        <span class=\"keyword\">if</span> roman_int_dic[x] &gt;= pre:</div><div class=\"line\">            res += roman_int_dic[x]</div><div class=\"line\">            pre = roman_int_dic[x]</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            res -= roman_int_dic[x]</div><div class=\"line\">            pre = roman_int_dic[x]</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 数字转罗马</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int_to_roman</span><span class=\"params\">(i)</span>:</span></div><div class=\"line\">    dic = &#123;</div><div class=\"line\">        <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>, <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>, <span class=\"number\">500</span>: <span class=\"string\">'D'</span>, <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</div><div class=\"line\">        <span class=\"number\">100</span>: <span class=\"string\">'C'</span>, <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>, <span class=\"number\">50</span>: <span class=\"string\">'L'</span>, <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</div><div class=\"line\">        <span class=\"number\">10</span>: <span class=\"string\">'X'</span>, <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>, <span class=\"number\">5</span>: <span class=\"string\">'V'</span>, <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>, <span class=\"number\">1</span>: <span class=\"string\">'I'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    res = <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</div><div class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">0</span>:</div><div class=\"line\">            res += i // k * dic[k]</div><div class=\"line\">            i %= k</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    result = roman_to_int(<span class=\"string\">'MMMCMXCIX'</span>)</div><div class=\"line\">    print(result)</div><div class=\"line\"></div><div class=\"line\">    int_res = int_to_roman(<span class=\"number\">3999</span>)</div><div class=\"line\">    print(int_res)</div><div class=\"line\"></div><div class=\"line\">    result = roman_to_int(<span class=\"string\">'MCMLXXX'</span>)</div><div class=\"line\">    print(result)</div><div class=\"line\"></div><div class=\"line\">    int_res = int_to_roman(<span class=\"number\">1980</span>)</div><div class=\"line\">    print(int_res)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'III'</span>) == <span class=\"number\">3</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'IV'</span>) == <span class=\"number\">4</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'VI'</span>) == <span class=\"number\">6</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'XIX'</span>) == <span class=\"number\">19</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'XLV'</span>) == <span class=\"number\">45</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'MCMLXXX'</span>) == <span class=\"number\">1980</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'CMXCIX'</span>) == <span class=\"number\">999</span></div><div class=\"line\">    print(<span class=\"string\">\"OK\"</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(<span class=\"string\">'MMMCMXCIX'</span>)</div><div class=\"line\"><span class=\"number\">3999</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">3999</span>)</div><div class=\"line\">MMMCMXCIX</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</div><div class=\"line\"><span class=\"number\">1980</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">1980</span>)</div><div class=\"line\">MCMLXXX</div></pre></td></tr></table></figure>\n<p>结果与要求一致</p>\n<p>End~</p>\n<hr>\n","excerpt":"<p><img src=\"/images/imagesource/17-07-08.jpg\" alt=\"roman\"></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p>\n<p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p>\n<ol>\n<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li>\n<li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li>\n<li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li>\n<li>在一个数的上面画一条横线，表示这个数曾1000倍</li>\n</ol>","more":"<p><strong>常见罗马字符表</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数字</th>\n<th style=\"text-align:center\">罗马字符</th>\n<th style=\"text-align:center\">数字</th>\n<th style=\"text-align:center\">罗马字符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Ⅰ</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Ⅱ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">Ⅲ</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">Ⅳ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Ⅴ</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">Ⅵ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">Ⅶ</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">Ⅷ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">Ⅸ</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">Ⅹ</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">XL</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">90</td>\n<td style=\"text-align:center\">XC</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">CD</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">900</td>\n<td style=\"text-align:center\">CM</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">M</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">MM</td>\n<td style=\"text-align:center\">2500</td>\n<td style=\"text-align:center\">MMD</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p>\n<blockquote>\n<p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>给定一个小于3999的整数，将其转换为罗马数</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># your code</span></div><div class=\"line\">    <span class=\"keyword\">return</span> i</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'III'</span>) == <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'IV'</span>) == <span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'VI'</span>) == <span class=\"number\">6</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'XIX'</span>) == <span class=\"number\">19</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'XX'</span>) == <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romaToInt(<span class=\"string\">'XLV'</span>) == <span class=\"number\">45</span></div><div class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">'MCMLXXX'</span>) == <span class=\"number\">1980</span></div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"罗马数转阿拉伯数\"><a href=\"#罗马数转阿拉伯数\" class=\"headerlink\" title=\"罗马数转阿拉伯数\"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p>\n<blockquote>\n<p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p>\n<ol>\n<li>第一位是X，表示10，pre = 0，res = 0 + 10</li>\n<li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li>\n<li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li>\n<li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li>\n<li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li>\n<li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li>\n<li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li>\n</ol>\n</blockquote>\n<p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p>\n<h3 id=\"阿拉伯数-整数-转罗马数\"><a href=\"#阿拉伯数-整数-转罗马数\" class=\"headerlink\" title=\"阿拉伯数(整数)转罗马数\"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p>\n<blockquote>\n<p>如1980，(res表示结果):</p>\n<ol>\n<li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li>\n<li>980 // 900 = 1, res += CM, 980 % 900 = 80</li>\n<li>80 // 50 = 1, res += L, 80 % 50 = 30</li>\n<li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li>\n</ol>\n</blockquote>\n<p>经过上述步骤即可得整数1980 = MCMLXXX</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"comment\"># 罗马数字转换</span></div><div class=\"line\"><span class=\"comment\"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></div><div class=\"line\"><span class=\"comment\"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># e.g.</span></div><div class=\"line\"><span class=\"comment\"># 3-&gt;III</span></div><div class=\"line\"><span class=\"comment\"># 4-&gt;IV</span></div><div class=\"line\"><span class=\"comment\"># 6-&gt;VI</span></div><div class=\"line\"><span class=\"comment\"># 19-&gt;XIX</span></div><div class=\"line\"><span class=\"comment\"># 45-&gt;XLV</span></div><div class=\"line\"><span class=\"comment\"># 999-&gt;CMXCIX</span></div><div class=\"line\"><span class=\"comment\"># 1980-&gt;MCMLXXX</span></div><div class=\"line\"><span class=\"comment\"># 3999-&gt;MMMCMXCIX</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 罗马转数字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">roman_to_int</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">    roman_int_dic = &#123;</div><div class=\"line\">        <span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'V'</span>: <span class=\"number\">5</span>, <span class=\"string\">'X'</span>: <span class=\"number\">10</span>,</div><div class=\"line\">        <span class=\"string\">'L'</span>: <span class=\"number\">50</span>, <span class=\"string\">'C'</span>: <span class=\"number\">100</span>, <span class=\"string\">'D'</span>: <span class=\"number\">500</span>,</div><div class=\"line\">        <span class=\"string\">'M'</span>: <span class=\"number\">1000</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    s = s[::<span class=\"number\">-1</span>]</div><div class=\"line\">    res, pre = <span class=\"number\">0</span>, <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> s:</div><div class=\"line\">        <span class=\"keyword\">if</span> roman_int_dic[x] &gt;= pre:</div><div class=\"line\">            res += roman_int_dic[x]</div><div class=\"line\">            pre = roman_int_dic[x]</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            res -= roman_int_dic[x]</div><div class=\"line\">            pre = roman_int_dic[x]</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 数字转罗马</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int_to_roman</span><span class=\"params\">(i)</span>:</span></div><div class=\"line\">    dic = &#123;</div><div class=\"line\">        <span class=\"number\">1000</span>: <span class=\"string\">'M'</span>, <span class=\"number\">900</span>: <span class=\"string\">'CM'</span>, <span class=\"number\">500</span>: <span class=\"string\">'D'</span>, <span class=\"number\">400</span>: <span class=\"string\">'CD'</span>,</div><div class=\"line\">        <span class=\"number\">100</span>: <span class=\"string\">'C'</span>, <span class=\"number\">90</span>: <span class=\"string\">'XC'</span>, <span class=\"number\">50</span>: <span class=\"string\">'L'</span>, <span class=\"number\">40</span>: <span class=\"string\">'XL'</span>,</div><div class=\"line\">        <span class=\"number\">10</span>: <span class=\"string\">'X'</span>, <span class=\"number\">9</span>: <span class=\"string\">'IX'</span>, <span class=\"number\">5</span>: <span class=\"string\">'V'</span>, <span class=\"number\">4</span>: <span class=\"string\">'IV'</span>, <span class=\"number\">1</span>: <span class=\"string\">'I'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    res = <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</div><div class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">0</span>:</div><div class=\"line\">            res += i // k * dic[k]</div><div class=\"line\">            i %= k</div><div class=\"line\">    <span class=\"keyword\">return</span> res</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 测试</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    result = roman_to_int(<span class=\"string\">'MMMCMXCIX'</span>)</div><div class=\"line\">    print(result)</div><div class=\"line\"></div><div class=\"line\">    int_res = int_to_roman(<span class=\"number\">3999</span>)</div><div class=\"line\">    print(int_res)</div><div class=\"line\"></div><div class=\"line\">    result = roman_to_int(<span class=\"string\">'MCMLXXX'</span>)</div><div class=\"line\">    print(result)</div><div class=\"line\"></div><div class=\"line\">    int_res = int_to_roman(<span class=\"number\">1980</span>)</div><div class=\"line\">    print(int_res)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'III'</span>) == <span class=\"number\">3</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'IV'</span>) == <span class=\"number\">4</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'VI'</span>) == <span class=\"number\">6</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'XIX'</span>) == <span class=\"number\">19</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'XLV'</span>) == <span class=\"number\">45</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'MCMLXXX'</span>) == <span class=\"number\">1980</span></div><div class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">'CMXCIX'</span>) == <span class=\"number\">999</span></div><div class=\"line\">    print(<span class=\"string\">\"OK\"</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(<span class=\"string\">'MMMCMXCIX'</span>)</div><div class=\"line\"><span class=\"number\">3999</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">3999</span>)</div><div class=\"line\">MMMCMXCIX</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</div><div class=\"line\"><span class=\"number\">1980</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">1980</span>)</div><div class=\"line\">MCMLXXX</div></pre></td></tr></table></figure>\n<p>结果与要求一致</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】阿姆斯特朗数","date":"2017-08-04T10:37:51.000Z","comments":1,"_content":"\n![armstrong](/images/imagesource/17-08-04.jpg )\n快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog...)，今天诈尸更新一下~~\n\n\n\n一个经典的编程练习题：\n> 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。\n如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数\n\n## 问题\n> 输出1000以内的所有阿姆斯特朗数。\n\n**附加题**\n> 输入一个整数，输出距离它最近的阿姆斯特朗数。\n\n<!--more-->\n\n## 思路\n\n一眼看到阿姆斯特朗就想到了[《银魂》](http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0)**阿姆斯特朗回旋加速喷气式阿姆斯特朗炮**了，果然银魂毁节操QAQ。\n\n回到主题，其实阿姆斯特朗数和[水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)差不多。\n满足阿姆斯特朗数的公式如下，设 $ n = d\\_kd\\_{k-1}\\cdots d\\_1 $，则有\n\n$$\nn = d\\_k^k + d\\_{k-1}^k+\\cdots+d\\_2^k+d\\_1^k\n$$\n\n编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。\n\n```python\ntemp = num\nwhile temp:\n    # 求出每位数的k次幂的和\n    res += (temp % 10)**n\n    num //= 10\nif res == num:\n    # 如果满足阿姆斯特朗数的条件，就返回这个数\n    return num\n```\n\n## Python实现\n```python\n# -*- coding: utf-8 -*-\n\n\n# 得到bound以内的阿姆斯特朗数，bound默认为1000\ndef get_number(bound=1000):\n    armstrong_number = []\n    for i in range(bound):\n        temp = i\n        n = len(str(i))\n        res = 0\n        while temp:\n            res += (temp % 10) ** n\n            temp //= 10\n        if res == i:\n            armstrong_number.append(i)\n    return armstrong_number\n\n\n# 得到离number最近的阿姆斯特朗数\ndef get_nearest_number(num):\n    if is_arm_num(num):\n        return num\n    temp = num\n    res = get_number(temp)[-1]\n    while not is_arm_num(temp):\n        temp += 1\n    res_new = temp\n    if abs(res_new - num) < abs(res - num):\n        return res_new\n    else:\n        return res\n\n\n# 判断num是否是阿姆斯特朗数\ndef is_arm_num(num):\n    temp = num\n    res = 0\n    n = len(str(num))\n    while temp:\n        res += (temp % 10) ** n\n        temp //= 10\n    return res == num\n\n\nif __name__ == '__main__':\n    print(get_number())\n    print(get_nearest_number(390))\n    print(get_nearest_number(389))\n\n```\n\n## 测试\n\n输出结果\n\n```ptyhon\n>>> get_number(1000)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]\n\n>>> get_nearest_number(390)\n407\n\n>>> get_nearest_number(389)\n371\n```\n\n满足问题要求\n\n## 参考资料\n[1]: [Wiki 水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)\n\nEnd~\n\n---\n\n\n\n","source":"_posts/【每周一坑】阿姆斯特朗数.md","raw":"---\ntitle: 【每周一坑】阿姆斯特朗数\ndate: 2017-08-04 18:37:51\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![armstrong](/images/imagesource/17-08-04.jpg )\n快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog...)，今天诈尸更新一下~~\n\n\n\n一个经典的编程练习题：\n> 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。\n如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数\n\n## 问题\n> 输出1000以内的所有阿姆斯特朗数。\n\n**附加题**\n> 输入一个整数，输出距离它最近的阿姆斯特朗数。\n\n<!--more-->\n\n## 思路\n\n一眼看到阿姆斯特朗就想到了[《银魂》](http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0)**阿姆斯特朗回旋加速喷气式阿姆斯特朗炮**了，果然银魂毁节操QAQ。\n\n回到主题，其实阿姆斯特朗数和[水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)差不多。\n满足阿姆斯特朗数的公式如下，设 $ n = d\\_kd\\_{k-1}\\cdots d\\_1 $，则有\n\n$$\nn = d\\_k^k + d\\_{k-1}^k+\\cdots+d\\_2^k+d\\_1^k\n$$\n\n编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。\n\n```python\ntemp = num\nwhile temp:\n    # 求出每位数的k次幂的和\n    res += (temp % 10)**n\n    num //= 10\nif res == num:\n    # 如果满足阿姆斯特朗数的条件，就返回这个数\n    return num\n```\n\n## Python实现\n```python\n# -*- coding: utf-8 -*-\n\n\n# 得到bound以内的阿姆斯特朗数，bound默认为1000\ndef get_number(bound=1000):\n    armstrong_number = []\n    for i in range(bound):\n        temp = i\n        n = len(str(i))\n        res = 0\n        while temp:\n            res += (temp % 10) ** n\n            temp //= 10\n        if res == i:\n            armstrong_number.append(i)\n    return armstrong_number\n\n\n# 得到离number最近的阿姆斯特朗数\ndef get_nearest_number(num):\n    if is_arm_num(num):\n        return num\n    temp = num\n    res = get_number(temp)[-1]\n    while not is_arm_num(temp):\n        temp += 1\n    res_new = temp\n    if abs(res_new - num) < abs(res - num):\n        return res_new\n    else:\n        return res\n\n\n# 判断num是否是阿姆斯特朗数\ndef is_arm_num(num):\n    temp = num\n    res = 0\n    n = len(str(num))\n    while temp:\n        res += (temp % 10) ** n\n        temp //= 10\n    return res == num\n\n\nif __name__ == '__main__':\n    print(get_number())\n    print(get_nearest_number(390))\n    print(get_nearest_number(389))\n\n```\n\n## 测试\n\n输出结果\n\n```ptyhon\n>>> get_number(1000)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]\n\n>>> get_nearest_number(390)\n407\n\n>>> get_nearest_number(389)\n371\n```\n\n满足问题要求\n\n## 参考资料\n[1]: [Wiki 水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)\n\nEnd~\n\n---\n\n\n\n","slug":"【每周一坑】阿姆斯特朗数","published":1,"updated":"2017-08-04T11:18:32.589Z","layout":"post","photos":[],"link":"","_id":"cjqojmlxm001wswqcfzfyzpne","content":"<p><img src=\"/images/imagesource/17-08-04.jpg\" alt=\"armstrong\"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p>\n<p>一个经典的编程练习题：</p>\n<blockquote>\n<p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出1000以内的所有阿姆斯特朗数。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href=\"http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0\" target=\"_blank\" rel=\"external\">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p>\n<p>回到主题，其实阿姆斯特朗数和<a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\" target=\"_blank\" rel=\"external\">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\\cdots d_1 $，则有</p>\n<p>$$<br>n = d_k^k + d_{k-1}^k+\\cdots+d_2^k+d_1^k<br>$$</p>\n<p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">temp = num</div><div class=\"line\"><span class=\"keyword\">while</span> temp:</div><div class=\"line\">    <span class=\"comment\"># 求出每位数的k次幂的和</span></div><div class=\"line\">    res += (temp % <span class=\"number\">10</span>)**n</div><div class=\"line\">    num //= <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">if</span> res == num:</div><div class=\"line\">    <span class=\"comment\"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> num</div></pre></td></tr></table></figure>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_number</span><span class=\"params\">(bound=<span class=\"number\">1000</span>)</span>:</span></div><div class=\"line\">    armstrong_number = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(bound):</div><div class=\"line\">        temp = i</div><div class=\"line\">        n = len(str(i))</div><div class=\"line\">        res = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">while</span> temp:</div><div class=\"line\">            res += (temp % <span class=\"number\">10</span>) ** n</div><div class=\"line\">            temp //= <span class=\"number\">10</span></div><div class=\"line\">        <span class=\"keyword\">if</span> res == i:</div><div class=\"line\">            armstrong_number.append(i)</div><div class=\"line\">    <span class=\"keyword\">return</span> armstrong_number</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 得到离number最近的阿姆斯特朗数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_nearest_number</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> is_arm_num(num):</div><div class=\"line\">        <span class=\"keyword\">return</span> num</div><div class=\"line\">    temp = num</div><div class=\"line\">    res = get_number(temp)[<span class=\"number\">-1</span>]</div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> is_arm_num(temp):</div><div class=\"line\">        temp += <span class=\"number\">1</span></div><div class=\"line\">    res_new = temp</div><div class=\"line\">    <span class=\"keyword\">if</span> abs(res_new - num) &lt; abs(res - num):</div><div class=\"line\">        <span class=\"keyword\">return</span> res_new</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> res</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 判断num是否是阿姆斯特朗数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_arm_num</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    temp = num</div><div class=\"line\">    res = <span class=\"number\">0</span></div><div class=\"line\">    n = len(str(num))</div><div class=\"line\">    <span class=\"keyword\">while</span> temp:</div><div class=\"line\">        res += (temp % <span class=\"number\">10</span>) ** n</div><div class=\"line\">        temp //= <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"keyword\">return</span> res == num</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(get_number())</div><div class=\"line\">    print(get_nearest_number(<span class=\"number\">390</span>))</div><div class=\"line\">    print(get_nearest_number(<span class=\"number\">389</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; get_number(1000)</div><div class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; get_nearest_number(390)</div><div class=\"line\">407</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; get_nearest_number(389)</div><div class=\"line\">371</div></pre></td></tr></table></figure>\n<p>满足问题要求</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\" target=\"_blank\" rel=\"external\">Wiki 水仙花数</a></p>\n<p>End~</p>\n<hr>\n","excerpt":"<p><img src=\"/images/imagesource/17-08-04.jpg\" alt=\"armstrong\"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p>\n<p>一个经典的编程练习题：</p>\n<blockquote>\n<p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出1000以内的所有阿姆斯特朗数。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p>\n</blockquote>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href=\"http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0\">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p>\n<p>回到主题，其实阿姆斯特朗数和<a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\\cdots d_1 $，则有</p>\n<p>$$<br>n = d_k^k + d_{k-1}^k+\\cdots+d_2^k+d_1^k<br>$$</p>\n<p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">temp = num</div><div class=\"line\"><span class=\"keyword\">while</span> temp:</div><div class=\"line\">    <span class=\"comment\"># 求出每位数的k次幂的和</span></div><div class=\"line\">    res += (temp % <span class=\"number\">10</span>)**n</div><div class=\"line\">    num //= <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">if</span> res == num:</div><div class=\"line\">    <span class=\"comment\"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> num</div></pre></td></tr></table></figure>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_number</span><span class=\"params\">(bound=<span class=\"number\">1000</span>)</span>:</span></div><div class=\"line\">    armstrong_number = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(bound):</div><div class=\"line\">        temp = i</div><div class=\"line\">        n = len(str(i))</div><div class=\"line\">        res = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">while</span> temp:</div><div class=\"line\">            res += (temp % <span class=\"number\">10</span>) ** n</div><div class=\"line\">            temp //= <span class=\"number\">10</span></div><div class=\"line\">        <span class=\"keyword\">if</span> res == i:</div><div class=\"line\">            armstrong_number.append(i)</div><div class=\"line\">    <span class=\"keyword\">return</span> armstrong_number</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 得到离number最近的阿姆斯特朗数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_nearest_number</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> is_arm_num(num):</div><div class=\"line\">        <span class=\"keyword\">return</span> num</div><div class=\"line\">    temp = num</div><div class=\"line\">    res = get_number(temp)[<span class=\"number\">-1</span>]</div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> is_arm_num(temp):</div><div class=\"line\">        temp += <span class=\"number\">1</span></div><div class=\"line\">    res_new = temp</div><div class=\"line\">    <span class=\"keyword\">if</span> abs(res_new - num) &lt; abs(res - num):</div><div class=\"line\">        <span class=\"keyword\">return</span> res_new</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> res</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 判断num是否是阿姆斯特朗数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_arm_num</span><span class=\"params\">(num)</span>:</span></div><div class=\"line\">    temp = num</div><div class=\"line\">    res = <span class=\"number\">0</span></div><div class=\"line\">    n = len(str(num))</div><div class=\"line\">    <span class=\"keyword\">while</span> temp:</div><div class=\"line\">        res += (temp % <span class=\"number\">10</span>) ** n</div><div class=\"line\">        temp //= <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"keyword\">return</span> res == num</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(get_number())</div><div class=\"line\">    print(get_nearest_number(<span class=\"number\">390</span>))</div><div class=\"line\">    print(get_nearest_number(<span class=\"number\">389</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; get_number(1000)</div><div class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; get_nearest_number(390)</div><div class=\"line\">407</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; get_nearest_number(389)</div><div class=\"line\">371</div></pre></td></tr></table></figure>\n<p>满足问题要求</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">Wiki 水仙花数</a></p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】螺旋矩阵","date":"2017-06-23T11:44:50.000Z","comments":1,"_content":"\n**螺旋矩阵**是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。\n![matrix](/images/imagesource/17-06-23.jpg )\n<!--more-->\n\n## 问题\n\n> 输出如图的螺旋矩阵\n>\n```\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n```\n\n**附加题**\n> 输入一个正整数N，输出以N为边长的螺旋矩阵。\n\n## 思路\n\n需要找到数字在二维数组中赋值的规律：\n\n1. 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；\n2. 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；\n3. 从第一行，当y < N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；\n4. 然后开始递增x(x<N)，y不变,为matrix[x][y]赋新值(从上至下)；\n5. 接下来开始递减y(y>=0)，x不变，为matrix[x][y]赋新值(从右至左)；\n6. 最后递减x(x>=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；\n7. 重复**3-6**步，直到最后赋的值等于N的平方\n\n\n## Python实现\n\n```python\n#  -*- coding: utf-8 -*-\n# 打印输出螺旋矩阵\n\n\ndef gen_matrix(n):\n    # 用二维数组来代表矩阵\n    matrix = [[0 for col in range(n)] for row in range(n)]\n    return matrix\n\n\ndef get_rota_matrix(n):\n    mat = gen_matrix(n)  # 初始矩阵，所有元素都为0\n    x = y = 0\n    total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1\n    while total != n * n:\n        while y + 1 < n and not mat[x][y + 1]: # 从左至右\n            y += 1\n            total += 1\n            mat[x][y] = total\n        while x + 1 < n and not mat[x + 1][y]: # 从上之下\n            x += 1\n            total += 1\n            mat[x][y] = total\n        while y - 1 >= 0 and not mat[x][y - 1]: # 从右至左\n            y -= 1\n            total += 1\n            mat[x][y] = total\n        while x - 1 >= 0 and not mat[x - 1][y]: # 从下至上\n            x -= 1\n            total += 1\n            mat[x][y] = total\n    return mat\n\n\nif __name__ == '__main__':\n    n = int(input(\"请输入矩形数组的大小:\"))\n    matrix = get_rota_matrix(n)\n    # print(matrix)\n    for i in range(n):\n        for j in range(n):\n            print('%4d' % matrix[i][j], end=\" \")\n        print()\n\n```\n\n## 测试\n\n输出结果\n当N = 4 时：\n```\n>>> 请输入矩形数组的大小： 4\n\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n\n```\n\n当N = 5 时：\n```\n>>> 请输入矩形数组的大小： 5\n\n    1     2     3     4    5 \n  16   17   18   19    6 \n  15   24   25   20    7 \n  14   23   22   21    8 \n  13   12   11   10    9 \n```\n\n结果与要求一致，可以输出任意N的螺旋矩阵。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】螺旋矩阵.md","raw":"---\ntitle: 【每周一坑】螺旋矩阵\ndate: 2017-06-23 19:44:50\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n**螺旋矩阵**是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。\n![matrix](/images/imagesource/17-06-23.jpg )\n<!--more-->\n\n## 问题\n\n> 输出如图的螺旋矩阵\n>\n```\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n```\n\n**附加题**\n> 输入一个正整数N，输出以N为边长的螺旋矩阵。\n\n## 思路\n\n需要找到数字在二维数组中赋值的规律：\n\n1. 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；\n2. 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；\n3. 从第一行，当y < N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；\n4. 然后开始递增x(x<N)，y不变,为matrix[x][y]赋新值(从上至下)；\n5. 接下来开始递减y(y>=0)，x不变，为matrix[x][y]赋新值(从右至左)；\n6. 最后递减x(x>=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；\n7. 重复**3-6**步，直到最后赋的值等于N的平方\n\n\n## Python实现\n\n```python\n#  -*- coding: utf-8 -*-\n# 打印输出螺旋矩阵\n\n\ndef gen_matrix(n):\n    # 用二维数组来代表矩阵\n    matrix = [[0 for col in range(n)] for row in range(n)]\n    return matrix\n\n\ndef get_rota_matrix(n):\n    mat = gen_matrix(n)  # 初始矩阵，所有元素都为0\n    x = y = 0\n    total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1\n    while total != n * n:\n        while y + 1 < n and not mat[x][y + 1]: # 从左至右\n            y += 1\n            total += 1\n            mat[x][y] = total\n        while x + 1 < n and not mat[x + 1][y]: # 从上之下\n            x += 1\n            total += 1\n            mat[x][y] = total\n        while y - 1 >= 0 and not mat[x][y - 1]: # 从右至左\n            y -= 1\n            total += 1\n            mat[x][y] = total\n        while x - 1 >= 0 and not mat[x - 1][y]: # 从下至上\n            x -= 1\n            total += 1\n            mat[x][y] = total\n    return mat\n\n\nif __name__ == '__main__':\n    n = int(input(\"请输入矩形数组的大小:\"))\n    matrix = get_rota_matrix(n)\n    # print(matrix)\n    for i in range(n):\n        for j in range(n):\n            print('%4d' % matrix[i][j], end=\" \")\n        print()\n\n```\n\n## 测试\n\n输出结果\n当N = 4 时：\n```\n>>> 请输入矩形数组的大小： 4\n\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n\n```\n\n当N = 5 时：\n```\n>>> 请输入矩形数组的大小： 5\n\n    1     2     3     4    5 \n  16   17   18   19    6 \n  15   24   25   20    7 \n  14   23   22   21    8 \n  13   12   11   10    9 \n```\n\n结果与要求一致，可以输出任意N的螺旋矩阵。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】螺旋矩阵","published":1,"updated":"2017-06-23T12:01:46.982Z","layout":"post","photos":[],"link":"","_id":"cjqojmly10020swqc90sivvuk","content":"<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img src=\"/images/imagesource/17-06-23.jpg\" alt=\"matrix\"><br><a id=\"more\"></a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出如图的螺旋矩阵</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">  1    2    3    4</div><div class=\"line\">12  13   14   5</div><div class=\"line\">11  16   15   6</div><div class=\"line\">10    9     8   7</div></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p>\n<ol>\n<li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li>\n<li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li>\n<li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li>\n<li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li>\n<li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li>\n<li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li>\n<li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li>\n</ol>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#  -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"comment\"># 打印输出螺旋矩阵</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_matrix</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 用二维数组来代表矩阵</span></div><div class=\"line\">    matrix = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_rota_matrix</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    mat = gen_matrix(n)  <span class=\"comment\"># 初始矩阵，所有元素都为0</span></div><div class=\"line\">    x = y = <span class=\"number\">0</span></div><div class=\"line\">    total = mat[x][y] = <span class=\"number\">1</span> <span class=\"comment\"># 将数组第一个元素设为1，即mat[0][0] = 1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> total != n * n:</div><div class=\"line\">        <span class=\"keyword\">while</span> y + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y + <span class=\"number\">1</span>]: <span class=\"comment\"># 从左至右</span></div><div class=\"line\">            y += <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> x + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x + <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从上之下</span></div><div class=\"line\">            x += <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> y - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y - <span class=\"number\">1</span>]: <span class=\"comment\"># 从右至左</span></div><div class=\"line\">            y -= <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> x - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x - <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从下至上</span></div><div class=\"line\">            x -= <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">    <span class=\"keyword\">return</span> mat</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    n = int(input(<span class=\"string\">\"请输入矩形数组的大小:\"</span>))</div><div class=\"line\">    matrix = get_rota_matrix(n)</div><div class=\"line\">    <span class=\"comment\"># print(matrix)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">            print(<span class=\"string\">'%4d'</span> % matrix[i][j], end=<span class=\"string\">\" \"</span>)</div><div class=\"line\">        print()</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果<br>当N = 4 时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 4</div><div class=\"line\"></div><div class=\"line\">      1    2    3    4</div><div class=\"line\">    12  13   14   5</div><div class=\"line\">    11  16   15   6</div><div class=\"line\">    10    9     8   7</div></pre></td></tr></table></figure></p>\n<p>当N = 5 时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 5</div><div class=\"line\"></div><div class=\"line\">    1     2     3     4    5 </div><div class=\"line\">  16   17   18   19    6 </div><div class=\"line\">  15   24   25   20    7 </div><div class=\"line\">  14   23   22   21    8 </div><div class=\"line\">  13   12   11   10    9</div></pre></td></tr></table></figure></p>\n<p>结果与要求一致，可以输出任意N的螺旋矩阵。</p>\n<p>End~</p>\n<hr>\n","excerpt":"<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img src=\"/images/imagesource/17-06-23.jpg\" alt=\"matrix\"><br>","more":"</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出如图的螺旋矩阵</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">  1    2    3    4</div><div class=\"line\">12  13   14   5</div><div class=\"line\">11  16   15   6</div><div class=\"line\">10    9     8   7</div></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p>\n<ol>\n<li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li>\n<li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li>\n<li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li>\n<li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li>\n<li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li>\n<li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li>\n<li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li>\n</ol>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#  -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"comment\"># 打印输出螺旋矩阵</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_matrix</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 用二维数组来代表矩阵</span></div><div class=\"line\">    matrix = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(n)]</div><div class=\"line\">    <span class=\"keyword\">return</span> matrix</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_rota_matrix</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    mat = gen_matrix(n)  <span class=\"comment\"># 初始矩阵，所有元素都为0</span></div><div class=\"line\">    x = y = <span class=\"number\">0</span></div><div class=\"line\">    total = mat[x][y] = <span class=\"number\">1</span> <span class=\"comment\"># 将数组第一个元素设为1，即mat[0][0] = 1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> total != n * n:</div><div class=\"line\">        <span class=\"keyword\">while</span> y + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y + <span class=\"number\">1</span>]: <span class=\"comment\"># 从左至右</span></div><div class=\"line\">            y += <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> x + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x + <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从上之下</span></div><div class=\"line\">            x += <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> y - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y - <span class=\"number\">1</span>]: <span class=\"comment\"># 从右至左</span></div><div class=\"line\">            y -= <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">        <span class=\"keyword\">while</span> x - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x - <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从下至上</span></div><div class=\"line\">            x -= <span class=\"number\">1</span></div><div class=\"line\">            total += <span class=\"number\">1</span></div><div class=\"line\">            mat[x][y] = total</div><div class=\"line\">    <span class=\"keyword\">return</span> mat</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    n = int(input(<span class=\"string\">\"请输入矩形数组的大小:\"</span>))</div><div class=\"line\">    matrix = get_rota_matrix(n)</div><div class=\"line\">    <span class=\"comment\"># print(matrix)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">            print(<span class=\"string\">'%4d'</span> % matrix[i][j], end=<span class=\"string\">\" \"</span>)</div><div class=\"line\">        print()</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果<br>当N = 4 时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 4</div><div class=\"line\"></div><div class=\"line\">      1    2    3    4</div><div class=\"line\">    12  13   14   5</div><div class=\"line\">    11  16   15   6</div><div class=\"line\">    10    9     8   7</div></pre></td></tr></table></figure></p>\n<p>当N = 5 时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 5</div><div class=\"line\"></div><div class=\"line\">    1     2     3     4    5 </div><div class=\"line\">  16   17   18   19    6 </div><div class=\"line\">  15   24   25   20    7 </div><div class=\"line\">  14   23   22   21    8 </div><div class=\"line\">  13   12   11   10    9</div></pre></td></tr></table></figure></p>\n<p>结果与要求一致，可以输出任意N的螺旋矩阵。</p>\n<p>End~</p>\n<hr>"},{"title":"二叉树相关问题(转载)","date":"2017-10-09T11:33:35.000Z","comments":1,"_content":"\n文章转自 http://blog.csdn.net/walkinginthewind/article/details/7518888\n\n# 二叉树\n\n树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。\n\n<!--more-->\n\n# 二叉树节点定义\n\n```C++\n/* Definition for a binary tree node*/\nstruct TreeNode {\n    int val;\n    TreeNode* left;    // left tree node\n    TreeNode* right;   // right tree node\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}    // ctor\n};\n```\n\n# 问题列表\n\n二叉树的大部分题目都应用了递归，时刻往递归结构去思考。\n\n[1. 求二叉树中的节点个数](#nodeNum)  \n[2. 求二叉树的深度](#nodeDepth)  \n[3. 前序、中序、后序遍历](#nodeTraverse)  \n[4. 其他遍历二叉树方法（深度、广度优先）](#nodeDFSBFS)  \n[5. 将二叉查找树变为有序的双向链表](#nodeList)  \n[6. 求二叉树第K层的节点个数](#nodeKth)  \n[7. 求二叉树中叶子节点的个数](#nodeLeaf)  \n[8. 判断两棵二叉树结构是否相同](#nodeStructure)  \n[9. 判断二叉树是不是平衡二叉树](#nodeAVL)  \n[10. 求二叉树的镜像](#nodeMirror)  \n[11. 求二叉树中两个节点的最低公共祖先节点](#nodeAncestor)  \n[12. 求二叉树中节点的最大距离](#nodeDistance)  \n[13. 由前序遍历序列和中序遍历序列重建二叉树](#nodeRebuild)  \n[14. 判断二叉树是不是完全二叉树](#nodeComplete)\n\n# 详细解答\n\n## <span id=\"nodeNum\">**求二叉树中的节点个数**</span>\n\n递归解法：\n1. 如果二叉树为空，节点个数为\n2. 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1\n\n参考代码：\n```c++\nint getNodeNum(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    return getNodeNum(root->left) + getNodeNum(root->right) + 1;\n}\n```\n\n## <span id=\"nodeDepth\">**求二叉树的深度**</span>\n\n递归解法：\n1. 如果二叉树为空，二叉树的深度为0\n2. 如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1\n\n参考代码：\n```c++\nint getDepth(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    int depthLeft = getDepth(root->left);\n    int depthRight = getDepth(root->right);\n    return depthLeft > depthRight ? depthLeft + 1 : depthRight + 1;\n}\n```\n\n## <span id=\"nodeTraverse\">**前序、中序、后序遍历**</span>\n\n### 前序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树\n\n参考代码：\n```c++\nvoid preOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    visit(root);                     // 访问根结点\n    preOrderTraverse(root->left);    // 前序遍历左子树\n    preOrderTraverse(root->right);   // 前序遍历右子树\n}\n```\n\n### 中序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树\n\n参考代码：\n```c++\nvoid inOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    inOrderTraverse(root->left);    // 中序遍历左子树\n    visit(root)；                   // 访问根结点\n    inOrderTraverse(root->right);   // 中序遍历右子树\n}\n```\n\n### 后序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点\n\n参考代码：\n```c++\nvoid postOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    postOrderTraverse(root->left);    // 后序遍历左子树\n    postOrderTraverse(root->right);   // 后序遍历右子树\n    visit(root);                      // 访问根结点\n}\n```\n\n## <span id=\"nodeDFSBFS\">**其他遍历二叉树方法(深度、广度优先)**</span>\n\n### 深度优先遍历解法：\n1. 借助一个栈（后进先出）来实现深度遍历\n2. 先访问根结点\n3. 遍历左子树接着遍历右子树\n\n参考代码：\n```c++\nvoid DFS(TreeNode* root)\n{\n    if (!root) return;\n    stack<TreeNode*> nodeStack;\n    nodeStack.push(root);\n    while (!nodeStack.empty()) {\n        TreeNode *tmp = nodeStack.top();\n        visit(tmp);\n        nodeStack.pop();\n        if (tmp->right)\n            nodeStack.push(tmp->right);\n        if (tmp->left)\n            nodeStack.push(tmp->left);\n    }\n}\n```\n\n### 广度优先遍历解法：\n1. 借助队列（先进先出）来实现广度优先遍历\n2. 将根节点入队\n3. 当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队\n\n参考代码：\n```c++\nvoid BFS(TreeNode* root)\n{\n    if (!root) return;\n    queue<TreeNode*> nodeQueue;\n    q.push(root);\n    while (!nodeQueue.empty()) {\n        TreeNode *tmp = q.front();\n        q.pop();\n        visit(tmp);\n        if (tmp->left)\n            nodeQueue.push(tmp->left);\n        if (tmp->right)\n            nodeQueue.push(tmp->right);\n}\n```\n\n## <span id=\"nodeList\">**将二叉查找树变为有序的双向链表**</span>\n\n要求不创建新节点，只调整指针。\n递归解法：\n1. 如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL\n2. 如果二叉查找树不为空：\n    如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；\n    如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；\n    如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；\n    如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。\n\n参考代码：\n```c++\n/**\n  * root: 二叉查找树的根结点指针\n  * pFirstNode: 转换后双向有序链表的第一个节点指针\n  * pLastNode: 转换后双向有序链表的最后一个节点指针\n  **/\n void convert(TreeNode* root, \n              TreeNode* &pFirstNode, \n              TreeNode* &pLastNode) {\n    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;\n    if (!root) {\n        pFirstNode = NULL;\n        pLastNode = NULL;\n        return;\n    }\n\n    if (!root->left)\n        // 如果左子树为空，对应双向有序链表的第一个节点是根节点\n        pFirstNode = root;\n    else {\n        convert(root->left, pFirstLeft, pLastLeft);\n        // 二叉查找树对应双向有序链表的第一个节点就是\n        // 左子树转换后双向有序链表的第一个节点\n        pFristNode = pFirstLeft;\n        // 将根节点与左子树转换后的双向有序链表的最后一个节点连接\n        root->left = pLastLeft;\n        pLastLeft->right = root;\n    }\n\n    if (!root->right)\n        // 对应双向有序链表的最后一个节点是根节点\n        pLastNode = root;\n    else {\n        convert(root->right, pFirstRight, pLastRight);\n        // 对应双向有序链表的最后一个节点就是\n        // 右子树转换后双向有序链表的最后一个节点\n        pLastNode = pLastRight;\n        // 将根节点和右子树转换后的双向有序链表的第一个节点连接\n        root->right = pFirstRight;\n        pFirstRight->left = root;\n    }\n}\n```\n\n## <span id=\"nodeKth\">**求二叉树第K层的节点个数**</span>\n\n递归解法:\n1. 如果二叉树为空或者k < 1，返回0\n2. 如果二叉树不为空且k = 1，返回1\n3. 如果二叉树不为空且k > 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和\n\n参考代码：\n```c++\nint getKthLevelNodeNum(TreeNode* root)\n{\n    if (!roo || k < 1) return 0;\n    if (k == 1) return 1;\n    \n    int leftNum = getKthLevelNodeNum(root->left);    // 左子树中k-1层节点个数\n    int rightNum = getKthLevelNodeNum(root->right);  // 右子树中k-1层节点个数\n    return (leftNum + rightNum);\n}\n```\n\n## <span id=\"nodeLeaf\">**求二叉树中叶子节点的个数**</span>\n\n递归解法：\n1. 如果二叉树为空，返回0\n2. 如果二叉树不为空且左右子树为空，返回1\n3. 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数\n\n参考代码：\n```c++\nint getLeafNodeNum(TreeNode* root)\n{\n    if (!root) return 0;\n    if(!root->left && !root->right) return 1;\n    \n    int numLeft = getLeafNodeNum(root->left);    // 左子树中叶节点个数\n    int numRight = getLeafNodeNum(root->right);  // 右子树中叶节点个数\n    return (numLeft + numRight);\n}\n```\n\n## <span id=\"nodeStructure\">**判断两棵二叉树结构是否相同**</span>\n\n不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。\n递归解法:\n1. 如果两棵二叉树都为空，返回真\n2. 如果两颗二叉树一棵为空，另一个不为空，返回假\n3. 如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假\n\n参考代码：\n```c++\nbool structureCmp(TreeNode* lhs, TreeNode* rhs)\n{\n    if (!lhs && !rhs) return true;           // 都为空树，返回真\n    else if (!lhs || !rhs) return false;     // 一个为空而另一个不为空，返回假\nbool resultLeft = structureCmp(lhs->left, rhs->left);    // 比较对应左子树\nbool resultRight = structureCmp(lhs->right, rhs->right); // 比较对应右子树\nreturn (resultLeft && resultRight);\n}\n```\n\n## <span id=\"nodeAVL\">**判断二叉树是不是平衡二叉树**</span>\n\n递归解法：\n1. 如果二叉树为空，返回真\n2. 如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假\n\n参考代码：\n```c++\nboo isAVL(TreeNode* root, int &height)\n{\n    if (!root) {    // 空树，返回真\n        height = 0;\n        return true;\n    }\n    \n    int heightLeft;\n    bool resultLeft = isAVL(root->left, heightLeft);\n    int heightRight;\n    bool resultRight = isAVL(root->right, heightRight);\n    if (resultLeft && resultRight && abs(heightLeft - heightRight) <= 1){    \n        // 左右子树都是AVL树，并且高度差不大于1，返回真\n        height = max(heightLeft, heightRight) + 1;\n        return true;\n    }\n    else {\n        height = max(heightLeft, heightRight) + 1;\n        return false;\n    }\n}\n```\n\n## <span id=\"nodeMirror\">**求二叉树的镜像**</span>\n\n递归解法：\n1. 如果二叉树为空，返回空\n2. 如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树\n\n参考代码：\n```c++\nTreeNode* mirrorTree(TreeNode* root)\n{\n    if (!root) return NULL;\n    \n    TreeNode *leftTree = mirrorTree(root->left);    // 求左子树镜像\n    TreeNode *rightTree = mirrorTree(root->right);  // 求右子树镜像\n    // 交换左右子树\n    root->left = leftTree;\n    root->right = rightTree;\n    return root;\n}\n```\n\n## <span id=\"nodeAncestor\">**求二叉树中两个节点的最低公共祖先节点**</span>\n\n### 递归解法：\n\n1. 如果两个节点分别在根结点的左子树和右子树，则返回根结点\n2. 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树\n\n参考代码：\n```c++\nbool findNode(TreeNode* root, TreeNode *pNode)\n{\n    if (!root || !pNode) return false;\n    \n    if (root == pNode) return true;\n    bool found = findNode(root->left, pNode);\n    if (!found)\n        found = findNode(root->right, pNode);\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode* root,\n                                  TreeNode* pNode1,\n                                  TreeNode* pNode2)\n{\n    if (findNode(root->left, pNode1)) {\n        if (findNode(root->right, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->left, pNode1, pNode2);\n    }\n    else {\n        if (find(root->left, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->right, pNode1, pNode2);\n    }\n}\n```\n\n递归解法效率较低，有很多重复遍历，下面看一下非递归解法。\n\n### 非递归解法：\n\n先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点\n\n参考代码：\n```c++\nbool getNodePath(TreeNode* root, \n                 TreeNode* pNode, \n                 list<TreeNode*> &path)\n{\n    if (root == pNode) {\n        path.push_back(root);\n        return true;\n    }\n    if (!root) return false;\n    path.push_back(root);\n    bool found = false;\n    found = getNodePath(root->left, pNode, path);\n    if (!found)\n        found = getNodePath(root->right, pNode, path);\n    if (!found)\n        path.pop_back();\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode *root, \n                                  TreeNode* pNode1, \n                                  TreeNode* pNode2)\n{\n    if (!root || !pNode1 || !pNode2) return NULL;\n    \n    list<TreeNode*> path1;\n    bool result1 = getNodePath(root, pNode1, path1);\n    list<TreeNode*> path2;\n    bool result2 = getNodePath(root, pNode2, path2);\n    \n    if (!result1 || !result2) return NULL;\n    TreeNode* pLast = NULL;\n    list<TreeNode*>::iterator iter1 = path1.begin();\n    list<TreeNode*>::iterator iter2 = path2.begin();\n    while (iter != path1.end() && iter2 != path2.end()) {\n        if (*iter1 == *iter2)\n            pLast = *iter1;\n        else\n            break;\n        ++iter1;\n        ++iter2;\n    }\n    return pLast;\n}\n```\n\n在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。\n\n## <span id=\"nodeDistance\">**求二叉树中节点的最大距离**</span>\n\n即二叉树中相距最远的两个节点之间的距离。\n递归解法：\n1. 如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0\n2. 如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离\n\n参考代码：\n```c++\nint getMaxDistance(TreeNode* root, int &maxLeft, int &maxRight)\n{\n    // maxLeft: 左子树中的节点离根节点的最远距离\n    // maxRight: 右子树中的节点离根节点的最远距离\n    if (!root) {\n        maxLeft = 0;\n        maxRight = 0;\n        return 0;\n    }\n    \n    int maxLL, maxLR, maxRL, maxRR;\n    int maxDistLeft, maxDistRight;\n    if (root->left) {\n        maxDistLeft = getMaxDistance(root->left, maxLL, maxLR);\n        maxLeft = max(maxLL, maxLR) + 1;\n    }\n    else {\n        maxDistLeft = 0;\n        maxLeft = 0;\n    }\n    if (root->right) {\n        maxDistRight = getMaxDistance(root->right, maxRL, maxRR);\n        maxRight = max(maxRL, maxRR) + 1;\n    }\n    else {\n        maxDistRight = 0;\n        maxRight = 0;\n    }\n    return max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);\n}\n```\n\n## <span id=\"nodeRebuild\">**由前序遍历序列和中序遍历序列重建二叉树**</span>\n\n二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。\n递归解法：\n1. 如果前序遍历为空或者节点个数小于等于0，返回NULL。\n2. 创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树\n\n参考代码：\n```c++\n/**\n  * pPreOrder: 前序遍历序列\n  * pInOrder: 中序遍历序列\n  * nodeNum: 二叉树节点数\n  **/\nTreeNode* rebuildTree(int* pPreOrder, int* pInOrder, int nodeNum)\n{\n    if (!pPreOrder || !pInOrder || nodeNum <= 0) return NULL;\n    TreeNode* root = new TreeNode;\n    // 前序遍历的第一个节点就是根节点\n    root->val = pPreOrder[0];\n    root->left = NULL;\n    root->right = NULL;\n    // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树\n    int rootPoistionInOrder = -1;\n    for (int i = 0; i < nodeNum; ++i) {\n        if (pInOrder[i] == root->val) {\n            rootPositionInOrder = i;\n            break;\n        }\n    }\n    if (rootPositionInOrder == -1)\n        throw std::exception(\"Invalid Input.\");\n    \n    // 重建左子树\n    int nodeNumLeft = rootPositionInOrder;\n    int* pPreOrderLeft = pPreOrder + 1;\n    int* pInOrderLeft = pInOrder;\n    root->left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);\n    // 重建右子树\n    int nodeNumRight = nodeNum - nodeNumLeft -1;\n    int* pPreOrderRight = pPreOrder + 1 + nodeNumLeft;\n    int* pInOrderRight = pInOrder + nodeNumLeft + 1;\n    root->right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);\n    return root;\n}\n```\n\n同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树\n\n## <span id=\"nodeComplete\">**判断二叉树是不是完全二叉树**</span>\n\n若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。\n如何判断是否为完全二叉树：\n按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树\n\n参考代码：\n```c++\nbool isCompleteTree(TreeNode* root)\n{\n    if (!root) return false;\n    queue<TreeNode*> nodeQueue;\n    nodeQueue.push(root);\n    bool mustHaveNoChild = false;\n    bool result = true;\n    while (!nodeQueue.empty()) {\n        TreeNode* pNode = nodeQueue.front();\n        nodeQueue.pop();\n        if (mustHaveNoChild) {   // 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)\n            if (pNode->left || pNode->right) {\n                result = false;\n                break;\n            }\n        }\n        else {\n            if (pNode->left && pNode->right) {\n                nodeQueue.push(pNode->left);\n                nodeQueue.push(pNode->right);\n            }\n            else if (pNode->left && !pNode->right) {\n                mustHaveNoChild = true;\n                nodeQueue.push(pNode->left);\n            }\n            else if (!pNode->left && pNode->right) {\n                result = false;\n                break;\n            }\n            else\n                mastHaveNoChild = true;\n        }\n    }\n    return result;\n}\n```\n\n---\n","source":"_posts/二叉树相关问题-转载.md","raw":"---\ntitle: 二叉树相关问题(转载)\ndate: 2017-10-09 19:33:35\ncategory: DataStructure\ntags: BinaryTree\ncomments: true\n---\n\n文章转自 http://blog.csdn.net/walkinginthewind/article/details/7518888\n\n# 二叉树\n\n树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。\n\n<!--more-->\n\n# 二叉树节点定义\n\n```C++\n/* Definition for a binary tree node*/\nstruct TreeNode {\n    int val;\n    TreeNode* left;    // left tree node\n    TreeNode* right;   // right tree node\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}    // ctor\n};\n```\n\n# 问题列表\n\n二叉树的大部分题目都应用了递归，时刻往递归结构去思考。\n\n[1. 求二叉树中的节点个数](#nodeNum)  \n[2. 求二叉树的深度](#nodeDepth)  \n[3. 前序、中序、后序遍历](#nodeTraverse)  \n[4. 其他遍历二叉树方法（深度、广度优先）](#nodeDFSBFS)  \n[5. 将二叉查找树变为有序的双向链表](#nodeList)  \n[6. 求二叉树第K层的节点个数](#nodeKth)  \n[7. 求二叉树中叶子节点的个数](#nodeLeaf)  \n[8. 判断两棵二叉树结构是否相同](#nodeStructure)  \n[9. 判断二叉树是不是平衡二叉树](#nodeAVL)  \n[10. 求二叉树的镜像](#nodeMirror)  \n[11. 求二叉树中两个节点的最低公共祖先节点](#nodeAncestor)  \n[12. 求二叉树中节点的最大距离](#nodeDistance)  \n[13. 由前序遍历序列和中序遍历序列重建二叉树](#nodeRebuild)  \n[14. 判断二叉树是不是完全二叉树](#nodeComplete)\n\n# 详细解答\n\n## <span id=\"nodeNum\">**求二叉树中的节点个数**</span>\n\n递归解法：\n1. 如果二叉树为空，节点个数为\n2. 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1\n\n参考代码：\n```c++\nint getNodeNum(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    return getNodeNum(root->left) + getNodeNum(root->right) + 1;\n}\n```\n\n## <span id=\"nodeDepth\">**求二叉树的深度**</span>\n\n递归解法：\n1. 如果二叉树为空，二叉树的深度为0\n2. 如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1\n\n参考代码：\n```c++\nint getDepth(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    int depthLeft = getDepth(root->left);\n    int depthRight = getDepth(root->right);\n    return depthLeft > depthRight ? depthLeft + 1 : depthRight + 1;\n}\n```\n\n## <span id=\"nodeTraverse\">**前序、中序、后序遍历**</span>\n\n### 前序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树\n\n参考代码：\n```c++\nvoid preOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    visit(root);                     // 访问根结点\n    preOrderTraverse(root->left);    // 前序遍历左子树\n    preOrderTraverse(root->right);   // 前序遍历右子树\n}\n```\n\n### 中序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树\n\n参考代码：\n```c++\nvoid inOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    inOrderTraverse(root->left);    // 中序遍历左子树\n    visit(root)；                   // 访问根结点\n    inOrderTraverse(root->right);   // 中序遍历右子树\n}\n```\n\n### 后序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点\n\n参考代码：\n```c++\nvoid postOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    postOrderTraverse(root->left);    // 后序遍历左子树\n    postOrderTraverse(root->right);   // 后序遍历右子树\n    visit(root);                      // 访问根结点\n}\n```\n\n## <span id=\"nodeDFSBFS\">**其他遍历二叉树方法(深度、广度优先)**</span>\n\n### 深度优先遍历解法：\n1. 借助一个栈（后进先出）来实现深度遍历\n2. 先访问根结点\n3. 遍历左子树接着遍历右子树\n\n参考代码：\n```c++\nvoid DFS(TreeNode* root)\n{\n    if (!root) return;\n    stack<TreeNode*> nodeStack;\n    nodeStack.push(root);\n    while (!nodeStack.empty()) {\n        TreeNode *tmp = nodeStack.top();\n        visit(tmp);\n        nodeStack.pop();\n        if (tmp->right)\n            nodeStack.push(tmp->right);\n        if (tmp->left)\n            nodeStack.push(tmp->left);\n    }\n}\n```\n\n### 广度优先遍历解法：\n1. 借助队列（先进先出）来实现广度优先遍历\n2. 将根节点入队\n3. 当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队\n\n参考代码：\n```c++\nvoid BFS(TreeNode* root)\n{\n    if (!root) return;\n    queue<TreeNode*> nodeQueue;\n    q.push(root);\n    while (!nodeQueue.empty()) {\n        TreeNode *tmp = q.front();\n        q.pop();\n        visit(tmp);\n        if (tmp->left)\n            nodeQueue.push(tmp->left);\n        if (tmp->right)\n            nodeQueue.push(tmp->right);\n}\n```\n\n## <span id=\"nodeList\">**将二叉查找树变为有序的双向链表**</span>\n\n要求不创建新节点，只调整指针。\n递归解法：\n1. 如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL\n2. 如果二叉查找树不为空：\n    如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；\n    如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；\n    如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；\n    如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。\n\n参考代码：\n```c++\n/**\n  * root: 二叉查找树的根结点指针\n  * pFirstNode: 转换后双向有序链表的第一个节点指针\n  * pLastNode: 转换后双向有序链表的最后一个节点指针\n  **/\n void convert(TreeNode* root, \n              TreeNode* &pFirstNode, \n              TreeNode* &pLastNode) {\n    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;\n    if (!root) {\n        pFirstNode = NULL;\n        pLastNode = NULL;\n        return;\n    }\n\n    if (!root->left)\n        // 如果左子树为空，对应双向有序链表的第一个节点是根节点\n        pFirstNode = root;\n    else {\n        convert(root->left, pFirstLeft, pLastLeft);\n        // 二叉查找树对应双向有序链表的第一个节点就是\n        // 左子树转换后双向有序链表的第一个节点\n        pFristNode = pFirstLeft;\n        // 将根节点与左子树转换后的双向有序链表的最后一个节点连接\n        root->left = pLastLeft;\n        pLastLeft->right = root;\n    }\n\n    if (!root->right)\n        // 对应双向有序链表的最后一个节点是根节点\n        pLastNode = root;\n    else {\n        convert(root->right, pFirstRight, pLastRight);\n        // 对应双向有序链表的最后一个节点就是\n        // 右子树转换后双向有序链表的最后一个节点\n        pLastNode = pLastRight;\n        // 将根节点和右子树转换后的双向有序链表的第一个节点连接\n        root->right = pFirstRight;\n        pFirstRight->left = root;\n    }\n}\n```\n\n## <span id=\"nodeKth\">**求二叉树第K层的节点个数**</span>\n\n递归解法:\n1. 如果二叉树为空或者k < 1，返回0\n2. 如果二叉树不为空且k = 1，返回1\n3. 如果二叉树不为空且k > 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和\n\n参考代码：\n```c++\nint getKthLevelNodeNum(TreeNode* root)\n{\n    if (!roo || k < 1) return 0;\n    if (k == 1) return 1;\n    \n    int leftNum = getKthLevelNodeNum(root->left);    // 左子树中k-1层节点个数\n    int rightNum = getKthLevelNodeNum(root->right);  // 右子树中k-1层节点个数\n    return (leftNum + rightNum);\n}\n```\n\n## <span id=\"nodeLeaf\">**求二叉树中叶子节点的个数**</span>\n\n递归解法：\n1. 如果二叉树为空，返回0\n2. 如果二叉树不为空且左右子树为空，返回1\n3. 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数\n\n参考代码：\n```c++\nint getLeafNodeNum(TreeNode* root)\n{\n    if (!root) return 0;\n    if(!root->left && !root->right) return 1;\n    \n    int numLeft = getLeafNodeNum(root->left);    // 左子树中叶节点个数\n    int numRight = getLeafNodeNum(root->right);  // 右子树中叶节点个数\n    return (numLeft + numRight);\n}\n```\n\n## <span id=\"nodeStructure\">**判断两棵二叉树结构是否相同**</span>\n\n不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。\n递归解法:\n1. 如果两棵二叉树都为空，返回真\n2. 如果两颗二叉树一棵为空，另一个不为空，返回假\n3. 如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假\n\n参考代码：\n```c++\nbool structureCmp(TreeNode* lhs, TreeNode* rhs)\n{\n    if (!lhs && !rhs) return true;           // 都为空树，返回真\n    else if (!lhs || !rhs) return false;     // 一个为空而另一个不为空，返回假\nbool resultLeft = structureCmp(lhs->left, rhs->left);    // 比较对应左子树\nbool resultRight = structureCmp(lhs->right, rhs->right); // 比较对应右子树\nreturn (resultLeft && resultRight);\n}\n```\n\n## <span id=\"nodeAVL\">**判断二叉树是不是平衡二叉树**</span>\n\n递归解法：\n1. 如果二叉树为空，返回真\n2. 如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假\n\n参考代码：\n```c++\nboo isAVL(TreeNode* root, int &height)\n{\n    if (!root) {    // 空树，返回真\n        height = 0;\n        return true;\n    }\n    \n    int heightLeft;\n    bool resultLeft = isAVL(root->left, heightLeft);\n    int heightRight;\n    bool resultRight = isAVL(root->right, heightRight);\n    if (resultLeft && resultRight && abs(heightLeft - heightRight) <= 1){    \n        // 左右子树都是AVL树，并且高度差不大于1，返回真\n        height = max(heightLeft, heightRight) + 1;\n        return true;\n    }\n    else {\n        height = max(heightLeft, heightRight) + 1;\n        return false;\n    }\n}\n```\n\n## <span id=\"nodeMirror\">**求二叉树的镜像**</span>\n\n递归解法：\n1. 如果二叉树为空，返回空\n2. 如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树\n\n参考代码：\n```c++\nTreeNode* mirrorTree(TreeNode* root)\n{\n    if (!root) return NULL;\n    \n    TreeNode *leftTree = mirrorTree(root->left);    // 求左子树镜像\n    TreeNode *rightTree = mirrorTree(root->right);  // 求右子树镜像\n    // 交换左右子树\n    root->left = leftTree;\n    root->right = rightTree;\n    return root;\n}\n```\n\n## <span id=\"nodeAncestor\">**求二叉树中两个节点的最低公共祖先节点**</span>\n\n### 递归解法：\n\n1. 如果两个节点分别在根结点的左子树和右子树，则返回根结点\n2. 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树\n\n参考代码：\n```c++\nbool findNode(TreeNode* root, TreeNode *pNode)\n{\n    if (!root || !pNode) return false;\n    \n    if (root == pNode) return true;\n    bool found = findNode(root->left, pNode);\n    if (!found)\n        found = findNode(root->right, pNode);\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode* root,\n                                  TreeNode* pNode1,\n                                  TreeNode* pNode2)\n{\n    if (findNode(root->left, pNode1)) {\n        if (findNode(root->right, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->left, pNode1, pNode2);\n    }\n    else {\n        if (find(root->left, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->right, pNode1, pNode2);\n    }\n}\n```\n\n递归解法效率较低，有很多重复遍历，下面看一下非递归解法。\n\n### 非递归解法：\n\n先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点\n\n参考代码：\n```c++\nbool getNodePath(TreeNode* root, \n                 TreeNode* pNode, \n                 list<TreeNode*> &path)\n{\n    if (root == pNode) {\n        path.push_back(root);\n        return true;\n    }\n    if (!root) return false;\n    path.push_back(root);\n    bool found = false;\n    found = getNodePath(root->left, pNode, path);\n    if (!found)\n        found = getNodePath(root->right, pNode, path);\n    if (!found)\n        path.pop_back();\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode *root, \n                                  TreeNode* pNode1, \n                                  TreeNode* pNode2)\n{\n    if (!root || !pNode1 || !pNode2) return NULL;\n    \n    list<TreeNode*> path1;\n    bool result1 = getNodePath(root, pNode1, path1);\n    list<TreeNode*> path2;\n    bool result2 = getNodePath(root, pNode2, path2);\n    \n    if (!result1 || !result2) return NULL;\n    TreeNode* pLast = NULL;\n    list<TreeNode*>::iterator iter1 = path1.begin();\n    list<TreeNode*>::iterator iter2 = path2.begin();\n    while (iter != path1.end() && iter2 != path2.end()) {\n        if (*iter1 == *iter2)\n            pLast = *iter1;\n        else\n            break;\n        ++iter1;\n        ++iter2;\n    }\n    return pLast;\n}\n```\n\n在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。\n\n## <span id=\"nodeDistance\">**求二叉树中节点的最大距离**</span>\n\n即二叉树中相距最远的两个节点之间的距离。\n递归解法：\n1. 如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0\n2. 如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离\n\n参考代码：\n```c++\nint getMaxDistance(TreeNode* root, int &maxLeft, int &maxRight)\n{\n    // maxLeft: 左子树中的节点离根节点的最远距离\n    // maxRight: 右子树中的节点离根节点的最远距离\n    if (!root) {\n        maxLeft = 0;\n        maxRight = 0;\n        return 0;\n    }\n    \n    int maxLL, maxLR, maxRL, maxRR;\n    int maxDistLeft, maxDistRight;\n    if (root->left) {\n        maxDistLeft = getMaxDistance(root->left, maxLL, maxLR);\n        maxLeft = max(maxLL, maxLR) + 1;\n    }\n    else {\n        maxDistLeft = 0;\n        maxLeft = 0;\n    }\n    if (root->right) {\n        maxDistRight = getMaxDistance(root->right, maxRL, maxRR);\n        maxRight = max(maxRL, maxRR) + 1;\n    }\n    else {\n        maxDistRight = 0;\n        maxRight = 0;\n    }\n    return max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);\n}\n```\n\n## <span id=\"nodeRebuild\">**由前序遍历序列和中序遍历序列重建二叉树**</span>\n\n二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。\n递归解法：\n1. 如果前序遍历为空或者节点个数小于等于0，返回NULL。\n2. 创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树\n\n参考代码：\n```c++\n/**\n  * pPreOrder: 前序遍历序列\n  * pInOrder: 中序遍历序列\n  * nodeNum: 二叉树节点数\n  **/\nTreeNode* rebuildTree(int* pPreOrder, int* pInOrder, int nodeNum)\n{\n    if (!pPreOrder || !pInOrder || nodeNum <= 0) return NULL;\n    TreeNode* root = new TreeNode;\n    // 前序遍历的第一个节点就是根节点\n    root->val = pPreOrder[0];\n    root->left = NULL;\n    root->right = NULL;\n    // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树\n    int rootPoistionInOrder = -1;\n    for (int i = 0; i < nodeNum; ++i) {\n        if (pInOrder[i] == root->val) {\n            rootPositionInOrder = i;\n            break;\n        }\n    }\n    if (rootPositionInOrder == -1)\n        throw std::exception(\"Invalid Input.\");\n    \n    // 重建左子树\n    int nodeNumLeft = rootPositionInOrder;\n    int* pPreOrderLeft = pPreOrder + 1;\n    int* pInOrderLeft = pInOrder;\n    root->left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);\n    // 重建右子树\n    int nodeNumRight = nodeNum - nodeNumLeft -1;\n    int* pPreOrderRight = pPreOrder + 1 + nodeNumLeft;\n    int* pInOrderRight = pInOrder + nodeNumLeft + 1;\n    root->right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);\n    return root;\n}\n```\n\n同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树\n\n## <span id=\"nodeComplete\">**判断二叉树是不是完全二叉树**</span>\n\n若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。\n如何判断是否为完全二叉树：\n按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树\n\n参考代码：\n```c++\nbool isCompleteTree(TreeNode* root)\n{\n    if (!root) return false;\n    queue<TreeNode*> nodeQueue;\n    nodeQueue.push(root);\n    bool mustHaveNoChild = false;\n    bool result = true;\n    while (!nodeQueue.empty()) {\n        TreeNode* pNode = nodeQueue.front();\n        nodeQueue.pop();\n        if (mustHaveNoChild) {   // 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)\n            if (pNode->left || pNode->right) {\n                result = false;\n                break;\n            }\n        }\n        else {\n            if (pNode->left && pNode->right) {\n                nodeQueue.push(pNode->left);\n                nodeQueue.push(pNode->right);\n            }\n            else if (pNode->left && !pNode->right) {\n                mustHaveNoChild = true;\n                nodeQueue.push(pNode->left);\n            }\n            else if (!pNode->left && pNode->right) {\n                result = false;\n                break;\n            }\n            else\n                mastHaveNoChild = true;\n        }\n    }\n    return result;\n}\n```\n\n---\n","slug":"二叉树相关问题-转载","published":1,"updated":"2019-01-07T13:25:14.786Z","layout":"post","photos":[],"link":"","_id":"cjqojmly10022swqcasipqg6i","content":"<p>文章转自 <a href=\"http://blog.csdn.net/walkinginthewind/article/details/7518888\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p>\n<a id=\"more\"></a>\n<h1 id=\"二叉树节点定义\"><a href=\"#二叉树节点定义\" class=\"headerlink\" title=\"二叉树节点定义\"></a>二叉树节点定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Definition for a binary tree node*/</span></div><div class=\"line\"><span class=\"keyword\">struct</span> TreeNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    TreeNode* left;    <span class=\"comment\">// left tree node</span></div><div class=\"line\">    TreeNode* right;   <span class=\"comment\">// right tree node</span></div><div class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) : val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;    <span class=\"comment\">// ctor</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h1 id=\"问题列表\"><a href=\"#问题列表\" class=\"headerlink\" title=\"问题列表\"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p>\n<p><a href=\"#nodeNum\">1. 求二叉树中的节点个数</a><br><a href=\"#nodeDepth\">2. 求二叉树的深度</a><br><a href=\"#nodeTraverse\">3. 前序、中序、后序遍历</a><br><a href=\"#nodeDFSBFS\">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href=\"#nodeList\">5. 将二叉查找树变为有序的双向链表</a><br><a href=\"#nodeKth\">6. 求二叉树第K层的节点个数</a><br><a href=\"#nodeLeaf\">7. 求二叉树中叶子节点的个数</a><br><a href=\"#nodeStructure\">8. 判断两棵二叉树结构是否相同</a><br><a href=\"#nodeAVL\">9. 判断二叉树是不是平衡二叉树</a><br><a href=\"#nodeMirror\">10. 求二叉树的镜像</a><br><a href=\"#nodeAncestor\">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href=\"#nodeDistance\">12. 求二叉树中节点的最大距离</a><br><a href=\"#nodeRebuild\">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href=\"#nodeComplete\">14. 判断二叉树是不是完全二叉树</a></p>\n<h1 id=\"详细解答\"><a href=\"#详细解答\" class=\"headerlink\" title=\"详细解答\"></a>详细解答</h1><h2 id=\"求二叉树中的节点个数\"><a href=\"#求二叉树中的节点个数\" class=\"headerlink\" title=\"求二叉树中的节点个数\"></a><span id=\"nodeNum\"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，节点个数为</li>\n<li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树的深度\"><a href=\"#求二叉树的深度\" class=\"headerlink\" title=\"求二叉树的深度\"></a><span id=\"nodeDepth\"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，二叉树的深度为0</li>\n<li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></div><div class=\"line\">    <span class=\"keyword\">int</span> depthLeft = getDepth(root-&gt;left);</div><div class=\"line\">    <span class=\"keyword\">int</span> depthRight = getDepth(root-&gt;right);</div><div class=\"line\">    <span class=\"keyword\">return</span> depthLeft &gt; depthRight ? depthLeft + <span class=\"number\">1</span> : depthRight + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"前序、中序、后序遍历\"><a href=\"#前序、中序、后序遍历\" class=\"headerlink\" title=\"前序、中序、后序遍历\"></a><span id=\"nodeTraverse\"><strong>前序、中序、后序遍历</strong></span></h2><h3 id=\"前序遍历递归解法：\"><a href=\"#前序遍历递归解法：\" class=\"headerlink\" title=\"前序遍历递归解法：\"></a>前序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    visit(root);                     <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">    preOrderTraverse(root-&gt;left);    <span class=\"comment\">// 前序遍历左子树</span></div><div class=\"line\">    preOrderTraverse(root-&gt;right);   <span class=\"comment\">// 前序遍历右子树</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历递归解法：\"><a href=\"#中序遍历递归解法：\" class=\"headerlink\" title=\"中序遍历递归解法：\"></a>中序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    inOrderTraverse(root-&gt;left);    <span class=\"comment\">// 中序遍历左子树</span></div><div class=\"line\">    visit(root)；                   <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">    inOrderTraverse(root-&gt;right);   <span class=\"comment\">// 中序遍历右子树</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历递归解法：\"><a href=\"#后序遍历递归解法：\" class=\"headerlink\" title=\"后序遍历递归解法：\"></a>后序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    postOrderTraverse(root-&gt;left);    <span class=\"comment\">// 后序遍历左子树</span></div><div class=\"line\">    postOrderTraverse(root-&gt;right);   <span class=\"comment\">// 后序遍历右子树</span></div><div class=\"line\">    visit(root);                      <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他遍历二叉树方法-深度、广度优先\"><a href=\"#其他遍历二叉树方法-深度、广度优先\" class=\"headerlink\" title=\"其他遍历二叉树方法(深度、广度优先)\"></a><span id=\"nodeDFSBFS\"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id=\"深度优先遍历解法：\"><a href=\"#深度优先遍历解法：\" class=\"headerlink\" title=\"深度优先遍历解法：\"></a>深度优先遍历解法：</h3><ol>\n<li>借助一个栈（后进先出）来实现深度遍历</li>\n<li>先访问根结点</li>\n<li>遍历左子树接着遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; nodeStack;</div><div class=\"line\">    nodeStack.push(root);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</div><div class=\"line\">        TreeNode *tmp = nodeStack.top();</div><div class=\"line\">        visit(tmp);</div><div class=\"line\">        nodeStack.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</div><div class=\"line\">            nodeStack.push(tmp-&gt;right);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</div><div class=\"line\">            nodeStack.push(tmp-&gt;left);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"广度优先遍历解法：\"><a href=\"#广度优先遍历解法：\" class=\"headerlink\" title=\"广度优先遍历解法：\"></a>广度优先遍历解法：</h3><ol>\n<li>借助队列（先进先出）来实现广度优先遍历</li>\n<li>将根节点入队</li>\n<li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class=\"line\">    q.push(root);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</div><div class=\"line\">        TreeNode *tmp = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        visit(tmp);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</div><div class=\"line\">            nodeQueue.push(tmp-&gt;left);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</div><div class=\"line\">            nodeQueue.push(tmp-&gt;right);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"将二叉查找树变为有序的双向链表\"><a href=\"#将二叉查找树变为有序的双向链表\" class=\"headerlink\" title=\"将二叉查找树变为有序的双向链表\"></a><span id=\"nodeList\"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p>\n<ol>\n<li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li>\n<li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * root: 二叉查找树的根结点指针</div><div class=\"line\">  * pFirstNode: 转换后双向有序链表的第一个节点指针</div><div class=\"line\">  * pLastNode: 转换后双向有序链表的最后一个节点指针</div><div class=\"line\">  **/</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(TreeNode* root, </span></span></div><div class=\"line\">              TreeNode* &amp;pFirstNode, </div><div class=\"line\">              TreeNode* &amp;pLastNode) &#123;</div><div class=\"line\">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</div><div class=\"line\">        pFirstNode = <span class=\"literal\">NULL</span>;</div><div class=\"line\">        pLastNode = <span class=\"literal\">NULL</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</div><div class=\"line\">        <span class=\"comment\">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></div><div class=\"line\">        pFirstNode = root;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        convert(root-&gt;left, pFirstLeft, pLastLeft);</div><div class=\"line\">        <span class=\"comment\">// 二叉查找树对应双向有序链表的第一个节点就是</span></div><div class=\"line\">        <span class=\"comment\">// 左子树转换后双向有序链表的第一个节点</span></div><div class=\"line\">        pFristNode = pFirstLeft;</div><div class=\"line\">        <span class=\"comment\">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></div><div class=\"line\">        root-&gt;left = pLastLeft;</div><div class=\"line\">        pLastLeft-&gt;right = root;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right)</div><div class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点是根节点</span></div><div class=\"line\">        pLastNode = root;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        convert(root-&gt;right, pFirstRight, pLastRight);</div><div class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点就是</span></div><div class=\"line\">        <span class=\"comment\">// 右子树转换后双向有序链表的最后一个节点</span></div><div class=\"line\">        pLastNode = pLastRight;</div><div class=\"line\">        <span class=\"comment\">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></div><div class=\"line\">        root-&gt;right = pFirstRight;</div><div class=\"line\">        pFirstRight-&gt;left = root;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树第K层的节点个数\"><a href=\"#求二叉树第K层的节点个数\" class=\"headerlink\" title=\"求二叉树第K层的节点个数\"></a><span id=\"nodeKth\"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p>\n<ol>\n<li>如果二叉树为空或者k &lt; 1，返回0</li>\n<li>如果二叉树不为空且k = 1，返回1</li>\n<li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthLevelNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!roo || k &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中k-1层节点个数</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中k-1层节点个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (leftNum + rightNum);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树中叶子节点的个数\"><a href=\"#求二叉树中叶子节点的个数\" class=\"headerlink\" title=\"求二叉树中叶子节点的个数\"></a><span id=\"nodeLeaf\"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回0</li>\n<li>如果二叉树不为空且左右子树为空，返回1</li>\n<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLeafNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中叶节点个数</span></div><div class=\"line\">    <span class=\"keyword\">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中叶节点个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (numLeft + numRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"判断两棵二叉树结构是否相同\"><a href=\"#判断两棵二叉树结构是否相同\" class=\"headerlink\" title=\"判断两棵二叉树结构是否相同\"></a><span id=\"nodeStructure\"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p>\n<ol>\n<li>如果两棵二叉树都为空，返回真</li>\n<li>如果两颗二叉树一棵为空，另一个不为空，返回假</li>\n<li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">structureCmp</span><span class=\"params\">(TreeNode* lhs, TreeNode* rhs)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!lhs &amp;&amp; !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;           <span class=\"comment\">// 都为空树，返回真</span></div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lhs || !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;     <span class=\"comment\">// 一个为空而另一个不为空，返回假</span></div><div class=\"line\"><span class=\"keyword\">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class=\"comment\">// 比较对应左子树</span></div><div class=\"line\"><span class=\"keyword\">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class=\"comment\">// 比较对应右子树</span></div><div class=\"line\"><span class=\"keyword\">return</span> (resultLeft &amp;&amp; resultRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"判断二叉树是不是平衡二叉树\"><a href=\"#判断二叉树是不是平衡二叉树\" class=\"headerlink\" title=\"判断二叉树是不是平衡二叉树\"></a><span id=\"nodeAVL\"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回真</li>\n<li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">boo <span class=\"title\">isAVL</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;height)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;    <span class=\"comment\">// 空树，返回真</span></div><div class=\"line\">        height = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> heightLeft;</div><div class=\"line\">    <span class=\"keyword\">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</div><div class=\"line\">    <span class=\"keyword\">int</span> heightRight;</div><div class=\"line\">    <span class=\"keyword\">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class=\"built_in\">abs</span>(heightLeft - heightRight) &lt;= <span class=\"number\">1</span>)&#123;    </div><div class=\"line\">        <span class=\"comment\">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></div><div class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树的镜像\"><a href=\"#求二叉树的镜像\" class=\"headerlink\" title=\"求二叉树的镜像\"></a><span id=\"nodeMirror\"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回空</li>\n<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    </div><div class=\"line\">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class=\"comment\">// 求左子树镜像</span></div><div class=\"line\">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class=\"comment\">// 求右子树镜像</span></div><div class=\"line\">    <span class=\"comment\">// 交换左右子树</span></div><div class=\"line\">    root-&gt;left = leftTree;</div><div class=\"line\">    root-&gt;right = rightTree;</div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树中两个节点的最低公共祖先节点\"><a href=\"#求二叉树中两个节点的最低公共祖先节点\" class=\"headerlink\" title=\"求二叉树中两个节点的最低公共祖先节点\"></a><span id=\"nodeAncestor\"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id=\"递归解法：\"><a href=\"#递归解法：\" class=\"headerlink\" title=\"递归解法：\"></a>递归解法：</h3><ol>\n<li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li>\n<li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findNode</span><span class=\"params\">(TreeNode* root, TreeNode *pNode)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> found = findNode(root-&gt;left, pNode);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        found = findNode(root-&gt;right, pNode);</div><div class=\"line\">    <span class=\"keyword\">return</span> found;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode* root,</span></span></div><div class=\"line\">                                  TreeNode* pNode1,</div><div class=\"line\">                                  TreeNode* pNode2)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (findNode(root-&gt;left, pNode1)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (findNode(root-&gt;right, pNode2))</div><div class=\"line\">            <span class=\"keyword\">return</span> root;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (find(root-&gt;left, pNode2))</div><div class=\"line\">            <span class=\"keyword\">return</span> root;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p>\n<h3 id=\"非递归解法：\"><a href=\"#非递归解法：\" class=\"headerlink\" title=\"非递归解法：\"></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getNodePath</span><span class=\"params\">(TreeNode* root, </span></span></div><div class=\"line\">                 TreeNode* pNode, </div><div class=\"line\">                 <span class=\"built_in\">list</span>&lt;TreeNode*&gt; &amp;path)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) &#123;</div><div class=\"line\">        path.push_back(root);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    path.push_back(root);</div><div class=\"line\">    <span class=\"keyword\">bool</span> found = <span class=\"literal\">false</span>;</div><div class=\"line\">    found = getNodePath(root-&gt;left, pNode, path);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        found = getNodePath(root-&gt;right, pNode, path);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        path.pop_back();</div><div class=\"line\">    <span class=\"keyword\">return</span> found;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode *root, </span></span></div><div class=\"line\">                                  TreeNode* pNode1, </div><div class=\"line\">                                  TreeNode* pNode2)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode1 || !pNode2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path1;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result1 = getNodePath(root, pNode1, path1);</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path2;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result2 = getNodePath(root, pNode2, path2);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!result1 || !result2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    TreeNode* pLast = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</div><div class=\"line\">    <span class=\"keyword\">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (*iter1 == *iter2)</div><div class=\"line\">            pLast = *iter1;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        ++iter1;</div><div class=\"line\">        ++iter2;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> pLast;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p>\n<h2 id=\"求二叉树中节点的最大距离\"><a href=\"#求二叉树中节点的最大距离\" class=\"headerlink\" title=\"求二叉树中节点的最大距离\"></a><span id=\"nodeDistance\"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p>\n<ol>\n<li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li>\n<li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMaxDistance</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;maxLeft, <span class=\"keyword\">int</span> &amp;maxRight)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// maxLeft: 左子树中的节点离根节点的最远距离</span></div><div class=\"line\">    <span class=\"comment\">// maxRight: 右子树中的节点离根节点的最远距离</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</div><div class=\"line\">        maxLeft = <span class=\"number\">0</span>;</div><div class=\"line\">        maxRight = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> maxLL, maxLR, maxRL, maxRR;</div><div class=\"line\">    <span class=\"keyword\">int</span> maxDistLeft, maxDistRight;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</div><div class=\"line\">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</div><div class=\"line\">        maxLeft = max(maxLL, maxLR) + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        maxDistLeft = <span class=\"number\">0</span>;</div><div class=\"line\">        maxLeft = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</div><div class=\"line\">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</div><div class=\"line\">        maxRight = max(maxRL, maxRR) + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        maxDistRight = <span class=\"number\">0</span>;</div><div class=\"line\">        maxRight = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"由前序遍历序列和中序遍历序列重建二叉树\"><a href=\"#由前序遍历序列和中序遍历序列重建二叉树\" class=\"headerlink\" title=\"由前序遍历序列和中序遍历序列重建二叉树\"></a><span id=\"nodeRebuild\"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p>\n<ol>\n<li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li>\n<li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * pPreOrder: 前序遍历序列</div><div class=\"line\">  * pInOrder: 中序遍历序列</div><div class=\"line\">  * nodeNum: 二叉树节点数</div><div class=\"line\">  **/</div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">rebuildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>* pPreOrder, <span class=\"keyword\">int</span>* pInOrder, <span class=\"keyword\">int</span> nodeNum)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> TreeNode;</div><div class=\"line\">    <span class=\"comment\">// 前序遍历的第一个节点就是根节点</span></div><div class=\"line\">    root-&gt;val = pPreOrder[<span class=\"number\">0</span>];</div><div class=\"line\">    root-&gt;left = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    root-&gt;right = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"comment\">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rootPoistionInOrder = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nodeNum; ++i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pInOrder[i] == root-&gt;val) &#123;</div><div class=\"line\">            rootPositionInOrder = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (rootPositionInOrder == <span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception(<span class=\"string\">\"Invalid Input.\"</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 重建左子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nodeNumLeft = rootPositionInOrder;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderLeft = pPreOrder + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pInOrderLeft = pInOrder;</div><div class=\"line\">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</div><div class=\"line\">    <span class=\"comment\">// 重建右子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderRight = pPreOrder + <span class=\"number\">1</span> + nodeNumLeft;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class=\"number\">1</span>;</div><div class=\"line\">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p>\n<h2 id=\"判断二叉树是不是完全二叉树\"><a href=\"#判断二叉树是不是完全二叉树\" class=\"headerlink\" title=\"判断二叉树是不是完全二叉树\"></a><span id=\"nodeComplete\"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(TreeNode* root)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class=\"line\">    nodeQueue.push(root);</div><div class=\"line\">    <span class=\"keyword\">bool</span> mustHaveNoChild = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</div><div class=\"line\">        TreeNode* pNode = nodeQueue.front();</div><div class=\"line\">        nodeQueue.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (mustHaveNoChild) &#123;   <span class=\"comment\">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</div><div class=\"line\">                result = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class=\"line\">                nodeQueue.push(pNode-&gt;left);</div><div class=\"line\">                nodeQueue.push(pNode-&gt;right);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</div><div class=\"line\">                mustHaveNoChild = <span class=\"literal\">true</span>;</div><div class=\"line\">                nodeQueue.push(pNode-&gt;left);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class=\"line\">                result = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                mastHaveNoChild = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n","excerpt":"<p>文章转自 <a href=\"http://blog.csdn.net/walkinginthewind/article/details/7518888\">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p>","more":"<h1 id=\"二叉树节点定义\"><a href=\"#二叉树节点定义\" class=\"headerlink\" title=\"二叉树节点定义\"></a>二叉树节点定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Definition for a binary tree node*/</span></div><div class=\"line\"><span class=\"keyword\">struct</span> TreeNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    TreeNode* left;    <span class=\"comment\">// left tree node</span></div><div class=\"line\">    TreeNode* right;   <span class=\"comment\">// right tree node</span></div><div class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) : val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;    <span class=\"comment\">// ctor</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h1 id=\"问题列表\"><a href=\"#问题列表\" class=\"headerlink\" title=\"问题列表\"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p>\n<p><a href=\"#nodeNum\">1. 求二叉树中的节点个数</a><br><a href=\"#nodeDepth\">2. 求二叉树的深度</a><br><a href=\"#nodeTraverse\">3. 前序、中序、后序遍历</a><br><a href=\"#nodeDFSBFS\">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href=\"#nodeList\">5. 将二叉查找树变为有序的双向链表</a><br><a href=\"#nodeKth\">6. 求二叉树第K层的节点个数</a><br><a href=\"#nodeLeaf\">7. 求二叉树中叶子节点的个数</a><br><a href=\"#nodeStructure\">8. 判断两棵二叉树结构是否相同</a><br><a href=\"#nodeAVL\">9. 判断二叉树是不是平衡二叉树</a><br><a href=\"#nodeMirror\">10. 求二叉树的镜像</a><br><a href=\"#nodeAncestor\">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href=\"#nodeDistance\">12. 求二叉树中节点的最大距离</a><br><a href=\"#nodeRebuild\">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href=\"#nodeComplete\">14. 判断二叉树是不是完全二叉树</a></p>\n<h1 id=\"详细解答\"><a href=\"#详细解答\" class=\"headerlink\" title=\"详细解答\"></a>详细解答</h1><h2 id=\"求二叉树中的节点个数\"><a href=\"#求二叉树中的节点个数\" class=\"headerlink\" title=\"求二叉树中的节点个数\"></a><span id=\"nodeNum\"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，节点个数为</li>\n<li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树的深度\"><a href=\"#求二叉树的深度\" class=\"headerlink\" title=\"求二叉树的深度\"></a><span id=\"nodeDepth\"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，二叉树的深度为0</li>\n<li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></div><div class=\"line\">    <span class=\"keyword\">int</span> depthLeft = getDepth(root-&gt;left);</div><div class=\"line\">    <span class=\"keyword\">int</span> depthRight = getDepth(root-&gt;right);</div><div class=\"line\">    <span class=\"keyword\">return</span> depthLeft &gt; depthRight ? depthLeft + <span class=\"number\">1</span> : depthRight + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"前序、中序、后序遍历\"><a href=\"#前序、中序、后序遍历\" class=\"headerlink\" title=\"前序、中序、后序遍历\"></a><span id=\"nodeTraverse\"><strong>前序、中序、后序遍历</strong></span></h2><h3 id=\"前序遍历递归解法：\"><a href=\"#前序遍历递归解法：\" class=\"headerlink\" title=\"前序遍历递归解法：\"></a>前序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    visit(root);                     <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">    preOrderTraverse(root-&gt;left);    <span class=\"comment\">// 前序遍历左子树</span></div><div class=\"line\">    preOrderTraverse(root-&gt;right);   <span class=\"comment\">// 前序遍历右子树</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历递归解法：\"><a href=\"#中序遍历递归解法：\" class=\"headerlink\" title=\"中序遍历递归解法：\"></a>中序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    inOrderTraverse(root-&gt;left);    <span class=\"comment\">// 中序遍历左子树</span></div><div class=\"line\">    visit(root)；                   <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">    inOrderTraverse(root-&gt;right);   <span class=\"comment\">// 中序遍历右子树</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历递归解法：\"><a href=\"#后序遍历递归解法：\" class=\"headerlink\" title=\"后序遍历递归解法：\"></a>后序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    postOrderTraverse(root-&gt;left);    <span class=\"comment\">// 后序遍历左子树</span></div><div class=\"line\">    postOrderTraverse(root-&gt;right);   <span class=\"comment\">// 后序遍历右子树</span></div><div class=\"line\">    visit(root);                      <span class=\"comment\">// 访问根结点</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他遍历二叉树方法-深度、广度优先\"><a href=\"#其他遍历二叉树方法-深度、广度优先\" class=\"headerlink\" title=\"其他遍历二叉树方法(深度、广度优先)\"></a><span id=\"nodeDFSBFS\"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id=\"深度优先遍历解法：\"><a href=\"#深度优先遍历解法：\" class=\"headerlink\" title=\"深度优先遍历解法：\"></a>深度优先遍历解法：</h3><ol>\n<li>借助一个栈（后进先出）来实现深度遍历</li>\n<li>先访问根结点</li>\n<li>遍历左子树接着遍历右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; nodeStack;</div><div class=\"line\">    nodeStack.push(root);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</div><div class=\"line\">        TreeNode *tmp = nodeStack.top();</div><div class=\"line\">        visit(tmp);</div><div class=\"line\">        nodeStack.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</div><div class=\"line\">            nodeStack.push(tmp-&gt;right);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</div><div class=\"line\">            nodeStack.push(tmp-&gt;left);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"广度优先遍历解法：\"><a href=\"#广度优先遍历解法：\" class=\"headerlink\" title=\"广度优先遍历解法：\"></a>广度优先遍历解法：</h3><ol>\n<li>借助队列（先进先出）来实现广度优先遍历</li>\n<li>将根节点入队</li>\n<li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class=\"line\">    q.push(root);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</div><div class=\"line\">        TreeNode *tmp = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        visit(tmp);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</div><div class=\"line\">            nodeQueue.push(tmp-&gt;left);</div><div class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</div><div class=\"line\">            nodeQueue.push(tmp-&gt;right);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"将二叉查找树变为有序的双向链表\"><a href=\"#将二叉查找树变为有序的双向链表\" class=\"headerlink\" title=\"将二叉查找树变为有序的双向链表\"></a><span id=\"nodeList\"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p>\n<ol>\n<li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li>\n<li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * root: 二叉查找树的根结点指针</div><div class=\"line\">  * pFirstNode: 转换后双向有序链表的第一个节点指针</div><div class=\"line\">  * pLastNode: 转换后双向有序链表的最后一个节点指针</div><div class=\"line\">  **/</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(TreeNode* root, </div><div class=\"line\">              TreeNode* &amp;pFirstNode, </div><div class=\"line\">              TreeNode* &amp;pLastNode)</span> </span>&#123;</div><div class=\"line\">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</div><div class=\"line\">        pFirstNode = <span class=\"literal\">NULL</span>;</div><div class=\"line\">        pLastNode = <span class=\"literal\">NULL</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</div><div class=\"line\">        <span class=\"comment\">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></div><div class=\"line\">        pFirstNode = root;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        convert(root-&gt;left, pFirstLeft, pLastLeft);</div><div class=\"line\">        <span class=\"comment\">// 二叉查找树对应双向有序链表的第一个节点就是</span></div><div class=\"line\">        <span class=\"comment\">// 左子树转换后双向有序链表的第一个节点</span></div><div class=\"line\">        pFristNode = pFirstLeft;</div><div class=\"line\">        <span class=\"comment\">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></div><div class=\"line\">        root-&gt;left = pLastLeft;</div><div class=\"line\">        pLastLeft-&gt;right = root;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right)</div><div class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点是根节点</span></div><div class=\"line\">        pLastNode = root;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        convert(root-&gt;right, pFirstRight, pLastRight);</div><div class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点就是</span></div><div class=\"line\">        <span class=\"comment\">// 右子树转换后双向有序链表的最后一个节点</span></div><div class=\"line\">        pLastNode = pLastRight;</div><div class=\"line\">        <span class=\"comment\">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></div><div class=\"line\">        root-&gt;right = pFirstRight;</div><div class=\"line\">        pFirstRight-&gt;left = root;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树第K层的节点个数\"><a href=\"#求二叉树第K层的节点个数\" class=\"headerlink\" title=\"求二叉树第K层的节点个数\"></a><span id=\"nodeKth\"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p>\n<ol>\n<li>如果二叉树为空或者k &lt; 1，返回0</li>\n<li>如果二叉树不为空且k = 1，返回1</li>\n<li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthLevelNodeNum</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!roo || k &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中k-1层节点个数</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中k-1层节点个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (leftNum + rightNum);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树中叶子节点的个数\"><a href=\"#求二叉树中叶子节点的个数\" class=\"headerlink\" title=\"求二叉树中叶子节点的个数\"></a><span id=\"nodeLeaf\"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回0</li>\n<li>如果二叉树不为空且左右子树为空，返回1</li>\n<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLeafNodeNum</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中叶节点个数</span></div><div class=\"line\">    <span class=\"keyword\">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中叶节点个数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (numLeft + numRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"判断两棵二叉树结构是否相同\"><a href=\"#判断两棵二叉树结构是否相同\" class=\"headerlink\" title=\"判断两棵二叉树结构是否相同\"></a><span id=\"nodeStructure\"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p>\n<ol>\n<li>如果两棵二叉树都为空，返回真</li>\n<li>如果两颗二叉树一棵为空，另一个不为空，返回假</li>\n<li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">structureCmp</span><span class=\"params\">(TreeNode* lhs, TreeNode* rhs)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!lhs &amp;&amp; !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;           <span class=\"comment\">// 都为空树，返回真</span></div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lhs || !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;     <span class=\"comment\">// 一个为空而另一个不为空，返回假</span></div><div class=\"line\"><span class=\"keyword\">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class=\"comment\">// 比较对应左子树</span></div><div class=\"line\"><span class=\"keyword\">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class=\"comment\">// 比较对应右子树</span></div><div class=\"line\"><span class=\"keyword\">return</span> (resultLeft &amp;&amp; resultRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"判断二叉树是不是平衡二叉树\"><a href=\"#判断二叉树是不是平衡二叉树\" class=\"headerlink\" title=\"判断二叉树是不是平衡二叉树\"></a><span id=\"nodeAVL\"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回真</li>\n<li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">boo <span class=\"title\">isAVL</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;height)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;    <span class=\"comment\">// 空树，返回真</span></div><div class=\"line\">        height = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> heightLeft;</div><div class=\"line\">    <span class=\"keyword\">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</div><div class=\"line\">    <span class=\"keyword\">int</span> heightRight;</div><div class=\"line\">    <span class=\"keyword\">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class=\"built_in\">abs</span>(heightLeft - heightRight) &lt;= <span class=\"number\">1</span>)&#123;    </div><div class=\"line\">        <span class=\"comment\">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></div><div class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树的镜像\"><a href=\"#求二叉树的镜像\" class=\"headerlink\" title=\"求二叉树的镜像\"></a><span id=\"nodeMirror\"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回空</li>\n<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    </div><div class=\"line\">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class=\"comment\">// 求左子树镜像</span></div><div class=\"line\">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class=\"comment\">// 求右子树镜像</span></div><div class=\"line\">    <span class=\"comment\">// 交换左右子树</span></div><div class=\"line\">    root-&gt;left = leftTree;</div><div class=\"line\">    root-&gt;right = rightTree;</div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"求二叉树中两个节点的最低公共祖先节点\"><a href=\"#求二叉树中两个节点的最低公共祖先节点\" class=\"headerlink\" title=\"求二叉树中两个节点的最低公共祖先节点\"></a><span id=\"nodeAncestor\"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id=\"递归解法：\"><a href=\"#递归解法：\" class=\"headerlink\" title=\"递归解法：\"></a>递归解法：</h3><ol>\n<li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li>\n<li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findNode</span><span class=\"params\">(TreeNode* root, TreeNode *pNode)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> found = findNode(root-&gt;left, pNode);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        found = findNode(root-&gt;right, pNode);</div><div class=\"line\">    <span class=\"keyword\">return</span> found;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode* root,</div><div class=\"line\">                                  TreeNode* pNode1,</div><div class=\"line\">                                  TreeNode* pNode2)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (findNode(root-&gt;left, pNode1)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (findNode(root-&gt;right, pNode2))</div><div class=\"line\">            <span class=\"keyword\">return</span> root;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (find(root-&gt;left, pNode2))</div><div class=\"line\">            <span class=\"keyword\">return</span> root;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p>\n<h3 id=\"非递归解法：\"><a href=\"#非递归解法：\" class=\"headerlink\" title=\"非递归解法：\"></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getNodePath</span><span class=\"params\">(TreeNode* root, </div><div class=\"line\">                 TreeNode* pNode, </div><div class=\"line\">                 <span class=\"built_in\">list</span>&lt;TreeNode*&gt; &amp;path)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) &#123;</div><div class=\"line\">        path.push_back(root);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    path.push_back(root);</div><div class=\"line\">    <span class=\"keyword\">bool</span> found = <span class=\"literal\">false</span>;</div><div class=\"line\">    found = getNodePath(root-&gt;left, pNode, path);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        found = getNodePath(root-&gt;right, pNode, path);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!found)</div><div class=\"line\">        path.pop_back();</div><div class=\"line\">    <span class=\"keyword\">return</span> found;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode *root, </div><div class=\"line\">                                  TreeNode* pNode1, </div><div class=\"line\">                                  TreeNode* pNode2)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode1 || !pNode2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path1;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result1 = getNodePath(root, pNode1, path1);</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path2;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result2 = getNodePath(root, pNode2, path2);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!result1 || !result2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    TreeNode* pLast = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</div><div class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</div><div class=\"line\">    <span class=\"keyword\">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (*iter1 == *iter2)</div><div class=\"line\">            pLast = *iter1;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        ++iter1;</div><div class=\"line\">        ++iter2;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> pLast;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p>\n<h2 id=\"求二叉树中节点的最大距离\"><a href=\"#求二叉树中节点的最大距离\" class=\"headerlink\" title=\"求二叉树中节点的最大距离\"></a><span id=\"nodeDistance\"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p>\n<ol>\n<li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li>\n<li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMaxDistance</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;maxLeft, <span class=\"keyword\">int</span> &amp;maxRight)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// maxLeft: 左子树中的节点离根节点的最远距离</span></div><div class=\"line\">    <span class=\"comment\">// maxRight: 右子树中的节点离根节点的最远距离</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</div><div class=\"line\">        maxLeft = <span class=\"number\">0</span>;</div><div class=\"line\">        maxRight = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">int</span> maxLL, maxLR, maxRL, maxRR;</div><div class=\"line\">    <span class=\"keyword\">int</span> maxDistLeft, maxDistRight;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</div><div class=\"line\">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</div><div class=\"line\">        maxLeft = max(maxLL, maxLR) + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        maxDistLeft = <span class=\"number\">0</span>;</div><div class=\"line\">        maxLeft = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</div><div class=\"line\">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</div><div class=\"line\">        maxRight = max(maxRL, maxRR) + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        maxDistRight = <span class=\"number\">0</span>;</div><div class=\"line\">        maxRight = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"由前序遍历序列和中序遍历序列重建二叉树\"><a href=\"#由前序遍历序列和中序遍历序列重建二叉树\" class=\"headerlink\" title=\"由前序遍历序列和中序遍历序列重建二叉树\"></a><span id=\"nodeRebuild\"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p>\n<ol>\n<li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li>\n<li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li>\n</ol>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * pPreOrder: 前序遍历序列</div><div class=\"line\">  * pInOrder: 中序遍历序列</div><div class=\"line\">  * nodeNum: 二叉树节点数</div><div class=\"line\">  **/</span></div><div class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">rebuildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>* pPreOrder, <span class=\"keyword\">int</span>* pInOrder, <span class=\"keyword\">int</span> nodeNum)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> TreeNode;</div><div class=\"line\">    <span class=\"comment\">// 前序遍历的第一个节点就是根节点</span></div><div class=\"line\">    root-&gt;val = pPreOrder[<span class=\"number\">0</span>];</div><div class=\"line\">    root-&gt;left = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    root-&gt;right = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"comment\">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rootPoistionInOrder = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nodeNum; ++i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pInOrder[i] == root-&gt;val) &#123;</div><div class=\"line\">            rootPositionInOrder = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (rootPositionInOrder == <span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception(<span class=\"string\">\"Invalid Input.\"</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 重建左子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nodeNumLeft = rootPositionInOrder;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderLeft = pPreOrder + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pInOrderLeft = pInOrder;</div><div class=\"line\">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</div><div class=\"line\">    <span class=\"comment\">// 重建右子树</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderRight = pPreOrder + <span class=\"number\">1</span> + nodeNumLeft;</div><div class=\"line\">    <span class=\"keyword\">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class=\"number\">1</span>;</div><div class=\"line\">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p>\n<h2 id=\"判断二叉树是不是完全二叉树\"><a href=\"#判断二叉树是不是完全二叉树\" class=\"headerlink\" title=\"判断二叉树是不是完全二叉树\"></a><span id=\"nodeComplete\"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p>\n<p>参考代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(TreeNode* root)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class=\"line\">    nodeQueue.push(root);</div><div class=\"line\">    <span class=\"keyword\">bool</span> mustHaveNoChild = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</div><div class=\"line\">        TreeNode* pNode = nodeQueue.front();</div><div class=\"line\">        nodeQueue.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (mustHaveNoChild) &#123;   <span class=\"comment\">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</div><div class=\"line\">                result = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class=\"line\">                nodeQueue.push(pNode-&gt;left);</div><div class=\"line\">                nodeQueue.push(pNode-&gt;right);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</div><div class=\"line\">                mustHaveNoChild = <span class=\"literal\">true</span>;</div><div class=\"line\">                nodeQueue.push(pNode-&gt;left);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class=\"line\">                result = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                mastHaveNoChild = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>"},{"title":"【每周一坑】验证哥德巴赫猜想","date":"2017-05-28T01:53:38.000Z","comments":1,"_content":"\n![Goldbach's conjecture](/images/imagesource/17-05-28.jpg )\n\n> 哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。\n\n<!--more-->\n\n## 问题描述\n\n**本周题目**\n\n> 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。\n\n示例：\n\n```python\n>>> Goldbach(123456)\n7 123449\n>>> Goldbach(12345678)\n31 12345647\n```\n\n## 思路\n\n这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。\n\n## Python实现\n\n```python\nimport math\n\n# 求得小于等于n的所有质数\ndef get_prime(n):\n    prime = []\n    prime_dic = {}\n    for i in range(2, n+1):\n        prime_dic[i] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        for j in range(i * i, n + 1, i):\n            if prime_dic[i] == 1:\n                prime_dic[j] = 0\n    for k, v in prime.items():\n        if v == 1:\n            prime.append(k)\n    return prime\n\n# 求满足猜想的质数和\ndef gold_bach(n):\n    cnt = 0\n    prime = get_prime(n)\n    for prime1 in prime:\n        prime2 = n - prime1\n        if prime2 in prime and cnt != 1:    # 只输出一种结果\n            cnt += 1\n            return prime1. prime2\n\nif __name__ == '__main__'：\n    print(gold_bach(123456))\n    print(gold_bach(12345678))\n```\n\n## 输出结果\n\nprint(gold_bach(123456))\n\n> (7, 123449)\n\nprint(gold_bach(12345678))\n\n> (31, 12345647)\n\n与示例一致。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】验证哥德巴赫猜想.md","raw":"---\ntitle: 【每周一坑】验证哥德巴赫猜想\ndate: 2017-05-28 09:53:38\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![Goldbach's conjecture](/images/imagesource/17-05-28.jpg )\n\n> 哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。\n\n<!--more-->\n\n## 问题描述\n\n**本周题目**\n\n> 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。\n\n示例：\n\n```python\n>>> Goldbach(123456)\n7 123449\n>>> Goldbach(12345678)\n31 12345647\n```\n\n## 思路\n\n这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。\n\n## Python实现\n\n```python\nimport math\n\n# 求得小于等于n的所有质数\ndef get_prime(n):\n    prime = []\n    prime_dic = {}\n    for i in range(2, n+1):\n        prime_dic[i] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        for j in range(i * i, n + 1, i):\n            if prime_dic[i] == 1:\n                prime_dic[j] = 0\n    for k, v in prime.items():\n        if v == 1:\n            prime.append(k)\n    return prime\n\n# 求满足猜想的质数和\ndef gold_bach(n):\n    cnt = 0\n    prime = get_prime(n)\n    for prime1 in prime:\n        prime2 = n - prime1\n        if prime2 in prime and cnt != 1:    # 只输出一种结果\n            cnt += 1\n            return prime1. prime2\n\nif __name__ == '__main__'：\n    print(gold_bach(123456))\n    print(gold_bach(12345678))\n```\n\n## 输出结果\n\nprint(gold_bach(123456))\n\n> (7, 123449)\n\nprint(gold_bach(12345678))\n\n> (31, 12345647)\n\n与示例一致。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】验证哥德巴赫猜想","published":1,"updated":"2017-05-28T02:12:08.872Z","layout":"post","photos":[],"link":"","_id":"cjqojmly10025swqcjxnrc3vc","content":"<p><img src=\"/images/imagesource/17-05-28.jpg\" alt=\"Goldbach&#39;s conjecture\"></p>\n<blockquote>\n<p>哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">123456</span>)</div><div class=\"line\"><span class=\"number\">7</span> <span class=\"number\">123449</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">12345678</span>)</div><div class=\"line\"><span class=\"number\">31</span> <span class=\"number\">12345647</span></div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 求得小于等于n的所有质数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_prime</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    prime = []</div><div class=\"line\">    prime_dic = &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</div><div class=\"line\">        prime_dic[i] = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, int(math.sqrt(n)) + <span class=\"number\">1</span>):</div><div class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i * i, n + <span class=\"number\">1</span>, i):</div><div class=\"line\">            <span class=\"keyword\">if</span> prime_dic[i] == <span class=\"number\">1</span>:</div><div class=\"line\">                prime_dic[j] = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> prime.items():</div><div class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">1</span>:</div><div class=\"line\">            prime.append(k)</div><div class=\"line\">    <span class=\"keyword\">return</span> prime</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 求满足猜想的质数和</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold_bach</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    cnt = <span class=\"number\">0</span></div><div class=\"line\">    prime = get_prime(n)</div><div class=\"line\">    <span class=\"keyword\">for</span> prime1 <span class=\"keyword\">in</span> prime:</div><div class=\"line\">        prime2 = n - prime1</div><div class=\"line\">        <span class=\"keyword\">if</span> prime2 <span class=\"keyword\">in</span> prime <span class=\"keyword\">and</span> cnt != <span class=\"number\">1</span>:    <span class=\"comment\"># 只输出一种结果</span></div><div class=\"line\">            cnt += <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">return</span> prime1. prime2</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>：</div><div class=\"line\">    print(gold_bach(<span class=\"number\">123456</span>))</div><div class=\"line\">    print(gold_bach(<span class=\"number\">12345678</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>print(gold_bach(123456))</p>\n<blockquote>\n<p>(7, 123449)</p>\n</blockquote>\n<p>print(gold_bach(12345678))</p>\n<blockquote>\n<p>(31, 12345647)</p>\n</blockquote>\n<p>与示例一致。</p>\n<p>End~</p>\n<hr>\n","excerpt":"<p><img src=\"/images/imagesource/17-05-28.jpg\" alt=\"Goldbach&#39;s conjecture\"></p>\n<blockquote>\n<p>哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。</p>\n</blockquote>","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">123456</span>)</div><div class=\"line\"><span class=\"number\">7</span> <span class=\"number\">123449</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">12345678</span>)</div><div class=\"line\"><span class=\"number\">31</span> <span class=\"number\">12345647</span></div></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 求得小于等于n的所有质数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_prime</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    prime = []</div><div class=\"line\">    prime_dic = &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</div><div class=\"line\">        prime_dic[i] = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, int(math.sqrt(n)) + <span class=\"number\">1</span>):</div><div class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i * i, n + <span class=\"number\">1</span>, i):</div><div class=\"line\">            <span class=\"keyword\">if</span> prime_dic[i] == <span class=\"number\">1</span>:</div><div class=\"line\">                prime_dic[j] = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> prime.items():</div><div class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">1</span>:</div><div class=\"line\">            prime.append(k)</div><div class=\"line\">    <span class=\"keyword\">return</span> prime</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 求满足猜想的质数和</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold_bach</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    cnt = <span class=\"number\">0</span></div><div class=\"line\">    prime = get_prime(n)</div><div class=\"line\">    <span class=\"keyword\">for</span> prime1 <span class=\"keyword\">in</span> prime:</div><div class=\"line\">        prime2 = n - prime1</div><div class=\"line\">        <span class=\"keyword\">if</span> prime2 <span class=\"keyword\">in</span> prime <span class=\"keyword\">and</span> cnt != <span class=\"number\">1</span>:    <span class=\"comment\"># 只输出一种结果</span></div><div class=\"line\">            cnt += <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">return</span> prime1. prime2</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>：</div><div class=\"line\">    print(gold_bach(<span class=\"number\">123456</span>))</div><div class=\"line\">    print(gold_bach(<span class=\"number\">12345678</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>print(gold_bach(123456))</p>\n<blockquote>\n<p>(7, 123449)</p>\n</blockquote>\n<p>print(gold_bach(12345678))</p>\n<blockquote>\n<p>(31, 12345647)</p>\n</blockquote>\n<p>与示例一致。</p>\n<p>End~</p>\n<hr>"},{"title":"函数返回数组指针或数组引用","date":"2017-04-15T11:05:14.000Z","comments":1,"_content":"因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n下面就介绍几种方法：\n\n<!--more-->\n\n## 方法一： 使用类型别名\n```C++\ntypedef int arrT[10];       // arrT是一个类型别名，表示的类型\n                            // 是含有10个整型的数组\nusing arrT = int[10];       // arrT的等价声明\narrT* func(int i);          // func返回一个指向含有10个整数的数组的指针\n```\n其中`arrT`是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此`func`函数接受一个`int`实参，返回一个指向包含10个整数的数组的指针。\n\n## 方法二： 声明一个返回数组指针的函数\n要想在声明`func`时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：\n```C++\nint arr[10];            // arr是一个含有10个整数的数组\nint *p1[10];            // p1是一个含有10个指针的数组\nint (*p2)[10] = &arr;   // p2是一个指针，他只想含有10个整数的数组\n```\n和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：\n\n> Type (*function(parameter_list)) [dimension]\n\n类似于其他数组的声明，`Type`表示元素的类型，`dimension`表示数组的大小。`(*function(parameter_list))`两段的括号必须存在，就像定义`p2`时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n```C++\nint (*func(int i)) [10];\n```\n可以按照以下的顺序来逐层理解该声明的含义：\n\n - `func(int i)`表示调用`func`函数时需要一个`int`类型的实参\n - `(*func(int i))`意味这我们可以对函数调用的结果执行解引用操作\n - `(*func(int i)) [10]`表示解引用`func`的调用将得到一个大小是10的数组\n - `int(*func(int i)) [10]`表示数组中元素是`int`类型\n\n## 方法三： 使用尾置返回类型\n在C++11新标准中海油可以简化上述`func`声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：\n\n```C++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*) [10];\n```\n因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。\n\n## 方法四： 使用decltype\n还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个：\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *addPtr(int i)\n{\n    return (i % 2) ? &odd : &even;      // 返回一个指向数组的指针\n}\n```\n`arrPtr`使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与`odd`类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个`*`符号。\n\n## 练习\n### 1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\n```C++\n    string (&func(string (&arr)[10])) [10];\n```\n### 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\n```C++\n// 使用类型别名\nusing arrT = string[10];\narrT& func1(arrT& arr);\n\n// 使用尾置返回类型\nauto func2(arrT& arr)->string(&) [10];\n\n// 使用decltype关键字\nstring arrS[10];\ndecltype(arrS) &func3(arrT& arr);\n```\n### 3. 修改arrPtr函数，使其返回数组的引用\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\ndecltype(odd) &arrPtr(int i)\n{\n    return (i % 2) ? odd : even;\n}\n```\n\n\n","source":"_posts/函数返回数组指针或数组引用.md","raw":"---\ntitle: 函数返回数组指针或数组引用\ndate: 2017-04-15 19:05:14\ncategory: CPP\ntags: C++\ncomments: true\n---\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n下面就介绍几种方法：\n\n<!--more-->\n\n## 方法一： 使用类型别名\n```C++\ntypedef int arrT[10];       // arrT是一个类型别名，表示的类型\n                            // 是含有10个整型的数组\nusing arrT = int[10];       // arrT的等价声明\narrT* func(int i);          // func返回一个指向含有10个整数的数组的指针\n```\n其中`arrT`是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此`func`函数接受一个`int`实参，返回一个指向包含10个整数的数组的指针。\n\n## 方法二： 声明一个返回数组指针的函数\n要想在声明`func`时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：\n```C++\nint arr[10];            // arr是一个含有10个整数的数组\nint *p1[10];            // p1是一个含有10个指针的数组\nint (*p2)[10] = &arr;   // p2是一个指针，他只想含有10个整数的数组\n```\n和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：\n\n> Type (*function(parameter_list)) [dimension]\n\n类似于其他数组的声明，`Type`表示元素的类型，`dimension`表示数组的大小。`(*function(parameter_list))`两段的括号必须存在，就像定义`p2`时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n```C++\nint (*func(int i)) [10];\n```\n可以按照以下的顺序来逐层理解该声明的含义：\n\n - `func(int i)`表示调用`func`函数时需要一个`int`类型的实参\n - `(*func(int i))`意味这我们可以对函数调用的结果执行解引用操作\n - `(*func(int i)) [10]`表示解引用`func`的调用将得到一个大小是10的数组\n - `int(*func(int i)) [10]`表示数组中元素是`int`类型\n\n## 方法三： 使用尾置返回类型\n在C++11新标准中海油可以简化上述`func`声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：\n\n```C++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*) [10];\n```\n因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。\n\n## 方法四： 使用decltype\n还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个：\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *addPtr(int i)\n{\n    return (i % 2) ? &odd : &even;      // 返回一个指向数组的指针\n}\n```\n`arrPtr`使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与`odd`类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个`*`符号。\n\n## 练习\n### 1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\n```C++\n    string (&func(string (&arr)[10])) [10];\n```\n### 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\n```C++\n// 使用类型别名\nusing arrT = string[10];\narrT& func1(arrT& arr);\n\n// 使用尾置返回类型\nauto func2(arrT& arr)->string(&) [10];\n\n// 使用decltype关键字\nstring arrS[10];\ndecltype(arrS) &func3(arrT& arr);\n```\n### 3. 修改arrPtr函数，使其返回数组的引用\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\ndecltype(odd) &arrPtr(int i)\n{\n    return (i % 2) ? odd : even;\n}\n```\n\n\n","slug":"函数返回数组指针或数组引用","published":1,"updated":"2019-01-07T13:44:48.079Z","layout":"post","photos":[],"link":"","_id":"cjqojmly10028swqczho22o96","content":"<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。<br>下面就介绍几种方法：</p>\n<a id=\"more\"></a>\n<h2 id=\"方法一：-使用类型别名\"><a href=\"#方法一：-使用类型别名\" class=\"headerlink\" title=\"方法一： 使用类型别名\"></a>方法一： 使用类型别名</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> arrT[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT是一个类型别名，表示的类型</span></div><div class=\"line\">                            <span class=\"comment\">// 是含有10个整型的数组</span></div><div class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT的等价声明</span></div><div class=\"line\"><span class=\"function\">arrT* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;          <span class=\"comment\">// func返回一个指向含有10个整数的数组的指针</span></div></pre></td></tr></table></figure>\n<p>其中<code>arrT</code>是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>\n<h2 id=\"方法二：-声明一个返回数组指针的函数\"><a href=\"#方法二：-声明一个返回数组指针的函数\" class=\"headerlink\" title=\"方法二： 声明一个返回数组指针的函数\"></a>方法二： 声明一个返回数组指针的函数</h2><p>要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];            <span class=\"comment\">// arr是一个含有10个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p1[<span class=\"number\">10</span>];            <span class=\"comment\">// p1是一个含有10个指针的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (*p2)[<span class=\"number\">10</span>] = &amp;arr;   <span class=\"comment\">// p2是一个指针，他只想含有10个整数的数组</span></div></pre></td></tr></table></figure></p>\n<p>和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：</p>\n<blockquote>\n<p>Type (*function(parameter_list)) [dimension]</p>\n</blockquote>\n<p>类似于其他数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两段的括号必须存在，就像定义<code>p2</code>时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。</p>\n<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (*func(<span class=\"keyword\">int</span> i)) [<span class=\"number\">10</span>];</div></pre></td></tr></table></figure></p>\n<p>可以按照以下的顺序来逐层理解该声明的含义：</p>\n<ul>\n<li><code>func(int i)</code>表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参</li>\n<li><code>(*func(int i))</code>意味这我们可以对函数调用的结果执行解引用操作</li>\n<li><code>(*func(int i)) [10]</code>表示解引用<code>func</code>的调用将得到一个大小是10的数组</li>\n<li><code>int(*func(int i)) [10]</code>表示数组中元素是<code>int</code>类型</li>\n</ul>\n<h2 id=\"方法三：-使用尾置返回类型\"><a href=\"#方法三：-使用尾置返回类型\" class=\"headerlink\" title=\"方法三： 使用尾置返回类型\"></a>方法三： 使用尾置返回类型</h2><p>在C++11新标准中海油可以简化上述<code>func</code>声明的方法，就是使用<strong>尾置返回类型(trailing return type)</strong>。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</div><div class=\"line\">auto func(int i) -&gt; int(*) [10];</div></pre></td></tr></table></figure>\n<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</p>\n<h2 id=\"方法四：-使用decltype\"><a href=\"#方法四：-使用decltype\" class=\"headerlink\" title=\"方法四： 使用decltype\"></a>方法四： 使用decltype</h2><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数<code>i</code>的不同指向两个已知数组中的某一个：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 返回一个指针，该指针指向含有5个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">decltype</span>(odd) *addPtr(<span class=\"keyword\">int</span> i)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;      <span class=\"comment\">// 返回一个指向数组的指针</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>arrPtr</code>使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个<code>*</code>符号。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"><a href=\"#1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\" class=\"headerlink\" title=\"1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"></a>1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> (&amp;func(<span class=\"built_in\">string</span> (&amp;arr)[<span class=\"number\">10</span>])) [<span class=\"number\">10</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"><a href=\"#2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\" class=\"headerlink\" title=\"2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"></a>2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用类型别名</div><div class=\"line\">using arrT = string[10];</div><div class=\"line\">arrT&amp; func1(arrT&amp; arr);</div><div class=\"line\"></div><div class=\"line\">// 使用尾置返回类型</div><div class=\"line\">auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];</div><div class=\"line\"></div><div class=\"line\">// 使用decltype关键字</div><div class=\"line\">string arrS[10];</div><div class=\"line\">decltype(arrS) &amp;func3(arrT&amp; arr);</div></pre></td></tr></table></figure>\n<h3 id=\"3-修改arrPtr函数，使其返回数组的引用\"><a href=\"#3-修改arrPtr函数，使其返回数组的引用\" class=\"headerlink\" title=\"3. 修改arrPtr函数，使其返回数组的引用\"></a>3. 修改arrPtr函数，使其返回数组的引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(odd) &amp;arrPtr(<span class=\"keyword\">int</span> i)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? odd : even;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。<br>下面就介绍几种方法：</p>","more":"<h2 id=\"方法一：-使用类型别名\"><a href=\"#方法一：-使用类型别名\" class=\"headerlink\" title=\"方法一： 使用类型别名\"></a>方法一： 使用类型别名</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> arrT[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT是一个类型别名，表示的类型</span></div><div class=\"line\">                            <span class=\"comment\">// 是含有10个整型的数组</span></div><div class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT的等价声明</span></div><div class=\"line\"><span class=\"function\">arrT* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;          <span class=\"comment\">// func返回一个指向含有10个整数的数组的指针</span></div></pre></td></tr></table></figure>\n<p>其中<code>arrT</code>是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>\n<h2 id=\"方法二：-声明一个返回数组指针的函数\"><a href=\"#方法二：-声明一个返回数组指针的函数\" class=\"headerlink\" title=\"方法二： 声明一个返回数组指针的函数\"></a>方法二： 声明一个返回数组指针的函数</h2><p>要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];            <span class=\"comment\">// arr是一个含有10个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p1[<span class=\"number\">10</span>];            <span class=\"comment\">// p1是一个含有10个指针的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (*p2)[<span class=\"number\">10</span>] = &amp;arr;   <span class=\"comment\">// p2是一个指针，他只想含有10个整数的数组</span></div></pre></td></tr></table></figure></p>\n<p>和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：</p>\n<blockquote>\n<p>Type (*function(parameter_list)) [dimension]</p>\n</blockquote>\n<p>类似于其他数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两段的括号必须存在，就像定义<code>p2</code>时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。</p>\n<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (*func(<span class=\"keyword\">int</span> i)) [<span class=\"number\">10</span>];</div></pre></td></tr></table></figure></p>\n<p>可以按照以下的顺序来逐层理解该声明的含义：</p>\n<ul>\n<li><code>func(int i)</code>表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参</li>\n<li><code>(*func(int i))</code>意味这我们可以对函数调用的结果执行解引用操作</li>\n<li><code>(*func(int i)) [10]</code>表示解引用<code>func</code>的调用将得到一个大小是10的数组</li>\n<li><code>int(*func(int i)) [10]</code>表示数组中元素是<code>int</code>类型</li>\n</ul>\n<h2 id=\"方法三：-使用尾置返回类型\"><a href=\"#方法三：-使用尾置返回类型\" class=\"headerlink\" title=\"方法三： 使用尾置返回类型\"></a>方法三： 使用尾置返回类型</h2><p>在C++11新标准中海油可以简化上述<code>func</code>声明的方法，就是使用<strong>尾置返回类型(trailing return type)</strong>。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</div><div class=\"line\">auto func(int i) -&gt; int(*) [10];</div></pre></td></tr></table></figure>\n<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</p>\n<h2 id=\"方法四：-使用decltype\"><a href=\"#方法四：-使用decltype\" class=\"headerlink\" title=\"方法四： 使用decltype\"></a>方法四： 使用decltype</h2><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数<code>i</code>的不同指向两个已知数组中的某一个：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 返回一个指针，该指针指向含有5个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">decltype</span>(odd) *addPtr(<span class=\"keyword\">int</span> i)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;      <span class=\"comment\">// 返回一个指向数组的指针</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>arrPtr</code>使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个<code>*</code>符号。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"><a href=\"#1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\" class=\"headerlink\" title=\"1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"></a>1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> (&amp;func(<span class=\"built_in\">string</span> (&amp;arr)[<span class=\"number\">10</span>])) [<span class=\"number\">10</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"><a href=\"#2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\" class=\"headerlink\" title=\"2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"></a>2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用类型别名</div><div class=\"line\">using arrT = string[10];</div><div class=\"line\">arrT&amp; func1(arrT&amp; arr);</div><div class=\"line\"></div><div class=\"line\">// 使用尾置返回类型</div><div class=\"line\">auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];</div><div class=\"line\"></div><div class=\"line\">// 使用decltype关键字</div><div class=\"line\">string arrS[10];</div><div class=\"line\">decltype(arrS) &amp;func3(arrT&amp; arr);</div></pre></td></tr></table></figure>\n<h3 id=\"3-修改arrPtr函数，使其返回数组的引用\"><a href=\"#3-修改arrPtr函数，使其返回数组的引用\" class=\"headerlink\" title=\"3. 修改arrPtr函数，使其返回数组的引用\"></a>3. 修改arrPtr函数，使其返回数组的引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(odd) &amp;arrPtr(<span class=\"keyword\">int</span> i)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? odd : even;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"给出一个表达式，按照顺序求出表达式的值","date":"2017-03-25T14:54:21.000Z","comments":1,"_content":"## 按顺序求出表达式的值\n今天碰到一个题目：\n**题目描述：**\n> 常规的表达式求值，我们都会根据计算的优先级来计算， 比如`*`、`/`的优先级就高于`+`、`-`。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有`/`，只有(`+`,`-`和`*`)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。\n\n**输入描述：**\n> 输入为一行字符串，即一个表达式。其中运算符只有`+`,`-`和`*`。参与计算的数字只有0-9。\n保证表达式是合法的，排列规则如样例所示。\n\n**输出描述**\n> 输出一个数，即表达式的值\n\n<!--more-->\n\n**输入例子**\n> 3+5*7\n\n**输出例子**\n> 56\n\n刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的...\n\n## C++实现\n``` C++\n/*\n * 输入字符串表达式，按照输入顺序求出表达式的结果\n */\n\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<cmath>\n\nusing namespace std;\n\n// 字符串转数字\nint get_number(string num_str)\n{\n\tstringstream stream;\t// 声明stringstram变量\n\tint result = 0;\n\tint str_len = num_str.length();\n\tstream << num_str;\n\tstream >> result;\n\treturn result;\n}\n\nint main()\n{\n\tstring s;\t\t// 保存输入的字符串\n\tcout << \"请输入要计算的表达式(不包含除):\" << endl;\n\tcin >> s;\n\tint number[100] = { 0 };\t\t// 保存数字的数组\n\tstring operator_str;\t\t// 保存操作符的字符串\n\tint length = s.length();\n\tstring number_str;\t\t// 保存每个操作符之前的字符串\n\tint index = 0;\t// 标记保存数字的数组的指针\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (s[i] >= '0' && s[i] <= '9')\t\t// 如果是数字，则存入 number_str\n\t\t{\n\t\t\tnumber_str += s[i];\n\t\t}\n\t\telse\t\t// 如果是操作符，存入operator_str\n\t\t{\n\t\t\toperator_str += s[i];\n\t\t\tnumber[index] = get_number(number_str);\t\t// 得到两个操作符之间的操作数，并存入数组\n\t\t\tindex++;\n\t\t\tnumber_str = \"\";\t\t\t// 将字符串置为空，重新存入下一个操作数的字符串\n\t\t}\n\t\tif (i == length -1)\t\t// 得到表达式的最后一个操作数\n\t\t{\n\t\t\tnumber[index] = get_number(number_str);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tint result = 0;\t\t// 计算结果\n\tfor (int i = 0; i < index; i++)\n\t{\n\t\t//todo 计算结果\n\t\tif (i<1)\n\t\t{\n\t\t\tresult += number[i];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tswitch (operator_str[i-1])\n\t\t\t{\n\t\t\tcase '+':\n\t\t\t\tresult = result + number[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult = result - number[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result * number[i];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << number[i] << endl;\n\t}\n\t//for (int i = 0; i < operator_str.length(); i++)\n\t//{\n\t//\tcout << operator_str[i] << endl;\n\t//}\n\t//cout << \"输入的字符串为:\" << s << \" 得到的数字为: \" << number << endl;\n\n\tcout << \"Result = \" << result << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n挺简单的题目，居然写了这么多！ _ _(:3」∠)_ _\n太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง\n\nEnd~\n","source":"_posts/给出一个表达式，按照顺序求出表达式的值.md","raw":"---\ntitle: 给出一个表达式，按照顺序求出表达式的值\ndate: 2017-03-25 22:54:21\ncategory: CPP\ntags:\n- C++\n- String\ncomments: true\n---\n## 按顺序求出表达式的值\n今天碰到一个题目：\n**题目描述：**\n> 常规的表达式求值，我们都会根据计算的优先级来计算， 比如`*`、`/`的优先级就高于`+`、`-`。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有`/`，只有(`+`,`-`和`*`)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。\n\n**输入描述：**\n> 输入为一行字符串，即一个表达式。其中运算符只有`+`,`-`和`*`。参与计算的数字只有0-9。\n保证表达式是合法的，排列规则如样例所示。\n\n**输出描述**\n> 输出一个数，即表达式的值\n\n<!--more-->\n\n**输入例子**\n> 3+5*7\n\n**输出例子**\n> 56\n\n刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的...\n\n## C++实现\n``` C++\n/*\n * 输入字符串表达式，按照输入顺序求出表达式的结果\n */\n\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<cmath>\n\nusing namespace std;\n\n// 字符串转数字\nint get_number(string num_str)\n{\n\tstringstream stream;\t// 声明stringstram变量\n\tint result = 0;\n\tint str_len = num_str.length();\n\tstream << num_str;\n\tstream >> result;\n\treturn result;\n}\n\nint main()\n{\n\tstring s;\t\t// 保存输入的字符串\n\tcout << \"请输入要计算的表达式(不包含除):\" << endl;\n\tcin >> s;\n\tint number[100] = { 0 };\t\t// 保存数字的数组\n\tstring operator_str;\t\t// 保存操作符的字符串\n\tint length = s.length();\n\tstring number_str;\t\t// 保存每个操作符之前的字符串\n\tint index = 0;\t// 标记保存数字的数组的指针\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (s[i] >= '0' && s[i] <= '9')\t\t// 如果是数字，则存入 number_str\n\t\t{\n\t\t\tnumber_str += s[i];\n\t\t}\n\t\telse\t\t// 如果是操作符，存入operator_str\n\t\t{\n\t\t\toperator_str += s[i];\n\t\t\tnumber[index] = get_number(number_str);\t\t// 得到两个操作符之间的操作数，并存入数组\n\t\t\tindex++;\n\t\t\tnumber_str = \"\";\t\t\t// 将字符串置为空，重新存入下一个操作数的字符串\n\t\t}\n\t\tif (i == length -1)\t\t// 得到表达式的最后一个操作数\n\t\t{\n\t\t\tnumber[index] = get_number(number_str);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tint result = 0;\t\t// 计算结果\n\tfor (int i = 0; i < index; i++)\n\t{\n\t\t//todo 计算结果\n\t\tif (i<1)\n\t\t{\n\t\t\tresult += number[i];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tswitch (operator_str[i-1])\n\t\t\t{\n\t\t\tcase '+':\n\t\t\t\tresult = result + number[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult = result - number[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result * number[i];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << number[i] << endl;\n\t}\n\t//for (int i = 0; i < operator_str.length(); i++)\n\t//{\n\t//\tcout << operator_str[i] << endl;\n\t//}\n\t//cout << \"输入的字符串为:\" << s << \" 得到的数字为: \" << number << endl;\n\n\tcout << \"Result = \" << result << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n挺简单的题目，居然写了这么多！ _ _(:3」∠)_ _\n太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง\n\nEnd~\n","slug":"给出一个表达式，按照顺序求出表达式的值","published":1,"updated":"2019-01-07T13:44:48.080Z","layout":"post","photos":[],"link":"","_id":"cjqojmlyh002bswqcfyx9sh7e","content":"<h2 id=\"按顺序求出表达式的值\"><a href=\"#按顺序求出表达式的值\" class=\"headerlink\" title=\"按顺序求出表达式的值\"></a>按顺序求出表达式的值</h2><p>今天碰到一个题目：<br><strong>题目描述：</strong></p>\n<blockquote>\n<p>常规的表达式求值，我们都会根据计算的优先级来计算， 比如<code>*</code>、<code>/</code>的优先级就高于<code>+</code>、<code>-</code>。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有<code>/</code>，只有(<code>+</code>,<code>-</code>和<code>*</code>)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。</p>\n</blockquote>\n<p><strong>输入描述：</strong></p>\n<blockquote>\n<p>输入为一行字符串，即一个表达式。其中运算符只有<code>+</code>,<code>-</code>和<code>*</code>。参与计算的数字只有0-9。<br>保证表达式是合法的，排列规则如样例所示。</p>\n</blockquote>\n<p><strong>输出描述</strong></p>\n<blockquote>\n<p>输出一个数，即表达式的值</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>输入例子</strong></p>\n<blockquote>\n<p>3+5*7</p>\n</blockquote>\n<p><strong>输出例子</strong></p>\n<blockquote>\n<p>56</p>\n</blockquote>\n<p>刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的…</p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * 输入字符串表达式，按照输入顺序求出表达式的结果</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 字符串转数字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_number</span><span class=\"params\">(<span class=\"built_in\">string</span> num_str)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">stringstream</span> stream;\t<span class=\"comment\">// 声明stringstram变量</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> str_len = num_str.length();</div><div class=\"line\">\tstream &lt;&lt; num_str;</div><div class=\"line\">\tstream &gt;&gt; result;</div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">string</span> s;\t\t<span class=\"comment\">// 保存输入的字符串</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入要计算的表达式(不包含除):\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; s;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number[<span class=\"number\">100</span>] = &#123; <span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 保存数字的数组</span></div><div class=\"line\">\t<span class=\"built_in\">string</span> operator_str;\t\t<span class=\"comment\">// 保存操作符的字符串</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> length = s.length();</div><div class=\"line\">\t<span class=\"built_in\">string</span> number_str;\t\t<span class=\"comment\">// 保存每个操作符之前的字符串</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;\t<span class=\"comment\">// 标记保存数字的数组的指针</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] &gt;= <span class=\"string\">'0'</span> &amp;&amp; s[i] &lt;= <span class=\"string\">'9'</span>)\t\t<span class=\"comment\">// 如果是数字，则存入 number_str</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tnumber_str += s[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>\t\t<span class=\"comment\">// 如果是操作符，存入operator_str</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\toperator_str += s[i];</div><div class=\"line\">\t\t\tnumber[index] = get_number(number_str);\t\t<span class=\"comment\">// 得到两个操作符之间的操作数，并存入数组</span></div><div class=\"line\">\t\t\tindex++;</div><div class=\"line\">\t\t\tnumber_str = <span class=\"string\">\"\"</span>;\t\t\t<span class=\"comment\">// 将字符串置为空，重新存入下一个操作数的字符串</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i == length <span class=\"number\">-1</span>)\t\t<span class=\"comment\">// 得到表达式的最后一个操作数</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tnumber[index] = get_number(number_str);</div><div class=\"line\">\t\t\tindex++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 计算结果</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//todo 计算结果</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;<span class=\"number\">1</span>)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tresult += number[i];</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (operator_str[i<span class=\"number\">-1</span>])</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">\t\t\t\tresult = result + number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">\t\t\t\tresult = result - number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">\t\t\t\tresult = result * number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; number[i] &lt;&lt; endl;</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//for (int i = 0; i &lt; operator_str.length(); i++)</span></div><div class=\"line\">\t<span class=\"comment\">//&#123;</span></div><div class=\"line\">\t<span class=\"comment\">//\tcout &lt;&lt; operator_str[i] &lt;&lt; endl;</span></div><div class=\"line\">\t<span class=\"comment\">//&#125;</span></div><div class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; \"输入的字符串为:\" &lt;&lt; s &lt;&lt; \" 得到的数字为: \" &lt;&lt; number &lt;&lt; endl;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Result = \"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>挺简单的题目，居然写了这么多！ <em> </em>(:3」∠)<em> </em><br>太久没写了，写的有点丑¬<em>¬，看来还是要多练习 (ง •̀</em>•́)ง</p>\n<p>End~</p>\n","excerpt":"<h2 id=\"按顺序求出表达式的值\"><a href=\"#按顺序求出表达式的值\" class=\"headerlink\" title=\"按顺序求出表达式的值\"></a>按顺序求出表达式的值</h2><p>今天碰到一个题目：<br><strong>题目描述：</strong></p>\n<blockquote>\n<p>常规的表达式求值，我们都会根据计算的优先级来计算， 比如<code>*</code>、<code>/</code>的优先级就高于<code>+</code>、<code>-</code>。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有<code>/</code>，只有(<code>+</code>,<code>-</code>和<code>*</code>)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。</p>\n</blockquote>\n<p><strong>输入描述：</strong></p>\n<blockquote>\n<p>输入为一行字符串，即一个表达式。其中运算符只有<code>+</code>,<code>-</code>和<code>*</code>。参与计算的数字只有0-9。<br>保证表达式是合法的，排列规则如样例所示。</p>\n</blockquote>\n<p><strong>输出描述</strong></p>\n<blockquote>\n<p>输出一个数，即表达式的值</p>\n</blockquote>","more":"<p><strong>输入例子</strong></p>\n<blockquote>\n<p>3+5*7</p>\n</blockquote>\n<p><strong>输出例子</strong></p>\n<blockquote>\n<p>56</p>\n</blockquote>\n<p>刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的…</p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * 输入字符串表达式，按照输入顺序求出表达式的结果</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 字符串转数字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_number</span><span class=\"params\">(<span class=\"built_in\">string</span> num_str)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">stringstream</span> stream;\t<span class=\"comment\">// 声明stringstram变量</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> str_len = num_str.length();</div><div class=\"line\">\tstream &lt;&lt; num_str;</div><div class=\"line\">\tstream &gt;&gt; result;</div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">string</span> s;\t\t<span class=\"comment\">// 保存输入的字符串</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入要计算的表达式(不包含除):\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; s;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number[<span class=\"number\">100</span>] = &#123; <span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 保存数字的数组</span></div><div class=\"line\">\t<span class=\"built_in\">string</span> operator_str;\t\t<span class=\"comment\">// 保存操作符的字符串</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> length = s.length();</div><div class=\"line\">\t<span class=\"built_in\">string</span> number_str;\t\t<span class=\"comment\">// 保存每个操作符之前的字符串</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;\t<span class=\"comment\">// 标记保存数字的数组的指针</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] &gt;= <span class=\"string\">'0'</span> &amp;&amp; s[i] &lt;= <span class=\"string\">'9'</span>)\t\t<span class=\"comment\">// 如果是数字，则存入 number_str</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tnumber_str += s[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>\t\t<span class=\"comment\">// 如果是操作符，存入operator_str</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\toperator_str += s[i];</div><div class=\"line\">\t\t\tnumber[index] = get_number(number_str);\t\t<span class=\"comment\">// 得到两个操作符之间的操作数，并存入数组</span></div><div class=\"line\">\t\t\tindex++;</div><div class=\"line\">\t\t\tnumber_str = <span class=\"string\">\"\"</span>;\t\t\t<span class=\"comment\">// 将字符串置为空，重新存入下一个操作数的字符串</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i == length <span class=\"number\">-1</span>)\t\t<span class=\"comment\">// 得到表达式的最后一个操作数</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tnumber[index] = get_number(number_str);</div><div class=\"line\">\t\t\tindex++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 计算结果</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//todo 计算结果</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;<span class=\"number\">1</span>)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tresult += number[i];</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (operator_str[i<span class=\"number\">-1</span>])</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">\t\t\t\tresult = result + number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">\t\t\t\tresult = result - number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">\t\t\t\tresult = result * number[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; number[i] &lt;&lt; endl;</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//for (int i = 0; i &lt; operator_str.length(); i++)</span></div><div class=\"line\">\t<span class=\"comment\">//&#123;</span></div><div class=\"line\">\t<span class=\"comment\">//\tcout &lt;&lt; operator_str[i] &lt;&lt; endl;</span></div><div class=\"line\">\t<span class=\"comment\">//&#125;</span></div><div class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; \"输入的字符串为:\" &lt;&lt; s &lt;&lt; \" 得到的数字为: \" &lt;&lt; number &lt;&lt; endl;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Result = \"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>挺简单的题目，居然写了这么多！ <em> </em>(:3」∠)<em> </em><br>太久没写了，写的有点丑¬<em>¬，看来还是要多练习 (ง •̀</em>•́)ง</p>\n<p>End~</p>"},{"title":"使用 Travis CI 实现 Hexo 博客自动构建和部署","date":"2019-01-16T05:54:52.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-01-16.jpg","_content":"\n![Travis CI](/images/imagesource/19-01-16/TravisCI-Full-Color.png)\n\n昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：\n\n1. 每次博客更新都要自己手动 `hexo d -g`，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。\n2. 考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。\n\n因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。\n\n<!--more-->\n\n## Hexo 博客源代码 GitHub 托管\n\nHexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 `source` 分支，用于存放源文件。\n\n![github branches](/images/imagesource/19-01-16/2019-01-16-1.png)\n\n具体操作如下：\n\n### 添加分支\n\n在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。\n\n### 将仓库克隆至本地\n\n在本地使用 `git clone 你的仓库地址` 将仓库克隆至本地，然后使用 `git checkout source` 命令，切换到新创建的分支。\n\n### 在新分支中添加博客源文件\n\n删除该分支下除了 `.git` 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：\n\n![source file](/images/imagesource/19-01-16/2019-01-16-2.png)\n\n然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。\n\n## 使用 Travis CI 自动部署\n\n### Travis CI 简介\n\nTravis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。\n\n### 配置 Travis CI\n\n#### 网页端配置\n\n首先进入 [Travis CI 官网](https://travis-ci.org/)，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 [付费版的 Travis CI](https://travis-ci.com/)。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 `Felon03.github.io`，把旁边的勾勾上，然后点击旁边的 `Settings` 进入设置页面。\n\n![Travis enable](/images/imagesource/19-01-16/2019-01-16-3.png)\n\n在设置页面中，General 中只勾选 `Build pushed branches`，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。\n\n![Travis settings](/images/imagesource/19-01-16/2019-01-16-4.png)\n\n接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 [Personal access tokens](https://github.com/settings/tokens) 页面，点击 `Generate new token`，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。\n\n![generate token](/images/imagesource/19-01-16/2019-01-16-5.png)\n\n接着在原来 Travis 的设置界面添加 token。如图所示：\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-6.png)\n\n在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。\n\n#### Travis 配置文件\n\n接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 `.travis.yml`，是自动化构建的配置文件。文件内容示例如下：\n\n```yml\nlanguage: node_js\nsudo: required\nnode_js:\n  - 7.9.0\n\n# 指定缓存模块，可加快编译速度\ncache:\n  directories:\n    - node_modules\n\n# 指定博客源码分支，这里填入博客源码的分支名\nbranches:\n  only:\n    - source\n\nbefore_install:\n  - export TZ='Asia/Shanghai' # 更改时区\n  - npm install -g hexo-cli\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n  - npm install hexo-deployer-git --save\n\nbefore_script:\n # - npm install -g gulp\n\nscript:\n  - hexo clean\n  - hexo generate\n\n# 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署\nafter_script:\n  - git config user.name \"FreedomLy\"\n  - git config user.email \"Freedom.JFL@gmail.com\"\n  - git clone https://github.com/Felon03/Felon03.github.io.git .deploy_git # 解决 commit 清空问题\n  - cd .deploy_git\n  - git checkout master\n  - cd ../\n  # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！\n  - sed -i \"s/gh_token/${GH_TOKEN}/g\" ./_config.yml # 这里的 GH_TOKEN 名字要和网页中定义的别名一致\n  - cat ./_config.yml\n  - hexo deploy\n# E: Build LifeCycle\n```\n\n同时修改 Hexo 的 `_confi.yml` 文件中的 deploy 模块，将原来的\n\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:Felon03/Felon03.github.io.git\n  branch: master\n```\n\n修改为\n\n```yml\ndeploy:\n  type: git\n  repo: https://gh_token@github.com/Felon03/Felon03.github.io.git\n  branch: master\n```\n\n这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 `.travis.yml` 中的 branches 中填入的是存放博客源码的分支，而 `_config.yml` 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。\n\n然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-7.png)\n\n自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 `.md` 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。\n\n## 参考资料\n\n[1]: [Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程](https://blog.csdn.net/Xiong_IT/article/details/78675874)\n[2]: [使用Travis CI自动部署Hexo博客](https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/)\n[3]: [使用Travis Ci使hexo自动生成并部署](https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/)","source":"_posts/Hexo-Travis-CI-auto-deploy.md","raw":"---\ntitle: 使用 Travis CI 实现 Hexo 博客自动构建和部署\ndate: 2019-01-16 13:54:52\ncategory: Tech\ntags: [Travis-CI, Hexo]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-01-16.jpg\n---\n\n![Travis CI](/images/imagesource/19-01-16/TravisCI-Full-Color.png)\n\n昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：\n\n1. 每次博客更新都要自己手动 `hexo d -g`，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。\n2. 考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。\n\n因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。\n\n<!--more-->\n\n## Hexo 博客源代码 GitHub 托管\n\nHexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 `source` 分支，用于存放源文件。\n\n![github branches](/images/imagesource/19-01-16/2019-01-16-1.png)\n\n具体操作如下：\n\n### 添加分支\n\n在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。\n\n### 将仓库克隆至本地\n\n在本地使用 `git clone 你的仓库地址` 将仓库克隆至本地，然后使用 `git checkout source` 命令，切换到新创建的分支。\n\n### 在新分支中添加博客源文件\n\n删除该分支下除了 `.git` 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：\n\n![source file](/images/imagesource/19-01-16/2019-01-16-2.png)\n\n然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。\n\n## 使用 Travis CI 自动部署\n\n### Travis CI 简介\n\nTravis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。\n\n### 配置 Travis CI\n\n#### 网页端配置\n\n首先进入 [Travis CI 官网](https://travis-ci.org/)，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 [付费版的 Travis CI](https://travis-ci.com/)。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 `Felon03.github.io`，把旁边的勾勾上，然后点击旁边的 `Settings` 进入设置页面。\n\n![Travis enable](/images/imagesource/19-01-16/2019-01-16-3.png)\n\n在设置页面中，General 中只勾选 `Build pushed branches`，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。\n\n![Travis settings](/images/imagesource/19-01-16/2019-01-16-4.png)\n\n接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 [Personal access tokens](https://github.com/settings/tokens) 页面，点击 `Generate new token`，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。\n\n![generate token](/images/imagesource/19-01-16/2019-01-16-5.png)\n\n接着在原来 Travis 的设置界面添加 token。如图所示：\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-6.png)\n\n在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。\n\n#### Travis 配置文件\n\n接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 `.travis.yml`，是自动化构建的配置文件。文件内容示例如下：\n\n```yml\nlanguage: node_js\nsudo: required\nnode_js:\n  - 7.9.0\n\n# 指定缓存模块，可加快编译速度\ncache:\n  directories:\n    - node_modules\n\n# 指定博客源码分支，这里填入博客源码的分支名\nbranches:\n  only:\n    - source\n\nbefore_install:\n  - export TZ='Asia/Shanghai' # 更改时区\n  - npm install -g hexo-cli\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n  - npm install hexo-deployer-git --save\n\nbefore_script:\n # - npm install -g gulp\n\nscript:\n  - hexo clean\n  - hexo generate\n\n# 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署\nafter_script:\n  - git config user.name \"FreedomLy\"\n  - git config user.email \"Freedom.JFL@gmail.com\"\n  - git clone https://github.com/Felon03/Felon03.github.io.git .deploy_git # 解决 commit 清空问题\n  - cd .deploy_git\n  - git checkout master\n  - cd ../\n  # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！\n  - sed -i \"s/gh_token/${GH_TOKEN}/g\" ./_config.yml # 这里的 GH_TOKEN 名字要和网页中定义的别名一致\n  - cat ./_config.yml\n  - hexo deploy\n# E: Build LifeCycle\n```\n\n同时修改 Hexo 的 `_confi.yml` 文件中的 deploy 模块，将原来的\n\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:Felon03/Felon03.github.io.git\n  branch: master\n```\n\n修改为\n\n```yml\ndeploy:\n  type: git\n  repo: https://gh_token@github.com/Felon03/Felon03.github.io.git\n  branch: master\n```\n\n这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 `.travis.yml` 中的 branches 中填入的是存放博客源码的分支，而 `_config.yml` 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。\n\n然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-7.png)\n\n自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 `.md` 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。\n\n## 参考资料\n\n[1]: [Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程](https://blog.csdn.net/Xiong_IT/article/details/78675874)\n[2]: [使用Travis CI自动部署Hexo博客](https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/)\n[3]: [使用Travis Ci使hexo自动生成并部署](https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/)","slug":"Hexo-Travis-CI-auto-deploy","published":1,"updated":"2019-01-16T07:40:47.013Z","layout":"post","photos":[],"link":"","_id":"cjqz9kucr0000m8qctz6ibxkv","content":"<p><img src=\"/images/imagesource/19-01-16/TravisCI-Full-Color.png\" alt=\"Travis CI\"></p>\n<p>昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：</p>\n<ol>\n<li>每次博客更新都要自己手动 <code>hexo d -g</code>，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。</li>\n<li>考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。</li>\n</ol>\n<p>因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。</p>\n<a id=\"more\"></a>\n<h2 id=\"Hexo-博客源代码-GitHub-托管\"><a href=\"#Hexo-博客源代码-GitHub-托管\" class=\"headerlink\" title=\"Hexo 博客源代码 GitHub 托管\"></a>Hexo 博客源代码 GitHub 托管</h2><p>Hexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 <code>source</code> 分支，用于存放源文件。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-1.png\" alt=\"github branches\"></p>\n<p>具体操作如下：</p>\n<h3 id=\"添加分支\"><a href=\"#添加分支\" class=\"headerlink\" title=\"添加分支\"></a>添加分支</h3><p>在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。</p>\n<h3 id=\"将仓库克隆至本地\"><a href=\"#将仓库克隆至本地\" class=\"headerlink\" title=\"将仓库克隆至本地\"></a>将仓库克隆至本地</h3><p>在本地使用 <code>git clone 你的仓库地址</code> 将仓库克隆至本地，然后使用 <code>git checkout source</code> 命令，切换到新创建的分支。</p>\n<h3 id=\"在新分支中添加博客源文件\"><a href=\"#在新分支中添加博客源文件\" class=\"headerlink\" title=\"在新分支中添加博客源文件\"></a>在新分支中添加博客源文件</h3><p>删除该分支下除了 <code>.git</code> 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-2.png\" alt=\"source file\"></p>\n<p>然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。</p>\n<h2 id=\"使用-Travis-CI-自动部署\"><a href=\"#使用-Travis-CI-自动部署\" class=\"headerlink\" title=\"使用 Travis CI 自动部署\"></a>使用 Travis CI 自动部署</h2><h3 id=\"Travis-CI-简介\"><a href=\"#Travis-CI-简介\" class=\"headerlink\" title=\"Travis CI 简介\"></a>Travis CI 简介</h3><p>Travis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。</p>\n<h3 id=\"配置-Travis-CI\"><a href=\"#配置-Travis-CI\" class=\"headerlink\" title=\"配置 Travis CI\"></a>配置 Travis CI</h3><h4 id=\"网页端配置\"><a href=\"#网页端配置\" class=\"headerlink\" title=\"网页端配置\"></a>网页端配置</h4><p>首先进入 <a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"external\">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 <code>Felon03.github.io</code>，把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-3.png\" alt=\"Travis enable\"></p>\n<p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-4.png\" alt=\"Travis settings\"></p>\n<p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"external\">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-5.png\" alt=\"generate token\"></p>\n<p>接着在原来 Travis 的设置界面添加 token。如图所示：</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-6.png\" alt=\"Travis token\"></p>\n<p>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p>\n<h4 id=\"Travis-配置文件\"><a href=\"#Travis-配置文件\" class=\"headerlink\" title=\"Travis 配置文件\"></a>Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></div><div class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"string\">required</span></div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"number\">7.9</span><span class=\"number\">.0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 指定缓存模块，可加快编译速度</span></div><div class=\"line\"><span class=\"attr\">cache:</span></div><div class=\"line\"><span class=\"attr\">  directories:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">node_modules</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 指定博客源码分支，这里填入博客源码的分支名</span></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">source</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">before_install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"bullet\">-g</span> <span class=\"string\">hexo-cli</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># S: Build Lifecycle</span></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"bullet\">--save</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">before_script:</span></div><div class=\"line\"> <span class=\"comment\"># - npm install -g gulp</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署</span></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"FreedomLy\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"Freedom.JFL@gmail.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://github.com/Felon03/Felon03.github.io.git</span> <span class=\"string\">.deploy_git</span> <span class=\"comment\"># 解决 commit 清空问题</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></div><div class=\"line\">  <span class=\"comment\"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">sed</span> <span class=\"bullet\">-i</span> <span class=\"string\">\"s/gh_token/$&#123;GH_TOKEN&#125;/g\"</span> <span class=\"string\">./_config.yml</span> <span class=\"comment\"># 这里的 GH_TOKEN 名字要和网页中定义的别名一致</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cat</span> <span class=\"string\">./_config.yml</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></div><div class=\"line\"><span class=\"comment\"># E: Build LifeCycle</span></div></pre></td></tr></table></figure>\n<p>同时修改 Hexo 的 <code>_confi.yml</code> 文件中的 deploy 模块，将原来的</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></div><div class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">git@github.com:Felon03/Felon03.github.io.git</span></div><div class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></div></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></div><div class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://gh_token@github.com/Felon03/Felon03.github.io.git</span></div><div class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></div></pre></td></tr></table></figure>\n<p>这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 <code>.travis.yml</code> 中的 branches 中填入的是存放博客源码的分支，而 <code>_config.yml</code> 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。</p>\n<p>然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-7.png\" alt=\"Travis token\"></p>\n<p>自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 <code>.md</code> 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://blog.csdn.net/Xiong_IT/article/details/78675874\" target=\"_blank\" rel=\"external\">Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程</a><br>[2]: <a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"external\">使用Travis CI自动部署Hexo博客</a><br>[3]: <a href=\"https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/\" target=\"_blank\" rel=\"external\">使用Travis Ci使hexo自动生成并部署</a></p>\n","excerpt":"<p><img src=\"/images/imagesource/19-01-16/TravisCI-Full-Color.png\" alt=\"Travis CI\"></p>\n<p>昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：</p>\n<ol>\n<li>每次博客更新都要自己手动 <code>hexo d -g</code>，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。</li>\n<li>考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。</li>\n</ol>\n<p>因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。</p>","more":"<h2 id=\"Hexo-博客源代码-GitHub-托管\"><a href=\"#Hexo-博客源代码-GitHub-托管\" class=\"headerlink\" title=\"Hexo 博客源代码 GitHub 托管\"></a>Hexo 博客源代码 GitHub 托管</h2><p>Hexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 <code>source</code> 分支，用于存放源文件。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-1.png\" alt=\"github branches\"></p>\n<p>具体操作如下：</p>\n<h3 id=\"添加分支\"><a href=\"#添加分支\" class=\"headerlink\" title=\"添加分支\"></a>添加分支</h3><p>在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。</p>\n<h3 id=\"将仓库克隆至本地\"><a href=\"#将仓库克隆至本地\" class=\"headerlink\" title=\"将仓库克隆至本地\"></a>将仓库克隆至本地</h3><p>在本地使用 <code>git clone 你的仓库地址</code> 将仓库克隆至本地，然后使用 <code>git checkout source</code> 命令，切换到新创建的分支。</p>\n<h3 id=\"在新分支中添加博客源文件\"><a href=\"#在新分支中添加博客源文件\" class=\"headerlink\" title=\"在新分支中添加博客源文件\"></a>在新分支中添加博客源文件</h3><p>删除该分支下除了 <code>.git</code> 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-2.png\" alt=\"source file\"></p>\n<p>然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。</p>\n<h2 id=\"使用-Travis-CI-自动部署\"><a href=\"#使用-Travis-CI-自动部署\" class=\"headerlink\" title=\"使用 Travis CI 自动部署\"></a>使用 Travis CI 自动部署</h2><h3 id=\"Travis-CI-简介\"><a href=\"#Travis-CI-简介\" class=\"headerlink\" title=\"Travis CI 简介\"></a>Travis CI 简介</h3><p>Travis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。</p>\n<h3 id=\"配置-Travis-CI\"><a href=\"#配置-Travis-CI\" class=\"headerlink\" title=\"配置 Travis CI\"></a>配置 Travis CI</h3><h4 id=\"网页端配置\"><a href=\"#网页端配置\" class=\"headerlink\" title=\"网页端配置\"></a>网页端配置</h4><p>首先进入 <a href=\"https://travis-ci.org/\">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href=\"https://travis-ci.com/\">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 <code>Felon03.github.io</code>，把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-3.png\" alt=\"Travis enable\"></p>\n<p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-4.png\" alt=\"Travis settings\"></p>\n<p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href=\"https://github.com/settings/tokens\">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-5.png\" alt=\"generate token\"></p>\n<p>接着在原来 Travis 的设置界面添加 token。如图所示：</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-6.png\" alt=\"Travis token\"></p>\n<p>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p>\n<h4 id=\"Travis-配置文件\"><a href=\"#Travis-配置文件\" class=\"headerlink\" title=\"Travis 配置文件\"></a>Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></div><div class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"string\">required</span></div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"number\">7.9</span><span class=\"number\">.0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 指定缓存模块，可加快编译速度</span></div><div class=\"line\"><span class=\"attr\">cache:</span></div><div class=\"line\"><span class=\"attr\">  directories:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">node_modules</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 指定博客源码分支，这里填入博客源码的分支名</span></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">source</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">before_install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"bullet\">-g</span> <span class=\"string\">hexo-cli</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># S: Build Lifecycle</span></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"bullet\">--save</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">before_script:</span></div><div class=\"line\"> <span class=\"comment\"># - npm install -g gulp</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署</span></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"FreedomLy\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"Freedom.JFL@gmail.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://github.com/Felon03/Felon03.github.io.git</span> <span class=\"string\">.deploy_git</span> <span class=\"comment\"># 解决 commit 清空问题</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></div><div class=\"line\">  <span class=\"comment\"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">sed</span> <span class=\"bullet\">-i</span> <span class=\"string\">\"s/gh_token/$&#123;GH_TOKEN&#125;/g\"</span> <span class=\"string\">./_config.yml</span> <span class=\"comment\"># 这里的 GH_TOKEN 名字要和网页中定义的别名一致</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">cat</span> <span class=\"string\">./_config.yml</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></div><div class=\"line\"><span class=\"comment\"># E: Build LifeCycle</span></div></pre></td></tr></table></figure>\n<p>同时修改 Hexo 的 <code>_confi.yml</code> 文件中的 deploy 模块，将原来的</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></div><div class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">git@github.com:Felon03/Felon03.github.io.git</span></div><div class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></div></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">deploy:</span></div><div class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></div><div class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://gh_token@github.com/Felon03/Felon03.github.io.git</span></div><div class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></div></pre></td></tr></table></figure>\n<p>这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 <code>.travis.yml</code> 中的 branches 中填入的是存放博客源码的分支，而 <code>_config.yml</code> 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。</p>\n<p>然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。</p>\n<p><img src=\"/images/imagesource/19-01-16/2019-01-16-7.png\" alt=\"Travis token\"></p>\n<p>自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 <code>.md</code> 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://blog.csdn.net/Xiong_IT/article/details/78675874\">Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程</a><br>[2]: <a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\">使用Travis CI自动部署Hexo博客</a><br>[3]: <a href=\"https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/\">使用Travis Ci使hexo自动生成并部署</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjqojmlvg000aswqcu1htuswu","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlvv000hswqcme6l4hzz"},{"post_id":"cjqojmlv00002swqcl7hfoxr1","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlvv000lswqcxkuij1eu"},{"post_id":"cjqojmlvg000cswqcavrvhzl4","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlvv000oswqc46whwbil"},{"post_id":"cjqojmlv00004swqczs0pu55v","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlwb000sswqcyv7s5t5k"},{"post_id":"cjqojmlvg0008swqce6ibfsqa","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlwq000uswqchp18v45x"},{"post_id":"cjqojmlwb000tswqc1fk4pigk","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlwq000zswqcjpc1qtjr"},{"post_id":"cjqojmlvv000gswqcz4qhkwle","category_id":"cjqojmlwb000qswqcn51rol97","_id":"cjqojmlwq0012swqcbuonur6h"},{"post_id":"cjqojmlwq000yswqcn023vi47","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlx60016swqcpt12n2te"},{"post_id":"cjqojmlvv000iswqcdxwyhzzo","category_id":"cjqojmlwb000qswqcn51rol97","_id":"cjqojmlx6001aswqcvlv4074a"},{"post_id":"cjqojmlwq0014swqc5a558ede","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlx6001eswqcgylchb7q"},{"post_id":"cjqojmlvv000nswqcpnnmf4vp","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlx6001iswqc0xlr8hp5"},{"post_id":"cjqojmlx60017swqckxhxigsd","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlxm001mswqch7ci3eck"},{"post_id":"cjqojmlx6001cswqcv35r3uxt","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlxm001oswqck1abegm4"},{"post_id":"cjqojmlvv000pswqcol24byzi","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlxm001sswqcu3qcxoa7"},{"post_id":"cjqojmlx6001fswqchp262cal","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlxm001vswqcph1dkybl"},{"post_id":"cjqojmlxm001kswqc0yaej6za","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmly1001yswqcmmt7w06y"},{"post_id":"cjqojmlwq000vswqcdmakblyy","category_id":"cjqojmlx6001gswqcm941r7p0","_id":"cjqojmly10021swqc1uoavfgu"},{"post_id":"cjqojmlxm001nswqcrgda3tw8","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmly10024swqc6ay1agld"},{"post_id":"cjqojmlxm001qswqc3qt6hcvp","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmly10027swqcv0er571x"},{"post_id":"cjqojmlxm001uswqcinxeqsnf","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlyh002aswqczhlrsvbd"},{"post_id":"cjqojmlwq0010swqctvb2l9uz","category_id":"cjqojmlxm001pswqcwy10ajpi","_id":"cjqojmlyh002dswqc1kkgqnij"},{"post_id":"cjqojmlxm001wswqcfzfyzpne","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlyh002gswqcbcl7tb9y"},{"post_id":"cjqojmly10020swqc90sivvuk","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlyh002iswqcezo8i5bc"},{"post_id":"cjqojmly10025swqcjxnrc3vc","category_id":"cjqojmlwq0011swqc582myis1","_id":"cjqojmlyh002kswqczh7v9pry"},{"post_id":"cjqojmly10028swqczho22o96","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlyh002nswqci0ch1bms"},{"post_id":"cjqojmlyh002bswqcfyx9sh7e","category_id":"cjqojmlv00006swqc19in2rhk","_id":"cjqojmlyh002pswqcn2wwxzs2"},{"post_id":"cjqojmly10022swqcasipqg6i","category_id":"cjqojmly10026swqcuuboxrrd","_id":"cjqojmlyh002sswqcpxj8l1u0"},{"post_id":"cjqz9kucr0000m8qctz6ibxkv","category_id":"cjqz9kud70001m8qcniy18kzw","_id":"cjqz9kudn0004m8qczjmgn6ph"}],"PostTag":[{"post_id":"cjqojmlv00002swqcl7hfoxr1","tag_id":"cjqojmlv00007swqceebgznej","_id":"cjqojmlvg000fswqc91a78jvh"},{"post_id":"cjqojmlv00004swqczs0pu55v","tag_id":"cjqojmlv00007swqceebgznej","_id":"cjqojmlvv000mswqclk52nty4"},{"post_id":"cjqojmlvg0008swqce6ibfsqa","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlx60015swqcc5ws0jag"},{"post_id":"cjqojmlvg0008swqce6ibfsqa","tag_id":"cjqojmlwb000rswqcmbdqgpvd","_id":"cjqojmlx60019swqcd64z9v45"},{"post_id":"cjqojmlvg0008swqce6ibfsqa","tag_id":"cjqojmlwq000xswqcuqtnrjr6","_id":"cjqojmlx6001dswqca02fl4os"},{"post_id":"cjqojmlvg000aswqcu1htuswu","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlx6001hswqcthp9dcdz"},{"post_id":"cjqojmlvg000cswqcavrvhzl4","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlxm001lswqcxnzerdo7"},{"post_id":"cjqojmlvv000gswqcz4qhkwle","tag_id":"cjqojmlx6001jswqctbojf9xr","_id":"cjqojmlxm001tswqccqxz3xko"},{"post_id":"cjqojmlvv000iswqcdxwyhzzo","tag_id":"cjqojmlx6001jswqctbojf9xr","_id":"cjqojmly1001zswqc4jzltryx"},{"post_id":"cjqojmlvv000nswqcpnnmf4vp","tag_id":"cjqojmly1001xswqcn0gf7ez3","_id":"cjqojmlyh002cswqc6b0jspp2"},{"post_id":"cjqojmlvv000nswqcpnnmf4vp","tag_id":"cjqojmly10023swqc3sbv63ah","_id":"cjqojmlyh002eswqc8us93hys"},{"post_id":"cjqojmly10028swqczho22o96","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlyh002hswqcu3ce5lvn"},{"post_id":"cjqojmlyh002bswqcfyx9sh7e","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlyh002jswqc980ukpg5"},{"post_id":"cjqojmlyh002bswqcfyx9sh7e","tag_id":"cjqojmlwb000rswqcmbdqgpvd","_id":"cjqojmlyh002mswqcpv40koq5"},{"post_id":"cjqojmlvv000pswqcol24byzi","tag_id":"cjqojmly1001xswqcn0gf7ez3","_id":"cjqojmlyh002oswqc8iy968gh"},{"post_id":"cjqojmlwb000tswqc1fk4pigk","tag_id":"cjqojmlyh002fswqchiix5mwd","_id":"cjqojmlyh002rswqcz16igh8t"},{"post_id":"cjqojmlwq000vswqcdmakblyy","tag_id":"cjqojmlyh002lswqcixljn5fl","_id":"cjqojmlyh002tswqcs9i2ihrb"},{"post_id":"cjqojmlwq000yswqcn023vi47","tag_id":"cjqojmlvv000kswqcl8jsx5bk","_id":"cjqojmlyx002vswqcsj6d1w8a"},{"post_id":"cjqojmlwq000yswqcn023vi47","tag_id":"cjqojmlyh002qswqcu8d9ongs","_id":"cjqojmlyx002wswqcdzch4eix"},{"post_id":"cjqojmlwq0010swqctvb2l9uz","tag_id":"cjqojmlyh002uswqcmnop1nth","_id":"cjqojmlyx002yswqcdihzw74j"},{"post_id":"cjqojmlwq0014swqc5a558ede","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx0030swqcqvtlrdgv"},{"post_id":"cjqojmlx60017swqckxhxigsd","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx0032swqcb6xjb8d5"},{"post_id":"cjqojmlx6001cswqcv35r3uxt","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx0035swqclu9fmvp6"},{"post_id":"cjqojmlx6001cswqcv35r3uxt","tag_id":"cjqojmlyx0033swqc0jk6v5p6","_id":"cjqojmlyx0036swqcdhqhvcce"},{"post_id":"cjqojmlx6001fswqchp262cal","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx0038swqc4u6gfxvz"},{"post_id":"cjqojmlxm001kswqc0yaej6za","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003aswqcoweljiqr"},{"post_id":"cjqojmlxm001nswqcrgda3tw8","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003cswqc68qd0nk0"},{"post_id":"cjqojmlxm001qswqc3qt6hcvp","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003eswqcqwh6sxuh"},{"post_id":"cjqojmlxm001uswqcinxeqsnf","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003gswqcueil8cq2"},{"post_id":"cjqojmlxm001wswqcfzfyzpne","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003iswqc736tmn8m"},{"post_id":"cjqojmly10020swqc90sivvuk","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003kswqcls8x7ab0"},{"post_id":"cjqojmly10022swqcasipqg6i","tag_id":"cjqojmlyx003jswqc9rgpygmr","_id":"cjqojmlyx003mswqcc11v3ez2"},{"post_id":"cjqojmly10025swqcjxnrc3vc","tag_id":"cjqojmlyx002xswqc2udp7fce","_id":"cjqojmlyx003nswqc67nfihj6"},{"post_id":"cjqz9kucr0000m8qctz6ibxkv","tag_id":"cjqz9kudn0002m8qcj0ubbpuw","_id":"cjqz9kudn0005m8qc9qykgy7k"},{"post_id":"cjqz9kucr0000m8qctz6ibxkv","tag_id":"cjqz9kudn0003m8qc5yzke77a","_id":"cjqz9kudn0006m8qcnsjgxdfb"}],"Tag":[{"name":"C++ Primer","_id":"cjqojmlv00007swqceebgznej"},{"name":"C++","_id":"cjqojmlvv000kswqcl8jsx5bk"},{"name":"String","_id":"cjqojmlwb000rswqcmbdqgpvd"},{"name":"vector","_id":"cjqojmlwq000xswqcuqtnrjr6"},{"name":"LeetCode","_id":"cjqojmlx6001jswqctbojf9xr"},{"name":"Python","_id":"cjqojmly1001xswqcn0gf7ez3"},{"name":"词云","_id":"cjqojmly10023swqc3sbv63ah"},{"name":"UTF-8","_id":"cjqojmlyh002fswqchiix5mwd"},{"name":"VSCode","_id":"cjqojmlyh002lswqcixljn5fl"},{"name":"IDE","_id":"cjqojmlyh002qswqcu8d9ongs"},{"name":"helloworld","_id":"cjqojmlyh002uswqcmnop1nth"},{"name":"每周一坑","_id":"cjqojmlyx002xswqc2udp7fce"},{"name":"正则表达式","_id":"cjqojmlyx0033swqc0jk6v5p6"},{"name":"BinaryTree","_id":"cjqojmlyx003jswqc9rgpygmr"},{"name":"Travis-CI","_id":"cjqz9kudn0002m8qcj0ubbpuw"},{"name":"Hexo","_id":"cjqz9kudn0003m8qc5yzke77a"}]}}