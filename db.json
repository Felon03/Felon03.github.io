{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/google2e409c2d3b4ed9c8.html","path":"google2e409c2d3b4ed9c8.html","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-03-23.jpg","path":"images/imagesource/17-03-23.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-03-25-1.png","path":"images/imagesource/17-03-25-1.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-03-25-2.jpg","path":"images/imagesource/17-03-25-2.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-04-27.jpg","path":"images/imagesource/17-04-27.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-05-28.jpg","path":"images/imagesource/17-05-28.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-06-09.png","path":"images/imagesource/17-06-09.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-06-23.jpg","path":"images/imagesource/17-06-23.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-07-08.jpg","path":"images/imagesource/17-07-08.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-08-04.jpg","path":"images/imagesource/17-08-04.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-08.png","path":"images/imagesource/19-01-08.png","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-01-08.jpg","path":"images/bing/BingWallPaper-2019-01-08.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-01-16.jpg","path":"images/bing/BingWallPaper-2019-01-16.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-05-14.jpg","path":"images/bing/BingWallPaper-2019-05-14.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-05-16.jpg","path":"images/bing/BingWallPaper-2019-05-16.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-05-17.jpg","path":"images/bing/BingWallPaper-2019-05-17.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-05-22.jpg","path":"images/bing/BingWallPaper-2019-05-22.jpg","modified":0,"renderable":0},{"_id":"source/images/bing/BingWallPaper-2019-05-24.jpg","path":"images/bing/BingWallPaper-2019-05-24.jpg","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-1.png","path":"images/imagesource/17-11-17/17-11-17-1.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-10.png","path":"images/imagesource/17-11-17/17-11-17-10.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-11.png","path":"images/imagesource/17-11-17/17-11-17-11.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-12.png","path":"images/imagesource/17-11-17/17-11-17-12.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-13.png","path":"images/imagesource/17-11-17/17-11-17-13.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-14.png","path":"images/imagesource/17-11-17/17-11-17-14.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-15.png","path":"images/imagesource/17-11-17/17-11-17-15.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-16.png","path":"images/imagesource/17-11-17/17-11-17-16.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-17.png","path":"images/imagesource/17-11-17/17-11-17-17.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-18.png","path":"images/imagesource/17-11-17/17-11-17-18.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-19.png","path":"images/imagesource/17-11-17/17-11-17-19.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-2.png","path":"images/imagesource/17-11-17/17-11-17-2.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-3.png","path":"images/imagesource/17-11-17/17-11-17-3.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-4.png","path":"images/imagesource/17-11-17/17-11-17-4.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-5.png","path":"images/imagesource/17-11-17/17-11-17-5.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-6.png","path":"images/imagesource/17-11-17/17-11-17-6.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-7.png","path":"images/imagesource/17-11-17/17-11-17-7.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-8.png","path":"images/imagesource/17-11-17/17-11-17-8.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/17-11-17/17-11-17-9.png","path":"images/imagesource/17-11-17/17-11-17-9.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-1.png","path":"images/imagesource/19-01-16/2019-01-16-1.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-2.png","path":"images/imagesource/19-01-16/2019-01-16-2.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-3.png","path":"images/imagesource/19-01-16/2019-01-16-3.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-4.png","path":"images/imagesource/19-01-16/2019-01-16-4.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-5.png","path":"images/imagesource/19-01-16/2019-01-16-5.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-6.png","path":"images/imagesource/19-01-16/2019-01-16-6.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/2019-01-16-7.png","path":"images/imagesource/19-01-16/2019-01-16-7.png","modified":0,"renderable":0},{"_id":"source/images/imagesource/19-01-16/TravisCI-Full-Color.png","path":"images/imagesource/19-01-16/TravisCI-Full-Color.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"7b9edb17298f32e9e41224c7546d71a8328ffec6","modified":1605191133719},{"_id":"source/CNAME","hash":"d0bd4454768930395ba6b57a9e528536e8886381","modified":1605191133715},{"_id":"source/README.md","hash":"d109a3efc14abaffc8e455792d19118e4a57bf3b","modified":1605191133714},{"_id":"source/google2e409c2d3b4ed9c8.html","hash":"12d2a7d5c00d8aea5a62539288068082b5934035","modified":1605191133716},{"_id":"source/about/index.md","hash":"f5cc9a02035f5432e7158909015ae59276e1de30","modified":1605191133720},{"_id":"source/_posts/C-Primer-第五版-练习-12-33.md","hash":"012b354f2a3e4d3eb6974c704accd59184670c2c","modified":1605191133669},{"_id":"source/_posts/C-Primer-第五版-练习12-3.md","hash":"8bf6484eac1ff360ef575a3e7d5f61e9070e98ce","modified":1605191133677},{"_id":"source/_posts/C-string输入问题.md","hash":"ba0ad0df18a3db1002adb270efe536f63ccf23d7","modified":1605191133653},{"_id":"source/_posts/C-中的explicit关键字.md","hash":"eec068334c417f03b96c6f2edb3a52a7c5f21383","modified":1605191133667},{"_id":"source/_posts/C-前置递增（递减）和后置递增（递减）运算符.md","hash":"8939cabe466fd416ae917e1bec57dcc03124f64c","modified":1605191133661},{"_id":"source/_posts/Hexo-Travis-CI-auto-deploy.md","hash":"21e132858e4d754c009cce0aa4388eaf45fae108","modified":1605191133671},{"_id":"source/_posts/LeetCode-19-Remove-Nth-Node-From-End-of-List.md","hash":"d7a8c4d93ca19e9e9d53751d90d2c3981907b311","modified":1605191133672},{"_id":"source/_posts/LeetCode-751-IP-to-CIDR.md","hash":"121efe6893d494632885c70e1126ad5aaca9fdb9","modified":1605191133658},{"_id":"source/_posts/OpenStack-Neutron-Architecture.md","hash":"a8d2bdc638da35aca07ac6b5b08582d27d1b5258","modified":1605191133664},{"_id":"source/_posts/OpenStack-Neutron-Linux-Virtual-Network.md","hash":"441e37ff4533cb90ca25a543d632c8bdc0219e2b","modified":1605191133676},{"_id":"source/_posts/OpenStack-Neutron-Network-Model.md","hash":"58180d6c5bb6ddcfe0739d72fef67ac539c3a889","modified":1605191133662},{"_id":"source/_posts/OpenStack-Neutron-Resources-Model.md","hash":"287ff42a55c5c0aad5c2cabd5f08ea9d4855bee5","modified":1605191133673},{"_id":"source/_posts/Python3脚本抓取Bing美图.md","hash":"759b416a9afa84ca90b86542d6ba70b6c32b5656","modified":1605191133665},{"_id":"source/_posts/Python生成词云.md","hash":"62de92bb37f0b2f6c8af61045a9aaefd7ba1bfef","modified":1605191133667},{"_id":"source/_posts/UTF-8-码点.md","hash":"085653d98dea6e5da966520cc9417ba57c901ba7","modified":1605191133666},{"_id":"source/_posts/VSCode-Extensions.md","hash":"df64232b56e06e88168faace2a76233e2a1751b5","modified":1605191133663},{"_id":"source/_posts/Vimtutor-commands.md","hash":"5208730c28b30140c8e8f400a5ee1b84359b7983","modified":1605191133668},{"_id":"source/_posts/Visual-Studio项目中集成Google-Test测试框架.md","hash":"5f7d869e1992359893759849134a4dbf48d3282f","modified":1605191133675},{"_id":"source/_posts/hello-world.md","hash":"d4521cdd3badf245936706ef0a62d4c0bf29565b","modified":1605191133670},{"_id":"source/_posts/【每周一坑】杨辉三角形.md","hash":"a26902787611af2631e40e57741a1e2c240e0838","modified":1605191133654},{"_id":"source/_posts/【每周一坑】校验文件哈希.md","hash":"fa9e862f46eecf08eecdf78212a557b466921dd1","modified":1605191133655},{"_id":"source/_posts/【每周一坑】求乘积最大.md","hash":"a62b05abda104a0fba5379d61e94450e57cf598e","modified":1605191133670},{"_id":"source/_posts/【每周一坑】注册表单验证.md","hash":"5607258aaee932ffc5c536c324d412d71025978a","modified":1605191133673},{"_id":"source/_posts/【每周一坑】矩阵旋转.md","hash":"540d385aa4d3eb7cc51e4e7be87bcbd121fd9cf8","modified":1605191133674},{"_id":"source/_posts/【每周一坑】神奇的九宫格.md","hash":"e5f49481bb3512af0beebed9e05cca7c96f4830e","modified":1605191133663},{"_id":"source/_posts/【每周一坑】罗马数字转换.md","hash":"3170a9f81c5ab8a5a7d2b3fb70571db8ee30e2d4","modified":1605191133659},{"_id":"source/_posts/【每周一坑】程序员的浪漫.md","hash":"47b4f63fef56232536c4345753af56db2cf75d0b","modified":1605191133656},{"_id":"source/_posts/【每周一坑】螺旋矩阵.md","hash":"17b713f9b36320577917c26d8726e1a52eac5302","modified":1605191133656},{"_id":"source/_posts/【每周一坑】阿姆斯特朗数.md","hash":"2c23c4341222df022f98f9a58acf5a6e7beb3039","modified":1605191133660},{"_id":"source/_posts/【每周一坑】验证哥德巴赫猜想.md","hash":"829465db45560de540ce4889f7d0da0b2e68d4d8","modified":1605191133661},{"_id":"source/_posts/二叉树相关问题-转载.md","hash":"b7f1c79f1bad1ab151988c0265669234bc18c851","modified":1605191133657},{"_id":"source/_posts/函数返回数组指针或数组引用.md","hash":"978398d08dec71623e02112b9284713f1c2e409e","modified":1605191133658},{"_id":"source/_posts/给出一个表达式，按照顺序求出表达式的值.md","hash":"7fb3d64c7cb437b991bb721e616565e4490f7f3a","modified":1605191133676},{"_id":"source/sitemap/index.md","hash":"1a565eb44a3bc6958fea328d89466ce753b90141","modified":1605191133718},{"_id":"source/images/avatar.png","hash":"1ffd03678d665d958cd861afb37f192195fa32d1","modified":1605191133713},{"_id":"source/categories/index.md","hash":"884b68fc6f21e23f3549ded82f991e798fd0f469","modified":1605191133717},{"_id":"source/tags/index.md","hash":"a1e5983fc1aaebf4d62bf11be0fe023637740661","modified":1605191133715},{"_id":"source/images/imagesource/17-05-28.jpg","hash":"8078c9bb635146749c2356ce09d4e488f872ca41","modified":1605191133687},{"_id":"source/images/imagesource/17-04-27.jpg","hash":"c88c5a4e690fd2b00258308aa9ae559cf5ad50f1","modified":1605191133687},{"_id":"source/images/imagesource/17-03-25-2.jpg","hash":"d39c83dad6ca202f658a5080c8410cb6784312aa","modified":1605191133686},{"_id":"source/images/imagesource/17-06-23.jpg","hash":"6efbfd2fbea3d57fa766e7eba8c842b9a7bedaae","modified":1605191133689},{"_id":"source/images/imagesource/17-08-04.jpg","hash":"ee945fff8e14b14d59359289f08b8f1d7f36821b","modified":1605191133690},{"_id":"source/images/imagesource/19-01-08.png","hash":"4e5e64367f7763266febadd4acc817d043c36dbc","modified":1605191133703},{"_id":"source/images/imagesource/17-11-17/17-11-17-1.png","hash":"7f50f4c5eadb21b235025ecb46b1fe7e729e643d","modified":1605191133691},{"_id":"source/images/imagesource/17-11-17/17-11-17-11.png","hash":"c59a8f5246ad69cf54816ab8d6bac6f24307c158","modified":1605191133692},{"_id":"source/images/imagesource/17-11-17/17-11-17-10.png","hash":"1f4f28d04c87e1c59a5dec5424a797c294dd9e85","modified":1605191133691},{"_id":"source/images/imagesource/17-11-17/17-11-17-12.png","hash":"0be73a6feb1e842f719fcb58eefc79ff7860f7bd","modified":1605191133693},{"_id":"source/images/imagesource/17-11-17/17-11-17-13.png","hash":"30608ba4948767ee479fc6c7786821313f4f9b9e","modified":1605191133693},{"_id":"source/images/imagesource/17-11-17/17-11-17-15.png","hash":"d98350de39ce3d11ced2a895b66f30abb2afe626","modified":1605191133695},{"_id":"source/images/imagesource/17-11-17/17-11-17-14.png","hash":"2ccbb9ad0a1b735a63fc709a34f88d943f9480b0","modified":1605191133694},{"_id":"source/images/imagesource/17-11-17/17-11-17-19.png","hash":"316eef52efd7aa15a0a6235575a6507965a2d6d0","modified":1605191133697},{"_id":"source/images/imagesource/17-11-17/17-11-17-18.png","hash":"2f346b4ae1b638695a0a1836c1d0eec3d608a06a","modified":1605191133697},{"_id":"source/images/imagesource/17-11-17/17-11-17-17.png","hash":"34671fb79859da8ea4fa5f24c44014e3e261d01d","modified":1605191133696},{"_id":"source/images/imagesource/17-11-17/17-11-17-2.png","hash":"fe7ac32c219f8715bcf6f9f078c45a0622be8874","modified":1605191133698},{"_id":"source/images/imagesource/17-11-17/17-11-17-5.png","hash":"e8b342adf7dde2f18adae32881407e279f31379c","modified":1605191133700},{"_id":"source/images/imagesource/17-11-17/17-11-17-4.png","hash":"4d247dbe07a773598cf5565fa9841ce4bc1950b6","modified":1605191133699},{"_id":"source/images/imagesource/17-11-17/17-11-17-3.png","hash":"caf5090ac3b0fce9c3129303626186019e3e7e1d","modified":1605191133699},{"_id":"source/images/imagesource/17-11-17/17-11-17-6.png","hash":"5fc15c3d9a3852e9a58bd5c51da9170e6787e4d3","modified":1605191133701},{"_id":"source/images/imagesource/17-11-17/17-11-17-9.png","hash":"937e4b2b5ecf7813f477b1dafbf0944e6f039658","modified":1605191133702},{"_id":"source/images/imagesource/17-11-17/17-11-17-7.png","hash":"c17a47924fd2d370f56c465f6639b1c431f5aeb3","modified":1605191133701},{"_id":"source/images/imagesource/17-11-17/17-11-17-8.png","hash":"fce6707121dd112795714df07b700c01a733c9e4","modified":1605191133702},{"_id":"source/images/imagesource/19-01-16/2019-01-16-1.png","hash":"f1e63a5b3bf7b4fca891e2a6e4f8a35016223d45","modified":1605191133704},{"_id":"source/images/imagesource/19-01-16/2019-01-16-4.png","hash":"e29c988d233a84eee395ae453f390f0d51b1b0da","modified":1605191133706},{"_id":"source/images/imagesource/19-01-16/2019-01-16-5.png","hash":"430dbec89c4e01e16b7e98fcaed1954a6837a5a9","modified":1605191133707},{"_id":"source/images/imagesource/19-01-16/2019-01-16-2.png","hash":"92b412858e9e7cbbdb7129e0ccef95f1181081ff","modified":1605191133705},{"_id":"source/images/imagesource/19-01-16/2019-01-16-6.png","hash":"2e9ba5be898b2bbfffd6cc496ea02786fa67e699","modified":1605191133708},{"_id":"source/images/imagesource/19-01-16/TravisCI-Full-Color.png","hash":"28b210ec069326d1914b54186854e278b874e08e","modified":1605191133709},{"_id":"source/images/imagesource/19-01-16/2019-01-16-3.png","hash":"f1aa869a297332fecac9253af18531e757e1b1c0","modified":1605191133706},{"_id":"source/images/imagesource/17-07-08.jpg","hash":"77b1420469d95dc44725a4a2b58d758788487a72","modified":1605191133689},{"_id":"source/images/imagesource/17-11-17/17-11-17-16.png","hash":"261abc9693a15f0009bc9fd08fa246293e9e25f7","modified":1605191133695},{"_id":"source/images/imagesource/19-01-16/2019-01-16-7.png","hash":"82eecba0cd84dd751a4a0bcfbaaaa564ea0e38d4","modified":1605191133709},{"_id":"source/images/imagesource/17-06-09.png","hash":"4ec8fa57b1e15c9f5b9b021da5492d3b9e965e4d","modified":1605191133688},{"_id":"source/images/imagesource/17-03-23.jpg","hash":"2c384536f5c8ee9c8266362a0472fe46846edc07","modified":1605191133685},{"_id":"source/images/bing/BingWallPaper-2019-05-22.jpg","hash":"1e85fac725b09f3c99842415fd4c9b0c431ccae1","modified":1605191133683},{"_id":"source/images/bing/BingWallPaper-2019-01-16.jpg","hash":"b842db9b6f6ce36b3fdfdde2b6b67235ffe86e91","modified":1605191133679},{"_id":"source/images/bing/BingWallPaper-2019-05-24.jpg","hash":"6e44859d6fc2554b4d5cf9448655332f9f09748b","modified":1605191133683},{"_id":"source/images/bing/BingWallPaper-2019-05-14.jpg","hash":"a7b016332084ddbc10a41c9cd57a407c5d060821","modified":1605191133680},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1605192185917},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1605192185876},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1605192185877},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1605192185892},{"_id":"themes/next/.npmignore","hash":"b5753ace1856548855d1f2c31c05da85781629e6","modified":1605192185891},{"_id":"themes/next/LICENSE.md","hash":"63ea7df5a8dc1b23cc92ca9de3ed16d53367f360","modified":1605192185893},{"_id":"themes/next/.gitignore","hash":"10fa9758d8f934669c1781564ed9ce83436b11f7","modified":1605192185891},{"_id":"themes/next/README.md","hash":"1fe48a23734bb659ee8a5f93070a4ab9c45c6b44","modified":1605192185893},{"_id":"themes/next/_config.yml","hash":"33a4461b74115a5c2644878995f3846a82197ef7","modified":1605193243238},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1605192185895},{"_id":"themes/next/package.json","hash":"4141b58d7146be5faa8deaf9c48f34c1885680f2","modified":1605192185915},{"_id":"themes/next/_vendors.yml","hash":"744133cdb17c7a91649c343d6e1a05d3d30854b9","modified":1605192185894},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1605192185760},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1605192185879},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"81dbb25800165f68c21859cd3c09276b9f4cc417","modified":1605192185882},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1605192185890},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1605192185889},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1605192185878},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1605192185882},{"_id":"themes/next/.github/labeler.yml","hash":"a45e489c62bf5bb5eb1866371af331b8cb9c6320","modified":1605192185884},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1605192185896},{"_id":"themes/next/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1605192185884},{"_id":"themes/next/.github/stale.yml","hash":"0e40b9975455152a690eaf7047135be348966e39","modified":1605192185883},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1605192185900},{"_id":"themes/next/docs/LICENSE.txt","hash":"8ef5fc1147c196680b06e1accab80c8d236ab951","modified":1605192185899},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1605192185913},{"_id":"themes/next/languages/ar.yml","hash":"7a62243ec54196e3d1bea7364f05aded490bc234","modified":1605192185913},{"_id":"themes/next/languages/de.yml","hash":"dc448f724c7d436233e9567711a09e0d56e60e3b","modified":1605192185914},{"_id":"themes/next/languages/es.yml","hash":"c3506dfaa771e827ae6adb322477c6e835cd0f09","modified":1605192185915},{"_id":"themes/next/languages/fr.yml","hash":"8ddfe98e7847ee8f1eaba9119f9fbdc42d7ec120","modified":1605192185910},{"_id":"themes/next/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1605192185911},{"_id":"themes/next/languages/default.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1605192185911},{"_id":"themes/next/languages/fa.yml","hash":"649823297167b902455c0aec8ddebb462df71c7d","modified":1605192185910},{"_id":"themes/next/languages/id.yml","hash":"ac018805190bc4bdc06091f5a6444e612fc700b0","modified":1605192185905},{"_id":"themes/next/languages/it.yml","hash":"82a93c32b3fcf6517441cdc73f75bc6173beb392","modified":1605192185912},{"_id":"themes/next/languages/ko.yml","hash":"8342df2f4190ba4ee004b70d1d6ccd341033dbe7","modified":1605192185910},{"_id":"themes/next/languages/ja.yml","hash":"fec1e1c15ad2df7ed1249173cc719ccba6d3b842","modified":1605192185908},{"_id":"themes/next/languages/nl.yml","hash":"0d3b56613197cb190900311507535db41daec7d4","modified":1605192185906},{"_id":"themes/next/languages/pt-BR.yml","hash":"47daeaa23c4db073e77761c9a6f62d3932af06ec","modified":1605192185906},{"_id":"themes/next/languages/ru.yml","hash":"fdf5c623890db24cb56ab5ffe0c49db3542477c8","modified":1605192185907},{"_id":"themes/next/languages/pt.yml","hash":"e0e2675261e2e80f7ce7d19c945c08217b068d81","modified":1605192185901},{"_id":"themes/next/languages/tr.yml","hash":"54de3d8d85e3c7b14b163c3d322411b7301a09b3","modified":1605192185902},{"_id":"themes/next/languages/uk.yml","hash":"1c9a0b8d8160c77cc62064207d57f460f365cae9","modified":1605192185902},{"_id":"themes/next/languages/vi.yml","hash":"1f9657b58e11db21f93eb895c90123b8f91751a7","modified":1605192185903},{"_id":"themes/next/languages/zh-TW.yml","hash":"d534f321ee0c235e1ebfea383eb1892bbd7d7e95","modified":1605192185904},{"_id":"themes/next/languages/zh-HK.yml","hash":"149fccd0afdbc8db76e372cbc73d7b5f07bb7515","modified":1605192185908},{"_id":"themes/next/layout/_layout.njk","hash":"bf7e6ca826b6c3f85e14da61d56d7b836d2414c4","modified":1605192185706},{"_id":"themes/next/layout/archive.njk","hash":"08885f48d5878c92c910f8c41e3209eb07b9b80e","modified":1605192185731},{"_id":"themes/next/layout/category.njk","hash":"434fc2b27120ebae91522002eb40e16f2158bd4f","modified":1605192185732},{"_id":"themes/next/languages/zh-CN.yml","hash":"6f7c742316c96d5b71da50fddfb060ff7ec1ea99","modified":1605192185904},{"_id":"themes/next/layout/index.njk","hash":"d8fa14549fa061e7bdba4ec1472cb45ecea96382","modified":1605192185736},{"_id":"themes/next/layout/page.njk","hash":"4f8f377e4f5511e27de1c2e4a1c13374b6a5d9bd","modified":1605192185733},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1605192185759},{"_id":"themes/next/layout/tag.njk","hash":"09075c80b53b06826e7eb9ce838bca9dc363fac1","modified":1605192185737},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1605192185789},{"_id":"themes/next/scripts/renderer.js","hash":"c53dbede2ad5f68d7349bc5ed8ac7157d723e987","modified":1605192185778},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1605192185879},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1605192185880},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"b47f529d059ef337b4f14ddf746c3a42744028f0","modified":1605192185881},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"d0d16ae88623d33946c16cfb68beb6ecab1ba69b","modified":1605192185881},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"b6d8162264dc4d6d31f1f9c2a940718f12cff874","modified":1605192185889},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"3acd5189488e720f23e904f2d9d24cf4b15ac1de","modified":1605192185888},{"_id":"themes/next/.github/workflows/linter.yml","hash":"f499ad31aea9ec598308475ef0b19b7e4177103c","modified":1605192185887},{"_id":"themes/next/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1605192185888},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1605192185886},{"_id":"themes/next/.github/workflows/tester.yml","hash":"3a740e76151cc0a696273594731d7864a8db5374","modified":1605192185886},{"_id":"themes/next/docs/ru/README.md","hash":"618709b37699088b8758a60b58a8548e3609144a","modified":1605192185900},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0e204dde6d21f100cba6ca7751de71848490759e","modified":1605192185898},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1605192185897},{"_id":"themes/next/docs/zh-CN/README.md","hash":"040de4b35cf548d265b1bd85c60ca699b12acf3a","modified":1605192185898},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1605192185735},{"_id":"themes/next/layout/_macro/post.njk","hash":"0a6e47fc04d211c416e00119011f7614d98c31cf","modified":1605192185734},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"c0a843a3019f0bb8f2e734dc173028ead732b3c0","modified":1605192185734},{"_id":"themes/next/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1605192185707},{"_id":"themes/next/layout/_partials/footer.njk","hash":"44060deff92a8fe331548dafeb27e5c188a8a6c2","modified":1605192185717},{"_id":"themes/next/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1605192185708},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1605192185710},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"24eb5b683310810f93c1d7f68f8f70f1a29fd217","modified":1605192185716},{"_id":"themes/next/layout/_scripts/index.njk","hash":"48cbbca0e4f97b8c25f2a5c408071603cd257a65","modified":1605192185729},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1605192185730},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1605192185729},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1605192185731},{"_id":"themes/next/layout/_third-party/baidu-push.njk","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1605192185753},{"_id":"themes/next/layout/_third-party/index.njk","hash":"4ca039707745c6a22615741b7411ff2cb0763e6d","modified":1605192185759},{"_id":"themes/next/layout/_third-party/nprogress.njk","hash":"271139c3896a6d294f46f767cb21b2e848050841","modified":1605192185758},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1605192185752},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1605192185755},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1605192185765},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1605192185773},{"_id":"themes/next/scripts/filters/locals.js","hash":"fa1e558f058f93455acdd553ab1be30b26f137e4","modified":1605192185772},{"_id":"themes/next/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1605192185773},{"_id":"themes/next/scripts/filters/post.js","hash":"bac5646993153f9f6a630c9f0052bb17fa760a9c","modified":1605192185771},{"_id":"themes/next/scripts/helpers/engine.js","hash":"682a8e16b5182c123c96b04222d967407e1fd6d6","modified":1605192185775},{"_id":"themes/next/scripts/helpers/font.js","hash":"9cf01a3cf62d9b5a1a0db8145088774bf94045c8","modified":1605192185778},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"413c51fa3caa87fe95d1d8f95e6023f096515632","modified":1605192185775},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1605192185776},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1605192185777},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1605192185785},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1605192185779},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1605192185781},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1605192185786},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9836e3212f889e94ada4c354c7b83f7d7caa9aa7","modified":1605192185780},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1605192185781},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1605192185783},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1605192185782},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1605192185785},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1605192185779},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1605192185783},{"_id":"themes/next/scripts/tags/pdf.js","hash":"27129fc4014d723ba93ac77b11342da2ee445d96","modified":1605192185784},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1605192185832},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1605192185799},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1605192185800},{"_id":"themes/next/source/css/main.styl","hash":"766d406beffa0c2cdbd64518262286baaeb8ec3b","modified":1605192185814},{"_id":"themes/next/source/css/_mixins.styl","hash":"b9c3d3087a917c94cf34ffd6621528d377af8fc9","modified":1605192185815},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1605192185801},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1605192185800},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1605192185802},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1605192185802},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1605192185803},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1605192185805},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1605192185804},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1605192185805},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1605192185807},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1605192185805},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1605192185806},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1605192185809},{"_id":"themes/next/source/js/algolia-search.js","hash":"7c6c966cdbe6e46d5f885606b0b9daf2ea3f757d","modified":1605192185808},{"_id":"themes/next/source/js/local-search.js","hash":"9f4fe7bbe0f16be72d26ccb8b22bd33767f83cff","modified":1605192185809},{"_id":"themes/next/source/js/utils.js","hash":"bc4217f9779b81c0f56de985c46d73c21d3992d5","modified":1605192185813},{"_id":"themes/next/source/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1605192185811},{"_id":"themes/next/source/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1605192185812},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1605192185788},{"_id":"themes/next/test/helpers/font.js","hash":"8930b1f16facc18dc6764bf6efd753ca50d3f1cb","modified":1605192185787},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1605192185810},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1605192185790},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1605192185789},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1605192185791},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1605192185793},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1605192185793},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1605192185791},{"_id":"themes/next/test/tags/group-pictures.js","hash":"caf9f6b9a72e41fb30aa24468a54496fba1fcdd8","modified":1605192185792},{"_id":"themes/next/test/tags/pdf.js","hash":"bac003317e5bb5e046848522c5c4a7cf231e53f6","modified":1605192185796},{"_id":"themes/next/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1605192185795},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1605192185795},{"_id":"themes/next/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1605192185794},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1605192185797},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1605192185797},{"_id":"themes/next/test/validate/index.js","hash":"ef716c1db8e3c93c320f73b6da4010e03b4eb0ae","modified":1605192185798},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"c082a16163d1fb5d7cf858fb7522fca9d18f1ba6","modified":1605192185720},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1605192185718},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"e8a73353f1343d2354b1612bf9dbb3b41085a8ed","modified":1605192185717},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1605192185721},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1605192185720},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"61eec1fb84711369b9dabd1d2cae64858844c2eb","modified":1605192185720},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1605192185721},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1605192185725},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1605192185726},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1605192185728},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"789915339a6234d6dd7c710cc1f8e728d9b81d35","modified":1605192185726},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1605192185727},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"fbdb5cdbd80970f201f5c75369eaa00aea369235","modified":1605192185713},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1605192185711},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1605192185712},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1605192185711},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"c2ccaac9caeea1a43dc31f4f8368f8f548aab0af","modified":1605192185723},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"90156f42d6e6e326ed38482d6623a0aac0352016","modified":1605192185724},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"b7a66a465e897c27624f0c441375c95c4cb7a5aa","modified":1605192185724},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1605192185713},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1605192185715},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1605192185740},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1605192185738},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"c419158e19805e2db614a5f5651e3e534e4a5e4e","modified":1605192185716},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1605192185754},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"d87df68dff14cfb4d91a77230cd1ac795c2a22d5","modified":1605192185738},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1605192185754},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1605192185749},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"ec0474e23ca122b34858ffb0bb8c99f241749c61","modified":1605192185750},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1605192185750},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1605192185739},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1605192185748},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1605192185752},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1605192185756},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"72d7abe567fab181725d120cb27eb6a6379611ea","modified":1605192185751},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1605192185742},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"b0efe26601037e621b5cb16f0fe2f347ee27acdb","modified":1605192185758},{"_id":"themes/next/layout/_third-party/search/swiftype.njk","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1605192185741},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a8239f99b316e6c060bad8173be3a25c67138697","modified":1605192185757},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1605192185741},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1605192185743},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.njk","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1605192185744},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"8635b13aa1092c22252af4743fa194272f089b59","modified":1605192185745},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"8b956fb56284e8fa4a4731b1efd1f25e1b2b4a78","modified":1605192185746},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"811a3ad58c0a15550100bdc199bef8add1ad526c","modified":1605192185744},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1605192185747},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1605192185763},{"_id":"themes/next/scripts/events/lib/config.js","hash":"5a1dd04ea7124494110b3c79f9880f55d899977b","modified":1605192185764},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"e227174a8ebab8d5b6e8e26faf4fd66c43f045ca","modified":1605192185762},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"67d80a57f6b2cf23d56276ca8f30f25e3e8707e9","modified":1605192185747},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1605192185761},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"f76c7e13fc4304f86260068c9d83d3477b64ee4b","modified":1605192185762},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1605192185769},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"199fa9a70914d0019cf0e47f55491183d53d1533","modified":1605192185766},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"a9b18b7447cd5a56cb692c574463a27356eb7fa6","modified":1605192185770},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"387e59cd396c62fe095b388c8ff8d4191cfbdeb9","modified":1605192185766},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7b8ce8e9a71cf083f5337fb7c9586be8f7c316e8","modified":1605192185771},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"1198cb63375a53400431c2e65e3361416cdf8eb6","modified":1605192185767},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"c67984fc868d4799b3aa6d3b3cd060e5260b3a98","modified":1605192185768},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1605192185829},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1605192185768},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"77dddb398fb1beefc2b824bec7b094030fdc3df9","modified":1605192185830},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1605192185831},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1605192185831},{"_id":"themes/next/source/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1605192185812},{"_id":"themes/next/source/css/_variables/base.styl","hash":"efbeee48d208a3960b4e352fab3feb2b2dab7ef8","modified":1605192185829},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1605192185869},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1c75a837faae9aa2d0a5f30d2078aa8d2ccc2552","modified":1605192185865},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1605192185860},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"92915560810c0311dada43ed629b8fc4ff0fc7a4","modified":1605192185865},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"28368ac06d04ccf0bbf3dc9e0dfcf341c200b28c","modified":1605192185838},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ea96e86b6bcb160351c18a7edc4a561918a820cb","modified":1605192185847},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1605192185847},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1605192185839},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1605192185848},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1605192185858},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"a472fb1afc6486266b85f773501a290e0a80c370","modified":1605192185859},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1605192185851},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e1c85ab2831fd7d4bb84aea1850a0160be0023e8","modified":1605192185851},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"06786e1ed8774f8f08cbfc711296cf189aaf1b8c","modified":1605192185817},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1605192185817},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7ad04d5a02a7618ebb09c1d5a435d46c4df2c620","modified":1605192185816},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1605192185858},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f6d165dae928c12bde3f271d299a93b334116433","modified":1605192185818},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"faadd1616a18d626f145e9fbdbfb770deab35b2c","modified":1605192185819},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1605192185820},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1605192185823},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1605192185821},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1605192185819},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c706733f5196776fe2657a9bebe0a727cf8fe8e5","modified":1605192185821},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"a57dca7008b1f4721359a2a3b420ed2eec02b0a1","modified":1605192185823},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1605192185822},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1605192185825},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1605192185826},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"031765bd4564d97ba694c1b73615ed631f1c64aa","modified":1605192185827},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c435cfd858bf82726fff2c85d384e2207bea0370","modified":1605192185828},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"78f0b6edc296a9ed5144da9f9752c0b96bebfaa5","modified":1605192185825},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1605192185866},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1605192185868},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1605192185826},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1605192185866},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"19fc5ca0784f5d2befddb9d8bc463b916c5c2518","modified":1605192185867},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1605192185868},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"8a2e724df3d5cd14765eb951f0a9e1dba399fd35","modified":1605192185870},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1605192185875},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"d6ecc5dfd15c588782ba5e1df9f915b305622aef","modified":1605192185871},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1605192185876},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cf6540e12c2de5befcfb7e92d915e3b75fd53dfa","modified":1605192185872},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"27001ad06f69ff035639210ab2f614861b21a4f4","modified":1605192185872},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8998a07acf0dbd10811835c8dfc91d92e680bcae","modified":1605192185874},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1605192185870},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1605192185873},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1605192185874},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1605192185862},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1605192185863},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"48ee817d05ddc788423d7f10e9823e23fda81d04","modified":1605192185862},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1605192185861},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"8cb89864e8245a356d08ef0fee3133810f646fea","modified":1605192185834},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1605192185833},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"254e781e7b25e31a1a589c8b38dc608802f1cc6e","modified":1605192185835},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a83a1236564b81eab9a23dba9a634a6de90d4726","modified":1605192185837},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1605192185836},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1605192185837},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1605192185841},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5d8fc91cdb7ee313eb367dcec7d5b2429f98242f","modified":1605192185863},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"6d8afd8e23c40bb2b2a2edbe4eb0d2671cd81188","modified":1605192185836},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1605192185846},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"66782e68f1c74a7d0aecef20e2ca16bbe6b52592","modified":1605192185841},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"ab715dbf2b98bfeb5e7b7c43e92e5c02496cc2ea","modified":1605192185842},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"469855a72d2c2b63a21df8fbcb8cc41d32cb9bde","modified":1605192185844},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"521b36ea7bb3a843029cbfbb6b5e76e91c40a19f","modified":1605192185842},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"3378f4d1640033ebde25798f602fddf88f3dcadd","modified":1605192185845},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1605192185849},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1605192185844},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1605192185843},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"497fc002d7415d9bed8cad26ba74ac66045397b7","modified":1605192185840},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1605192185852},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1605192185858},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"920f21dc03b28f006aef7e9d0fd444c2cd283efc","modified":1605192185850},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"f09bc97e3681d73c38d7d3c5c271486c2c6537e2","modified":1605192185852},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"acfdec45e56cdd6a5ea61e0154f8a6d1bc068214","modified":1605192185853},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"dcf426c2a4836386c0c27235de3f9a95c5de67cc","modified":1605192185856},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1605192185854},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1605192185856},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"29bef220307d86b1eafbb3714381df32d48b5a60","modified":1605192185854},{"_id":"source/images/bing/BingWallPaper-2019-05-16.jpg","hash":"c47f25d5b90904abd4a2cac1ad16e13e53b839ed","modified":1605191133681},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1605192185857},{"_id":"source/images/bing/BingWallPaper-2019-05-17.jpg","hash":"cfd8a2cb4c022fa13ecbe690c6fa932f84857944","modified":1605191133682},{"_id":"source/images/bing/BingWallPaper-2019-01-08.jpg","hash":"37aab6fbaa550db66847ada43f270a196142c8fd","modified":1605191133679},{"_id":"source/images/imagesource/17-03-25-1.png","hash":"0d52efafdf810859c9c11627b58ba4168bab3bc8","modified":1605191133685},{"_id":"source/images/background.jpg","hash":"d7db27a39ef107c8911a4e5eae302268393a7039","modified":1605191133712},{"_id":"public/atom.xml","hash":"c86ca8563af80a683e1ed43c926e7907b1f2b1ab","modified":1605282017625},{"_id":"public/sitemap.xml","hash":"77aad6ddb4dc54535a830dcb469ec5b771979640","modified":1605282017625},{"_id":"public/404.html","hash":"37533ad90c5d0ec357d989dfafa026326c0dd26e","modified":1605282017625},{"_id":"public/about/index.html","hash":"d6ab800f6630c62e4a25fd0f2a085277fdf9445c","modified":1605282017625},{"_id":"public/tags/index.html","hash":"5d740e6c43628b74eb90cfab378546244f3df400","modified":1605282017625},{"_id":"public/categories/index.html","hash":"626fc522fbad2c36afb97a877fe1db0915e521aa","modified":1605282017625},{"_id":"public/sitemap/index.html","hash":"cd5ed2523dca590ba9b5321af6aebc843c5c1800","modified":1605282017625},{"_id":"public/2019/05/24/OpenStack-Neutron-Architecture/index.html","hash":"6e620da1a944f7f21288b42bd6e05d353f1c17c4","modified":1605282017625},{"_id":"public/2019/05/22/OpenStack-Neutron-Resources-Model/index.html","hash":"e25c391b339c1171e1adefb010d065c5702bef6a","modified":1605282017625},{"_id":"public/2019/05/17/Vimtutor-commands/index.html","hash":"9f50efbba7abf397281836ddc94b693aaf33f15b","modified":1605282017625},{"_id":"public/2019/05/16/OpenStack-Neutron-Network-Model/index.html","hash":"54e45bd4e913654b64951a74e1a2b3c5e4f48895","modified":1605282017625},{"_id":"public/2019/05/14/OpenStack-Neutron-Linux-Virtual-Network/index.html","hash":"35bf0ba622c96500b34f1af83f842ecce2a26178","modified":1605282017625},{"_id":"public/2019/01/16/Hexo-Travis-CI-auto-deploy/index.html","hash":"ad761b9ad3304ec87f91739ce85d8c3abb551050","modified":1605282017625},{"_id":"public/2019/01/08/VSCode-Extensions/index.html","hash":"161d10a33e9b4a0604ca477e0545a264f76b6448","modified":1605282017625},{"_id":"public/2018/01/09/LeetCode-19-Remove-Nth-Node-From-End-of-List/index.html","hash":"b6ed192c32a6de86494bf28378ce5c201d4ed3b5","modified":1605282017625},{"_id":"public/2017/12/29/LeetCode-751-IP-to-CIDR/index.html","hash":"0515265983c5748bff304ac2d1ee53e6fc0a2428","modified":1605282017625},{"_id":"public/2017/11/17/Visual-Studio项目中集成Google-Test测试框架/index.html","hash":"df1fecb8de432a0a05d8251086510d65d8f410a8","modified":1605282017625},{"_id":"public/2017/10/13/【每周一坑】注册表单验证/index.html","hash":"bbd0299a1d83731cb5bed1725c10966d444caa2f","modified":1605282017625},{"_id":"public/2017/10/09/二叉树相关问题-转载/index.html","hash":"900524d5680d98a37654dc03d754f5187b2da2bd","modified":1605282017625},{"_id":"public/2017/10/09/UTF-8-码点/index.html","hash":"37f5925435f540cfcdbd3c3d7866c27c860fc45e","modified":1605282017625},{"_id":"public/2017/09/06/【每周一坑】矩阵旋转/index.html","hash":"823472f0cfe46657b4e7b1b39bb929138dfb1b0e","modified":1605282017625},{"_id":"public/2017/08/04/【每周一坑】阿姆斯特朗数/index.html","hash":"e1a500e8aed2ad4f2ea824ac99cbbc7782386867","modified":1605282017625},{"_id":"public/2017/07/08/【每周一坑】罗马数字转换/index.html","hash":"fd389f9d0070d3a8a66a7913544a80566bb95257","modified":1605282017625},{"_id":"public/2017/06/23/【每周一坑】螺旋矩阵/index.html","hash":"ee77fd231a78b4170e164f01ecedaa2b1281899c","modified":1605282017625},{"_id":"public/2017/06/15/C-中的explicit关键字/index.html","hash":"bf319ef2addbf43c8d2968b92b045e0fde043145","modified":1605282017625},{"_id":"public/2017/06/09/【每周一坑】校验文件哈希/index.html","hash":"60047b4e0ebec5eb952caa129bda939798a527f0","modified":1605282017625},{"_id":"public/2017/06/07/C-Primer-第五版-练习-12-33/index.html","hash":"52babcaa8552704c1470c8778081c57152041c63","modified":1605282017625},{"_id":"public/2017/05/28/【每周一坑】验证哥德巴赫猜想/index.html","hash":"443d5bc39615f63ac21d2a2464fd88cfc1b4b90c","modified":1605282017625},{"_id":"public/2017/05/26/C-Primer-第五版-练习12-3/index.html","hash":"0a3a9e845dcfedf28cee1c4cf4e176abfbfe97ad","modified":1605282017625},{"_id":"public/2017/05/19/【每周一坑】杨辉三角形/index.html","hash":"27fc61ee4803ad9945d706393db3fd9e1891b9e4","modified":1605282017625},{"_id":"public/2017/05/15/【每周一坑】神奇的九宫格/index.html","hash":"3338e00407b26d552a8cd56ce8a8e9feabbd58a5","modified":1605282017625},{"_id":"public/2017/05/03/【每周一坑】求乘积最大/index.html","hash":"7c20042b1ac9a2096721e74e86a1e8d486aefe1b","modified":1605282017625},{"_id":"public/2017/04/27/【每周一坑】程序员的浪漫/index.html","hash":"7bd0756e83649ce8fb3cb043b4b5df98d5babe40","modified":1605282017625},{"_id":"public/2017/04/15/函数返回数组指针或数组引用/index.html","hash":"3e405b7f2a0077777005f1ea9439a05bbd27e365","modified":1605282017625},{"_id":"public/2017/04/07/C-前置递增（递减）和后置递增（递减）运算符/index.html","hash":"7ce528dfb5f8b9cc05d7dad77faddb889bc18507","modified":1605282017625},{"_id":"public/2017/03/31/C-string输入问题/index.html","hash":"7db1a0f6df6e33a48c8f0200c64df66524c19046","modified":1605282017625},{"_id":"public/2017/03/25/给出一个表达式，按照顺序求出表达式的值/index.html","hash":"85064f130bc099e1a41ec566981cfbbfb311c156","modified":1605282017625},{"_id":"public/2017/03/25/Python生成词云/index.html","hash":"57769aa6d65b59041486d9268b85aa91d80d687a","modified":1605282017625},{"_id":"public/2017/03/23/Python3脚本抓取Bing美图/index.html","hash":"c2d9a9be7079ec4b0574d86a14d59bf771bc1434","modified":1605282017625},{"_id":"public/2017/03/21/hello-world/index.html","hash":"afb4fe1d892636c7d09a20df9aaad601b5fa870b","modified":1605282017625},{"_id":"public/archives/index.html","hash":"da40c1d51c12c4ba6f30f4085319a92ad839abfa","modified":1605282017625},{"_id":"public/archives/page/2/index.html","hash":"7a66b8f767b43c90e370cf485d032cf065522d4a","modified":1605282017625},{"_id":"public/archives/page/3/index.html","hash":"96adbd5bdbe1aef54a78806626cd1fa08dbe1e0f","modified":1605282017625},{"_id":"public/archives/page/4/index.html","hash":"44aa956dca1fd0d71618b73786aeda812f14bcf2","modified":1605282017625},{"_id":"public/archives/2017/index.html","hash":"3852c155074e637aa49c75b30bc28e25ef86446b","modified":1605282017625},{"_id":"public/archives/2017/page/2/index.html","hash":"29a206775b5ff75fcd8b8f4ab27bfea1d54c5178","modified":1605282017625},{"_id":"public/archives/2017/page/3/index.html","hash":"b21c1ae4aa0c83af3a8e131540878ea86e61bc7f","modified":1605282017625},{"_id":"public/archives/2017/03/index.html","hash":"9f1a11e041445de5d5d71ca1d918ddcbeca8078c","modified":1605282017625},{"_id":"public/archives/2017/04/index.html","hash":"107f0f35ac3b483141e5f8aae738273b8136c3e1","modified":1605282017625},{"_id":"public/archives/2017/05/index.html","hash":"e1d45a358730bb3f94221711dd4b61651b3183f0","modified":1605282017625},{"_id":"public/archives/2017/06/index.html","hash":"ec4de41b289f5888690025d656cb54a947360ab5","modified":1605282017625},{"_id":"public/archives/2017/07/index.html","hash":"83882c4e99093ac252113887fdebfc9a9612276d","modified":1605282017625},{"_id":"public/archives/2017/08/index.html","hash":"7008558d637ffb71421693caa772c7aa4f92ff1c","modified":1605282017625},{"_id":"public/archives/2017/09/index.html","hash":"5b83675592ea9063b71845718ffa637a0cfd90a6","modified":1605282017625},{"_id":"public/archives/2017/10/index.html","hash":"8a57c44ae7099e670a336d6f3ea48068719d7ede","modified":1605282017625},{"_id":"public/archives/2017/11/index.html","hash":"e8a616b15cb569d4482e8897c0092690d5a9ee91","modified":1605282017625},{"_id":"public/archives/2017/12/index.html","hash":"f0dac4879a223df2fe1884f4c7d8dd7dcf4cee7a","modified":1605282017625},{"_id":"public/archives/2018/index.html","hash":"5121804b77da02abcec31b2ca9c678742c2ddfe1","modified":1605282017625},{"_id":"public/archives/2018/01/index.html","hash":"8e03e8ea3ef9de3aedaeae4f51377d7014ddb8e5","modified":1605282017625},{"_id":"public/archives/2019/index.html","hash":"793c7b89cf98140c7b1a6574ac4d84a7b70b478f","modified":1605282017625},{"_id":"public/archives/2019/01/index.html","hash":"1802ad9b69dc77e68e2ac011fa7cf2b95e14397b","modified":1605282017625},{"_id":"public/archives/2019/05/index.html","hash":"40a99db34956a466cb3a0942d03774585d66f2a1","modified":1605282017625},{"_id":"public/tags/C-Primer/index.html","hash":"b026dc49ee2662397b4aeb2db26bcd0cdebe56c3","modified":1605282017625},{"_id":"public/tags/C/index.html","hash":"1f4ffd0ef6d9b6af8b4f3ca1d17e37a7b2fa5cbe","modified":1605282017625},{"_id":"public/tags/String/index.html","hash":"bfcd54c21866709bd247ecd514288d14c30501df","modified":1605282017625},{"_id":"public/tags/vector/index.html","hash":"2b7ac2c00acbc9d97e368c9153dbc6d2da905756","modified":1605282017625},{"_id":"public/tags/Travis-CI/index.html","hash":"73357835091cbb11526e0c13a1a213272230886a","modified":1605282017625},{"_id":"public/tags/Hexo/index.html","hash":"a6e9e0398be2abbd85b37760e06073f0fe3482c1","modified":1605282017625},{"_id":"public/tags/LeetCode/index.html","hash":"0527060c4442e89b96a10c579b61454294e7ecee","modified":1605282017625},{"_id":"public/tags/Neutron/index.html","hash":"a9e750e50b4e3957e38bdb8b3446ddf2f3774101","modified":1605282017625},{"_id":"public/tags/Python/index.html","hash":"fdf7fcbcb2123af2c748783053d5b693e2574d60","modified":1605282017625},{"_id":"public/tags/词云/index.html","hash":"b9b4d116e75b8188eb50b0cf3ba559c448a9b648","modified":1605282017625},{"_id":"public/tags/UTF-8/index.html","hash":"5557b43cbd8a800944b4a7741cf5a29bce0bd508","modified":1605282017625},{"_id":"public/tags/VSCode/index.html","hash":"742650c0c01a1d68a84c3510d9f5e8e0c590d787","modified":1605282017625},{"_id":"public/tags/Vim教程/index.html","hash":"3efa068e38c631f6c5cdd7b28f61e95d634a646e","modified":1605282017625},{"_id":"public/tags/IDE/index.html","hash":"0e5d78caff6aca5021161d927337e245eec32a8e","modified":1605282017625},{"_id":"public/tags/helloworld/index.html","hash":"88befb2b277e3241edfe4a9e2dcd7ea156fbd17b","modified":1605282017625},{"_id":"public/tags/每周一坑/index.html","hash":"7f449e67b5898216fb2cc4d2582f6285182dfba1","modified":1605282017625},{"_id":"public/tags/每周一坑/page/2/index.html","hash":"5425031cd637ba55e616d950859e82c0e6c4c669","modified":1605282017625},{"_id":"public/tags/正则表达式/index.html","hash":"3590c0bcd48d8c1e8b5039fd8c58e9cf729b8e09","modified":1605282017625},{"_id":"public/tags/BinaryTree/index.html","hash":"d71623912611e17b1ceb99f02590b78af6643484","modified":1605282017625},{"_id":"public/categories/CPP/index.html","hash":"1e9e0075e17146e9044e4a40178d988322c0edbc","modified":1605282017625},{"_id":"public/categories/Tech/index.html","hash":"343eff5e19e7838fe7fcc7a0acf7745543d75435","modified":1605282017625},{"_id":"public/categories/LeetCode/index.html","hash":"428e44b8a221901f3dd95cd65e3c3b0a190a197b","modified":1605282017625},{"_id":"public/categories/OpenStack/index.html","hash":"a3b0d38a023126787d735beb2b4122fc8c4347c8","modified":1605282017625},{"_id":"public/categories/Python/index.html","hash":"1d90e22aa44949c79f255a98495677faabc9ccb7","modified":1605282017625},{"_id":"public/categories/Python/page/2/index.html","hash":"4ed775decd944887471752ff6672bbd2aedf863a","modified":1605282017625},{"_id":"public/categories/Development/index.html","hash":"7462569b72d866f260f913dba5bce60df870f224","modified":1605282017625},{"_id":"public/categories/Vim/index.html","hash":"28881aac071157b9cfa8cd6f3d77635f5464d7ea","modified":1605282017625},{"_id":"public/categories/helloworld/index.html","hash":"14392fe69e6e50336a71d6c210551ccf0014b34c","modified":1605282017625},{"_id":"public/categories/DataStructure/index.html","hash":"fddd1f05d265faf3095cece811388d48e12e8057","modified":1605282017625},{"_id":"public/index.html","hash":"6883997630bcf35ed184e4bfce5d28c4faf68652","modified":1605282017625},{"_id":"public/page/2/index.html","hash":"7f179a82e47bad708c67e40f4633f49ef834ff17","modified":1605282017625},{"_id":"public/page/3/index.html","hash":"219d7976ae5be0cc28abf482b6d32a49765bc36f","modified":1605282017625},{"_id":"public/page/4/index.html","hash":"c7cc905a727879fd65f4a8ec101a289d7e073422","modified":1605282017625},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1605282017625},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1605282017625},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1605282017625},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1605282017625},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1605282017625},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1605282017625},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1605282017625},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1605282017625},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1605282017625},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1605282017625},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1605282017625},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1605282017625},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1605282017625},{"_id":"public/CNAME","hash":"d0bd4454768930395ba6b57a9e528536e8886381","modified":1605282017625},{"_id":"public/README.md","hash":"d109a3efc14abaffc8e455792d19118e4a57bf3b","modified":1605282017625},{"_id":"public/images/avatar.png","hash":"1ffd03678d665d958cd861afb37f192195fa32d1","modified":1605282017625},{"_id":"public/google2e409c2d3b4ed9c8.html","hash":"12d2a7d5c00d8aea5a62539288068082b5934035","modified":1605282017625},{"_id":"public/images/imagesource/17-03-25-2.jpg","hash":"d39c83dad6ca202f658a5080c8410cb6784312aa","modified":1605282017625},{"_id":"public/images/imagesource/17-04-27.jpg","hash":"c88c5a4e690fd2b00258308aa9ae559cf5ad50f1","modified":1605282017625},{"_id":"public/images/imagesource/17-05-28.jpg","hash":"8078c9bb635146749c2356ce09d4e488f872ca41","modified":1605282017625},{"_id":"public/images/imagesource/17-06-23.jpg","hash":"6efbfd2fbea3d57fa766e7eba8c842b9a7bedaae","modified":1605282017625},{"_id":"public/images/imagesource/17-08-04.jpg","hash":"ee945fff8e14b14d59359289f08b8f1d7f36821b","modified":1605282017625},{"_id":"public/images/imagesource/19-01-08.png","hash":"4e5e64367f7763266febadd4acc817d043c36dbc","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-1.png","hash":"7f50f4c5eadb21b235025ecb46b1fe7e729e643d","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-10.png","hash":"1f4f28d04c87e1c59a5dec5424a797c294dd9e85","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-11.png","hash":"c59a8f5246ad69cf54816ab8d6bac6f24307c158","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-12.png","hash":"0be73a6feb1e842f719fcb58eefc79ff7860f7bd","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-14.png","hash":"2ccbb9ad0a1b735a63fc709a34f88d943f9480b0","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-15.png","hash":"d98350de39ce3d11ced2a895b66f30abb2afe626","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-17.png","hash":"34671fb79859da8ea4fa5f24c44014e3e261d01d","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-18.png","hash":"2f346b4ae1b638695a0a1836c1d0eec3d608a06a","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-19.png","hash":"316eef52efd7aa15a0a6235575a6507965a2d6d0","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-4.png","hash":"4d247dbe07a773598cf5565fa9841ce4bc1950b6","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-2.png","hash":"fe7ac32c219f8715bcf6f9f078c45a0622be8874","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-5.png","hash":"e8b342adf7dde2f18adae32881407e279f31379c","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-3.png","hash":"caf5090ac3b0fce9c3129303626186019e3e7e1d","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-6.png","hash":"5fc15c3d9a3852e9a58bd5c51da9170e6787e4d3","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-7.png","hash":"c17a47924fd2d370f56c465f6639b1c431f5aeb3","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-9.png","hash":"937e4b2b5ecf7813f477b1dafbf0944e6f039658","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-8.png","hash":"fce6707121dd112795714df07b700c01a733c9e4","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-2.png","hash":"92b412858e9e7cbbdb7129e0ccef95f1181081ff","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-3.png","hash":"f1aa869a297332fecac9253af18531e757e1b1c0","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-1.png","hash":"f1e63a5b3bf7b4fca891e2a6e4f8a35016223d45","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-4.png","hash":"e29c988d233a84eee395ae453f390f0d51b1b0da","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-5.png","hash":"430dbec89c4e01e16b7e98fcaed1954a6837a5a9","modified":1605282017625},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-6.png","hash":"2e9ba5be898b2bbfffd6cc496ea02786fa67e699","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/TravisCI-Full-Color.png","hash":"28b210ec069326d1914b54186854e278b874e08e","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-13.png","hash":"30608ba4948767ee479fc6c7786821313f4f9b9e","modified":1605282017625},{"_id":"public/images/imagesource/17-11-17/17-11-17-16.png","hash":"261abc9693a15f0009bc9fd08fa246293e9e25f7","modified":1605282017625},{"_id":"public/images/imagesource/19-01-16/2019-01-16-7.png","hash":"82eecba0cd84dd751a4a0bcfbaaaa564ea0e38d4","modified":1605282017625},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1605282017625},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1605282017625},{"_id":"public/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1605282017625},{"_id":"public/css/main.css","hash":"29b682bdd61c1089aafbbc47e82974632583694f","modified":1605282017625},{"_id":"public/images/imagesource/17-07-08.jpg","hash":"77b1420469d95dc44725a4a2b58d758788487a72","modified":1605282017625},{"_id":"public/js/local-search.js","hash":"9f4fe7bbe0f16be72d26ccb8b22bd33767f83cff","modified":1605282017625},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1605282017625},{"_id":"public/js/algolia-search.js","hash":"7c6c966cdbe6e46d5f885606b0b9daf2ea3f757d","modified":1605282017625},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1605282017625},{"_id":"public/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1605282017625},{"_id":"public/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1605282017625},{"_id":"public/js/utils.js","hash":"bc4217f9779b81c0f56de985c46d73c21d3992d5","modified":1605282017625},{"_id":"public/images/imagesource/17-06-09.png","hash":"4ec8fa57b1e15c9f5b9b021da5492d3b9e965e4d","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-01-08.jpg","hash":"37aab6fbaa550db66847ada43f270a196142c8fd","modified":1605282017625},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-05-22.jpg","hash":"1e85fac725b09f3c99842415fd4c9b0c431ccae1","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-05-14.jpg","hash":"a7b016332084ddbc10a41c9cd57a407c5d060821","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-05-16.jpg","hash":"c47f25d5b90904abd4a2cac1ad16e13e53b839ed","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-05-24.jpg","hash":"6e44859d6fc2554b4d5cf9448655332f9f09748b","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-05-17.jpg","hash":"cfd8a2cb4c022fa13ecbe690c6fa932f84857944","modified":1605282017625},{"_id":"public/images/bing/BingWallPaper-2019-01-16.jpg","hash":"b842db9b6f6ce36b3fdfdde2b6b67235ffe86e91","modified":1605282017625},{"_id":"public/images/imagesource/17-03-23.jpg","hash":"2c384536f5c8ee9c8266362a0472fe46846edc07","modified":1605282017625},{"_id":"public/images/imagesource/17-03-25-1.png","hash":"0d52efafdf810859c9c11627b58ba4168bab3bc8","modified":1605282017625},{"_id":"public/images/background.jpg","hash":"d7db27a39ef107c8911a4e5eae302268393a7039","modified":1605282017625}],"Category":[{"name":"CPP","_id":"ckhgfgsic0004w8vodki28f7k"},{"name":"Tech","_id":"ckhgfgsil000pw8vo7yd3f2r0"},{"name":"LeetCode","_id":"ckhgfgsin000vw8vo0qwr52z9"},{"name":"OpenStack","_id":"ckhgfgsir0015w8vo77315i8e"},{"name":"Python","_id":"ckhgfgsiw001qw8vo3q8z20rj"},{"name":"Development","_id":"ckhgfgsj00025w8vobbhj7rsc"},{"name":"Vim","_id":"ckhgfgsj1002cw8voeq5agn3y"},{"name":"helloworld","_id":"ckhgfgsj2002iw8vogj1ebwxn"},{"name":"DataStructure","_id":"ckhgfgsje004hw8voc47e0byr"}],"Data":[],"Page":[{"layout":"404","title":"404","description":"Oops! Page not found...","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"404\"\ndescription: \"Oops! Page not found...\"\n---","date":"2020-11-12T14:25:33.719Z","updated":"2020-11-12T14:25:33.719Z","path":"404.html","comments":1,"_id":"ckhgfgsi70000w8vo5c2l8g6g","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"关于","date":"2017-03-21T14:16:45.000Z","layout":"about","_content":"---\nName: Feilong Jiang\nBirthday: 1993-10-03\nLocation: Hangzhou, Zhejiang, China\nContact me: <Freedom.JFL@live.com>, <Freedom.JFL@gmail.com>\n\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n> 所谓眼泪啊 \n是流出来就能把辛酸和悲伤都冲走的好东西\n可等你们有一天长大成人就会明白\n人生中还有眼泪也冲刷不干净的巨大悲伤\n还有痛苦让你们即使想哭也不能流泪\n所以真正坚强的人\n都是越想哭反而笑得越大声\n怀揣着一切痛苦和悲伤\n即使如此也要带着它们笑着前行\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-03-21 22:16:45\nlayout: about\n# type: \"about\"\n# comments: true\n---\n---\nName: Feilong Jiang\nBirthday: 1993-10-03\nLocation: Hangzhou, Zhejiang, China\nContact me: <Freedom.JFL@live.com>, <Freedom.JFL@gmail.com>\n\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n> 所谓眼泪啊 \n是流出来就能把辛酸和悲伤都冲走的好东西\n可等你们有一天长大成人就会明白\n人生中还有眼泪也冲刷不干净的巨大悲伤\n还有痛苦让你们即使想哭也不能流泪\n所以真正坚强的人\n都是越想哭反而笑得越大声\n怀揣着一切痛苦和悲伤\n即使如此也要带着它们笑着前行\n\n\n","updated":"2020-11-12T14:25:33.720Z","path":"about/index.html","comments":1,"_id":"ckhgfgsia0002w8vo5h8v3l9v","content":"<hr>\n<p>Name: Feilong Jiang<br>Birthday: 1993-10-03<br>Location: Hangzhou, Zhejiang, China<br>Contact me: <a href=\"mailto:&#70;&#x72;&#101;&#101;&#x64;&#111;&#109;&#46;&#x4a;&#x46;&#76;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#x72;&#101;&#101;&#x64;&#111;&#109;&#46;&#x4a;&#x46;&#76;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;</a>, <a href=\"mailto:&#x46;&#114;&#101;&#x65;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;\">&#x46;&#114;&#101;&#x65;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;</a></p>\n<hr>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n<blockquote>\n<p>所谓眼泪啊<br>是流出来就能把辛酸和悲伤都冲走的好东西<br>可等你们有一天长大成人就会明白<br>人生中还有眼泪也冲刷不干净的巨大悲伤<br>还有痛苦让你们即使想哭也不能流泪<br>所以真正坚强的人<br>都是越想哭反而笑得越大声<br>怀揣着一切痛苦和悲伤<br>即使如此也要带着它们笑着前行</p>\n</blockquote>\n","site":{"data":{}},"length":434,"excerpt":"","more":"<hr>\n<p>Name: Feilong Jiang<br>Birthday: 1993-10-03<br>Location: Hangzhou, Zhejiang, China<br>Contact me: <a href=\"mailto:&#70;&#x72;&#101;&#101;&#x64;&#111;&#109;&#46;&#x4a;&#x46;&#76;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;\">&#70;&#x72;&#101;&#101;&#x64;&#111;&#109;&#46;&#x4a;&#x46;&#76;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;</a>, <a href=\"mailto:&#x46;&#114;&#101;&#x65;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;\">&#x46;&#114;&#101;&#x65;&#100;&#x6f;&#x6d;&#x2e;&#74;&#x46;&#x4c;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;</a></p>\n<hr>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 \nsrc=\"//music.163.com/outchain/player?type=2&id=4962128&auto=1&height=66\">\n</iframe>\n\n\n\n\n<blockquote>\n<p>所谓眼泪啊<br>是流出来就能把辛酸和悲伤都冲走的好东西<br>可等你们有一天长大成人就会明白<br>人生中还有眼泪也冲刷不干净的巨大悲伤<br>还有痛苦让你们即使想哭也不能流泪<br>所以真正坚强的人<br>都是越想哭反而笑得越大声<br>怀揣着一切痛苦和悲伤<br>即使如此也要带着它们笑着前行</p>\n</blockquote>\n"},{"title":"标签","date":"2017-03-21T14:15:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-03-21 22:15:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-11-12T14:25:33.715Z","path":"tags/index.html","layout":"page","_id":"ckhgfgsid0006w8vo1okueewg","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"文章分类","date":"2019-01-07T13:45:34.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-01-07 21:45:34\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-11-12T14:25:33.717Z","path":"categories/index.html","layout":"page","_id":"ckhgfgsie0008w8vo2geh21dt","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"sitemap","date":"2017-03-21T14:17:04.000Z","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2017-03-21 22:17:04\n---\n","updated":"2020-11-12T14:25:33.718Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"ckhgfgsif000aw8vobum8dffz","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"C++ Primer 第五版 练习 12.33","date":"2017-06-07T14:39:56.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\nC++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——**文本查询程序**。\n<!--more-->\n\n## 文本查询程序\n\n> 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。\n\n## 文本查询程序设计\n\n设计两个类：`TextQuery`和`QueryResult`\n其中`TextQuery`用来生成每个单词对应的行号以及进行相关的查询操作；\n`QuerResult`用来保存查询结果，通过其成员函数`print()`输出查询结果。\n\n## 查询程序的实现\n\nQuery.h\n```C++\n#pragma once\n/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，\n   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，\n   返回一个shared_ptr，指向QueryResult对象中的文件\n*/\n\n#include\"12.22.h\"\n// 定义了StrBlob类的头文件\nusing std::shared_ptr;\n\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<set>\n\n// 为了定义函数query的返回类型，这个定义是必须的\nclass QueryResult;\nclass TextQuery {\npublic:\n\tTextQuery(std::ifstream&);\n\tQueryResult query(const string&) const;\n\nprivate:\n \t// 输入文件\n\tshared_ptr<StrBlob> file;\t\t\t\t\t\t   \n\t// 每个单词到它所在行号的映射\n\tstd::map<std::string, \n\t\tshared_ptr<std::set<StrBlob::size_type>>> wordmap;\n};\n\nclass QueryResult {\n\tusing qr_iter = std::set<StrBlob::size_type>::iterator;\n\tfriend std::ostream &print(std::ostream&, QueryResult&);\n\npublic:\n\tQueryResult(string s, shared_ptr<std::set<StrBlob::size_type>> l, shared_ptr<StrBlob> f) :\n\t\tword(s), lines(l), file(f) {}\n\n\tqr_iter begin() const { return lines->begin(); }\n\tqr_iter end() const { return lines->end(); }\n\n\tshared_ptr<StrBlob> get_file() const { return file; }\n\nprivate:\n\t// 查询单词\n\tstring word;\n\t// 出现的行号\n\tshared_ptr<std::set<StrBlob::size_type>> lines;\n\t // 输入文件\n\tshared_ptr<StrBlob> file;\n};\n\nstd::ostream &print(std::ostream &os, QueryResult &query_result);\n\n```\n\nQuery.cpp\n```C++\n#include \"Query.h\"\n#include<iterator>\n#include<sstream>\n#include<algorithm>\n\n//读取输入文件并建立单词到行号的映射\nTextQuery::TextQuery(std::ifstream &ifs) : file(new StrBlob)\n{\n\t// 保存行号\n\tStrBlob::size_type line_no{ 0 };\n\t// 对文件中的每一行\n\tfor (string line; std::getline(ifs, line); ++line_no)\n\t{\n\t\t// 保存此行文本\n\t\tfile->push_back(line);\n\t\t // 将文本分解为单词\n\t\tstd::istringstream stream(line);\n\t\t// 对行中每个单词\n\t\tfor (string text, word; stream >> text; word.clear())\n\t\t{\n\t\t\t// 去除单词中的标点符号\n\t\t\tstd::remove_copy_if(text.begin(), text.end(),\n\t\t\t\tstd::back_inserter(word), ispunct);\n\t\t\t// 如果单词不在wordmap中，以之为下标在wordmap中添加一项\n\t\t\tauto &lines = wordmap[word];\n\t\t\t// 第一次遇到这个单词时，lines的指针为空\n\t\t\t// 分配一个新的set\n\t\t\tif (!lines) lines.reset(new std::set<StrBlob::size_type>);\n\t\t\t// 将此行号插入set中\n\t\t\tlines->insert(line_no);\n\t\t}\n\t}\n}\n\nQueryResult TextQuery::query(const string &sought) const\n{\n\t// 如果未找到sought，将返回一个指向此set的指针\n\tstatic shared_ptr<std::set<StrBlob::size_type>>\n\t\tnodata(new std::set< StrBlob::size_type>);\n\t// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中\n\tauto found = wordmap.find(sought);\n\tif (found != wordmap.end())\n\t\t// 找到单词\n\t\treturn QueryResult(sought, found->second, file);\n\telse\n\t\t// 未找到\n\t\treturn QueryResult(sought, nodata, file);\n}\n\nstd::ostream & print(std::ostream &os, QueryResult &query_result)\n{\n\t// TODO: 在此处插入 return 语句\n\t// 如果找到了单词，打印出现次数和所有出现的位置\n\tos << query_result.word << \" occurs \" << query_result.lines->size() << \" \"\n\t\t<< (query_result.lines->size() > 1 ? \"times.\" : \"time.\") << std::endl;\n\n\t// 打印单词出现的每一行\n\tfor (auto it = query_result.begin(); it != query_result.end(); ++it)\n\t{\n\t\tConstStrBlobPtr p(*query_result.file, *it);\n\t\tos << \"\\t(line \" << *it + 1 << \") \" << p.deref() << std::endl;\n\t}\n\treturn os;\n}\n```\n\n## 测试\nQuery_test.cpp\n```C++\n#include\"12.33.h\"\n\nvoid runQueries(std::ifstream &ifs)\n{\n\tTextQuery text_query(ifs);\n\tdo\n\t{\n\t\tstd::cout << \"Enter word to look for or q to quit: \";\n\t\tstring word;\n\t\tif (!(std::cin >> word) || word == \"q\") break;\n\t\tprint(std::cout, text_query.query(word)) << std::endl;\n\t} while (true);\n}\n\nint main()\n{\n\tstd::ifstream ifs(\"data/story.txt\");\n\trunQueries(ifs);\n\n\treturn 0;\n}\n```\n\n## 总结\n这里用到了之前几节定义的`StrBlob`来代替`vector<string>`来保存每一行的内容。\n算是一个比较综合的练习了。刚开始做没什么思路，多亏了[GayHub](https://github.com/pezy/CppPrimer)（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!\n(ง •̀_•́)ง \n\n\n\nEnd~\n\n---","source":"_posts/C-Primer-第五版-练习-12-33.md","raw":"---\ntitle: C++ Primer 第五版 练习 12.33\ndate: 2017-06-07 22:39:56\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: C++ Primer\ncomments: true\n---\n\nC++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——**文本查询程序**。\n<!--more-->\n\n## 文本查询程序\n\n> 实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。\n\n## 文本查询程序设计\n\n设计两个类：`TextQuery`和`QueryResult`\n其中`TextQuery`用来生成每个单词对应的行号以及进行相关的查询操作；\n`QuerResult`用来保存查询结果，通过其成员函数`print()`输出查询结果。\n\n## 查询程序的实现\n\nQuery.h\n```C++\n#pragma once\n/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，\n   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，\n   返回一个shared_ptr，指向QueryResult对象中的文件\n*/\n\n#include\"12.22.h\"\n// 定义了StrBlob类的头文件\nusing std::shared_ptr;\n\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<set>\n\n// 为了定义函数query的返回类型，这个定义是必须的\nclass QueryResult;\nclass TextQuery {\npublic:\n\tTextQuery(std::ifstream&);\n\tQueryResult query(const string&) const;\n\nprivate:\n \t// 输入文件\n\tshared_ptr<StrBlob> file;\t\t\t\t\t\t   \n\t// 每个单词到它所在行号的映射\n\tstd::map<std::string, \n\t\tshared_ptr<std::set<StrBlob::size_type>>> wordmap;\n};\n\nclass QueryResult {\n\tusing qr_iter = std::set<StrBlob::size_type>::iterator;\n\tfriend std::ostream &print(std::ostream&, QueryResult&);\n\npublic:\n\tQueryResult(string s, shared_ptr<std::set<StrBlob::size_type>> l, shared_ptr<StrBlob> f) :\n\t\tword(s), lines(l), file(f) {}\n\n\tqr_iter begin() const { return lines->begin(); }\n\tqr_iter end() const { return lines->end(); }\n\n\tshared_ptr<StrBlob> get_file() const { return file; }\n\nprivate:\n\t// 查询单词\n\tstring word;\n\t// 出现的行号\n\tshared_ptr<std::set<StrBlob::size_type>> lines;\n\t // 输入文件\n\tshared_ptr<StrBlob> file;\n};\n\nstd::ostream &print(std::ostream &os, QueryResult &query_result);\n\n```\n\nQuery.cpp\n```C++\n#include \"Query.h\"\n#include<iterator>\n#include<sstream>\n#include<algorithm>\n\n//读取输入文件并建立单词到行号的映射\nTextQuery::TextQuery(std::ifstream &ifs) : file(new StrBlob)\n{\n\t// 保存行号\n\tStrBlob::size_type line_no{ 0 };\n\t// 对文件中的每一行\n\tfor (string line; std::getline(ifs, line); ++line_no)\n\t{\n\t\t// 保存此行文本\n\t\tfile->push_back(line);\n\t\t // 将文本分解为单词\n\t\tstd::istringstream stream(line);\n\t\t// 对行中每个单词\n\t\tfor (string text, word; stream >> text; word.clear())\n\t\t{\n\t\t\t// 去除单词中的标点符号\n\t\t\tstd::remove_copy_if(text.begin(), text.end(),\n\t\t\t\tstd::back_inserter(word), ispunct);\n\t\t\t// 如果单词不在wordmap中，以之为下标在wordmap中添加一项\n\t\t\tauto &lines = wordmap[word];\n\t\t\t// 第一次遇到这个单词时，lines的指针为空\n\t\t\t// 分配一个新的set\n\t\t\tif (!lines) lines.reset(new std::set<StrBlob::size_type>);\n\t\t\t// 将此行号插入set中\n\t\t\tlines->insert(line_no);\n\t\t}\n\t}\n}\n\nQueryResult TextQuery::query(const string &sought) const\n{\n\t// 如果未找到sought，将返回一个指向此set的指针\n\tstatic shared_ptr<std::set<StrBlob::size_type>>\n\t\tnodata(new std::set< StrBlob::size_type>);\n\t// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中\n\tauto found = wordmap.find(sought);\n\tif (found != wordmap.end())\n\t\t// 找到单词\n\t\treturn QueryResult(sought, found->second, file);\n\telse\n\t\t// 未找到\n\t\treturn QueryResult(sought, nodata, file);\n}\n\nstd::ostream & print(std::ostream &os, QueryResult &query_result)\n{\n\t// TODO: 在此处插入 return 语句\n\t// 如果找到了单词，打印出现次数和所有出现的位置\n\tos << query_result.word << \" occurs \" << query_result.lines->size() << \" \"\n\t\t<< (query_result.lines->size() > 1 ? \"times.\" : \"time.\") << std::endl;\n\n\t// 打印单词出现的每一行\n\tfor (auto it = query_result.begin(); it != query_result.end(); ++it)\n\t{\n\t\tConstStrBlobPtr p(*query_result.file, *it);\n\t\tos << \"\\t(line \" << *it + 1 << \") \" << p.deref() << std::endl;\n\t}\n\treturn os;\n}\n```\n\n## 测试\nQuery_test.cpp\n```C++\n#include\"12.33.h\"\n\nvoid runQueries(std::ifstream &ifs)\n{\n\tTextQuery text_query(ifs);\n\tdo\n\t{\n\t\tstd::cout << \"Enter word to look for or q to quit: \";\n\t\tstring word;\n\t\tif (!(std::cin >> word) || word == \"q\") break;\n\t\tprint(std::cout, text_query.query(word)) << std::endl;\n\t} while (true);\n}\n\nint main()\n{\n\tstd::ifstream ifs(\"data/story.txt\");\n\trunQueries(ifs);\n\n\treturn 0;\n}\n```\n\n## 总结\n这里用到了之前几节定义的`StrBlob`来代替`vector<string>`来保存每一行的内容。\n算是一个比较综合的练习了。刚开始做没什么思路，多亏了[GayHub](https://github.com/pezy/CppPrimer)（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!\n(ง •̀_•́)ง \n\n\n\nEnd~\n\n---","slug":"C-Primer-第五版-练习-12-33","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsi80001w8vo8x7jcy7b","content":"<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"文本查询程序\"><a href=\"#文本查询程序\" class=\"headerlink\" title=\"文本查询程序\"></a>文本查询程序</h2><blockquote>\n<p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p>\n</blockquote>\n<h2 id=\"文本查询程序设计\"><a href=\"#文本查询程序设计\" class=\"headerlink\" title=\"文本查询程序设计\"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p>\n<h2 id=\"查询程序的实现\"><a href=\"#查询程序的实现\" class=\"headerlink\" title=\"查询程序的实现\"></a>查询程序的实现</h2><p>Query.h</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"comment\">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</span></span><br><span class=\"line\"><span class=\"comment\">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</span></span><br><span class=\"line\"><span class=\"comment\">   返回一个shared_ptr，指向QueryResult对象中的文件</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;12.22.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义了StrBlob类的头文件</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了定义函数query的返回类型，这个定义是必须的</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryResult</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextQuery</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTextQuery(<span class=\"built_in\">std</span>::ifstream&amp;);</span><br><span class=\"line\">\t<span class=\"function\">QueryResult <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"> \t<span class=\"comment\">// 输入文件</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;\t\t\t\t\t\t   </span><br><span class=\"line\">\t<span class=\"comment\">// 每个单词到它所在行号的映射</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, </span><br><span class=\"line\">\t\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryResult</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">using</span> qr_iter = <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;::iterator;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"built_in\">std</span>::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueryResult(<span class=\"built_in\">string</span> s, <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; f) :</span><br><span class=\"line\">\t\tword(s), lines(l), file(f) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;begin(); &#125;</span><br><span class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;end(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; <span class=\"title\">get_file</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> file; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 查询单词</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t<span class=\"comment\">// 出现的行号</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</span><br><span class=\"line\">\t <span class=\"comment\">// 输入文件</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Query.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Query.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取输入文件并建立单词到行号的映射</span></span><br><span class=\"line\">TextQuery::TextQuery(<span class=\"built_in\">std</span>::ifstream &amp;ifs) : file(<span class=\"keyword\">new</span> StrBlob)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 保存行号</span></span><br><span class=\"line\">\tStrBlob::size_type line_no&#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 对文件中的每一行</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> line; <span class=\"built_in\">std</span>::getline(ifs, line); ++line_no)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存此行文本</span></span><br><span class=\"line\">\t\tfile-&gt;push_back(line);</span><br><span class=\"line\">\t\t <span class=\"comment\">// 将文本分解为单词</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">istringstream</span> <span class=\"title\">stream</span><span class=\"params\">(line)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对行中每个单词</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> text, word; stream &gt;&gt; text; word.clear())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 去除单词中的标点符号</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">std</span>::remove_copy_if(text.begin(), text.end(),</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">std</span>::back_inserter(word), <span class=\"built_in\">ispunct</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> &amp;lines = wordmap[word];</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 第一次遇到这个单词时，lines的指针为空</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配一个新的set</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!lines) lines.reset(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将此行号插入set中</span></span><br><span class=\"line\">\t\t\tlines-&gt;insert(line_no);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">QueryResult <span class=\"title\">TextQuery::query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;sought)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果未找到sought，将返回一个指向此set的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;</span><br><span class=\"line\">\t\tnodata(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt; StrBlob::size_type&gt;);</span><br><span class=\"line\">\t<span class=\"comment\">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> found = wordmap.find(sought);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (found != wordmap.end())</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到单词</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, found-&gt;second, file);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 未找到</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, nodata, file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::ostream &amp; <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在此处插入 return 语句</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class=\"line\">\tos &lt;&lt; query_result.word &lt;&lt; <span class=\"string\">&quot; occurs &quot;</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">\t\t&lt;&lt; (query_result.lines-&gt;size() &gt; <span class=\"number\">1</span> ? <span class=\"string\">&quot;times.&quot;</span> : <span class=\"string\">&quot;time.&quot;</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印单词出现的每一行</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">ConstStrBlobPtr <span class=\"title\">p</span><span class=\"params\">(*query_result.file, *it)</span></span>;</span><br><span class=\"line\">\t\tos &lt;&lt; <span class=\"string\">&quot;\\t(line &quot;</span> &lt;&lt; *it + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;) &quot;</span> &lt;&lt; p.deref() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>Query_test.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;12.33.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runQueries</span><span class=\"params\">(<span class=\"built_in\">std</span>::ifstream &amp;ifs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">TextQuery <span class=\"title\">text_query</span><span class=\"params\">(ifs)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter word to look for or q to quit: &quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; word) || word == <span class=\"string\">&quot;q&quot;</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tprint(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>, text_query.query(word)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::ifstream <span class=\"title\">ifs</span><span class=\"params\">(<span class=\"string\">&quot;data/story.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\trunQueries(ifs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href=\"https://github.com/pezy/CppPrimer\">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":4072,"excerpt":"<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。</p>","more":"<h2 id=\"文本查询程序\"><a href=\"#文本查询程序\" class=\"headerlink\" title=\"文本查询程序\"></a>文本查询程序</h2><blockquote>\n<p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p>\n</blockquote>\n<h2 id=\"文本查询程序设计\"><a href=\"#文本查询程序设计\" class=\"headerlink\" title=\"文本查询程序设计\"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p>\n<h2 id=\"查询程序的实现\"><a href=\"#查询程序的实现\" class=\"headerlink\" title=\"查询程序的实现\"></a>查询程序的实现</h2><p>Query.h</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"comment\">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</span></span><br><span class=\"line\"><span class=\"comment\">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</span></span><br><span class=\"line\"><span class=\"comment\">   返回一个shared_ptr，指向QueryResult对象中的文件</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;12.22.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义了StrBlob类的头文件</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了定义函数query的返回类型，这个定义是必须的</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryResult</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextQuery</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTextQuery(<span class=\"built_in\">std</span>::ifstream&amp;);</span><br><span class=\"line\">\t<span class=\"function\">QueryResult <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"> \t<span class=\"comment\">// 输入文件</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;\t\t\t\t\t\t   </span><br><span class=\"line\">\t<span class=\"comment\">// 每个单词到它所在行号的映射</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, </span><br><span class=\"line\">\t\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryResult</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">using</span> qr_iter = <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;::iterator;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"built_in\">std</span>::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueryResult(<span class=\"built_in\">string</span> s, <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; f) :</span><br><span class=\"line\">\t\tword(s), lines(l), file(f) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;begin(); &#125;</span><br><span class=\"line\">\t<span class=\"function\">qr_iter <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> lines-&gt;end(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; <span class=\"title\">get_file</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> file; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 查询单词</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t<span class=\"comment\">// 出现的行号</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</span><br><span class=\"line\">\t <span class=\"comment\">// 输入文件</span></span><br><span class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;StrBlob&gt; file;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Query.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Query.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取输入文件并建立单词到行号的映射</span></span><br><span class=\"line\">TextQuery::TextQuery(<span class=\"built_in\">std</span>::ifstream &amp;ifs) : file(<span class=\"keyword\">new</span> StrBlob)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 保存行号</span></span><br><span class=\"line\">\tStrBlob::size_type line_no&#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 对文件中的每一行</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> line; <span class=\"built_in\">std</span>::getline(ifs, line); ++line_no)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存此行文本</span></span><br><span class=\"line\">\t\tfile-&gt;push_back(line);</span><br><span class=\"line\">\t\t <span class=\"comment\">// 将文本分解为单词</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">istringstream</span> <span class=\"title\">stream</span><span class=\"params\">(line)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对行中每个单词</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> text, word; stream &gt;&gt; text; word.clear())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 去除单词中的标点符号</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">std</span>::remove_copy_if(text.begin(), text.end(),</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">std</span>::back_inserter(word), <span class=\"built_in\">ispunct</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> &amp;lines = wordmap[word];</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 第一次遇到这个单词时，lines的指针为空</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配一个新的set</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!lines) lines.reset(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将此行号插入set中</span></span><br><span class=\"line\">\t\t\tlines-&gt;insert(line_no);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">QueryResult <span class=\"title\">TextQuery::query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;sought)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果未找到sought，将返回一个指向此set的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;StrBlob::size_type&gt;&gt;</span><br><span class=\"line\">\t\tnodata(<span class=\"keyword\">new</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt; StrBlob::size_type&gt;);</span><br><span class=\"line\">\t<span class=\"comment\">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> found = wordmap.find(sought);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (found != wordmap.end())</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到单词</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, found-&gt;second, file);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 未找到</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueryResult(sought, nodata, file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::ostream &amp; <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 在此处插入 return 语句</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class=\"line\">\tos &lt;&lt; query_result.word &lt;&lt; <span class=\"string\">&quot; occurs &quot;</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">\t\t&lt;&lt; (query_result.lines-&gt;size() &gt; <span class=\"number\">1</span> ? <span class=\"string\">&quot;times.&quot;</span> : <span class=\"string\">&quot;time.&quot;</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印单词出现的每一行</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">ConstStrBlobPtr <span class=\"title\">p</span><span class=\"params\">(*query_result.file, *it)</span></span>;</span><br><span class=\"line\">\t\tos &lt;&lt; <span class=\"string\">&quot;\\t(line &quot;</span> &lt;&lt; *it + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;) &quot;</span> &lt;&lt; p.deref() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>Query_test.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;12.33.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runQueries</span><span class=\"params\">(<span class=\"built_in\">std</span>::ifstream &amp;ifs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">TextQuery <span class=\"title\">text_query</span><span class=\"params\">(ifs)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter word to look for or q to quit: &quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; word) || word == <span class=\"string\">&quot;q&quot;</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tprint(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>, text_query.query(word)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::ifstream <span class=\"title\">ifs</span><span class=\"params\">(<span class=\"string\">&quot;data/story.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\trunQueries(ifs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href=\"https://github.com/pezy/CppPrimer\">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p>\n<p>End~</p>\n<hr>"},{"title":"C++ Primer 第五版 练习12.3","date":"2017-05-26T06:27:11.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\n## 问题\n\nStrBlob需要const版本的`push_back`和`pop_back`吗？如果需要，添加进去。否则，解释为什么不需要。\n\n<!--more-->\n\n## 定义StrBlob类\n\n首先，定义**StrBlob**类。类的定义如下：\n\n```C++\n\n/* StrBlob.h */\n/* 编写你自己的StrBlob类，包含const版本的front和back */\n#pragma once\n#include<vector>\n#include<string>\n#include<initializer_list>\n#include<memory>\n#include<exception>\n\nusing std::vector;\nusing std::string;\n\nclass StrBlob {\npublic:\n    using size_type = vector<string>::size_type;\n    StrBlob() : data(std::make_shared<vector<string>>()) {}\n    StrBlob(std::initializer_list<string> il)\n        : data(std::make_shared<vector<string>>(il)) {}\n    size_type size() cosnt { return data->size(); }\n    bool empty() const { return data->empty(); }\n    // 添加和删除元素\n    void push_back(const string &t) { data->push_back(t); }\n    void pop_back()\n    {\n       check(0, \"pop_back on empty StrBlob\");\n       data->pop_back();\n    }\n    // 元素访问\n    string &front()\n    {\n        // 如果vector为空，check会抛出一个异常\n       check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    const string &front() const\n    {\n        check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    string &back()\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\n    const string &back() const\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\nprivate:\n    void check(size_type i, const string &msg) const\n    {\n    if (i >= data->size())\n        throw std::out_of_range(msg);\n    }\nprivate:\n    std::shared_ptr<vector<string>> data;\n\n```\n\n## 测试\n\n### 非const StrBlob对象\n\n根据**StrBlob**的定义，我们来测试一下：\n首先声明一个**StrBlob**对象**b1**：\n\n    StrBlob b1 = {\"a\", \"an\", \"the\"};        // 非const对象\n\n然后分别对**b1**调用`push_back()`和`pop_back()`：\n\n    b1.push_back(\"test\");       // 向b1添加元素test\n\n此时**b1**保存的内容是 **a**, **an**, **the**, **test**;\n接着就是\n\n     b1.pop_back();         // 删除刚刚添加的元素\n\n此时**b1**保存的内容是 **a**, **an**, **the**;\n可以看到，我们定义的非const的**StrBlob**对象进行`push_back()`和`pop_back()`操作是没有问题的。\n\n### const StrBlob对象\n\n上面的操作都很顺利，那么当我们声明一个const **StrBlob**对象会怎么样呢？\n接下来，我们声明一个const类型的**StrBlob**对象：\n\n    const StrBlob cb = {\"a\", \"an\", \"the\"};       // const 对象\n \n同样的，我们对**cb**调用`push_back()`和`pop_back()`，看看会发生什么：\n\n    cb.push_back(\"test\");       // 向cb添加元素test\n运行一下程序，就会报错：\n> *Error C2662 “void StrBlob::push_back(const std::string &)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n\n    cb.pop_back();           // 删除元素\n\n在运行程序，同样也会报错：\n> *Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n原因是我们在定义**StrBlob**类时，`push_back()`和`pop_back()`并没有添const版本。\n那么，自然而然地，我们将添加const版本的`push_back()`和`pop_back()`，在StrBlob.h中添加以下代码:\n\n```C++\n\n/* StrBlob.h */\n...\nvoid push_back(const string &t) { data->push_back(t); }\nvoid pop_back()\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n// 添加const类型的push_back()和pop_back()\nvoid push_back(const string &t) const \n{\n    data->push_back(t);\n}\nvoid pop_back() const\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n...\n\n```\n\n再运行一下程序，通过了，并且输出和之前非const版本的一样。\n\n## 讨论\n\n那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？\n\n如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的`push_back()`和`pop_back()`是必须的。但是要注意的是：\n\n**我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向`vector<string>`的智能指针；但由于类的封装，在使用者看来，数据成员是`vector<string>`，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是`vector<string>`的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像`push_back()`和`pop_back()`这样会改变智能指针所指向的`vector<string>`内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用`push_back()`和`pop_back()`成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。**\n\n通过以上的考虑，我认为**StrBlob**不需要const版本的`push_back`和`pop_back`。\n\n\n## 参考资料\n\n [1]:  [豆瓣 - 大家来讨论一下 exercise 12.3](https://www.douban.com/group/topic/61573279/)\n [2]:  [Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?](https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi)\n\n\n\n\nEnd~\n\n---\n","source":"_posts/C-Primer-第五版-练习12-3.md","raw":"---\ntitle: C++ Primer 第五版 练习12.3\ndate: 2017-05-26 14:27:11\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: C++ Primer\ncomments: true\n---\n\n## 问题\n\nStrBlob需要const版本的`push_back`和`pop_back`吗？如果需要，添加进去。否则，解释为什么不需要。\n\n<!--more-->\n\n## 定义StrBlob类\n\n首先，定义**StrBlob**类。类的定义如下：\n\n```C++\n\n/* StrBlob.h */\n/* 编写你自己的StrBlob类，包含const版本的front和back */\n#pragma once\n#include<vector>\n#include<string>\n#include<initializer_list>\n#include<memory>\n#include<exception>\n\nusing std::vector;\nusing std::string;\n\nclass StrBlob {\npublic:\n    using size_type = vector<string>::size_type;\n    StrBlob() : data(std::make_shared<vector<string>>()) {}\n    StrBlob(std::initializer_list<string> il)\n        : data(std::make_shared<vector<string>>(il)) {}\n    size_type size() cosnt { return data->size(); }\n    bool empty() const { return data->empty(); }\n    // 添加和删除元素\n    void push_back(const string &t) { data->push_back(t); }\n    void pop_back()\n    {\n       check(0, \"pop_back on empty StrBlob\");\n       data->pop_back();\n    }\n    // 元素访问\n    string &front()\n    {\n        // 如果vector为空，check会抛出一个异常\n       check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    const string &front() const\n    {\n        check(0, \"front on empty StrBlob\");\n       return data->front();\n    }\n    string &back()\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\n    const string &back() const\n    {\n        check(0, \"back on empty StrBlob\");\n        return data->back();\n    }\nprivate:\n    void check(size_type i, const string &msg) const\n    {\n    if (i >= data->size())\n        throw std::out_of_range(msg);\n    }\nprivate:\n    std::shared_ptr<vector<string>> data;\n\n```\n\n## 测试\n\n### 非const StrBlob对象\n\n根据**StrBlob**的定义，我们来测试一下：\n首先声明一个**StrBlob**对象**b1**：\n\n    StrBlob b1 = {\"a\", \"an\", \"the\"};        // 非const对象\n\n然后分别对**b1**调用`push_back()`和`pop_back()`：\n\n    b1.push_back(\"test\");       // 向b1添加元素test\n\n此时**b1**保存的内容是 **a**, **an**, **the**, **test**;\n接着就是\n\n     b1.pop_back();         // 删除刚刚添加的元素\n\n此时**b1**保存的内容是 **a**, **an**, **the**;\n可以看到，我们定义的非const的**StrBlob**对象进行`push_back()`和`pop_back()`操作是没有问题的。\n\n### const StrBlob对象\n\n上面的操作都很顺利，那么当我们声明一个const **StrBlob**对象会怎么样呢？\n接下来，我们声明一个const类型的**StrBlob**对象：\n\n    const StrBlob cb = {\"a\", \"an\", \"the\"};       // const 对象\n \n同样的，我们对**cb**调用`push_back()`和`pop_back()`，看看会发生什么：\n\n    cb.push_back(\"test\");       // 向cb添加元素test\n运行一下程序，就会报错：\n> *Error C2662 “void StrBlob::push_back(const std::string &)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n\n    cb.pop_back();           // 删除元素\n\n在运行程序，同样也会报错：\n> *Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &”*\n\n原因是我们在定义**StrBlob**类时，`push_back()`和`pop_back()`并没有添const版本。\n那么，自然而然地，我们将添加const版本的`push_back()`和`pop_back()`，在StrBlob.h中添加以下代码:\n\n```C++\n\n/* StrBlob.h */\n...\nvoid push_back(const string &t) { data->push_back(t); }\nvoid pop_back()\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n// 添加const类型的push_back()和pop_back()\nvoid push_back(const string &t) const \n{\n    data->push_back(t);\n}\nvoid pop_back() const\n{\n    check(0, \"pop_back on empty StrBlob\");\n    data->pop_back();\n}\n...\n\n```\n\n再运行一下程序，通过了，并且输出和之前非const版本的一样。\n\n## 讨论\n\n那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？\n\n如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的`push_back()`和`pop_back()`是必须的。但是要注意的是：\n\n**我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向`vector<string>`的智能指针；但由于类的封装，在使用者看来，数据成员是`vector<string>`，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是`vector<string>`的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像`push_back()`和`pop_back()`这样会改变智能指针所指向的`vector<string>`内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用`push_back()`和`pop_back()`成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。**\n\n通过以上的考虑，我认为**StrBlob**不需要const版本的`push_back`和`pop_back`。\n\n\n## 参考资料\n\n [1]:  [豆瓣 - 大家来讨论一下 exercise 12.3](https://www.douban.com/group/topic/61573279/)\n [2]:  [Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?](https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi)\n\n\n\n\nEnd~\n\n---\n","slug":"C-Primer-第五版-练习12-3","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsib0003w8vo0c08gt69","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>StrBlob需要const版本的<code>push_back</code>和<code>pop_back</code>吗？如果需要，添加进去。否则，解释为什么不需要。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"定义StrBlob类\"><a href=\"#定义StrBlob类\" class=\"headerlink\" title=\"定义StrBlob类\"></a>定义StrBlob类</h2><p>首先，定义<strong>StrBlob</strong>类。类的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></span><br><span class=\"line\"><span class=\"comment\">/* 编写你自己的StrBlob类，包含const版本的front和back */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;initializer_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlob</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> size_type = <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;::size_type;</span><br><span class=\"line\">    StrBlob() : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</span><br><span class=\"line\">    StrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">string</span>&gt; il)</span><br><span class=\"line\">        : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> cosnt </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加和删除元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       data-&gt;pop_back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 元素访问</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果vector为空，check会抛出一个异常</span></span><br><span class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">&quot;front on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;front on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= data-&gt;size())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; data;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"非const-StrBlob对象\"><a href=\"#非const-StrBlob对象\" class=\"headerlink\" title=\"非const StrBlob对象\"></a>非const StrBlob对象</h3><p>根据<strong>StrBlob</strong>的定义，我们来测试一下：<br>首先声明一个<strong>StrBlob</strong>对象<strong>b1</strong>：</p>\n<pre><code>StrBlob b1 = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;        // 非const对象</code></pre>\n<p>然后分别对<strong>b1</strong>调用<code>push_back()</code>和<code>pop_back()</code>：</p>\n<pre><code>b1.push_back(&quot;test&quot;);       // 向b1添加元素test</code></pre>\n<p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>, <strong>test</strong>;<br>接着就是</p>\n<pre><code> b1.pop_back();         // 删除刚刚添加的元素</code></pre>\n<p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>;<br>可以看到，我们定义的非const的<strong>StrBlob</strong>对象进行<code>push_back()</code>和<code>pop_back()</code>操作是没有问题的。</p>\n<h3 id=\"const-StrBlob对象\"><a href=\"#const-StrBlob对象\" class=\"headerlink\" title=\"const StrBlob对象\"></a>const StrBlob对象</h3><p>上面的操作都很顺利，那么当我们声明一个const <strong>StrBlob</strong>对象会怎么样呢？<br>接下来，我们声明一个const类型的<strong>StrBlob</strong>对象：</p>\n<pre><code>const StrBlob cb = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;       // const 对象</code></pre>\n<p>同样的，我们对<strong>cb</strong>调用<code>push_back()</code>和<code>pop_back()</code>，看看会发生什么：</p>\n<pre><code>cb.push_back(&quot;test&quot;);       // 向cb添加元素test</code></pre>\n<p>运行一下程序，就会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<pre><code>cb.pop_back();           // 删除元素</code></pre>\n<p>在运行程序，同样也会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<p>原因是我们在定义<strong>StrBlob</strong>类时，<code>push_back()</code>和<code>pop_back()</code>并没有添const版本。<br>那么，自然而然地，我们将添加const版本的<code>push_back()</code>和<code>pop_back()</code>，在StrBlob.h中添加以下代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">    data-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加const类型的push_back()和pop_back()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> <span class=\"keyword\">const</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    data-&gt;push_back(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">    data-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再运行一下程序，通过了，并且输出和之前非const版本的一样。</p>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？</p>\n<p>如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的<code>push_back()</code>和<code>pop_back()</code>是必须的。但是要注意的是：</p>\n<p><strong>我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向<code>vector&lt;string&gt;</code>的智能指针；但由于类的封装，在使用者看来，数据成员是<code>vector&lt;string&gt;</code>，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是<code>vector&lt;string&gt;</code>的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像<code>push_back()</code>和<code>pop_back()</code>这样会改变智能指针所指向的<code>vector&lt;string&gt;</code>内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用<code>push_back()</code>和<code>pop_back()</code>成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。</strong></p>\n<p>通过以上的考虑，我认为<strong>StrBlob</strong>不需要const版本的<code>push_back</code>和<code>pop_back</code>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p> [1]:  <a href=\"https://www.douban.com/group/topic/61573279/\">豆瓣 - 大家来讨论一下 exercise 12.3</a><br> [2]:  <a href=\"https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi\">Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?</a></p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":3612,"excerpt":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>StrBlob需要const版本的<code>push_back</code>和<code>pop_back</code>吗？如果需要，添加进去。否则，解释为什么不需要。</p>","more":"<h2 id=\"定义StrBlob类\"><a href=\"#定义StrBlob类\" class=\"headerlink\" title=\"定义StrBlob类\"></a>定义StrBlob类</h2><p>首先，定义<strong>StrBlob</strong>类。类的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></span><br><span class=\"line\"><span class=\"comment\">/* 编写你自己的StrBlob类，包含const版本的front和back */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;initializer_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlob</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> size_type = <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;::size_type;</span><br><span class=\"line\">    StrBlob() : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</span><br><span class=\"line\">    StrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">string</span>&gt; il)</span><br><span class=\"line\">        : data(<span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> cosnt </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加和删除元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       data-&gt;pop_back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 元素访问</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果vector为空，check会抛出一个异常</span></span><br><span class=\"line\">       check(<span class=\"number\">0</span>, <span class=\"string\">&quot;front on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">front</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;front on empty StrBlob&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        check(<span class=\"number\">0</span>, <span class=\"string\">&quot;back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= data-&gt;size())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; data;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"非const-StrBlob对象\"><a href=\"#非const-StrBlob对象\" class=\"headerlink\" title=\"非const StrBlob对象\"></a>非const StrBlob对象</h3><p>根据<strong>StrBlob</strong>的定义，我们来测试一下：<br>首先声明一个<strong>StrBlob</strong>对象<strong>b1</strong>：</p>\n<pre><code>StrBlob b1 = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;        // 非const对象</code></pre>\n<p>然后分别对<strong>b1</strong>调用<code>push_back()</code>和<code>pop_back()</code>：</p>\n<pre><code>b1.push_back(&quot;test&quot;);       // 向b1添加元素test</code></pre>\n<p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>, <strong>test</strong>;<br>接着就是</p>\n<pre><code> b1.pop_back();         // 删除刚刚添加的元素</code></pre>\n<p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>;<br>可以看到，我们定义的非const的<strong>StrBlob</strong>对象进行<code>push_back()</code>和<code>pop_back()</code>操作是没有问题的。</p>\n<h3 id=\"const-StrBlob对象\"><a href=\"#const-StrBlob对象\" class=\"headerlink\" title=\"const StrBlob对象\"></a>const StrBlob对象</h3><p>上面的操作都很顺利，那么当我们声明一个const <strong>StrBlob</strong>对象会怎么样呢？<br>接下来，我们声明一个const类型的<strong>StrBlob</strong>对象：</p>\n<pre><code>const StrBlob cb = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;       // const 对象</code></pre>\n<p>同样的，我们对<strong>cb</strong>调用<code>push_back()</code>和<code>pop_back()</code>，看看会发生什么：</p>\n<pre><code>cb.push_back(&quot;test&quot;);       // 向cb添加元素test</code></pre>\n<p>运行一下程序，就会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<pre><code>cb.pop_back();           // 删除元素</code></pre>\n<p>在运行程序，同样也会报错：</p>\n<blockquote>\n<p><em>Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>\n</blockquote>\n<p>原因是我们在定义<strong>StrBlob</strong>类时，<code>push_back()</code>和<code>pop_back()</code>并没有添const版本。<br>那么，自然而然地，我们将添加const版本的<code>push_back()</code>和<code>pop_back()</code>，在StrBlob.h中添加以下代码:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* StrBlob.h */</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">    data-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加const类型的push_back()和pop_back()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> <span class=\"keyword\">const</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    data-&gt;push_back(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    check(<span class=\"number\">0</span>, <span class=\"string\">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class=\"line\">    data-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再运行一下程序，通过了，并且输出和之前非const版本的一样。</p>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？</p>\n<p>如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的<code>push_back()</code>和<code>pop_back()</code>是必须的。但是要注意的是：</p>\n<p><strong>我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向<code>vector&lt;string&gt;</code>的智能指针；但由于类的封装，在使用者看来，数据成员是<code>vector&lt;string&gt;</code>，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是<code>vector&lt;string&gt;</code>的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像<code>push_back()</code>和<code>pop_back()</code>这样会改变智能指针所指向的<code>vector&lt;string&gt;</code>内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用<code>push_back()</code>和<code>pop_back()</code>成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。</strong></p>\n<p>通过以上的考虑，我认为<strong>StrBlob</strong>不需要const版本的<code>push_back</code>和<code>pop_back</code>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p> [1]:  <a href=\"https://www.douban.com/group/topic/61573279/\">豆瓣 - 大家来讨论一下 exercise 12.3</a><br> [2]:  <a href=\"https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi\">Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?</a></p>\n<p>End~</p>\n<hr>"},{"title":"C++ string输入问题","date":"2017-03-31T06:38:28.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\n## 问题描述\n\n> 使用cin读入一组字符串并存入一个vector对象\n\n<!--more-->\n\n## 代码实现\n使用如下代码\n```c++\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n/*用cin读入一组字符串并把它们存入一个vector对象*/\nint main()\n{\n\tvector<string> text;\n\tstring word;\n\twhile (getline(cin, word))\n\t{\n\t\ttext.push_back(word);\n\t}\n\tcout << \"[\";\n\tfor (auto i : text)\n\t\tif (i == text.back())\n\t\t\tcout << i;\n\t\telse\n\t\t\tcout << i << \",\";\n\tcout << \"]\";\n\n\treturn 0;\n}\n```\n\n在运行测试时发现了一个问题：\n当输入为\n\n> aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)\n\n按回车后发现输出卡出了，并不会输出所输入的字符串\n\n当输入为\n> aa ss dd qq ww ee\n^Z(换行后的^Z)\n\n就可以正确输出了\n\n## 解决办法\n百思不得其解，遂百度之。\n看到了两种解释，感觉都有道理，就都贴上来好了\n1.\n\n> 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin>>调用立即返回，cin状态为eof，while退出。\n\n2.\n\n> windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。\n\n意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。\n","source":"_posts/C-string输入问题.md","raw":"---\ntitle: C++ string输入问题\ndate: 2017-03-31 14:38:28\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags:\n- C++\n- String\n- vector\ncomments: true\n---\n\n## 问题描述\n\n> 使用cin读入一组字符串并存入一个vector对象\n\n<!--more-->\n\n## 代码实现\n使用如下代码\n```c++\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n/*用cin读入一组字符串并把它们存入一个vector对象*/\nint main()\n{\n\tvector<string> text;\n\tstring word;\n\twhile (getline(cin, word))\n\t{\n\t\ttext.push_back(word);\n\t}\n\tcout << \"[\";\n\tfor (auto i : text)\n\t\tif (i == text.back())\n\t\t\tcout << i;\n\t\telse\n\t\t\tcout << i << \",\";\n\tcout << \"]\";\n\n\treturn 0;\n}\n```\n\n在运行测试时发现了一个问题：\n当输入为\n\n> aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)\n\n按回车后发现输出卡出了，并不会输出所输入的字符串\n\n当输入为\n> aa ss dd qq ww ee\n^Z(换行后的^Z)\n\n就可以正确输出了\n\n## 解决办法\n百思不得其解，遂百度之。\n看到了两种解释，感觉都有道理，就都贴上来好了\n1.\n\n> 因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin>>调用立即返回，cin状态为eof，while退出。\n\n2.\n\n> windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。\n\n意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。\n","slug":"C-string输入问题","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsid0007w8vo3p4vhlvh","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><blockquote>\n<p>使用cin读入一组字符串并存入一个vector对象</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>使用如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*用cin读入一组字符串并把它们存入一个vector对象*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; text;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (getline(<span class=\"built_in\">cin</span>, word))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttext.push_back(word);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : text)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == text.back())</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在运行测试时发现了一个问题：<br>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)</p>\n</blockquote>\n<p>按回车后发现输出卡出了，并不会输出所输入的字符串</p>\n<p>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee<br>^Z(换行后的^Z)</p>\n</blockquote>\n<p>就可以正确输出了</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>百思不得其解，遂百度之。<br>看到了两种解释，感觉都有道理，就都贴上来好了<br>1.</p>\n<blockquote>\n<p>因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。</p>\n</blockquote>\n<p>2.</p>\n<blockquote>\n<p>windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。</p>\n</blockquote>\n<p>意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。</p>\n","site":{"data":{}},"length":927,"excerpt":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><blockquote>\n<p>使用cin读入一组字符串并存入一个vector对象</p>\n</blockquote>","more":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>使用如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*用cin读入一组字符串并把它们存入一个vector对象*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; text;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> word;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (getline(<span class=\"built_in\">cin</span>, word))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttext.push_back(word);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : text)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == text.back())</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在运行测试时发现了一个问题：<br>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)</p>\n</blockquote>\n<p>按回车后发现输出卡出了，并不会输出所输入的字符串</p>\n<p>当输入为</p>\n<blockquote>\n<p>aa ss dd qq ww ee<br>^Z(换行后的^Z)</p>\n</blockquote>\n<p>就可以正确输出了</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>百思不得其解，遂百度之。<br>看到了两种解释，感觉都有道理，就都贴上来好了<br>1.</p>\n<blockquote>\n<p>因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。</p>\n</blockquote>\n<p>2.</p>\n<blockquote>\n<p>windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。</p>\n</blockquote>\n<p>意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。</p>"},{"title":"C++中的explicit关键字","date":"2017-06-15T08:19:33.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\n## 隐式的类类型转换\n\n在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：\n> 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作**转换构造函数(converting constructor)**\n\n<!--more-->\n也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。\n\n## 转换示例\n\n下面就给出一个例子，一个类的构造函数可以被用于隐式转换：\n\n```c++\nclass Foo {\npublic:\n\t// 单形参构造函数，可以用作隐式转换\n\tFoo(int foo) : m_foo(foo) {}\n\n\tint getFoo() { return m_foo; }\n\nprivate:\n\tint m_foo;\n};\n\n// 定义一个函数，接受Foo类型的形参\nvoid Bar(Foo foo)\n{\n\tint i = foo.getFoo();\n}\n\n// 主函数\nint main()\n{\n\tBar(42);\n\n\treturn 0;\n}\n```\n可以看到在`main`函数中，传入`Bar`的并不是一个`Foo`的对象，而是内置类型`int`，但类`Foo`的构造函数接受一个`int`，因此这个构造函数可以用来将参数转换成正确的类型。\n\n## 使用explicit抑制构造函数定义的隐式转换\n\n为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个**explicit**关键字：\n\n```c++\nexplicit Foo(int foo) : m_foo(foo) {}\n```\n\n这样就可以有效防止隐式转换。之前在`main`函数中`Bar(42)`就会报错：\n> void Bar(Foo): 无法将参数1从\"int\"转换为\"Foo\"\n\n进行如下修改，对传入的`int`进行显式转换\n```c++\nBar(Foo(42))\n```\n这样就不会报错了。使用**explicit**关键字的原因是为了防止预想之外的情况发生。\n下面举个例子（感觉不太合适）：\n> 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&)，然后调用print(3)。我们期望它能输出\"3\"，但是它实际上输出的是一个长度为3的空string。\n\n## 结论\n\n关于**explicit**的结论：\n\n - 关键字**explicit**只对一个实参的构造函数有效\n - 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为**explicit**的\n - 只能在类内声明构造函数时使用**explicit**关键字，在类外部定义式不应重复\n\n当我们用**explicit**关键字声明构造函数时，它将只能以直接初始化的形式(例如`string s(\"Hello\")`)使用。而且编译器将不会在自动转换过程中使用改构造函数。\n\n如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为**explicit**的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。\n\n## 参考资料\n\n[1]: [Stack OverFlow - What does the explicit keyword mean?](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163)\n\n\nEnd~\n\n---","source":"_posts/C-中的explicit关键字.md","raw":"---\ntitle: C++中的explicit关键字\ndate: 2017-06-15 16:19:33\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: C++\ncomments: true\n---\n\n## 隐式的类类型转换\n\n在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：\n> 如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作**转换构造函数(converting constructor)**\n\n<!--more-->\n也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。\n\n## 转换示例\n\n下面就给出一个例子，一个类的构造函数可以被用于隐式转换：\n\n```c++\nclass Foo {\npublic:\n\t// 单形参构造函数，可以用作隐式转换\n\tFoo(int foo) : m_foo(foo) {}\n\n\tint getFoo() { return m_foo; }\n\nprivate:\n\tint m_foo;\n};\n\n// 定义一个函数，接受Foo类型的形参\nvoid Bar(Foo foo)\n{\n\tint i = foo.getFoo();\n}\n\n// 主函数\nint main()\n{\n\tBar(42);\n\n\treturn 0;\n}\n```\n可以看到在`main`函数中，传入`Bar`的并不是一个`Foo`的对象，而是内置类型`int`，但类`Foo`的构造函数接受一个`int`，因此这个构造函数可以用来将参数转换成正确的类型。\n\n## 使用explicit抑制构造函数定义的隐式转换\n\n为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个**explicit**关键字：\n\n```c++\nexplicit Foo(int foo) : m_foo(foo) {}\n```\n\n这样就可以有效防止隐式转换。之前在`main`函数中`Bar(42)`就会报错：\n> void Bar(Foo): 无法将参数1从\"int\"转换为\"Foo\"\n\n进行如下修改，对传入的`int`进行显式转换\n```c++\nBar(Foo(42))\n```\n这样就不会报错了。使用**explicit**关键字的原因是为了防止预想之外的情况发生。\n下面举个例子（感觉不太合适）：\n> 假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&)，然后调用print(3)。我们期望它能输出\"3\"，但是它实际上输出的是一个长度为3的空string。\n\n## 结论\n\n关于**explicit**的结论：\n\n - 关键字**explicit**只对一个实参的构造函数有效\n - 需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为**explicit**的\n - 只能在类内声明构造函数时使用**explicit**关键字，在类外部定义式不应重复\n\n当我们用**explicit**关键字声明构造函数时，它将只能以直接初始化的形式(例如`string s(\"Hello\")`)使用。而且编译器将不会在自动转换过程中使用改构造函数。\n\n如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为**explicit**的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。\n\n## 参考资料\n\n[1]: [Stack OverFlow - What does the explicit keyword mean?](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163)\n\n\nEnd~\n\n---","slug":"C-中的explicit关键字","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsie0009w8vo1iizcjlu","content":"<h2 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p>\n<blockquote>\n<p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p>\n<h2 id=\"转换示例\"><a href=\"#转换示例\" class=\"headerlink\" title=\"转换示例\"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 单形参构造函数，可以用作隐式转换</span></span><br><span class=\"line\">\tFoo(<span class=\"keyword\">int</span> foo) : m_foo(foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_foo; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_foo;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个函数，接受Foo类型的形参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">(Foo foo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = foo.getFoo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBar(<span class=\"number\">42</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p>\n<h2 id=\"使用explicit抑制构造函数定义的隐式转换\"><a href=\"#使用explicit抑制构造函数定义的隐式转换\" class=\"headerlink\" title=\"使用explicit抑制构造函数定义的隐式转换\"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Foo</span><span class=\"params\">(<span class=\"keyword\">int</span> foo)</span> : <span class=\"title\">m_foo</span><span class=\"params\">(foo)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p>\n<blockquote>\n<p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p>\n</blockquote>\n<p>进行如下修改，对传入的<code>int</code>进行显式转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bar(Foo(<span class=\"number\">42</span>))</span><br></pre></td></tr></table></figure>\n<p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p>\n<blockquote>\n<p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p>\n</blockquote>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p>\n<ul>\n<li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li>\n<li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li>\n<li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li>\n</ul>\n<p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p>\n<p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163\">Stack OverFlow - What does the explicit keyword mean?</a></p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1323,"excerpt":"<h2 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p>\n<blockquote>\n<p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p>\n</blockquote>","more":"<p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p>\n<h2 id=\"转换示例\"><a href=\"#转换示例\" class=\"headerlink\" title=\"转换示例\"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 单形参构造函数，可以用作隐式转换</span></span><br><span class=\"line\">\tFoo(<span class=\"keyword\">int</span> foo) : m_foo(foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_foo; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_foo;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个函数，接受Foo类型的形参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">(Foo foo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = foo.getFoo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBar(<span class=\"number\">42</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p>\n<h2 id=\"使用explicit抑制构造函数定义的隐式转换\"><a href=\"#使用explicit抑制构造函数定义的隐式转换\" class=\"headerlink\" title=\"使用explicit抑制构造函数定义的隐式转换\"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Foo</span><span class=\"params\">(<span class=\"keyword\">int</span> foo)</span> : <span class=\"title\">m_foo</span><span class=\"params\">(foo)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p>\n<blockquote>\n<p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p>\n</blockquote>\n<p>进行如下修改，对传入的<code>int</code>进行显式转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bar(Foo(<span class=\"number\">42</span>))</span><br></pre></td></tr></table></figure>\n<p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p>\n<blockquote>\n<p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p>\n</blockquote>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p>\n<ul>\n<li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li>\n<li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li>\n<li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li>\n</ul>\n<p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p>\n<p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163\">Stack OverFlow - What does the explicit keyword mean?</a></p>\n<p>End~</p>\n<hr>"},{"title":"C++递增(递减)运算符","date":"2017-04-07T10:31:16.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\n在做C++ primer 第五版课后习题4.31时遇到一个问题：\n> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。\n\n<!--more-->\n\n源程序代码如下：\n```c++\nvector<int>::size_type cnt = ivec.size();\n// 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0;\n                    ix != ivec.size(); ++ix, --cnt)\n    ivec[ix] = cnt;\n```\n可以看到源程序用的是前置递增和递减运算符\n我根据源代码写了一下可运行的版本：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ++ix, --cnt)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n然后根据题目的意思，使用了后置版本的递增和递减运算符：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ix++, cnt--)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n结果一样啊喂！(＃°Д°)\n哪里需要修改了(╯‵□′)╯︵┻━┻\n各种百度没有没百度到，突然想起来可以找课后练习答案啊！\n找到了结果，还以为我错了，没想到答案居然是...\n\n> We use prefix and not postfix, just because of the **Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary**.\nSo, it's just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: \n```c++\nfor(vector<int>::size_type ix = 0; ix != ivec.size(); ix++, cnt--)  \n    ivec[ix] = cnt; \n```\n> This is not an appropriate example to discuss the difference of prefix and postfix.\n\n果然不是我的问题 ( •̀ ω •́ )\n\n","source":"_posts/C-前置递增（递减）和后置递增（递减）运算符.md","raw":"---\ntitle: C++递增(递减)运算符\ndate: 2017-04-07 18:31:16\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: C++\ncomments: true\n\n---\n\n在做C++ primer 第五版课后习题4.31时遇到一个问题：\n> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。\n\n<!--more-->\n\n源程序代码如下：\n```c++\nvector<int>::size_type cnt = ivec.size();\n// 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0;\n                    ix != ivec.size(); ++ix, --cnt)\n    ivec[ix] = cnt;\n```\n可以看到源程序用的是前置递增和递减运算符\n我根据源代码写了一下可运行的版本：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ++ix, --cnt)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n然后根据题目的意思，使用了后置版本的递增和递减运算符：\n```c++\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tvector<int> ivec(10, 0);        // 初始化ivec\n\tvector<int>::size_type cnt = ivec.size();\n\tfor (vector<int>::size_type ix = 0; \n\t                    ix != ivec.size(); ix++, cnt--)\n\t\tivec[ix] = cnt;\n\tfor (auto x : ivec)\n\t\tcout << x << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出的结果为\n> 10 9 8 7 6 5 4 3 2 1\n\n结果一样啊喂！(＃°Д°)\n哪里需要修改了(╯‵□′)╯︵┻━┻\n各种百度没有没百度到，突然想起来可以找课后练习答案啊！\n找到了结果，还以为我错了，没想到答案居然是...\n\n> We use prefix and not postfix, just because of the **Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary**.\nSo, it's just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: \n```c++\nfor(vector<int>::size_type ix = 0; ix != ivec.size(); ix++, cnt--)  \n    ivec[ix] = cnt; \n```\n> This is not an appropriate example to discuss the difference of prefix and postfix.\n\n果然不是我的问题 ( •̀ ω •́ )\n\n","slug":"C-前置递增（递减）和后置递增（递减）运算符","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsif000bw8vofmyq8av1","content":"<p>在做C++ primer 第五版课后习题4.31时遇到一个问题：</p>\n<blockquote>\n<p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>源程序代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\"><span class=\"comment\">// 将把从size到1的值赋给ivec的元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    ix != ivec.size(); ++ix, --cnt)</span><br><span class=\"line\">    ivec[ix] = cnt;</span><br></pre></td></tr></table></figure>\n<p>可以看到源程序用的是前置递增和递减运算符<br>我根据源代码写了一下可运行的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ivec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">0</span>)</span></span>;        <span class=\"comment\">// 初始化ivec</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t                    ix != ivec.size(); ++ix, --cnt)</span><br><span class=\"line\">\t\tivec[ix] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>然后根据题目的意思，使用了后置版本的递增和递减运算符：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ivec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">0</span>)</span></span>;        <span class=\"comment\">// 初始化ivec</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t                    ix != ivec.size(); ix++, cnt--)</span><br><span class=\"line\">\t\tivec[ix] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>结果一样啊喂！(＃°Д°)<br>哪里需要修改了(╯‵□′)╯︵┻━┻<br>各种百度没有没百度到，突然想起来可以找课后练习答案啊！<br>找到了结果，还以为我错了，没想到答案居然是…</p>\n<blockquote>\n<p>We use prefix and not postfix, just because of the <strong>Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary</strong>.<br>So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: </p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; ix != ivec.size(); ix++, cnt--)  </span><br><span class=\"line\">    ivec[ix] = cnt; </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>This is not an appropriate example to discuss the difference of prefix and postfix.</p>\n</blockquote>\n<p>果然不是我的问题 ( •̀ ω •́ )</p>\n","site":{"data":{}},"length":1490,"excerpt":"<p>在做C++ primer 第五版课后习题4.31时遇到一个问题：</p>\n<blockquote>\n<p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。</p>\n</blockquote>","more":"<p>源程序代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\"><span class=\"comment\">// 将把从size到1的值赋给ivec的元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    ix != ivec.size(); ++ix, --cnt)</span><br><span class=\"line\">    ivec[ix] = cnt;</span><br></pre></td></tr></table></figure>\n<p>可以看到源程序用的是前置递增和递减运算符<br>我根据源代码写了一下可运行的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ivec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">0</span>)</span></span>;        <span class=\"comment\">// 初始化ivec</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t                    ix != ivec.size(); ++ix, --cnt)</span><br><span class=\"line\">\t\tivec[ix] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>然后根据题目的意思，使用了后置版本的递增和递减运算符：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ivec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">0</span>)</span></span>;        <span class=\"comment\">// 初始化ivec</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type cnt = ivec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t                    ix != ivec.size(); ix++, cnt--)</span><br><span class=\"line\">\t\tivec[ix] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : ivec)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果为</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2 1</p>\n</blockquote>\n<p>结果一样啊喂！(＃°Д°)<br>哪里需要修改了(╯‵□′)╯︵┻━┻<br>各种百度没有没百度到，突然想起来可以找课后练习答案啊！<br>找到了结果，还以为我错了，没想到答案居然是…</p>\n<blockquote>\n<p>We use prefix and not postfix, just because of the <strong>Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary</strong>.<br>So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite: </p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type ix = <span class=\"number\">0</span>; ix != ivec.size(); ix++, cnt--)  </span><br><span class=\"line\">    ivec[ix] = cnt; </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>This is not an appropriate example to discuss the difference of prefix and postfix.</p>\n</blockquote>\n<p>果然不是我的问题 ( •̀ ω •́ )</p>"},{"title":"使用 Travis CI 实现 Hexo 博客自动构建和部署","date":"2019-01-16T05:54:52.000Z","updated":"2019-01-17T14:38:14.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-01-16.jpg","_content":"\n![Travis CI](/images/imagesource/19-01-16/TravisCI-Full-Color.png)\n\n昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：\n\n1. 每次博客更新都要自己手动 `hexo d -g`，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。\n2. 考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。\n\n因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。\n\n<!--more-->\n\n## Hexo 博客源代码 GitHub 托管\n\nHexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 `source` 分支，用于存放源文件。\n\n![github branches](/images/imagesource/19-01-16/2019-01-16-1.png)\n\n具体操作如下：\n\n### 添加分支\n\n在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。\n\n### 将仓库克隆至本地\n\n在本地使用 `git clone 你的仓库地址` 将仓库克隆至本地，然后使用 `git checkout source` 命令，切换到新创建的分支。\n\n### 在新分支中添加博客源文件\n\n删除该分支下除了 `.git` 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：\n\n![source file](/images/imagesource/19-01-16/2019-01-16-2.png)\n\n然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。\n\n## 使用 Travis CI 自动部署\n\n### Travis CI 简介\n\nTravis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。\n\n### 配置 Travis CI\n\n#### 网页端配置\n\n首先进入 [Travis CI 官网](https://travis-ci.org/)，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 [付费版的 Travis CI](https://travis-ci.com/)。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 `feilongjiang.github.io`，把旁边的勾勾上，然后点击旁边的 `Settings` 进入设置页面。\n\n![Travis enable](/images/imagesource/19-01-16/2019-01-16-3.png)\n\n在设置页面中，General 中只勾选 `Build pushed branches`，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。\n\n![Travis settings](/images/imagesource/19-01-16/2019-01-16-4.png)\n\n接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 [Personal access tokens](https://github.com/settings/tokens) 页面，点击 `Generate new token`，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。\n\n![generate token](/images/imagesource/19-01-16/2019-01-16-5.png)\n\n接着在原来 Travis 的设置界面添加 token。如图所示：\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-6.png)\n\n在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。\n\n#### Travis 配置文件\n\n接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 `.travis.yml`，是自动化构建的配置文件。文件内容示例如下：\n\n```yml\nlanguage: node_js\nsudo: required\nnode_js:\n  - 7.9.0\n\n# 指定缓存模块，可加快编译速度\ncache:\n  directories:\n    - node_modules\n\n# 指定博客源码分支，这里填入博客源码的分支名\nbranches:\n  only:\n    - source\n\nbefore_install:\n  - export TZ='Asia/Shanghai' # 更改时区\n  - npm install -g hexo-cli\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n  - npm install hexo-deployer-git --save\n\nbefore_script:\n # - npm install -g gulp\n\nscript:\n  - hexo clean\n  - hexo generate\n\n# 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署\nafter_script:\n  - git config user.name \"FreedomLy\"\n  - git config user.email \"Freedom.JFL@gmail.com\"\n  - git clone https://github.com/feilongjiang/feilongjiang.github.io.git .deploy_git # 解决 commit 清空问题\n  - cd .deploy_git\n  - git checkout master\n  - cd ../\n  # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！\n  - sed -i \"s/gh_token/${GH_TOKEN}/g\" ./_config.yml # 这里的 GH_TOKEN 名字要和网页中定义的别名一致\n  - cat ./_config.yml\n  - hexo deploy\n# E: Build LifeCycle\n```\n\n同时修改 Hexo 的 `_confi.yml` 文件中的 deploy 模块，将原来的\n\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:feilongjiang/feilongjiang.github.io.git\n  branch: master\n```\n\n修改为\n\n```yml\ndeploy:\n  type: git\n  repo: https://gh_token@github.com/feilongjiang/feilongjiang.github.io.git\n  branch: master\n```\n\n这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 `.travis.yml` 中的 branches 中填入的是存放博客源码的分支，而 `_config.yml` 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。\n\n然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-7.png)\n\n自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 `.md` 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。\n\n## 参考资料\n\n[1]: [Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程](https://blog.csdn.net/Xiong_IT/article/details/78675874)\n[2]: [使用Travis CI自动部署Hexo博客](https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/)\n[3]: [使用Travis Ci使hexo自动生成并部署](https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/)\n[4]: [解决 Travis CI 总是更新旧博客的问题](https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/)","source":"_posts/Hexo-Travis-CI-auto-deploy.md","raw":"---\ntitle: 使用 Travis CI 实现 Hexo 博客自动构建和部署\ndate: 2019-01-16 13:54:52\nupdated: 2019-01-17 22:38:14\ncategory: Tech\ntags: [Travis-CI, Hexo]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-01-16.jpg\n---\n\n![Travis CI](/images/imagesource/19-01-16/TravisCI-Full-Color.png)\n\n昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：\n\n1. 每次博客更新都要自己手动 `hexo d -g`，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。\n2. 考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。\n\n因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。\n\n<!--more-->\n\n## Hexo 博客源代码 GitHub 托管\n\nHexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 `source` 分支，用于存放源文件。\n\n![github branches](/images/imagesource/19-01-16/2019-01-16-1.png)\n\n具体操作如下：\n\n### 添加分支\n\n在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。\n\n### 将仓库克隆至本地\n\n在本地使用 `git clone 你的仓库地址` 将仓库克隆至本地，然后使用 `git checkout source` 命令，切换到新创建的分支。\n\n### 在新分支中添加博客源文件\n\n删除该分支下除了 `.git` 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：\n\n![source file](/images/imagesource/19-01-16/2019-01-16-2.png)\n\n然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。\n\n## 使用 Travis CI 自动部署\n\n### Travis CI 简介\n\nTravis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。\n\n### 配置 Travis CI\n\n#### 网页端配置\n\n首先进入 [Travis CI 官网](https://travis-ci.org/)，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 [付费版的 Travis CI](https://travis-ci.com/)。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 `feilongjiang.github.io`，把旁边的勾勾上，然后点击旁边的 `Settings` 进入设置页面。\n\n![Travis enable](/images/imagesource/19-01-16/2019-01-16-3.png)\n\n在设置页面中，General 中只勾选 `Build pushed branches`，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。\n\n![Travis settings](/images/imagesource/19-01-16/2019-01-16-4.png)\n\n接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 [Personal access tokens](https://github.com/settings/tokens) 页面，点击 `Generate new token`，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。\n\n![generate token](/images/imagesource/19-01-16/2019-01-16-5.png)\n\n接着在原来 Travis 的设置界面添加 token。如图所示：\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-6.png)\n\n在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。\n\n#### Travis 配置文件\n\n接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 `.travis.yml`，是自动化构建的配置文件。文件内容示例如下：\n\n```yml\nlanguage: node_js\nsudo: required\nnode_js:\n  - 7.9.0\n\n# 指定缓存模块，可加快编译速度\ncache:\n  directories:\n    - node_modules\n\n# 指定博客源码分支，这里填入博客源码的分支名\nbranches:\n  only:\n    - source\n\nbefore_install:\n  - export TZ='Asia/Shanghai' # 更改时区\n  - npm install -g hexo-cli\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n  - npm install hexo-deployer-git --save\n\nbefore_script:\n # - npm install -g gulp\n\nscript:\n  - hexo clean\n  - hexo generate\n\n# 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署\nafter_script:\n  - git config user.name \"FreedomLy\"\n  - git config user.email \"Freedom.JFL@gmail.com\"\n  - git clone https://github.com/feilongjiang/feilongjiang.github.io.git .deploy_git # 解决 commit 清空问题\n  - cd .deploy_git\n  - git checkout master\n  - cd ../\n  # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！\n  - sed -i \"s/gh_token/${GH_TOKEN}/g\" ./_config.yml # 这里的 GH_TOKEN 名字要和网页中定义的别名一致\n  - cat ./_config.yml\n  - hexo deploy\n# E: Build LifeCycle\n```\n\n同时修改 Hexo 的 `_confi.yml` 文件中的 deploy 模块，将原来的\n\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:feilongjiang/feilongjiang.github.io.git\n  branch: master\n```\n\n修改为\n\n```yml\ndeploy:\n  type: git\n  repo: https://gh_token@github.com/feilongjiang/feilongjiang.github.io.git\n  branch: master\n```\n\n这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 `.travis.yml` 中的 branches 中填入的是存放博客源码的分支，而 `_config.yml` 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。\n\n然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。\n\n![Travis token](/images/imagesource/19-01-16/2019-01-16-7.png)\n\n自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 `.md` 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。\n\n## 参考资料\n\n[1]: [Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程](https://blog.csdn.net/Xiong_IT/article/details/78675874)\n[2]: [使用Travis CI自动部署Hexo博客](https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/)\n[3]: [使用Travis Ci使hexo自动生成并部署](https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/)\n[4]: [解决 Travis CI 总是更新旧博客的问题](https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/)","slug":"Hexo-Travis-CI-auto-deploy","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsii000fw8vo77c971em","content":"<p><img data-src=\"/images/imagesource/19-01-16/TravisCI-Full-Color.png\" alt=\"Travis CI\"></p>\n<p>昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：</p>\n<ol>\n<li>每次博客更新都要自己手动 <code>hexo d -g</code>，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。</li>\n<li>考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。</li>\n</ol>\n<p>因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Hexo-博客源代码-GitHub-托管\"><a href=\"#Hexo-博客源代码-GitHub-托管\" class=\"headerlink\" title=\"Hexo 博客源代码 GitHub 托管\"></a>Hexo 博客源代码 GitHub 托管</h2><p>Hexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 <code>source</code> 分支，用于存放源文件。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-1.png\" alt=\"github branches\"></p>\n<p>具体操作如下：</p>\n<h3 id=\"添加分支\"><a href=\"#添加分支\" class=\"headerlink\" title=\"添加分支\"></a>添加分支</h3><p>在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。</p>\n<h3 id=\"将仓库克隆至本地\"><a href=\"#将仓库克隆至本地\" class=\"headerlink\" title=\"将仓库克隆至本地\"></a>将仓库克隆至本地</h3><p>在本地使用 <code>git clone 你的仓库地址</code> 将仓库克隆至本地，然后使用 <code>git checkout source</code> 命令，切换到新创建的分支。</p>\n<h3 id=\"在新分支中添加博客源文件\"><a href=\"#在新分支中添加博客源文件\" class=\"headerlink\" title=\"在新分支中添加博客源文件\"></a>在新分支中添加博客源文件</h3><p>删除该分支下除了 <code>.git</code> 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-2.png\" alt=\"source file\"></p>\n<p>然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。</p>\n<h2 id=\"使用-Travis-CI-自动部署\"><a href=\"#使用-Travis-CI-自动部署\" class=\"headerlink\" title=\"使用 Travis CI 自动部署\"></a>使用 Travis CI 自动部署</h2><h3 id=\"Travis-CI-简介\"><a href=\"#Travis-CI-简介\" class=\"headerlink\" title=\"Travis CI 简介\"></a>Travis CI 简介</h3><p>Travis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。</p>\n<h3 id=\"配置-Travis-CI\"><a href=\"#配置-Travis-CI\" class=\"headerlink\" title=\"配置 Travis CI\"></a>配置 Travis CI</h3><h4 id=\"网页端配置\"><a href=\"#网页端配置\" class=\"headerlink\" title=\"网页端配置\"></a>网页端配置</h4><p>首先进入 <a href=\"https://travis-ci.org/\">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href=\"https://travis-ci.com/\">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 <code>feilongjiang.github.io</code>，把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-3.png\" alt=\"Travis enable\"></p>\n<p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-4.png\" alt=\"Travis settings\"></p>\n<p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href=\"https://github.com/settings/tokens\">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-5.png\" alt=\"generate token\"></p>\n<p>接着在原来 Travis 的设置界面添加 token。如图所示：</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-6.png\" alt=\"Travis token\"></p>\n<p>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p>\n<h4 id=\"Travis-配置文件\"><a href=\"#Travis-配置文件\" class=\"headerlink\" title=\"Travis 配置文件\"></a>Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"string\">required</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">7.9</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定缓存模块，可加快编译速度</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\">  <span class=\"attr\">directories:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">node_modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定博客源码分支，这里填入博客源码的分支名</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ=&#x27;Asia/Shanghai&#x27;</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">-g</span> <span class=\"string\">hexo-cli</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># S: Build Lifecycle</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"string\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">before_script:</span></span><br><span class=\"line\"> <span class=\"comment\"># - npm install -g gulp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署</span></span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">&quot;FreedomLy&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">&quot;Freedom.JFL@gmail.com&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"string\">https://github.com/feilongjiang/feilongjiang.github.io.git</span> <span class=\"string\">.deploy_git</span> <span class=\"comment\"># 解决 commit 清空问题</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\">  <span class=\"comment\"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">sed</span> <span class=\"string\">-i</span> <span class=\"string\">&quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot;</span> <span class=\"string\">./_config.yml</span> <span class=\"comment\"># 这里的 GH_TOKEN 名字要和网页中定义的别名一致</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cat</span> <span class=\"string\">./_config.yml</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"><span class=\"comment\"># E: Build LifeCycle</span></span><br></pre></td></tr></table></figure>\n\n<p>同时修改 Hexo 的 <code>_confi.yml</code> 文件中的 deploy 模块，将原来的</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:feilongjiang/feilongjiang.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gh_token@github.com/feilongjiang/feilongjiang.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 <code>.travis.yml</code> 中的 branches 中填入的是存放博客源码的分支，而 <code>_config.yml</code> 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。</p>\n<p>然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-7.png\" alt=\"Travis token\"></p>\n<p>自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 <code>.md</code> 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://blog.csdn.net/Xiong_IT/article/details/78675874\">Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程</a><br>[2]: <a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\">使用Travis CI自动部署Hexo博客</a><br>[3]: <a href=\"https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/\">使用Travis Ci使hexo自动生成并部署</a><br>[4]: <a href=\"https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/\">解决 Travis CI 总是更新旧博客的问题</a></p>\n","site":{"data":{}},"length":2906,"excerpt":"<p><img data-src=\"/images/imagesource/19-01-16/TravisCI-Full-Color.png\" alt=\"Travis CI\"></p>\n<p>昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：</p>\n<ol>\n<li>每次博客更新都要自己手动 <code>hexo d -g</code>，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。</li>\n<li>考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。</li>\n</ol>\n<p>因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。</p>","more":"<h2 id=\"Hexo-博客源代码-GitHub-托管\"><a href=\"#Hexo-博客源代码-GitHub-托管\" class=\"headerlink\" title=\"Hexo 博客源代码 GitHub 托管\"></a>Hexo 博客源代码 GitHub 托管</h2><p>Hexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 <code>source</code> 分支，用于存放源文件。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-1.png\" alt=\"github branches\"></p>\n<p>具体操作如下：</p>\n<h3 id=\"添加分支\"><a href=\"#添加分支\" class=\"headerlink\" title=\"添加分支\"></a>添加分支</h3><p>在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。</p>\n<h3 id=\"将仓库克隆至本地\"><a href=\"#将仓库克隆至本地\" class=\"headerlink\" title=\"将仓库克隆至本地\"></a>将仓库克隆至本地</h3><p>在本地使用 <code>git clone 你的仓库地址</code> 将仓库克隆至本地，然后使用 <code>git checkout source</code> 命令，切换到新创建的分支。</p>\n<h3 id=\"在新分支中添加博客源文件\"><a href=\"#在新分支中添加博客源文件\" class=\"headerlink\" title=\"在新分支中添加博客源文件\"></a>在新分支中添加博客源文件</h3><p>删除该分支下除了 <code>.git</code> 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-2.png\" alt=\"source file\"></p>\n<p>然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。</p>\n<h2 id=\"使用-Travis-CI-自动部署\"><a href=\"#使用-Travis-CI-自动部署\" class=\"headerlink\" title=\"使用 Travis CI 自动部署\"></a>使用 Travis CI 自动部署</h2><h3 id=\"Travis-CI-简介\"><a href=\"#Travis-CI-简介\" class=\"headerlink\" title=\"Travis CI 简介\"></a>Travis CI 简介</h3><p>Travis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。</p>\n<h3 id=\"配置-Travis-CI\"><a href=\"#配置-Travis-CI\" class=\"headerlink\" title=\"配置 Travis CI\"></a>配置 Travis CI</h3><h4 id=\"网页端配置\"><a href=\"#网页端配置\" class=\"headerlink\" title=\"网页端配置\"></a>网页端配置</h4><p>首先进入 <a href=\"https://travis-ci.org/\">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href=\"https://travis-ci.com/\">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 <code>feilongjiang.github.io</code>，把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-3.png\" alt=\"Travis enable\"></p>\n<p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-4.png\" alt=\"Travis settings\"></p>\n<p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href=\"https://github.com/settings/tokens\">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-5.png\" alt=\"generate token\"></p>\n<p>接着在原来 Travis 的设置界面添加 token。如图所示：</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-6.png\" alt=\"Travis token\"></p>\n<p>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p>\n<h4 id=\"Travis-配置文件\"><a href=\"#Travis-配置文件\" class=\"headerlink\" title=\"Travis 配置文件\"></a>Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"string\">required</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">7.9</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定缓存模块，可加快编译速度</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\">  <span class=\"attr\">directories:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">node_modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定博客源码分支，这里填入博客源码的分支名</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ=&#x27;Asia/Shanghai&#x27;</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">-g</span> <span class=\"string\">hexo-cli</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># S: Build Lifecycle</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"string\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">before_script:</span></span><br><span class=\"line\"> <span class=\"comment\"># - npm install -g gulp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署</span></span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">&quot;FreedomLy&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">&quot;Freedom.JFL@gmail.com&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"string\">https://github.com/feilongjiang/feilongjiang.github.io.git</span> <span class=\"string\">.deploy_git</span> <span class=\"comment\"># 解决 commit 清空问题</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\">  <span class=\"comment\"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">sed</span> <span class=\"string\">-i</span> <span class=\"string\">&quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot;</span> <span class=\"string\">./_config.yml</span> <span class=\"comment\"># 这里的 GH_TOKEN 名字要和网页中定义的别名一致</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cat</span> <span class=\"string\">./_config.yml</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"><span class=\"comment\"># E: Build LifeCycle</span></span><br></pre></td></tr></table></figure>\n\n<p>同时修改 Hexo 的 <code>_confi.yml</code> 文件中的 deploy 模块，将原来的</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:feilongjiang/feilongjiang.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>修改为</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gh_token@github.com/feilongjiang/feilongjiang.github.io.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 <code>.travis.yml</code> 中的 branches 中填入的是存放博客源码的分支，而 <code>_config.yml</code> 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。</p>\n<p>然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。</p>\n<p><img data-src=\"/images/imagesource/19-01-16/2019-01-16-7.png\" alt=\"Travis token\"></p>\n<p>自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 <code>.md</code> 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://blog.csdn.net/Xiong_IT/article/details/78675874\">Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程</a><br>[2]: <a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\">使用Travis CI自动部署Hexo博客</a><br>[3]: <a href=\"https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/\">使用Travis Ci使hexo自动生成并部署</a><br>[4]: <a href=\"https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/\">解决 Travis CI 总是更新旧博客的问题</a></p>"},{"title":"LeetCode 19. Remove Nth Node From End of List","date":"2018-01-09T10:46:44.000Z","updated":"2018-01-09T10:55:04.000Z","comments":1,"_content":"\n## Problem\n\nGive a linked list, remove the $n^{th}$ node from the end of list and return its head.\n\n<!--more-->\n\n### Example\n\n> Given linked list: **1->2->3->4->5**, and **n = 2**\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.\n\n### Note\n\nGiven *n* will always be valid.\nTry do this in one pass.\n\n## Answer\n\n### 单链表结构定义\n\n```c++\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n```\n\n### 普通方法(遍历两次链表)\n\n先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：\n\n```c++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        int cnt = 0;\n        ListNode *p1 = head, *p2 = head;\n\n        while (p1)\n        {\n            ++cnt;\n            p1 = p1->next;\n        }\n\n        int j = 0;\n        if (cnt == n) return head->next;\n        while (j < cnt - n - 1)\n        {\n            j++;\n            p2 = p2->next;\n        }\n        auto tmp = p2->next;\n        p2->next = p2->next->next;\n        delete tmp;\n        return head;\n    }\n};\n```\n\n### New Meta(使用二级指针，遍历一次链表)\n\n```c++\nclass Solution{\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        // 利用二级指针删除元素\n        ListNode **t1 = &head, *t2 = head;\n\n        // 将t2向后移动n位，此时t2的位置在len(head) - n\n        for (int i = 1; i < n; ++i)\n            t2 = t2->next;\n        // 当t2的下一个节点不为空时，开始移动t1\n        while (t2->next)\n        {\n            // t1指向下一个元素指针的地址\n            t1 = &((*t1)->next);\n            t2 = t2->next;\n        }\n        // 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址\n        // 因此我们需要删除该元素,并使t1指向下一个元素指针的地址\n        auto tmp = *t1;\n        *t1 = (*t1)->next;\n\n        delete tmp;\n        return head;\n    }\n};\n```\n\n使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。","source":"_posts/LeetCode-19-Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: LeetCode 19. Remove Nth Node From End of List\ndate: 2018-01-09 18:46:44\nupdated: 2018-01-09 18:55:04\ncategory: LeetCode\ntags: LeetCode\ncomments: true\n---\n\n## Problem\n\nGive a linked list, remove the $n^{th}$ node from the end of list and return its head.\n\n<!--more-->\n\n### Example\n\n> Given linked list: **1->2->3->4->5**, and **n = 2**\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.\n\n### Note\n\nGiven *n* will always be valid.\nTry do this in one pass.\n\n## Answer\n\n### 单链表结构定义\n\n```c++\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n```\n\n### 普通方法(遍历两次链表)\n\n先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：\n\n```c++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        int cnt = 0;\n        ListNode *p1 = head, *p2 = head;\n\n        while (p1)\n        {\n            ++cnt;\n            p1 = p1->next;\n        }\n\n        int j = 0;\n        if (cnt == n) return head->next;\n        while (j < cnt - n - 1)\n        {\n            j++;\n            p2 = p2->next;\n        }\n        auto tmp = p2->next;\n        p2->next = p2->next->next;\n        delete tmp;\n        return head;\n    }\n};\n```\n\n### New Meta(使用二级指针，遍历一次链表)\n\n```c++\nclass Solution{\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n)\n    {\n        // 利用二级指针删除元素\n        ListNode **t1 = &head, *t2 = head;\n\n        // 将t2向后移动n位，此时t2的位置在len(head) - n\n        for (int i = 1; i < n; ++i)\n            t2 = t2->next;\n        // 当t2的下一个节点不为空时，开始移动t1\n        while (t2->next)\n        {\n            // t1指向下一个元素指针的地址\n            t1 = &((*t1)->next);\n            t2 = t2->next;\n        }\n        // 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址\n        // 因此我们需要删除该元素,并使t1指向下一个元素指针的地址\n        auto tmp = *t1;\n        *t1 = (*t1)->next;\n\n        delete tmp;\n        return head;\n    }\n};\n```\n\n使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。","slug":"LeetCode-19-Remove-Nth-Node-From-End-of-List","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsij000gw8vobxu26svw","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Give a linked list, remove the $n^{th}$ node from the end of list and return its head.</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><blockquote>\n<p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong>n = 2</strong><br>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><p>Given <em>n</em> will always be valid.<br>Try do this in one pass.</p>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><h3 id=\"单链表结构定义\"><a href=\"#单链表结构定义\" class=\"headerlink\" title=\"单链表结构定义\"></a>单链表结构定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"普通方法-遍历两次链表\"><a href=\"#普通方法-遍历两次链表\" class=\"headerlink\" title=\"普通方法(遍历两次链表)\"></a>普通方法(遍历两次链表)</h3><p>先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *p1 = head, *p2 = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt == n) <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; cnt - n - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> tmp = p2-&gt;next;</span><br><span class=\"line\">        p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"New-Meta-使用二级指针，遍历一次链表\"><a href=\"#New-Meta-使用二级指针，遍历一次链表\" class=\"headerlink\" title=\"New Meta(使用二级指针，遍历一次链表)\"></a>New Meta(使用二级指针，遍历一次链表)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用二级指针删除元素</span></span><br><span class=\"line\">        ListNode **t1 = &amp;head, *t2 = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将t2向后移动n位，此时t2的位置在len(head) - n</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">            t2 = t2-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 当t2的下一个节点不为空时，开始移动t1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (t2-&gt;next)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// t1指向下一个元素指针的地址</span></span><br><span class=\"line\">            t1 = &amp;((*t1)-&gt;next);</span><br><span class=\"line\">            t2 = t2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此我们需要删除该元素,并使t1指向下一个元素指针的地址</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> tmp = *t1;</span><br><span class=\"line\">        *t1 = (*t1)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。</p>\n","site":{"data":{}},"length":1346,"excerpt":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Give a linked list, remove the $n^{th}$ node from the end of list and return its head.</p>","more":"<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><blockquote>\n<p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong>n = 2</strong><br>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><p>Given <em>n</em> will always be valid.<br>Try do this in one pass.</p>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><h3 id=\"单链表结构定义\"><a href=\"#单链表结构定义\" class=\"headerlink\" title=\"单链表结构定义\"></a>单链表结构定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"普通方法-遍历两次链表\"><a href=\"#普通方法-遍历两次链表\" class=\"headerlink\" title=\"普通方法(遍历两次链表)\"></a>普通方法(遍历两次链表)</h3><p>先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *p1 = head, *p2 = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt == n) <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; cnt - n - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> tmp = p2-&gt;next;</span><br><span class=\"line\">        p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"New-Meta-使用二级指针，遍历一次链表\"><a href=\"#New-Meta-使用二级指针，遍历一次链表\" class=\"headerlink\" title=\"New Meta(使用二级指针，遍历一次链表)\"></a>New Meta(使用二级指针，遍历一次链表)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用二级指针删除元素</span></span><br><span class=\"line\">        ListNode **t1 = &amp;head, *t2 = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将t2向后移动n位，此时t2的位置在len(head) - n</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">            t2 = t2-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 当t2的下一个节点不为空时，开始移动t1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (t2-&gt;next)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// t1指向下一个元素指针的地址</span></span><br><span class=\"line\">            t1 = &amp;((*t1)-&gt;next);</span><br><span class=\"line\">            t2 = t2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此我们需要删除该元素,并使t1指向下一个元素指针的地址</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> tmp = *t1;</span><br><span class=\"line\">        *t1 = (*t1)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。</p>"},{"title":"LeetCode 751. IP to CIDR","date":"2017-12-29T07:09:13.000Z","updated":"2017-12-29T07:42:58.000Z","comments":1,"_content":"\n## Problem\nGiven a start IP address `ip` and a number of ips we need to cover `n`, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\n\nA CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: \"123.45.67.89/20\". That prefix length \"20\" represents the number of common prefix bits in the specified range.\n\n<!--more-->\n\n### Example 1\n\n> **Input:** ip = \"255.0.0.7\", n = 10\n**Output:** [\"255.0.0.7/32\", \"255,0.0.8/29\", \"255.0.0.16/32\"]\n**Explanation:**\nThe initial ip address, when convered to binary, look like this (spaces added for clarity):\n255.0.0.7 -> 1111111 00000000 00000000 00000111\nThe address \"255.0.0.7/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just this one address.\n\n> The address \"255.0.0.8/29\" specifies all address with a common prefix of 29 bits to the given address:\n255.0.0.8 -> 11111111 00000000 0000000 00001000\nAddress with common prefix of 29 bits are:\n11111111 00000000 00000000 00001000\n11111111 00000000 00000000 00001001\n11111111 00000000 00000000 00001010\n11111111 00000000 00000000 00001011\n11111111 00000000 00000000 00001100\n11111111 00000000 00000000 00001101\n11111111 00000000 00000000 00001110\n11111111 00000000 00000000 00001111\n\n> The address \"255.0.0.16/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just 11111111 00000000 00000000 00010000\n\n> In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\n\n> There were other representations, such as:\n[\"255.0.0.7/32\", \"\"255.0.0.8/30\", \"255.0.0.12/30\", \"255.0.0.16/32\"],\nbut our answer was the shortest possible.\n\n> Also note that a representation beginning with say, \"255.0.0.7/30\" would be incorrect,\nbecause it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100\nthat are outside the specified range.\n\n### Note\n\n 1. `ip` will be a valid IPv4 address.\n 2. Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.\n 3. `n` will be an integer in the range `[1, 1000]`.\n\n\n## Answer\n\n这个问题是在给定的起始IP地址，求最少的[CIDR][1]正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。\n\n先说明一下`255.255.0.8/29`中29的含义：\n一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。\n\n比如我们以`255.0.0.7`开始，覆盖30个地址，那么就有：\n> 255.0.0.7/32\n只有一个IP地址 剩余30 - 1 = 29\n\n> 接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改\n则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21\n\n> 8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改\n则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5\n\n\n> 接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改\n则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1\n\n> 那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖\n至此可以得到最少的CIDR。\n\n### 实现代码\n\n将IP转为数字:\n\n```c++\nvector<string> split(const string &str, char delim)\n{\n    stringstream ss(str);\n    string word;\n    vector<string> ret;\n    while (getline(ss, word, delim))\n    {\n        ret.emplace_back(word);\n    }\n    return ret;\n}\n\nint ip2Num(const string &ip)\n{\n    vector<string> vec = split(ip, '.');\n    int num = 0;\n    num = static_cast<int>(stoi(vec[0));\n    num = num << 8 | static_cast<int>(stoi(vec[1]));\n    num = num << 8 | static_cast<int>(stoi(vec[2]));\n    num = num << 8 | static_cast<int>(stoi(vec[3]));\n    return num;\n}\n```\n\n数字转换为IP\n```c++\nstring num2Ip(int num)\n{\n    vector<string> vec;\n    for (int i = 0; i < 4; ++i)\n    {\n        vec.emplace_back(to_string(num & 0xff));\n        num >>= 8;\n    }\n    string ret;\n    ret.append(vec[3] + '.');\n    ret.append(vec[2] + '.');\n    ret.append(vec[1] + '.');\n    ret.append(vec[0]);\n    return ret;\n}\n```\n\n主函数\n```c++\nvector<string> ipToCIDR(string ip, int range)\n{\n    vector<string> ret;\n    unsigned num = ip2Num(ip);\n    \n    while (range)\n    {\n        int weight = 1;\n        int i = 0;\n        while (i < 32)\n        {\n            weight <<= 1;\n            if ((1 << i & num) || (weight > range))\n                break;\n            ++i;\n        }\n        weight >>= 1;\n        range -= weight;\n        ret.emplace_back(num2Ip(num) + \"/\" + to_string(32 - i));\n        num += weight;\n    }\n    return ret;\n}\n```\n\n[1]: https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR","source":"_posts/LeetCode-751-IP-to-CIDR.md","raw":"---\ntitle: LeetCode 751. IP to CIDR\ndate: 2017-12-29 15:09:13\nupdated: 2017-12-29 15:42:58\ncategory: LeetCode\ntags: LeetCode\ncomments: true\n---\n\n## Problem\nGiven a start IP address `ip` and a number of ips we need to cover `n`, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\n\nA CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: \"123.45.67.89/20\". That prefix length \"20\" represents the number of common prefix bits in the specified range.\n\n<!--more-->\n\n### Example 1\n\n> **Input:** ip = \"255.0.0.7\", n = 10\n**Output:** [\"255.0.0.7/32\", \"255,0.0.8/29\", \"255.0.0.16/32\"]\n**Explanation:**\nThe initial ip address, when convered to binary, look like this (spaces added for clarity):\n255.0.0.7 -> 1111111 00000000 00000000 00000111\nThe address \"255.0.0.7/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just this one address.\n\n> The address \"255.0.0.8/29\" specifies all address with a common prefix of 29 bits to the given address:\n255.0.0.8 -> 11111111 00000000 0000000 00001000\nAddress with common prefix of 29 bits are:\n11111111 00000000 00000000 00001000\n11111111 00000000 00000000 00001001\n11111111 00000000 00000000 00001010\n11111111 00000000 00000000 00001011\n11111111 00000000 00000000 00001100\n11111111 00000000 00000000 00001101\n11111111 00000000 00000000 00001110\n11111111 00000000 00000000 00001111\n\n> The address \"255.0.0.16/32\" specifies all address with a common prefix of 32 bits to the given address,\nie. just 11111111 00000000 00000000 00010000\n\n> In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\n\n> There were other representations, such as:\n[\"255.0.0.7/32\", \"\"255.0.0.8/30\", \"255.0.0.12/30\", \"255.0.0.16/32\"],\nbut our answer was the shortest possible.\n\n> Also note that a representation beginning with say, \"255.0.0.7/30\" would be incorrect,\nbecause it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100\nthat are outside the specified range.\n\n### Note\n\n 1. `ip` will be a valid IPv4 address.\n 2. Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.\n 3. `n` will be an integer in the range `[1, 1000]`.\n\n\n## Answer\n\n这个问题是在给定的起始IP地址，求最少的[CIDR][1]正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。\n\n先说明一下`255.255.0.8/29`中29的含义：\n一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。\n\n比如我们以`255.0.0.7`开始，覆盖30个地址，那么就有：\n> 255.0.0.7/32\n只有一个IP地址 剩余30 - 1 = 29\n\n> 接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改\n则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21\n\n> 8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改\n则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5\n\n\n> 接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改\n则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1\n\n> 那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖\n至此可以得到最少的CIDR。\n\n### 实现代码\n\n将IP转为数字:\n\n```c++\nvector<string> split(const string &str, char delim)\n{\n    stringstream ss(str);\n    string word;\n    vector<string> ret;\n    while (getline(ss, word, delim))\n    {\n        ret.emplace_back(word);\n    }\n    return ret;\n}\n\nint ip2Num(const string &ip)\n{\n    vector<string> vec = split(ip, '.');\n    int num = 0;\n    num = static_cast<int>(stoi(vec[0));\n    num = num << 8 | static_cast<int>(stoi(vec[1]));\n    num = num << 8 | static_cast<int>(stoi(vec[2]));\n    num = num << 8 | static_cast<int>(stoi(vec[3]));\n    return num;\n}\n```\n\n数字转换为IP\n```c++\nstring num2Ip(int num)\n{\n    vector<string> vec;\n    for (int i = 0; i < 4; ++i)\n    {\n        vec.emplace_back(to_string(num & 0xff));\n        num >>= 8;\n    }\n    string ret;\n    ret.append(vec[3] + '.');\n    ret.append(vec[2] + '.');\n    ret.append(vec[1] + '.');\n    ret.append(vec[0]);\n    return ret;\n}\n```\n\n主函数\n```c++\nvector<string> ipToCIDR(string ip, int range)\n{\n    vector<string> ret;\n    unsigned num = ip2Num(ip);\n    \n    while (range)\n    {\n        int weight = 1;\n        int i = 0;\n        while (i < 32)\n        {\n            weight <<= 1;\n            if ((1 << i & num) || (weight > range))\n                break;\n            ++i;\n        }\n        weight >>= 1;\n        range -= weight;\n        ret.emplace_back(num2Ip(num) + \"/\" + to_string(32 - i));\n        num += weight;\n    }\n    return ret;\n}\n```\n\n[1]: https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR","slug":"LeetCode-751-IP-to-CIDR","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsik000lw8vo0ttggvys","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>\n<p>A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h3><blockquote>\n<p><strong>Input:</strong> ip = “255.0.0.7”, n = 10<br><strong>Output:</strong> [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]<br><strong>Explanation:</strong><br>The initial ip address, when convered to binary, look like this (spaces added for clarity):<br>255.0.0.7 -&gt; 1111111 00000000 00000000 00000111<br>The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just this one address.</p>\n</blockquote>\n<blockquote>\n<p>The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:<br>255.0.0.8 -&gt; 11111111 00000000 0000000 00001000<br>Address with common prefix of 29 bits are:<br>11111111 00000000 00000000 00001000<br>11111111 00000000 00000000 00001001<br>11111111 00000000 00000000 00001010<br>11111111 00000000 00000000 00001011<br>11111111 00000000 00000000 00001100<br>11111111 00000000 00000000 00001101<br>11111111 00000000 00000000 00001110<br>11111111 00000000 00000000 00001111</p>\n</blockquote>\n<blockquote>\n<p>The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just 11111111 00000000 00000000 00010000</p>\n</blockquote>\n<blockquote>\n<p>In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</p>\n</blockquote>\n<blockquote>\n<p>There were other representations, such as:<br>[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],<br>but our answer was the shortest possible.</p>\n</blockquote>\n<blockquote>\n<p>Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,<br>because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100<br>that are outside the specified range.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><ol>\n<li><code>ip</code> will be a valid IPv4 address.</li>\n<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>\n<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>\n</ol>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><p>这个问题是在给定的起始IP地址，求最少的<a href=\"https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR\">CIDR</a>正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。</p>\n<p>先说明一下<code>255.255.0.8/29</code>中29的含义：<br>一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。</p>\n<p>比如我们以<code>255.0.0.7</code>开始，覆盖30个地址，那么就有：</p>\n<blockquote>\n<p>255.0.0.7/32<br>只有一个IP地址 剩余30 - 1 = 29</p>\n</blockquote>\n<blockquote>\n<p>接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改<br>则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21</p>\n</blockquote>\n<blockquote>\n<p>8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改<br>则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5</p>\n</blockquote>\n<blockquote>\n<p>接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改<br>则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1</p>\n</blockquote>\n<blockquote>\n<p>那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖<br>至此可以得到最少的CIDR。</p>\n</blockquote>\n<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p>将IP转为数字:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str, <span class=\"keyword\">char</span> delim)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(str)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> word;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ss, word, delim))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret.emplace_back(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ip2Num</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec = split(ip, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">0</span>));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">1</span>]));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">3</span>]));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数字转换为IP</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">num2Ip</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vec.emplace_back(to_string(num &amp; <span class=\"number\">0xff</span>));</span><br><span class=\"line\">        num &gt;&gt;= <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ret;</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">3</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">2</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">1</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">ipToCIDR</span><span class=\"params\">(<span class=\"built_in\">string</span> ip, <span class=\"keyword\">int</span> range)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> num = ip2Num(ip);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (range)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">32</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            weight &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">1</span> &lt;&lt; i &amp; num) || (weight &gt; range))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        weight &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        range -= weight;</span><br><span class=\"line\">        ret.emplace_back(num2Ip(num) + <span class=\"string\">&quot;/&quot;</span> + to_string(<span class=\"number\">32</span> - i));</span><br><span class=\"line\">        num += weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":3549,"excerpt":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>\n<p>A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p>","more":"<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1\"></a>Example 1</h3><blockquote>\n<p><strong>Input:</strong> ip = “255.0.0.7”, n = 10<br><strong>Output:</strong> [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]<br><strong>Explanation:</strong><br>The initial ip address, when convered to binary, look like this (spaces added for clarity):<br>255.0.0.7 -&gt; 1111111 00000000 00000000 00000111<br>The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just this one address.</p>\n</blockquote>\n<blockquote>\n<p>The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:<br>255.0.0.8 -&gt; 11111111 00000000 0000000 00001000<br>Address with common prefix of 29 bits are:<br>11111111 00000000 00000000 00001000<br>11111111 00000000 00000000 00001001<br>11111111 00000000 00000000 00001010<br>11111111 00000000 00000000 00001011<br>11111111 00000000 00000000 00001100<br>11111111 00000000 00000000 00001101<br>11111111 00000000 00000000 00001110<br>11111111 00000000 00000000 00001111</p>\n</blockquote>\n<blockquote>\n<p>The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just 11111111 00000000 00000000 00010000</p>\n</blockquote>\n<blockquote>\n<p>In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</p>\n</blockquote>\n<blockquote>\n<p>There were other representations, such as:<br>[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],<br>but our answer was the shortest possible.</p>\n</blockquote>\n<blockquote>\n<p>Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,<br>because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100<br>that are outside the specified range.</p>\n</blockquote>\n<h3 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h3><ol>\n<li><code>ip</code> will be a valid IPv4 address.</li>\n<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>\n<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>\n</ol>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><p>这个问题是在给定的起始IP地址，求最少的<a href=\"https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR\">CIDR</a>正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。</p>\n<p>先说明一下<code>255.255.0.8/29</code>中29的含义：<br>一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。</p>\n<p>比如我们以<code>255.0.0.7</code>开始，覆盖30个地址，那么就有：</p>\n<blockquote>\n<p>255.0.0.7/32<br>只有一个IP地址 剩余30 - 1 = 29</p>\n</blockquote>\n<blockquote>\n<p>接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改<br>则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21</p>\n</blockquote>\n<blockquote>\n<p>8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改<br>则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5</p>\n</blockquote>\n<blockquote>\n<p>接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改<br>则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1</p>\n</blockquote>\n<blockquote>\n<p>那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖<br>至此可以得到最少的CIDR。</p>\n</blockquote>\n<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p>将IP转为数字:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str, <span class=\"keyword\">char</span> delim)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(str)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> word;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getline(ss, word, delim))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret.emplace_back(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ip2Num</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec = split(ip, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">0</span>));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">1</span>]));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    num = num &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(stoi(vec[<span class=\"number\">3</span>]));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数字转换为IP</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">num2Ip</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vec.emplace_back(to_string(num &amp; <span class=\"number\">0xff</span>));</span><br><span class=\"line\">        num &gt;&gt;= <span class=\"number\">8</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ret;</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">3</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">2</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">1</span>] + <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">    ret.append(vec[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">ipToCIDR</span><span class=\"params\">(<span class=\"built_in\">string</span> ip, <span class=\"keyword\">int</span> range)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> num = ip2Num(ip);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (range)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">32</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            weight &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">1</span> &lt;&lt; i &amp; num) || (weight &gt; range))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        weight &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        range -= weight;</span><br><span class=\"line\">        ret.emplace_back(num2Ip(num) + <span class=\"string\">&quot;/&quot;</span> + to_string(<span class=\"number\">32</span> - i));</span><br><span class=\"line\">        num += weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"OpenStack Neutron -- Neutron 架构分析","date":"2019-05-24T06:51:53.000Z","updated":"2019-05-24T06:51:53.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-05-24.jpg","_content":"Neutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：\n\n1. 对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）\n2. 内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络\n\nNeutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：\n\n1. Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等\n2. 开源的网络功能，如 OVS 等\n3. 厂商提供的闭源产品\n\n在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。\n\n<!--more-->\n\n## Neutron 中的 WSGI Application\n\nWSGI 是 Web Server Gateway Interface 的缩写。WSGI 本身只是一套标准接口，而非具体实现。这套接口位于 Web Service 和 Web Application（或者 Framework）之间，为的是提升 Web Applications 针对各种 Web Servers 的适配能力。\n\n能够被 Web Server 按照 WSGI 接口调用的 Web Application 称为 WSGI Application，它有三个特征：\n\n1. 是一个可调用的对象\n2. 有两个参数：environ、start_response\n3. 有一个可迭代的返回值\n\n对于 Neutron 来说，只需要按照 WSGI 规范写好 WSGI Application 即可，WSGI Application 才是真正的业务处理单元。\n\n## Neutron 的消息通信机制\n\nNeutron 内部组件（进程）之间的通信（比如 Neutron Server 与 Neutron Agent），采用 AMQP （Advanced Message Queuing Protocol，高级消息队列协议）机制，进行 RPC 通信。Neutron 采用了三种 AMQP 标准的具体实现：RabbitMQ、Qpid 和 ZMQ，具体应用中根据配置文件选用某种实现。\n\n### AMQP 基本概念\n\nAMQP 把通信的双方（发送方和接收方）分别称为 Producer 和 Consumer。Producer 把消息发送到 Consumer 需要经过 Message Broker 的处理和传递。AMQP 中，承担 Message Broker 功能的是 AMQP Server，而 AMQP 的 Producer 和 Consumer 都是 AMQP Client。\n\n在 AMQP Server 中，有两大部件：Exchange 和 Message Queues，其含义如下：\n\n1. Exchange 接收 Producers 发过来的消息，按照一定规则转发到相应的 Message Queues 中\n\n1. Message Queues 再将消息转发到相应的 Consumers\n\n### AMQP 的消息转发\n\n#### AMQP 消息转发模型\n\nProducer 发送的消息，经过 AMQP Server 转发以后，到达对应的 Consumer，在这个消息转发中，起关键的“路由标识”作用的是一个字符串 Routing Key。具体的说，就是 Producer 首先发消息到 Exchange，Exchange 根据一定的转发规则转发到相应的 Message Queue，然后 Queue 通知绑定到它的 Consumer。Exchange 转发消息给 Message Queue 的规则根据 Routing Key 进行匹配。其匹配模式可分为三种：\n\n1. Direct Exchanges\n\n    - Routing Key 是一个字符串\n    - 匹配规则为全值匹配\n\n    Message Queue 绑定的 Routing Key 与 Producer 发送的 Routine Key 完全相同时，Exchange 才会将消息转发给该 Message Queue。\n\n2. Topic Exchanges\n\n    - Routing Key 是一个字符串，但是由“.” 分割为多个子字符串\n    - 匹配规则是模式匹配\n\n    所谓模式匹配，是有两个通配符，一个是“*”，代表任意一个字符串；另一个是“#”，代表任意多个子字符串。Producer 发送的 Routing Key 是一个完整的字符串，没有通配符，Message Queue 绑定的 Routing Key 可以有通配符。\n\n3. Fanout Exchanges\n\n    - 没有 Routing Key\n    - 所有绑定到 Fanout Exchange Message Queue都能收到相应的 Producer 发送的消息\n\n#### AMQP 的几种通信模式\n\n基于 AMQP 的消息转发模型，有以下几种通信模式：\n\n1. 远程过程调用（RPC）\n2. 发布—订阅（Publish-Subscribe）\n3. 广播（Broadcast）\n\n发布订阅只需采用 Topic Exchanges 消息转发模型即可，而广播只需采用 Fanout Exchanges 消息转发模型即可。RPC（Remote Procedure Call Protocol，远程过程调用协议），一般称为“远程过程调用”，是一种 Client/Server 通信模型。Client 和 Server 之间有一来（request）一往（response）两个消息。在 request 消息中，RPC Client 担任 Producer 的角色，RPC Server 担任 Consumer 的角色。在 response 消息中，两种角色进行了互换，RPC Server 担任 Producer 角色，RPC Client 担任 Consumer 角色。\n\n## Neutron 的并发机制\n\nNeutron 北向提供 RESTful 接口，需要处理并发请求，南向对接多个“网元”，Neutron 不能算作“计算密集型”应用，而可以归类为“I/O阻塞型”应用，因此 Neutron 主要采用协程，并且在必要的时候，结合多进程方案来共同构建其并发机制。\n\n### 协程与进程、线程的比较\n\n协程与进程和线程的比较如下：\n\n1. 协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程与进程、线程的含义不在同一维度\n2. 一个进程可以包含多个线程，一个线程可以包含多个协程\n3. 一个线程内的多个协程虽然可以切换，但是这**多个协程是串行执行的**，只能在这一个线程内运行，没法利用 CPU 多核的能力\n4. 协程与进程一样，它们的切换都存在上下文切换问题\n\n表面上看，进程、线程和协程均存在上下文切换的问题，但是三者上下文切换又有显著的不同，如下表所示：\n\n|                | 进程                                   | 线程                                   | 协程                                 |\n| :------------- | :------------------------------------- | :------------------------------------- | :----------------------------------- |\n| 切换者         | 操作系统                               | 操作系统                               | 用户（编程者/应用程序）              |\n| 切换时机       | 根据操作系统自己的切换策略，用户不感知 | 根据操作系统自己的切换策略，用户不感知 | 用户自己（的程序）决定               |\n| 切换内容       | 页全局目录、内核栈、硬件上下文         | 内核栈、硬件上下文                     | 硬件上下文                           |\n| 切换内容的保存 | 保存于内核栈中                         | 保存于内核栈中                         | 保存于用户自己的变量（用户栈或堆）中 |\n| 切换过程       | 用户态 - 内核态 - 用户态               | 用户态 - 内核态- 用户态                | 用户态（没有陷入内核态）             |\n| 切换效率       | 低                                     | 中                                     | 高                                   |\n\n\n## 通用库 Oslo\n\n为了降低代码的冗余度，OpenStack 社区创建了 Oslo 项目，从 OpenStack 代码中提取公共的部分，构建出一批 lib 库以供 OpenStack 其他项目使用。Neutron 使用了 Oslo 中的 lib。","source":"_posts/OpenStack-Neutron-Architecture.md","raw":"---\ntitle: OpenStack Neutron -- Neutron 架构分析\ndate: 2019-05-24 14:51:53\nupdated: 2019-05-24 14:51:53\ncategory: OpenStack\ntags: [Neutron]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-05-24.jpg\n---\nNeutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：\n\n1. 对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）\n2. 内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络\n\nNeutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：\n\n1. Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等\n2. 开源的网络功能，如 OVS 等\n3. 厂商提供的闭源产品\n\n在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。\n\n<!--more-->\n\n## Neutron 中的 WSGI Application\n\nWSGI 是 Web Server Gateway Interface 的缩写。WSGI 本身只是一套标准接口，而非具体实现。这套接口位于 Web Service 和 Web Application（或者 Framework）之间，为的是提升 Web Applications 针对各种 Web Servers 的适配能力。\n\n能够被 Web Server 按照 WSGI 接口调用的 Web Application 称为 WSGI Application，它有三个特征：\n\n1. 是一个可调用的对象\n2. 有两个参数：environ、start_response\n3. 有一个可迭代的返回值\n\n对于 Neutron 来说，只需要按照 WSGI 规范写好 WSGI Application 即可，WSGI Application 才是真正的业务处理单元。\n\n## Neutron 的消息通信机制\n\nNeutron 内部组件（进程）之间的通信（比如 Neutron Server 与 Neutron Agent），采用 AMQP （Advanced Message Queuing Protocol，高级消息队列协议）机制，进行 RPC 通信。Neutron 采用了三种 AMQP 标准的具体实现：RabbitMQ、Qpid 和 ZMQ，具体应用中根据配置文件选用某种实现。\n\n### AMQP 基本概念\n\nAMQP 把通信的双方（发送方和接收方）分别称为 Producer 和 Consumer。Producer 把消息发送到 Consumer 需要经过 Message Broker 的处理和传递。AMQP 中，承担 Message Broker 功能的是 AMQP Server，而 AMQP 的 Producer 和 Consumer 都是 AMQP Client。\n\n在 AMQP Server 中，有两大部件：Exchange 和 Message Queues，其含义如下：\n\n1. Exchange 接收 Producers 发过来的消息，按照一定规则转发到相应的 Message Queues 中\n\n1. Message Queues 再将消息转发到相应的 Consumers\n\n### AMQP 的消息转发\n\n#### AMQP 消息转发模型\n\nProducer 发送的消息，经过 AMQP Server 转发以后，到达对应的 Consumer，在这个消息转发中，起关键的“路由标识”作用的是一个字符串 Routing Key。具体的说，就是 Producer 首先发消息到 Exchange，Exchange 根据一定的转发规则转发到相应的 Message Queue，然后 Queue 通知绑定到它的 Consumer。Exchange 转发消息给 Message Queue 的规则根据 Routing Key 进行匹配。其匹配模式可分为三种：\n\n1. Direct Exchanges\n\n    - Routing Key 是一个字符串\n    - 匹配规则为全值匹配\n\n    Message Queue 绑定的 Routing Key 与 Producer 发送的 Routine Key 完全相同时，Exchange 才会将消息转发给该 Message Queue。\n\n2. Topic Exchanges\n\n    - Routing Key 是一个字符串，但是由“.” 分割为多个子字符串\n    - 匹配规则是模式匹配\n\n    所谓模式匹配，是有两个通配符，一个是“*”，代表任意一个字符串；另一个是“#”，代表任意多个子字符串。Producer 发送的 Routing Key 是一个完整的字符串，没有通配符，Message Queue 绑定的 Routing Key 可以有通配符。\n\n3. Fanout Exchanges\n\n    - 没有 Routing Key\n    - 所有绑定到 Fanout Exchange Message Queue都能收到相应的 Producer 发送的消息\n\n#### AMQP 的几种通信模式\n\n基于 AMQP 的消息转发模型，有以下几种通信模式：\n\n1. 远程过程调用（RPC）\n2. 发布—订阅（Publish-Subscribe）\n3. 广播（Broadcast）\n\n发布订阅只需采用 Topic Exchanges 消息转发模型即可，而广播只需采用 Fanout Exchanges 消息转发模型即可。RPC（Remote Procedure Call Protocol，远程过程调用协议），一般称为“远程过程调用”，是一种 Client/Server 通信模型。Client 和 Server 之间有一来（request）一往（response）两个消息。在 request 消息中，RPC Client 担任 Producer 的角色，RPC Server 担任 Consumer 的角色。在 response 消息中，两种角色进行了互换，RPC Server 担任 Producer 角色，RPC Client 担任 Consumer 角色。\n\n## Neutron 的并发机制\n\nNeutron 北向提供 RESTful 接口，需要处理并发请求，南向对接多个“网元”，Neutron 不能算作“计算密集型”应用，而可以归类为“I/O阻塞型”应用，因此 Neutron 主要采用协程，并且在必要的时候，结合多进程方案来共同构建其并发机制。\n\n### 协程与进程、线程的比较\n\n协程与进程和线程的比较如下：\n\n1. 协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程与进程、线程的含义不在同一维度\n2. 一个进程可以包含多个线程，一个线程可以包含多个协程\n3. 一个线程内的多个协程虽然可以切换，但是这**多个协程是串行执行的**，只能在这一个线程内运行，没法利用 CPU 多核的能力\n4. 协程与进程一样，它们的切换都存在上下文切换问题\n\n表面上看，进程、线程和协程均存在上下文切换的问题，但是三者上下文切换又有显著的不同，如下表所示：\n\n|                | 进程                                   | 线程                                   | 协程                                 |\n| :------------- | :------------------------------------- | :------------------------------------- | :----------------------------------- |\n| 切换者         | 操作系统                               | 操作系统                               | 用户（编程者/应用程序）              |\n| 切换时机       | 根据操作系统自己的切换策略，用户不感知 | 根据操作系统自己的切换策略，用户不感知 | 用户自己（的程序）决定               |\n| 切换内容       | 页全局目录、内核栈、硬件上下文         | 内核栈、硬件上下文                     | 硬件上下文                           |\n| 切换内容的保存 | 保存于内核栈中                         | 保存于内核栈中                         | 保存于用户自己的变量（用户栈或堆）中 |\n| 切换过程       | 用户态 - 内核态 - 用户态               | 用户态 - 内核态- 用户态                | 用户态（没有陷入内核态）             |\n| 切换效率       | 低                                     | 中                                     | 高                                   |\n\n\n## 通用库 Oslo\n\n为了降低代码的冗余度，OpenStack 社区创建了 Oslo 项目，从 OpenStack 代码中提取公共的部分，构建出一批 lib 库以供 OpenStack 其他项目使用。Neutron 使用了 Oslo 中的 lib。","slug":"OpenStack-Neutron-Architecture","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsil000nw8vo1fbvdc04","content":"<p>Neutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：</p>\n<ol>\n<li>对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）</li>\n<li>内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络</li>\n</ol>\n<p>Neutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：</p>\n<ol>\n<li>Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等</li>\n<li>开源的网络功能，如 OVS 等</li>\n<li>厂商提供的闭源产品</li>\n</ol>\n<p>在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Neutron-中的-WSGI-Application\"><a href=\"#Neutron-中的-WSGI-Application\" class=\"headerlink\" title=\"Neutron 中的 WSGI Application\"></a>Neutron 中的 WSGI Application</h2><p>WSGI 是 Web Server Gateway Interface 的缩写。WSGI 本身只是一套标准接口，而非具体实现。这套接口位于 Web Service 和 Web Application（或者 Framework）之间，为的是提升 Web Applications 针对各种 Web Servers 的适配能力。</p>\n<p>能够被 Web Server 按照 WSGI 接口调用的 Web Application 称为 WSGI Application，它有三个特征：</p>\n<ol>\n<li>是一个可调用的对象</li>\n<li>有两个参数：environ、start_response</li>\n<li>有一个可迭代的返回值</li>\n</ol>\n<p>对于 Neutron 来说，只需要按照 WSGI 规范写好 WSGI Application 即可，WSGI Application 才是真正的业务处理单元。</p>\n<h2 id=\"Neutron-的消息通信机制\"><a href=\"#Neutron-的消息通信机制\" class=\"headerlink\" title=\"Neutron 的消息通信机制\"></a>Neutron 的消息通信机制</h2><p>Neutron 内部组件（进程）之间的通信（比如 Neutron Server 与 Neutron Agent），采用 AMQP （Advanced Message Queuing Protocol，高级消息队列协议）机制，进行 RPC 通信。Neutron 采用了三种 AMQP 标准的具体实现：RabbitMQ、Qpid 和 ZMQ，具体应用中根据配置文件选用某种实现。</p>\n<h3 id=\"AMQP-基本概念\"><a href=\"#AMQP-基本概念\" class=\"headerlink\" title=\"AMQP 基本概念\"></a>AMQP 基本概念</h3><p>AMQP 把通信的双方（发送方和接收方）分别称为 Producer 和 Consumer。Producer 把消息发送到 Consumer 需要经过 Message Broker 的处理和传递。AMQP 中，承担 Message Broker 功能的是 AMQP Server，而 AMQP 的 Producer 和 Consumer 都是 AMQP Client。</p>\n<p>在 AMQP Server 中，有两大部件：Exchange 和 Message Queues，其含义如下：</p>\n<ol>\n<li><p>Exchange 接收 Producers 发过来的消息，按照一定规则转发到相应的 Message Queues 中</p>\n</li>\n<li><p>Message Queues 再将消息转发到相应的 Consumers</p>\n</li>\n</ol>\n<h3 id=\"AMQP-的消息转发\"><a href=\"#AMQP-的消息转发\" class=\"headerlink\" title=\"AMQP 的消息转发\"></a>AMQP 的消息转发</h3><h4 id=\"AMQP-消息转发模型\"><a href=\"#AMQP-消息转发模型\" class=\"headerlink\" title=\"AMQP 消息转发模型\"></a>AMQP 消息转发模型</h4><p>Producer 发送的消息，经过 AMQP Server 转发以后，到达对应的 Consumer，在这个消息转发中，起关键的“路由标识”作用的是一个字符串 Routing Key。具体的说，就是 Producer 首先发消息到 Exchange，Exchange 根据一定的转发规则转发到相应的 Message Queue，然后 Queue 通知绑定到它的 Consumer。Exchange 转发消息给 Message Queue 的规则根据 Routing Key 进行匹配。其匹配模式可分为三种：</p>\n<ol>\n<li><p>Direct Exchanges</p>\n<ul>\n<li><p>Routing Key 是一个字符串</p>\n</li>\n<li><p>匹配规则为全值匹配</p>\n<p>Message Queue 绑定的 Routing Key 与 Producer 发送的 Routine Key 完全相同时，Exchange 才会将消息转发给该 Message Queue。</p>\n</li>\n</ul>\n</li>\n<li><p>Topic Exchanges</p>\n<ul>\n<li><p>Routing Key 是一个字符串，但是由“.” 分割为多个子字符串</p>\n</li>\n<li><p>匹配规则是模式匹配</p>\n<p>所谓模式匹配，是有两个通配符，一个是“*”，代表任意一个字符串；另一个是“#”，代表任意多个子字符串。Producer 发送的 Routing Key 是一个完整的字符串，没有通配符，Message Queue 绑定的 Routing Key 可以有通配符。</p>\n</li>\n</ul>\n</li>\n<li><p>Fanout Exchanges</p>\n<ul>\n<li>没有 Routing Key</li>\n<li>所有绑定到 Fanout Exchange Message Queue都能收到相应的 Producer 发送的消息</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"AMQP-的几种通信模式\"><a href=\"#AMQP-的几种通信模式\" class=\"headerlink\" title=\"AMQP 的几种通信模式\"></a>AMQP 的几种通信模式</h4><p>基于 AMQP 的消息转发模型，有以下几种通信模式：</p>\n<ol>\n<li>远程过程调用（RPC）</li>\n<li>发布—订阅（Publish-Subscribe）</li>\n<li>广播（Broadcast）</li>\n</ol>\n<p>发布订阅只需采用 Topic Exchanges 消息转发模型即可，而广播只需采用 Fanout Exchanges 消息转发模型即可。RPC（Remote Procedure Call Protocol，远程过程调用协议），一般称为“远程过程调用”，是一种 Client/Server 通信模型。Client 和 Server 之间有一来（request）一往（response）两个消息。在 request 消息中，RPC Client 担任 Producer 的角色，RPC Server 担任 Consumer 的角色。在 response 消息中，两种角色进行了互换，RPC Server 担任 Producer 角色，RPC Client 担任 Consumer 角色。</p>\n<h2 id=\"Neutron-的并发机制\"><a href=\"#Neutron-的并发机制\" class=\"headerlink\" title=\"Neutron 的并发机制\"></a>Neutron 的并发机制</h2><p>Neutron 北向提供 RESTful 接口，需要处理并发请求，南向对接多个“网元”，Neutron 不能算作“计算密集型”应用，而可以归类为“I/O阻塞型”应用，因此 Neutron 主要采用协程，并且在必要的时候，结合多进程方案来共同构建其并发机制。</p>\n<h3 id=\"协程与进程、线程的比较\"><a href=\"#协程与进程、线程的比较\" class=\"headerlink\" title=\"协程与进程、线程的比较\"></a>协程与进程、线程的比较</h3><p>协程与进程和线程的比较如下：</p>\n<ol>\n<li>协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程与进程、线程的含义不在同一维度</li>\n<li>一个进程可以包含多个线程，一个线程可以包含多个协程</li>\n<li>一个线程内的多个协程虽然可以切换，但是这<strong>多个协程是串行执行的</strong>，只能在这一个线程内运行，没法利用 CPU 多核的能力</li>\n<li>协程与进程一样，它们的切换都存在上下文切换问题</li>\n</ol>\n<p>表面上看，进程、线程和协程均存在上下文切换的问题，但是三者上下文切换又有显著的不同，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">进程</th>\n<th align=\"left\">线程</th>\n<th align=\"left\">协程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">切换者</td>\n<td align=\"left\">操作系统</td>\n<td align=\"left\">操作系统</td>\n<td align=\"left\">用户（编程者/应用程序）</td>\n</tr>\n<tr>\n<td align=\"left\">切换时机</td>\n<td align=\"left\">根据操作系统自己的切换策略，用户不感知</td>\n<td align=\"left\">根据操作系统自己的切换策略，用户不感知</td>\n<td align=\"left\">用户自己（的程序）决定</td>\n</tr>\n<tr>\n<td align=\"left\">切换内容</td>\n<td align=\"left\">页全局目录、内核栈、硬件上下文</td>\n<td align=\"left\">内核栈、硬件上下文</td>\n<td align=\"left\">硬件上下文</td>\n</tr>\n<tr>\n<td align=\"left\">切换内容的保存</td>\n<td align=\"left\">保存于内核栈中</td>\n<td align=\"left\">保存于内核栈中</td>\n<td align=\"left\">保存于用户自己的变量（用户栈或堆）中</td>\n</tr>\n<tr>\n<td align=\"left\">切换过程</td>\n<td align=\"left\">用户态 - 内核态 - 用户态</td>\n<td align=\"left\">用户态 - 内核态- 用户态</td>\n<td align=\"left\">用户态（没有陷入内核态）</td>\n</tr>\n<tr>\n<td align=\"left\">切换效率</td>\n<td align=\"left\">低</td>\n<td align=\"left\">中</td>\n<td align=\"left\">高</td>\n</tr>\n</tbody></table>\n<h2 id=\"通用库-Oslo\"><a href=\"#通用库-Oslo\" class=\"headerlink\" title=\"通用库 Oslo\"></a>通用库 Oslo</h2><p>为了降低代码的冗余度，OpenStack 社区创建了 Oslo 项目，从 OpenStack 代码中提取公共的部分，构建出一批 lib 库以供 OpenStack 其他项目使用。Neutron 使用了 Oslo 中的 lib。</p>\n","site":{"data":{}},"length":3065,"excerpt":"<p>Neutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：</p>\n<ol>\n<li>对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）</li>\n<li>内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络</li>\n</ol>\n<p>Neutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：</p>\n<ol>\n<li>Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等</li>\n<li>开源的网络功能，如 OVS 等</li>\n<li>厂商提供的闭源产品</li>\n</ol>\n<p>在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。</p>","more":"<h2 id=\"Neutron-中的-WSGI-Application\"><a href=\"#Neutron-中的-WSGI-Application\" class=\"headerlink\" title=\"Neutron 中的 WSGI Application\"></a>Neutron 中的 WSGI Application</h2><p>WSGI 是 Web Server Gateway Interface 的缩写。WSGI 本身只是一套标准接口，而非具体实现。这套接口位于 Web Service 和 Web Application（或者 Framework）之间，为的是提升 Web Applications 针对各种 Web Servers 的适配能力。</p>\n<p>能够被 Web Server 按照 WSGI 接口调用的 Web Application 称为 WSGI Application，它有三个特征：</p>\n<ol>\n<li>是一个可调用的对象</li>\n<li>有两个参数：environ、start_response</li>\n<li>有一个可迭代的返回值</li>\n</ol>\n<p>对于 Neutron 来说，只需要按照 WSGI 规范写好 WSGI Application 即可，WSGI Application 才是真正的业务处理单元。</p>\n<h2 id=\"Neutron-的消息通信机制\"><a href=\"#Neutron-的消息通信机制\" class=\"headerlink\" title=\"Neutron 的消息通信机制\"></a>Neutron 的消息通信机制</h2><p>Neutron 内部组件（进程）之间的通信（比如 Neutron Server 与 Neutron Agent），采用 AMQP （Advanced Message Queuing Protocol，高级消息队列协议）机制，进行 RPC 通信。Neutron 采用了三种 AMQP 标准的具体实现：RabbitMQ、Qpid 和 ZMQ，具体应用中根据配置文件选用某种实现。</p>\n<h3 id=\"AMQP-基本概念\"><a href=\"#AMQP-基本概念\" class=\"headerlink\" title=\"AMQP 基本概念\"></a>AMQP 基本概念</h3><p>AMQP 把通信的双方（发送方和接收方）分别称为 Producer 和 Consumer。Producer 把消息发送到 Consumer 需要经过 Message Broker 的处理和传递。AMQP 中，承担 Message Broker 功能的是 AMQP Server，而 AMQP 的 Producer 和 Consumer 都是 AMQP Client。</p>\n<p>在 AMQP Server 中，有两大部件：Exchange 和 Message Queues，其含义如下：</p>\n<ol>\n<li><p>Exchange 接收 Producers 发过来的消息，按照一定规则转发到相应的 Message Queues 中</p>\n</li>\n<li><p>Message Queues 再将消息转发到相应的 Consumers</p>\n</li>\n</ol>\n<h3 id=\"AMQP-的消息转发\"><a href=\"#AMQP-的消息转发\" class=\"headerlink\" title=\"AMQP 的消息转发\"></a>AMQP 的消息转发</h3><h4 id=\"AMQP-消息转发模型\"><a href=\"#AMQP-消息转发模型\" class=\"headerlink\" title=\"AMQP 消息转发模型\"></a>AMQP 消息转发模型</h4><p>Producer 发送的消息，经过 AMQP Server 转发以后，到达对应的 Consumer，在这个消息转发中，起关键的“路由标识”作用的是一个字符串 Routing Key。具体的说，就是 Producer 首先发消息到 Exchange，Exchange 根据一定的转发规则转发到相应的 Message Queue，然后 Queue 通知绑定到它的 Consumer。Exchange 转发消息给 Message Queue 的规则根据 Routing Key 进行匹配。其匹配模式可分为三种：</p>\n<ol>\n<li><p>Direct Exchanges</p>\n<ul>\n<li><p>Routing Key 是一个字符串</p>\n</li>\n<li><p>匹配规则为全值匹配</p>\n<p>Message Queue 绑定的 Routing Key 与 Producer 发送的 Routine Key 完全相同时，Exchange 才会将消息转发给该 Message Queue。</p>\n</li>\n</ul>\n</li>\n<li><p>Topic Exchanges</p>\n<ul>\n<li><p>Routing Key 是一个字符串，但是由“.” 分割为多个子字符串</p>\n</li>\n<li><p>匹配规则是模式匹配</p>\n<p>所谓模式匹配，是有两个通配符，一个是“*”，代表任意一个字符串；另一个是“#”，代表任意多个子字符串。Producer 发送的 Routing Key 是一个完整的字符串，没有通配符，Message Queue 绑定的 Routing Key 可以有通配符。</p>\n</li>\n</ul>\n</li>\n<li><p>Fanout Exchanges</p>\n<ul>\n<li>没有 Routing Key</li>\n<li>所有绑定到 Fanout Exchange Message Queue都能收到相应的 Producer 发送的消息</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"AMQP-的几种通信模式\"><a href=\"#AMQP-的几种通信模式\" class=\"headerlink\" title=\"AMQP 的几种通信模式\"></a>AMQP 的几种通信模式</h4><p>基于 AMQP 的消息转发模型，有以下几种通信模式：</p>\n<ol>\n<li>远程过程调用（RPC）</li>\n<li>发布—订阅（Publish-Subscribe）</li>\n<li>广播（Broadcast）</li>\n</ol>\n<p>发布订阅只需采用 Topic Exchanges 消息转发模型即可，而广播只需采用 Fanout Exchanges 消息转发模型即可。RPC（Remote Procedure Call Protocol，远程过程调用协议），一般称为“远程过程调用”，是一种 Client/Server 通信模型。Client 和 Server 之间有一来（request）一往（response）两个消息。在 request 消息中，RPC Client 担任 Producer 的角色，RPC Server 担任 Consumer 的角色。在 response 消息中，两种角色进行了互换，RPC Server 担任 Producer 角色，RPC Client 担任 Consumer 角色。</p>\n<h2 id=\"Neutron-的并发机制\"><a href=\"#Neutron-的并发机制\" class=\"headerlink\" title=\"Neutron 的并发机制\"></a>Neutron 的并发机制</h2><p>Neutron 北向提供 RESTful 接口，需要处理并发请求，南向对接多个“网元”，Neutron 不能算作“计算密集型”应用，而可以归类为“I/O阻塞型”应用，因此 Neutron 主要采用协程，并且在必要的时候，结合多进程方案来共同构建其并发机制。</p>\n<h3 id=\"协程与进程、线程的比较\"><a href=\"#协程与进程、线程的比较\" class=\"headerlink\" title=\"协程与进程、线程的比较\"></a>协程与进程、线程的比较</h3><p>协程与进程和线程的比较如下：</p>\n<ol>\n<li>协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程与进程、线程的含义不在同一维度</li>\n<li>一个进程可以包含多个线程，一个线程可以包含多个协程</li>\n<li>一个线程内的多个协程虽然可以切换，但是这<strong>多个协程是串行执行的</strong>，只能在这一个线程内运行，没法利用 CPU 多核的能力</li>\n<li>协程与进程一样，它们的切换都存在上下文切换问题</li>\n</ol>\n<p>表面上看，进程、线程和协程均存在上下文切换的问题，但是三者上下文切换又有显著的不同，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">进程</th>\n<th align=\"left\">线程</th>\n<th align=\"left\">协程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">切换者</td>\n<td align=\"left\">操作系统</td>\n<td align=\"left\">操作系统</td>\n<td align=\"left\">用户（编程者/应用程序）</td>\n</tr>\n<tr>\n<td align=\"left\">切换时机</td>\n<td align=\"left\">根据操作系统自己的切换策略，用户不感知</td>\n<td align=\"left\">根据操作系统自己的切换策略，用户不感知</td>\n<td align=\"left\">用户自己（的程序）决定</td>\n</tr>\n<tr>\n<td align=\"left\">切换内容</td>\n<td align=\"left\">页全局目录、内核栈、硬件上下文</td>\n<td align=\"left\">内核栈、硬件上下文</td>\n<td align=\"left\">硬件上下文</td>\n</tr>\n<tr>\n<td align=\"left\">切换内容的保存</td>\n<td align=\"left\">保存于内核栈中</td>\n<td align=\"left\">保存于内核栈中</td>\n<td align=\"left\">保存于用户自己的变量（用户栈或堆）中</td>\n</tr>\n<tr>\n<td align=\"left\">切换过程</td>\n<td align=\"left\">用户态 - 内核态 - 用户态</td>\n<td align=\"left\">用户态 - 内核态- 用户态</td>\n<td align=\"left\">用户态（没有陷入内核态）</td>\n</tr>\n<tr>\n<td align=\"left\">切换效率</td>\n<td align=\"left\">低</td>\n<td align=\"left\">中</td>\n<td align=\"left\">高</td>\n</tr>\n</tbody></table>\n<h2 id=\"通用库-Oslo\"><a href=\"#通用库-Oslo\" class=\"headerlink\" title=\"通用库 Oslo\"></a>通用库 Oslo</h2><p>为了降低代码的冗余度，OpenStack 社区创建了 Oslo 项目，从 OpenStack 代码中提取公共的部分，构建出一批 lib 库以供 OpenStack 其他项目使用。Neutron 使用了 Oslo 中的 lib。</p>"},{"title":"OpenStack Neutron -- Neutron 的网络实现模型","date":"2019-05-16T06:26:17.000Z","updated":"2019-05-16T06:26:17.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-05-16.jpg","_content":"承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。\n<!--more-->\n\n## 计算节点\n\n一个基于 OpenStack 的云系统会有很多计算节点，一个计算节点就是一个 Host。一个计算节点里包含多个 VM。计算节点的网络模型主要服务于二层网络，用于构建各种类型的二层网络。而二层网络通信需要 Bridge/Switch（这里可以将 Bridge/Switch 理解为同一个概念）。只考虑网络层面，计算节点可分为 2 层：用户网络层、本地网络层。\n\n### 用户网络层\n\n用户网络层（User Network），指的是 OpenStack 的用户创建的网络，也即外部网络，这个外部网络是相对于 Host 内部网络而言的。用户网络层对应的 Bridge 是 br-ethx （对应Flat、VLAN 等非隧道型二层网络）或者 br-tun （对应 VXLAN、GRE 等隧道型二层网络），其实现载体一般来说是 OVS （Open vSwitch）。用户网络层实现的是用户网络和本地网络之间的相互转换。**用户网络层是对本地网络层的一个屏蔽，即不管用户网络采用什么技术（如 VXLAN、GRE 等），本地网络永远感知的仅仅是一个技术：VLAN**。\n\n### 本地网络层\n\n本地网络指的是 Host 内部的本地网络。本地网络只要感知一种技术：VLAN。本地网络还可以分为两层：安全层、Bridge 层。\n\n#### qbr\n\nqbr 的实现载体是 Linux Bridge，它仅仅负责安全相关设置，所以称之为安全层。\n\n#### br-int\n\nbr-int 的实现载体一般是 OVS，她负责内部交换，所以称之为 Bridge 层。**Bridge 层是对 VM 层的一个屏蔽。从 VM 发出的 Untag 报文，被 Bridge 层转换为 Tag 报文转发到 br-ethx/br-tun；从 br-ethx/br-tun 转发到 br-int 的 Tag 报文，被 br-int 剥去 Tag，变成 Untag 报文，然后再转发给 VM**。\n\n位于同一个 Host 的本地网络中的不同 VM 之间的通信，他们经过本地层网络（即经过 br-int）即可完成，无需通再往上通过用户网络层。\n\n## 网络节点\n\n在计算节点中，同属一个二层网络的 VM 可以自由进行二层通信。若要访问二层网络之外的网络，则需要网络节点。Neutron 除了在网络节点部署 Router （此路由器为虚拟路由器，利用了 Linux 内核功能）之外，还部署了 DHCP Server 等服务。从网络视角看，网络节点可分为 4 层：用户网络层、本地网络层、网络服务层和外部网络层。前两层与计算节点几乎相同。\n\n### 网络服务层\n\n网络服务层为计算节点的 VM 提供网络服务，典型的服务有 DHCP Service 和 Router Service。关于 DHCP 有如下概念：\n\n1. Neutron 的 DHCP Service，采用的是 dnsmasq 进程（轻量级服务进程，可以提供 dns、dhcp、tftp等服务）\n2. 一个网络一个 DHCP Service\n3. 由于存在多个 DHCP Service （多个 dnsmasq 进程），Neutron 采用的是 namespace 方法做隔离，即一个 DHCP Service 运行在一个 namespace 中。\n\n网络服务层中的 Router 本质上是 Linux 内核模块。Router 做路由转发外，还提供 SNAT/DNAT 功能。为了达到隔离的目的，每个 Router 运行在一个 namespace 中。准确地说，Neutron 创建了 namespace，并且在 namespace 中开启了路由转发功能。\n\n> 1. SNAT：Source Network Address Translation，源地址路由转换；DNAT：Destination Network Address Translation，目的地址路由转换\n> 2. OpenStack Juno 版本引入了 DVR 特性，DVR 部署在计算节点上。计算节点访问 Internet，不必经过网络节点，直接从计算节点的 DVR 即可访问\n\n### 外部服务层\n\n外部服务层包含 br-ex 和 Router。Router 是与外部网络联通的主体，而 br-ex 则是将 Router 对接到网络节点的物理网口。br-ex 相当于一个 Hub，而实际上 br-ex 是一个 Bridge，一般选用 OVS。\n\n## 控制节点\n\n计算机节点与网络节点承担 OpenStack 中网络构建的任务，实现网络功能的是两个节点中的各个 Bridge、DHCP Service 和 Router 等虚拟网元。控制节点并不实现具体网络功能，只是对各种虚拟网元进行管理和控制。控制节点部署着 OpenStack 的各种进程，对于 Neutron 来说，它的进程名为 neutron-server。\n\nNeutron 中的控制功能不仅仅体现于一个控制节点，还包含计算节点和网络节点中的各种 Agent。控制节点中的 Neutron 进程只是 Neutron 控制系统的一部分。\n\n控制节点的 Neutron 进程通过 RESTful 或者 CLI （Command Line Interface，命令行）接口接收外部请求，通过 RPC 与 Agent 进行交互。Neutron 进程与各个 Agent 进程共同完成管理控制任务。\n\n## 总结\n\n从部署角度来说，Neutron 分为三类节点：控制节点、网络节点和计算节点。**网络节点和计算节点为 VM 构建了具体网络，控制节点则对这些网络进行管理。**\n\n控制节点的 Neutron 进程与网络节点、计算节点的各个 Agent 进程互相配合，对内完成对网络节点、控制节点**？**（书上是控制节点，但是感觉应该是计算节点）中虚拟网元的配置管理，对外提供 RESTful 等服务接口。Neutron 进程与 Agent 进程之间的通信协议是 RPC（Remote Procedure Call，远程过程调用）。\n\n计算节点中的各个 Bridge 构建了 Neutron 中的 Local、Flat、VLAN、GRE、VXLAN、Geneve 6 种二层网络。br-ethx 与 br-tun 对外构建用户网络，内对则为 br-int 屏蔽用户网络的各种差异，将不同类型的用户网络转换为 VLAN 网络。br-int 在 Host 内部为各个 VM 构建了一个本地网络。qbr 为 br-int （也是为各个 VM）提供辅助的安全功能。\n\n网络节点为 Neutron 提供了其他网络服务，比如 DHCP Service 等。网络节点中的 Router，则提供了三层服务，除了提供普通的路由转发功能外，还提供了 SNAT/DNAT 等功能。\n\nNeutron 的三类节点互相配合，共同完成了 Neutron 对外宣称的使命：NaaS（Network as a Service，网络即服务）。","source":"_posts/OpenStack-Neutron-Network-Model.md","raw":"---\ntitle: OpenStack Neutron -- Neutron 的网络实现模型\ndate: 2019-05-16 14:26:17\nupdated: 2019-05-16 14:26:17\ncategory: OpenStack\ntags: [Neutron]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-05-16.jpg\n---\n承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。\n<!--more-->\n\n## 计算节点\n\n一个基于 OpenStack 的云系统会有很多计算节点，一个计算节点就是一个 Host。一个计算节点里包含多个 VM。计算节点的网络模型主要服务于二层网络，用于构建各种类型的二层网络。而二层网络通信需要 Bridge/Switch（这里可以将 Bridge/Switch 理解为同一个概念）。只考虑网络层面，计算节点可分为 2 层：用户网络层、本地网络层。\n\n### 用户网络层\n\n用户网络层（User Network），指的是 OpenStack 的用户创建的网络，也即外部网络，这个外部网络是相对于 Host 内部网络而言的。用户网络层对应的 Bridge 是 br-ethx （对应Flat、VLAN 等非隧道型二层网络）或者 br-tun （对应 VXLAN、GRE 等隧道型二层网络），其实现载体一般来说是 OVS （Open vSwitch）。用户网络层实现的是用户网络和本地网络之间的相互转换。**用户网络层是对本地网络层的一个屏蔽，即不管用户网络采用什么技术（如 VXLAN、GRE 等），本地网络永远感知的仅仅是一个技术：VLAN**。\n\n### 本地网络层\n\n本地网络指的是 Host 内部的本地网络。本地网络只要感知一种技术：VLAN。本地网络还可以分为两层：安全层、Bridge 层。\n\n#### qbr\n\nqbr 的实现载体是 Linux Bridge，它仅仅负责安全相关设置，所以称之为安全层。\n\n#### br-int\n\nbr-int 的实现载体一般是 OVS，她负责内部交换，所以称之为 Bridge 层。**Bridge 层是对 VM 层的一个屏蔽。从 VM 发出的 Untag 报文，被 Bridge 层转换为 Tag 报文转发到 br-ethx/br-tun；从 br-ethx/br-tun 转发到 br-int 的 Tag 报文，被 br-int 剥去 Tag，变成 Untag 报文，然后再转发给 VM**。\n\n位于同一个 Host 的本地网络中的不同 VM 之间的通信，他们经过本地层网络（即经过 br-int）即可完成，无需通再往上通过用户网络层。\n\n## 网络节点\n\n在计算节点中，同属一个二层网络的 VM 可以自由进行二层通信。若要访问二层网络之外的网络，则需要网络节点。Neutron 除了在网络节点部署 Router （此路由器为虚拟路由器，利用了 Linux 内核功能）之外，还部署了 DHCP Server 等服务。从网络视角看，网络节点可分为 4 层：用户网络层、本地网络层、网络服务层和外部网络层。前两层与计算节点几乎相同。\n\n### 网络服务层\n\n网络服务层为计算节点的 VM 提供网络服务，典型的服务有 DHCP Service 和 Router Service。关于 DHCP 有如下概念：\n\n1. Neutron 的 DHCP Service，采用的是 dnsmasq 进程（轻量级服务进程，可以提供 dns、dhcp、tftp等服务）\n2. 一个网络一个 DHCP Service\n3. 由于存在多个 DHCP Service （多个 dnsmasq 进程），Neutron 采用的是 namespace 方法做隔离，即一个 DHCP Service 运行在一个 namespace 中。\n\n网络服务层中的 Router 本质上是 Linux 内核模块。Router 做路由转发外，还提供 SNAT/DNAT 功能。为了达到隔离的目的，每个 Router 运行在一个 namespace 中。准确地说，Neutron 创建了 namespace，并且在 namespace 中开启了路由转发功能。\n\n> 1. SNAT：Source Network Address Translation，源地址路由转换；DNAT：Destination Network Address Translation，目的地址路由转换\n> 2. OpenStack Juno 版本引入了 DVR 特性，DVR 部署在计算节点上。计算节点访问 Internet，不必经过网络节点，直接从计算节点的 DVR 即可访问\n\n### 外部服务层\n\n外部服务层包含 br-ex 和 Router。Router 是与外部网络联通的主体，而 br-ex 则是将 Router 对接到网络节点的物理网口。br-ex 相当于一个 Hub，而实际上 br-ex 是一个 Bridge，一般选用 OVS。\n\n## 控制节点\n\n计算机节点与网络节点承担 OpenStack 中网络构建的任务，实现网络功能的是两个节点中的各个 Bridge、DHCP Service 和 Router 等虚拟网元。控制节点并不实现具体网络功能，只是对各种虚拟网元进行管理和控制。控制节点部署着 OpenStack 的各种进程，对于 Neutron 来说，它的进程名为 neutron-server。\n\nNeutron 中的控制功能不仅仅体现于一个控制节点，还包含计算节点和网络节点中的各种 Agent。控制节点中的 Neutron 进程只是 Neutron 控制系统的一部分。\n\n控制节点的 Neutron 进程通过 RESTful 或者 CLI （Command Line Interface，命令行）接口接收外部请求，通过 RPC 与 Agent 进行交互。Neutron 进程与各个 Agent 进程共同完成管理控制任务。\n\n## 总结\n\n从部署角度来说，Neutron 分为三类节点：控制节点、网络节点和计算节点。**网络节点和计算节点为 VM 构建了具体网络，控制节点则对这些网络进行管理。**\n\n控制节点的 Neutron 进程与网络节点、计算节点的各个 Agent 进程互相配合，对内完成对网络节点、控制节点**？**（书上是控制节点，但是感觉应该是计算节点）中虚拟网元的配置管理，对外提供 RESTful 等服务接口。Neutron 进程与 Agent 进程之间的通信协议是 RPC（Remote Procedure Call，远程过程调用）。\n\n计算节点中的各个 Bridge 构建了 Neutron 中的 Local、Flat、VLAN、GRE、VXLAN、Geneve 6 种二层网络。br-ethx 与 br-tun 对外构建用户网络，内对则为 br-int 屏蔽用户网络的各种差异，将不同类型的用户网络转换为 VLAN 网络。br-int 在 Host 内部为各个 VM 构建了一个本地网络。qbr 为 br-int （也是为各个 VM）提供辅助的安全功能。\n\n网络节点为 Neutron 提供了其他网络服务，比如 DHCP Service 等。网络节点中的 Router，则提供了三层服务，除了提供普通的路由转发功能外，还提供了 SNAT/DNAT 等功能。\n\nNeutron 的三类节点互相配合，共同完成了 Neutron 对外宣称的使命：NaaS（Network as a Service，网络即服务）。","slug":"OpenStack-Neutron-Network-Model","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsim000rw8vo7wgq6s7t","content":"<p>承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"计算节点\"><a href=\"#计算节点\" class=\"headerlink\" title=\"计算节点\"></a>计算节点</h2><p>一个基于 OpenStack 的云系统会有很多计算节点，一个计算节点就是一个 Host。一个计算节点里包含多个 VM。计算节点的网络模型主要服务于二层网络，用于构建各种类型的二层网络。而二层网络通信需要 Bridge/Switch（这里可以将 Bridge/Switch 理解为同一个概念）。只考虑网络层面，计算节点可分为 2 层：用户网络层、本地网络层。</p>\n<h3 id=\"用户网络层\"><a href=\"#用户网络层\" class=\"headerlink\" title=\"用户网络层\"></a>用户网络层</h3><p>用户网络层（User Network），指的是 OpenStack 的用户创建的网络，也即外部网络，这个外部网络是相对于 Host 内部网络而言的。用户网络层对应的 Bridge 是 br-ethx （对应Flat、VLAN 等非隧道型二层网络）或者 br-tun （对应 VXLAN、GRE 等隧道型二层网络），其实现载体一般来说是 OVS （Open vSwitch）。用户网络层实现的是用户网络和本地网络之间的相互转换。<strong>用户网络层是对本地网络层的一个屏蔽，即不管用户网络采用什么技术（如 VXLAN、GRE 等），本地网络永远感知的仅仅是一个技术：VLAN</strong>。</p>\n<h3 id=\"本地网络层\"><a href=\"#本地网络层\" class=\"headerlink\" title=\"本地网络层\"></a>本地网络层</h3><p>本地网络指的是 Host 内部的本地网络。本地网络只要感知一种技术：VLAN。本地网络还可以分为两层：安全层、Bridge 层。</p>\n<h4 id=\"qbr\"><a href=\"#qbr\" class=\"headerlink\" title=\"qbr\"></a>qbr</h4><p>qbr 的实现载体是 Linux Bridge，它仅仅负责安全相关设置，所以称之为安全层。</p>\n<h4 id=\"br-int\"><a href=\"#br-int\" class=\"headerlink\" title=\"br-int\"></a>br-int</h4><p>br-int 的实现载体一般是 OVS，她负责内部交换，所以称之为 Bridge 层。<strong>Bridge 层是对 VM 层的一个屏蔽。从 VM 发出的 Untag 报文，被 Bridge 层转换为 Tag 报文转发到 br-ethx/br-tun；从 br-ethx/br-tun 转发到 br-int 的 Tag 报文，被 br-int 剥去 Tag，变成 Untag 报文，然后再转发给 VM</strong>。</p>\n<p>位于同一个 Host 的本地网络中的不同 VM 之间的通信，他们经过本地层网络（即经过 br-int）即可完成，无需通再往上通过用户网络层。</p>\n<h2 id=\"网络节点\"><a href=\"#网络节点\" class=\"headerlink\" title=\"网络节点\"></a>网络节点</h2><p>在计算节点中，同属一个二层网络的 VM 可以自由进行二层通信。若要访问二层网络之外的网络，则需要网络节点。Neutron 除了在网络节点部署 Router （此路由器为虚拟路由器，利用了 Linux 内核功能）之外，还部署了 DHCP Server 等服务。从网络视角看，网络节点可分为 4 层：用户网络层、本地网络层、网络服务层和外部网络层。前两层与计算节点几乎相同。</p>\n<h3 id=\"网络服务层\"><a href=\"#网络服务层\" class=\"headerlink\" title=\"网络服务层\"></a>网络服务层</h3><p>网络服务层为计算节点的 VM 提供网络服务，典型的服务有 DHCP Service 和 Router Service。关于 DHCP 有如下概念：</p>\n<ol>\n<li>Neutron 的 DHCP Service，采用的是 dnsmasq 进程（轻量级服务进程，可以提供 dns、dhcp、tftp等服务）</li>\n<li>一个网络一个 DHCP Service</li>\n<li>由于存在多个 DHCP Service （多个 dnsmasq 进程），Neutron 采用的是 namespace 方法做隔离，即一个 DHCP Service 运行在一个 namespace 中。</li>\n</ol>\n<p>网络服务层中的 Router 本质上是 Linux 内核模块。Router 做路由转发外，还提供 SNAT/DNAT 功能。为了达到隔离的目的，每个 Router 运行在一个 namespace 中。准确地说，Neutron 创建了 namespace，并且在 namespace 中开启了路由转发功能。</p>\n<blockquote>\n<ol>\n<li>SNAT：Source Network Address Translation，源地址路由转换；DNAT：Destination Network Address Translation，目的地址路由转换</li>\n<li>OpenStack Juno 版本引入了 DVR 特性，DVR 部署在计算节点上。计算节点访问 Internet，不必经过网络节点，直接从计算节点的 DVR 即可访问</li>\n</ol>\n</blockquote>\n<h3 id=\"外部服务层\"><a href=\"#外部服务层\" class=\"headerlink\" title=\"外部服务层\"></a>外部服务层</h3><p>外部服务层包含 br-ex 和 Router。Router 是与外部网络联通的主体，而 br-ex 则是将 Router 对接到网络节点的物理网口。br-ex 相当于一个 Hub，而实际上 br-ex 是一个 Bridge，一般选用 OVS。</p>\n<h2 id=\"控制节点\"><a href=\"#控制节点\" class=\"headerlink\" title=\"控制节点\"></a>控制节点</h2><p>计算机节点与网络节点承担 OpenStack 中网络构建的任务，实现网络功能的是两个节点中的各个 Bridge、DHCP Service 和 Router 等虚拟网元。控制节点并不实现具体网络功能，只是对各种虚拟网元进行管理和控制。控制节点部署着 OpenStack 的各种进程，对于 Neutron 来说，它的进程名为 neutron-server。</p>\n<p>Neutron 中的控制功能不仅仅体现于一个控制节点，还包含计算节点和网络节点中的各种 Agent。控制节点中的 Neutron 进程只是 Neutron 控制系统的一部分。</p>\n<p>控制节点的 Neutron 进程通过 RESTful 或者 CLI （Command Line Interface，命令行）接口接收外部请求，通过 RPC 与 Agent 进行交互。Neutron 进程与各个 Agent 进程共同完成管理控制任务。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从部署角度来说，Neutron 分为三类节点：控制节点、网络节点和计算节点。<strong>网络节点和计算节点为 VM 构建了具体网络，控制节点则对这些网络进行管理。</strong></p>\n<p>控制节点的 Neutron 进程与网络节点、计算节点的各个 Agent 进程互相配合，对内完成对网络节点、控制节点<strong>？</strong>（书上是控制节点，但是感觉应该是计算节点）中虚拟网元的配置管理，对外提供 RESTful 等服务接口。Neutron 进程与 Agent 进程之间的通信协议是 RPC（Remote Procedure Call，远程过程调用）。</p>\n<p>计算节点中的各个 Bridge 构建了 Neutron 中的 Local、Flat、VLAN、GRE、VXLAN、Geneve 6 种二层网络。br-ethx 与 br-tun 对外构建用户网络，内对则为 br-int 屏蔽用户网络的各种差异，将不同类型的用户网络转换为 VLAN 网络。br-int 在 Host 内部为各个 VM 构建了一个本地网络。qbr 为 br-int （也是为各个 VM）提供辅助的安全功能。</p>\n<p>网络节点为 Neutron 提供了其他网络服务，比如 DHCP Service 等。网络节点中的 Router，则提供了三层服务，除了提供普通的路由转发功能外，还提供了 SNAT/DNAT 等功能。</p>\n<p>Neutron 的三类节点互相配合，共同完成了 Neutron 对外宣称的使命：NaaS（Network as a Service，网络即服务）。</p>\n","site":{"data":{}},"length":2652,"excerpt":"<p>承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。</p>","more":"<h2 id=\"计算节点\"><a href=\"#计算节点\" class=\"headerlink\" title=\"计算节点\"></a>计算节点</h2><p>一个基于 OpenStack 的云系统会有很多计算节点，一个计算节点就是一个 Host。一个计算节点里包含多个 VM。计算节点的网络模型主要服务于二层网络，用于构建各种类型的二层网络。而二层网络通信需要 Bridge/Switch（这里可以将 Bridge/Switch 理解为同一个概念）。只考虑网络层面，计算节点可分为 2 层：用户网络层、本地网络层。</p>\n<h3 id=\"用户网络层\"><a href=\"#用户网络层\" class=\"headerlink\" title=\"用户网络层\"></a>用户网络层</h3><p>用户网络层（User Network），指的是 OpenStack 的用户创建的网络，也即外部网络，这个外部网络是相对于 Host 内部网络而言的。用户网络层对应的 Bridge 是 br-ethx （对应Flat、VLAN 等非隧道型二层网络）或者 br-tun （对应 VXLAN、GRE 等隧道型二层网络），其实现载体一般来说是 OVS （Open vSwitch）。用户网络层实现的是用户网络和本地网络之间的相互转换。<strong>用户网络层是对本地网络层的一个屏蔽，即不管用户网络采用什么技术（如 VXLAN、GRE 等），本地网络永远感知的仅仅是一个技术：VLAN</strong>。</p>\n<h3 id=\"本地网络层\"><a href=\"#本地网络层\" class=\"headerlink\" title=\"本地网络层\"></a>本地网络层</h3><p>本地网络指的是 Host 内部的本地网络。本地网络只要感知一种技术：VLAN。本地网络还可以分为两层：安全层、Bridge 层。</p>\n<h4 id=\"qbr\"><a href=\"#qbr\" class=\"headerlink\" title=\"qbr\"></a>qbr</h4><p>qbr 的实现载体是 Linux Bridge，它仅仅负责安全相关设置，所以称之为安全层。</p>\n<h4 id=\"br-int\"><a href=\"#br-int\" class=\"headerlink\" title=\"br-int\"></a>br-int</h4><p>br-int 的实现载体一般是 OVS，她负责内部交换，所以称之为 Bridge 层。<strong>Bridge 层是对 VM 层的一个屏蔽。从 VM 发出的 Untag 报文，被 Bridge 层转换为 Tag 报文转发到 br-ethx/br-tun；从 br-ethx/br-tun 转发到 br-int 的 Tag 报文，被 br-int 剥去 Tag，变成 Untag 报文，然后再转发给 VM</strong>。</p>\n<p>位于同一个 Host 的本地网络中的不同 VM 之间的通信，他们经过本地层网络（即经过 br-int）即可完成，无需通再往上通过用户网络层。</p>\n<h2 id=\"网络节点\"><a href=\"#网络节点\" class=\"headerlink\" title=\"网络节点\"></a>网络节点</h2><p>在计算节点中，同属一个二层网络的 VM 可以自由进行二层通信。若要访问二层网络之外的网络，则需要网络节点。Neutron 除了在网络节点部署 Router （此路由器为虚拟路由器，利用了 Linux 内核功能）之外，还部署了 DHCP Server 等服务。从网络视角看，网络节点可分为 4 层：用户网络层、本地网络层、网络服务层和外部网络层。前两层与计算节点几乎相同。</p>\n<h3 id=\"网络服务层\"><a href=\"#网络服务层\" class=\"headerlink\" title=\"网络服务层\"></a>网络服务层</h3><p>网络服务层为计算节点的 VM 提供网络服务，典型的服务有 DHCP Service 和 Router Service。关于 DHCP 有如下概念：</p>\n<ol>\n<li>Neutron 的 DHCP Service，采用的是 dnsmasq 进程（轻量级服务进程，可以提供 dns、dhcp、tftp等服务）</li>\n<li>一个网络一个 DHCP Service</li>\n<li>由于存在多个 DHCP Service （多个 dnsmasq 进程），Neutron 采用的是 namespace 方法做隔离，即一个 DHCP Service 运行在一个 namespace 中。</li>\n</ol>\n<p>网络服务层中的 Router 本质上是 Linux 内核模块。Router 做路由转发外，还提供 SNAT/DNAT 功能。为了达到隔离的目的，每个 Router 运行在一个 namespace 中。准确地说，Neutron 创建了 namespace，并且在 namespace 中开启了路由转发功能。</p>\n<blockquote>\n<ol>\n<li>SNAT：Source Network Address Translation，源地址路由转换；DNAT：Destination Network Address Translation，目的地址路由转换</li>\n<li>OpenStack Juno 版本引入了 DVR 特性，DVR 部署在计算节点上。计算节点访问 Internet，不必经过网络节点，直接从计算节点的 DVR 即可访问</li>\n</ol>\n</blockquote>\n<h3 id=\"外部服务层\"><a href=\"#外部服务层\" class=\"headerlink\" title=\"外部服务层\"></a>外部服务层</h3><p>外部服务层包含 br-ex 和 Router。Router 是与外部网络联通的主体，而 br-ex 则是将 Router 对接到网络节点的物理网口。br-ex 相当于一个 Hub，而实际上 br-ex 是一个 Bridge，一般选用 OVS。</p>\n<h2 id=\"控制节点\"><a href=\"#控制节点\" class=\"headerlink\" title=\"控制节点\"></a>控制节点</h2><p>计算机节点与网络节点承担 OpenStack 中网络构建的任务，实现网络功能的是两个节点中的各个 Bridge、DHCP Service 和 Router 等虚拟网元。控制节点并不实现具体网络功能，只是对各种虚拟网元进行管理和控制。控制节点部署着 OpenStack 的各种进程，对于 Neutron 来说，它的进程名为 neutron-server。</p>\n<p>Neutron 中的控制功能不仅仅体现于一个控制节点，还包含计算节点和网络节点中的各种 Agent。控制节点中的 Neutron 进程只是 Neutron 控制系统的一部分。</p>\n<p>控制节点的 Neutron 进程通过 RESTful 或者 CLI （Command Line Interface，命令行）接口接收外部请求，通过 RPC 与 Agent 进行交互。Neutron 进程与各个 Agent 进程共同完成管理控制任务。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从部署角度来说，Neutron 分为三类节点：控制节点、网络节点和计算节点。<strong>网络节点和计算节点为 VM 构建了具体网络，控制节点则对这些网络进行管理。</strong></p>\n<p>控制节点的 Neutron 进程与网络节点、计算节点的各个 Agent 进程互相配合，对内完成对网络节点、控制节点<strong>？</strong>（书上是控制节点，但是感觉应该是计算节点）中虚拟网元的配置管理，对外提供 RESTful 等服务接口。Neutron 进程与 Agent 进程之间的通信协议是 RPC（Remote Procedure Call，远程过程调用）。</p>\n<p>计算节点中的各个 Bridge 构建了 Neutron 中的 Local、Flat、VLAN、GRE、VXLAN、Geneve 6 种二层网络。br-ethx 与 br-tun 对外构建用户网络，内对则为 br-int 屏蔽用户网络的各种差异，将不同类型的用户网络转换为 VLAN 网络。br-int 在 Host 内部为各个 VM 构建了一个本地网络。qbr 为 br-int （也是为各个 VM）提供辅助的安全功能。</p>\n<p>网络节点为 Neutron 提供了其他网络服务，比如 DHCP Service 等。网络节点中的 Router，则提供了三层服务，除了提供普通的路由转发功能外，还提供了 SNAT/DNAT 等功能。</p>\n<p>Neutron 的三类节点互相配合，共同完成了 Neutron 对外宣称的使命：NaaS（Network as a Service，网络即服务）。</p>"},{"title":"OpenStack Neutron -- Neutron 的资源模型","date":"2019-05-22T07:06:13.000Z","updated":"2019-05-22T07:06:13.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-05-22.jpg","_content":"\nNeutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。\n<!--more-->\n\n## Neutron 资源的租户隔离\n\n租户隔离指的是将不同的用户隔离开来，用户对其他用户无感知。租户隔离有三种含义：管理面的隔离、数据面的隔离和故障面的隔离。\n\n### 管理面的隔离\n\n管里面的隔离，指的是”管理权限“的隔离，每个租户只知道他自己的网络，对其他网络毫无感觉。\n\n### 数据面的隔离\n\n数据面的隔离，指的是数据转发的隔离。不同租户之间的网络，一般来说是不能互通的。从管理权限的角度，一个租户感知不到另外一个租户的网络。不仅无法感知，而且还可以”重复“。从这个角度来说，数据面的隔离是为了复用。\n\n### 故障面的隔离\n\n故障隔离，主要是管里面的故障、数据面的故障要做到租户隔离，而物理资源层面，无法真正做到故障隔离。Neutron 在故障面的目标不是租户隔离，而是容错——尽量保证不受故障影响。\n\n## Network\n\nNetwork 是 Neutron 的一个二层网络的资源模型，它支持的网络类型有：Local、Flat、VLAN、VXLAN、GRE、Geneve 等。其中，Local 仅仅是一个主机内的网络类型，只会用于测试，不会用于生产环境。VXLAN、GRE、Geneve 属于隧道型网络，Flat 和 VLAN 属于非隧道型网络。一般来说，这些网络内的虚拟机之间的二层通信并不需要用到路由器。\n\n### 运营商网络和租户网络\n\n由租户创建并管理的网络，Neutron 称之为租户网络。有时候，Neutron 还需要创建一个网络来映射外部网络，这个网络称为运营商网络（Provider Network）。\n\n运营商网络与租户网络，从模型角度来讲，都是 Neutron 的资源模型 Network。两者的区别如下：\n\n1. 管理的权限和角色不同。租户创建的网络，就是租户网络，而运营商管理员创建的网络，就是运营商网络\n2. 创建网络时，传入的参数不同。创建运营商网络时，需要传入 provider:network_type、provider:physical_network、provider:segmentation_id 三个参数，而创建租户网络时，没有办法传入这三个参数，它们是由 OpenStack 在管理员配置的范围内自动分配的\n\nNeutron 创建了一个网络，如果这个网络只是为了映射（匹配）另外一个网络，而且这个被映射的网络不在 Neutron 的管理范围内，这样的场景就是运营商网络的一般化使用场景。Neutron 创建的这个网络，也称为运营商网络。运营商网络可以认为是运营商的某个物理网络在 OpenStack （Neutron）上的延伸。\n\n### 物理网络\n\n一般来说，物理网络可以理解为运营商网络需要匹配的那个网络。物理网络的实际意义如下：\n\n1. 非隧道型网络角度\n    - 对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络的名称，这个含义是为了方便阅读和理解\n    - 无论是对于运营商网络还是租户网络，物理网络都意味着 br-ehtx 的选择（背后是主机网卡的选择），这个含义是 Neutron 所需要的，因此创建运营商网络时，需要直接传入这个参数，创建租户网络时，需要间接传入这个参数\n2. 隧道型网络角度\n    - 对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络名称，之歌含义只为了方便阅读和理解，对 Neutron 无意义\n\n## Trunk Networking\n\nTrunk Networking 是 OpenStack Newton 版本所增加的特性，目的是为了支持 VLAN aware VM。一般情况下，VM 发送和接收的报文都是不带 VLAN Tag 的，不过有时候，VM 也期望能够发送和接收带有 VLAN Tag 的报文，这种情形即可称为 VLAN aware VM。\n\n### Bridge 的 VLAN 接口模式\n\n一个 Bridge 可以抽象为两大部分：交换模块（基于 VLAN ID 做报文交换）和接口。\n\nBridge 接口关于 VLAN ID 的处理方式有三种模式：Access、Trunk 和 Hybrid。\n\n#### Access 接口模式\n\nAccess 模式，在报文入接口，对于 Tag 报文，直接丢弃，对于 Untag 报文，则打上 Default VID Tag 后送入交换模块（进行 VLAN 交换）。在报文出接口，先将报文去除 Tag，然后再从接口转发。\n\n#### Trunk 接口模式\n\nTrunk 模式，首先要配置允许进入接口的 VLAN ID 列表（范围）。在列表范围内的 VLAN ID 可以进入端口，其他的则不允许进入。\n\n#### Hybrid 接口模式\n\nHybrid 模式，在 Trunk 模式的基础上又多了一部分内容。Trunk 模式，在报文出接口时，如果 VLAN ID 等于 Default ID，那么 VLAN Tag 会去除。而 Hybrid 模式，允许配置哪些 VLAN ID 的报文，在出接口时，需要去除 VLAN Tag，比如配置 VLAN ID 在 40 ~ 50 这个范围内的报文，当其出接口时，需要去除 VLAN Tag。\n\n> 上述描述中的几个名词解释：\n>\n> - Tag 报文：指的是报文中有 VLAN ID，简称 Tag\n> - Untag 报文：指的是报文中没有 VLAN ID，简称 Untag\n> - Default ID：端口默认 VLAN ID。Bridge 端口的默认 VLAN ID 为 “1”。这个默认值可以被修改\n\n### VLAN aware VM 与 Trunk Networking\n\nVM 能够发送和接收带有 VLAN Tag 的报文，这种情形称作 VLAN aware VM。在没有引入 Trunk Networking 特性之前，Neutron 的模型设计中有这样的约束：一个 Port 只能属于一个 Network。假设一个 VM 只有一个 Port，如果想让 VM 具备 VLAN aware 特性，就意味着这个 Port 必须要属于多个 Network，这与 Neutron 的约束是矛盾的。这里所涉及的 Port，可以简单理解为 VM 的虚拟网口（virtual Network Interface Card，vNIC）。为了解决这个问题，Neutron 提出了 Trunk Networking 方案，主要解决实现 VLAN aware 的以下问题：\n\n1. VM aware 的 VLAN ID，在 Host 内部不能冲突\n2. VM aware 的 VLAN ID，不需要在 Host 之间的物理网络透传（不能要求物理网络透传该 VLAN ID，因为物理网络很可能不在 Neutron 的管理范围内）\n3. 不要打破原来的 Network、Port 模型，否则会引发 Neutron 的源代码大量修改\n\n#### Trunk Networking 的实现模型\n\n为了解决 VM aware 的 VLAN ID 与 Host 内部的 VLAN ID 冲突的问题， Neutron 引入了一个 Trunk Bridge。Trunk Bridge 仍然是一个普通的 Bridge，只不过接口模式有所不同。Neutron 利用 br-trunk 做 VLAN ID 的转换，就可以解决上述的 VLAN ID 冲突的问题。\n\n#### Trunk Networking 的资源模型\n\nNeutron 最终采取的模型不是“一个 Port 对应多个 Network”，而是增加了一个模型，名为 trunk，这个模型里最核心的就是两个字段：Parent Port 和 Sub Port List，如下表所示：\n\n|   名称    |  类型  |          描述          |\n| :-------: | :----: | :--------------------: |\n|  port_id  | stirng |       父端口 ID        |\n| sub_ports | array  | Trunk 关联的子端口列表 |\n\n这个模型在不同的视角有不同的解读，并解决了对应的问题。\n\n从 VM 视角，它仍然相当于一个端口对接多个网络，因为它的端口可以发送带 VLAN ID 的报文，每个 VLAN ID 对应一个网络。这解决了 VM 的端口不能太多的问题。\n\n从 Neutron 模型的角度，Trunk 模型利用一个 Parent Port （对应字段为 port_id）和多个 Sub Port（对应字段为 sub_ports）与不同的 Network 相对应。Parent Port 与 Sub Port 对应的都是 Port 模型，它们与 Network 的关系仍是一个 Port 对应一个 Network。\n\nTrunk Networking 方案没有修改原来的实现模型和资源模型，而是在原来的实现模型中引入了 Trunk Bridge。在原来的资源模型中引入了 Trunk 资源模型，对原来的代码修改较少，就支持了 VLAN aware VM 特性。\n\n## Subnet\n\nSubnet（子网）在一般概念中，有两个基本含义：\n\n1. 这个子网的网段（CIDR）和 IP 版本\n2. 这个子网的路由信息（含默认路由）\n\nNeutron 中，Subnet 模型除了标识 CIDR、IP version 这样的纯逻辑资源外，为了解决 VM 的 IP 地址分配和 DNS 设置问题，还蕴含了管理功能，这些管理功能又称为 IP 的核心服务。\n\n### IP 核心网络服务\n\nIP 核心网络服务（IP Core Network Services），又称 DDI 服务，包括：DNS、DHCP 和 IPAM。这三个服务是所有 IP 网络及应用系统得以顺利运行的基础。\n\n## Port\n\n如果说 Network 是 Neutron 模型中的“根”，那么 Port 则是 Neutron 模型中的“灵魂”，尤其是对于三层转发来说。因为无论 Neutron 的模型怎么设计，它的三层转发总归是绕不开 IP 地址，而承载 IP 地址的就是 Port。\n\nPort 是一个逻辑模型，但是也可以理解为其代表一个虚拟网口。所以一个 VM 需要绑定 Port，一个 Router 也需要绑定 Port。作为一个虚拟网口，Port 具备两个基本属性：IP 地址和 MAC 地址。一个 Port 可以有多个 IP 地址，但在一般情况下，一个 Port 只有一个 MAC 地址。但是 Port 模型中有一个 allowed_address_pairs字段，允许多个绑定多个 MAC 地址，其典型的应用场景为 Antispoofing（一种识别和删除有错误源地址的数据包技术）。\n\nNetwork、Subnet、Port 三者的关系如下：\n\n一个 Network 可以有多个 Subnet，一个 Subnet 只能归属一个 Network。同时一个  Network 可以有多个 Port，而一个 Port 可以与其所在的 Network 中的所有 Subnet 相关联。当然，一个 Subnet 也可以有多个 Port。\n\n## Router\n\n如果说 Port 是 Neutron 模型的“灵魂”，那么 Router 就是 Neutron 模型的 “发动机”，它承担着路由转发的功能。Router 可以简单地抽象为三部分：端口、路由表、路由协议处理单元。Router 最关键的两个概念就是端口和路由表。\n\nNeutron 的 Router 模型中，蕴含三种路由：直连路由、默认静态路由和静态路由。前两种路由不需要显式地增加路由表项（routes 的 [destination (string), nexthop (string)]），也不会体现在路由表（routes）中。\n\n路由表中的路由也是静态路由，它与默认静态路由一样，都是通往外部网络（Neutron 管理范围外的网络）。静态路由中的外部网络，一般指的是私网，而默认静态路由中的外部网络，一般指的是公网。\n\n### Floating IP\n\nFloating IP 首先是一个 SNAT/DNAT 转换规则：floating_ip_address（外网/公网 IP）与 fixed_ip_address （内网/私网 IP）互相转换。然后，从实现角度来讲，他才是绑定到一个 Router（router_id）的端口（port_id）上，以让报文在进出这个端口时，Router 能对其做 SNAT/DNAT 转换。\n\n## BGP VPN\n\nNeutron 的 BGP VPN，指的是 MP-BGP MPLS L3VPN 或者是 E-VPN （E-VPN 的控制协议也是 MP-BGP）。\n\nNeutron 中 BGP VPN 的实现模型主要是关于 PE/CE 的实现方法，有如下几种：\n\n1. PE/CE 都位于计算节点内，VM 扮演 CE 的角色，PE 则有 br-ehtx/br-tun（OVS）承担\n2. PE/CE 都位于网络节点内， Router 承担 CE 角色，而由 L3 Agent 承担 PE 角色\n3. CE 位于网络节点内，PE 位于外部路由器，Router 承担 CE 角色，而由外部路由器承担 PE 角色\n\n> 名词解释：\n>\n> PE：Provider Edge，运营商边缘路由器\n>\n> CE：Customer Edge，用户边缘路由器","source":"_posts/OpenStack-Neutron-Resources-Model.md","raw":"---\ntitle: OpenStack Neutron -- Neutron 的资源模型\ndate: 2019-05-22 15:06:13\nupdated: 2019-05-22 15:06:13\ncategory: OpenStack\ntags: [Neutron]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-05-22.jpg\n---\n\nNeutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。\n<!--more-->\n\n## Neutron 资源的租户隔离\n\n租户隔离指的是将不同的用户隔离开来，用户对其他用户无感知。租户隔离有三种含义：管理面的隔离、数据面的隔离和故障面的隔离。\n\n### 管理面的隔离\n\n管里面的隔离，指的是”管理权限“的隔离，每个租户只知道他自己的网络，对其他网络毫无感觉。\n\n### 数据面的隔离\n\n数据面的隔离，指的是数据转发的隔离。不同租户之间的网络，一般来说是不能互通的。从管理权限的角度，一个租户感知不到另外一个租户的网络。不仅无法感知，而且还可以”重复“。从这个角度来说，数据面的隔离是为了复用。\n\n### 故障面的隔离\n\n故障隔离，主要是管里面的故障、数据面的故障要做到租户隔离，而物理资源层面，无法真正做到故障隔离。Neutron 在故障面的目标不是租户隔离，而是容错——尽量保证不受故障影响。\n\n## Network\n\nNetwork 是 Neutron 的一个二层网络的资源模型，它支持的网络类型有：Local、Flat、VLAN、VXLAN、GRE、Geneve 等。其中，Local 仅仅是一个主机内的网络类型，只会用于测试，不会用于生产环境。VXLAN、GRE、Geneve 属于隧道型网络，Flat 和 VLAN 属于非隧道型网络。一般来说，这些网络内的虚拟机之间的二层通信并不需要用到路由器。\n\n### 运营商网络和租户网络\n\n由租户创建并管理的网络，Neutron 称之为租户网络。有时候，Neutron 还需要创建一个网络来映射外部网络，这个网络称为运营商网络（Provider Network）。\n\n运营商网络与租户网络，从模型角度来讲，都是 Neutron 的资源模型 Network。两者的区别如下：\n\n1. 管理的权限和角色不同。租户创建的网络，就是租户网络，而运营商管理员创建的网络，就是运营商网络\n2. 创建网络时，传入的参数不同。创建运营商网络时，需要传入 provider:network_type、provider:physical_network、provider:segmentation_id 三个参数，而创建租户网络时，没有办法传入这三个参数，它们是由 OpenStack 在管理员配置的范围内自动分配的\n\nNeutron 创建了一个网络，如果这个网络只是为了映射（匹配）另外一个网络，而且这个被映射的网络不在 Neutron 的管理范围内，这样的场景就是运营商网络的一般化使用场景。Neutron 创建的这个网络，也称为运营商网络。运营商网络可以认为是运营商的某个物理网络在 OpenStack （Neutron）上的延伸。\n\n### 物理网络\n\n一般来说，物理网络可以理解为运营商网络需要匹配的那个网络。物理网络的实际意义如下：\n\n1. 非隧道型网络角度\n    - 对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络的名称，这个含义是为了方便阅读和理解\n    - 无论是对于运营商网络还是租户网络，物理网络都意味着 br-ehtx 的选择（背后是主机网卡的选择），这个含义是 Neutron 所需要的，因此创建运营商网络时，需要直接传入这个参数，创建租户网络时，需要间接传入这个参数\n2. 隧道型网络角度\n    - 对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络名称，之歌含义只为了方便阅读和理解，对 Neutron 无意义\n\n## Trunk Networking\n\nTrunk Networking 是 OpenStack Newton 版本所增加的特性，目的是为了支持 VLAN aware VM。一般情况下，VM 发送和接收的报文都是不带 VLAN Tag 的，不过有时候，VM 也期望能够发送和接收带有 VLAN Tag 的报文，这种情形即可称为 VLAN aware VM。\n\n### Bridge 的 VLAN 接口模式\n\n一个 Bridge 可以抽象为两大部分：交换模块（基于 VLAN ID 做报文交换）和接口。\n\nBridge 接口关于 VLAN ID 的处理方式有三种模式：Access、Trunk 和 Hybrid。\n\n#### Access 接口模式\n\nAccess 模式，在报文入接口，对于 Tag 报文，直接丢弃，对于 Untag 报文，则打上 Default VID Tag 后送入交换模块（进行 VLAN 交换）。在报文出接口，先将报文去除 Tag，然后再从接口转发。\n\n#### Trunk 接口模式\n\nTrunk 模式，首先要配置允许进入接口的 VLAN ID 列表（范围）。在列表范围内的 VLAN ID 可以进入端口，其他的则不允许进入。\n\n#### Hybrid 接口模式\n\nHybrid 模式，在 Trunk 模式的基础上又多了一部分内容。Trunk 模式，在报文出接口时，如果 VLAN ID 等于 Default ID，那么 VLAN Tag 会去除。而 Hybrid 模式，允许配置哪些 VLAN ID 的报文，在出接口时，需要去除 VLAN Tag，比如配置 VLAN ID 在 40 ~ 50 这个范围内的报文，当其出接口时，需要去除 VLAN Tag。\n\n> 上述描述中的几个名词解释：\n>\n> - Tag 报文：指的是报文中有 VLAN ID，简称 Tag\n> - Untag 报文：指的是报文中没有 VLAN ID，简称 Untag\n> - Default ID：端口默认 VLAN ID。Bridge 端口的默认 VLAN ID 为 “1”。这个默认值可以被修改\n\n### VLAN aware VM 与 Trunk Networking\n\nVM 能够发送和接收带有 VLAN Tag 的报文，这种情形称作 VLAN aware VM。在没有引入 Trunk Networking 特性之前，Neutron 的模型设计中有这样的约束：一个 Port 只能属于一个 Network。假设一个 VM 只有一个 Port，如果想让 VM 具备 VLAN aware 特性，就意味着这个 Port 必须要属于多个 Network，这与 Neutron 的约束是矛盾的。这里所涉及的 Port，可以简单理解为 VM 的虚拟网口（virtual Network Interface Card，vNIC）。为了解决这个问题，Neutron 提出了 Trunk Networking 方案，主要解决实现 VLAN aware 的以下问题：\n\n1. VM aware 的 VLAN ID，在 Host 内部不能冲突\n2. VM aware 的 VLAN ID，不需要在 Host 之间的物理网络透传（不能要求物理网络透传该 VLAN ID，因为物理网络很可能不在 Neutron 的管理范围内）\n3. 不要打破原来的 Network、Port 模型，否则会引发 Neutron 的源代码大量修改\n\n#### Trunk Networking 的实现模型\n\n为了解决 VM aware 的 VLAN ID 与 Host 内部的 VLAN ID 冲突的问题， Neutron 引入了一个 Trunk Bridge。Trunk Bridge 仍然是一个普通的 Bridge，只不过接口模式有所不同。Neutron 利用 br-trunk 做 VLAN ID 的转换，就可以解决上述的 VLAN ID 冲突的问题。\n\n#### Trunk Networking 的资源模型\n\nNeutron 最终采取的模型不是“一个 Port 对应多个 Network”，而是增加了一个模型，名为 trunk，这个模型里最核心的就是两个字段：Parent Port 和 Sub Port List，如下表所示：\n\n|   名称    |  类型  |          描述          |\n| :-------: | :----: | :--------------------: |\n|  port_id  | stirng |       父端口 ID        |\n| sub_ports | array  | Trunk 关联的子端口列表 |\n\n这个模型在不同的视角有不同的解读，并解决了对应的问题。\n\n从 VM 视角，它仍然相当于一个端口对接多个网络，因为它的端口可以发送带 VLAN ID 的报文，每个 VLAN ID 对应一个网络。这解决了 VM 的端口不能太多的问题。\n\n从 Neutron 模型的角度，Trunk 模型利用一个 Parent Port （对应字段为 port_id）和多个 Sub Port（对应字段为 sub_ports）与不同的 Network 相对应。Parent Port 与 Sub Port 对应的都是 Port 模型，它们与 Network 的关系仍是一个 Port 对应一个 Network。\n\nTrunk Networking 方案没有修改原来的实现模型和资源模型，而是在原来的实现模型中引入了 Trunk Bridge。在原来的资源模型中引入了 Trunk 资源模型，对原来的代码修改较少，就支持了 VLAN aware VM 特性。\n\n## Subnet\n\nSubnet（子网）在一般概念中，有两个基本含义：\n\n1. 这个子网的网段（CIDR）和 IP 版本\n2. 这个子网的路由信息（含默认路由）\n\nNeutron 中，Subnet 模型除了标识 CIDR、IP version 这样的纯逻辑资源外，为了解决 VM 的 IP 地址分配和 DNS 设置问题，还蕴含了管理功能，这些管理功能又称为 IP 的核心服务。\n\n### IP 核心网络服务\n\nIP 核心网络服务（IP Core Network Services），又称 DDI 服务，包括：DNS、DHCP 和 IPAM。这三个服务是所有 IP 网络及应用系统得以顺利运行的基础。\n\n## Port\n\n如果说 Network 是 Neutron 模型中的“根”，那么 Port 则是 Neutron 模型中的“灵魂”，尤其是对于三层转发来说。因为无论 Neutron 的模型怎么设计，它的三层转发总归是绕不开 IP 地址，而承载 IP 地址的就是 Port。\n\nPort 是一个逻辑模型，但是也可以理解为其代表一个虚拟网口。所以一个 VM 需要绑定 Port，一个 Router 也需要绑定 Port。作为一个虚拟网口，Port 具备两个基本属性：IP 地址和 MAC 地址。一个 Port 可以有多个 IP 地址，但在一般情况下，一个 Port 只有一个 MAC 地址。但是 Port 模型中有一个 allowed_address_pairs字段，允许多个绑定多个 MAC 地址，其典型的应用场景为 Antispoofing（一种识别和删除有错误源地址的数据包技术）。\n\nNetwork、Subnet、Port 三者的关系如下：\n\n一个 Network 可以有多个 Subnet，一个 Subnet 只能归属一个 Network。同时一个  Network 可以有多个 Port，而一个 Port 可以与其所在的 Network 中的所有 Subnet 相关联。当然，一个 Subnet 也可以有多个 Port。\n\n## Router\n\n如果说 Port 是 Neutron 模型的“灵魂”，那么 Router 就是 Neutron 模型的 “发动机”，它承担着路由转发的功能。Router 可以简单地抽象为三部分：端口、路由表、路由协议处理单元。Router 最关键的两个概念就是端口和路由表。\n\nNeutron 的 Router 模型中，蕴含三种路由：直连路由、默认静态路由和静态路由。前两种路由不需要显式地增加路由表项（routes 的 [destination (string), nexthop (string)]），也不会体现在路由表（routes）中。\n\n路由表中的路由也是静态路由，它与默认静态路由一样，都是通往外部网络（Neutron 管理范围外的网络）。静态路由中的外部网络，一般指的是私网，而默认静态路由中的外部网络，一般指的是公网。\n\n### Floating IP\n\nFloating IP 首先是一个 SNAT/DNAT 转换规则：floating_ip_address（外网/公网 IP）与 fixed_ip_address （内网/私网 IP）互相转换。然后，从实现角度来讲，他才是绑定到一个 Router（router_id）的端口（port_id）上，以让报文在进出这个端口时，Router 能对其做 SNAT/DNAT 转换。\n\n## BGP VPN\n\nNeutron 的 BGP VPN，指的是 MP-BGP MPLS L3VPN 或者是 E-VPN （E-VPN 的控制协议也是 MP-BGP）。\n\nNeutron 中 BGP VPN 的实现模型主要是关于 PE/CE 的实现方法，有如下几种：\n\n1. PE/CE 都位于计算节点内，VM 扮演 CE 的角色，PE 则有 br-ehtx/br-tun（OVS）承担\n2. PE/CE 都位于网络节点内， Router 承担 CE 角色，而由 L3 Agent 承担 PE 角色\n3. CE 位于网络节点内，PE 位于外部路由器，Router 承担 CE 角色，而由外部路由器承担 PE 角色\n\n> 名词解释：\n>\n> PE：Provider Edge，运营商边缘路由器\n>\n> CE：Customer Edge，用户边缘路由器","slug":"OpenStack-Neutron-Resources-Model","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsim000tw8voe32gau78","content":"<p>Neutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Neutron-资源的租户隔离\"><a href=\"#Neutron-资源的租户隔离\" class=\"headerlink\" title=\"Neutron 资源的租户隔离\"></a>Neutron 资源的租户隔离</h2><p>租户隔离指的是将不同的用户隔离开来，用户对其他用户无感知。租户隔离有三种含义：管理面的隔离、数据面的隔离和故障面的隔离。</p>\n<h3 id=\"管理面的隔离\"><a href=\"#管理面的隔离\" class=\"headerlink\" title=\"管理面的隔离\"></a>管理面的隔离</h3><p>管里面的隔离，指的是”管理权限“的隔离，每个租户只知道他自己的网络，对其他网络毫无感觉。</p>\n<h3 id=\"数据面的隔离\"><a href=\"#数据面的隔离\" class=\"headerlink\" title=\"数据面的隔离\"></a>数据面的隔离</h3><p>数据面的隔离，指的是数据转发的隔离。不同租户之间的网络，一般来说是不能互通的。从管理权限的角度，一个租户感知不到另外一个租户的网络。不仅无法感知，而且还可以”重复“。从这个角度来说，数据面的隔离是为了复用。</p>\n<h3 id=\"故障面的隔离\"><a href=\"#故障面的隔离\" class=\"headerlink\" title=\"故障面的隔离\"></a>故障面的隔离</h3><p>故障隔离，主要是管里面的故障、数据面的故障要做到租户隔离，而物理资源层面，无法真正做到故障隔离。Neutron 在故障面的目标不是租户隔离，而是容错——尽量保证不受故障影响。</p>\n<h2 id=\"Network\"><a href=\"#Network\" class=\"headerlink\" title=\"Network\"></a>Network</h2><p>Network 是 Neutron 的一个二层网络的资源模型，它支持的网络类型有：Local、Flat、VLAN、VXLAN、GRE、Geneve 等。其中，Local 仅仅是一个主机内的网络类型，只会用于测试，不会用于生产环境。VXLAN、GRE、Geneve 属于隧道型网络，Flat 和 VLAN 属于非隧道型网络。一般来说，这些网络内的虚拟机之间的二层通信并不需要用到路由器。</p>\n<h3 id=\"运营商网络和租户网络\"><a href=\"#运营商网络和租户网络\" class=\"headerlink\" title=\"运营商网络和租户网络\"></a>运营商网络和租户网络</h3><p>由租户创建并管理的网络，Neutron 称之为租户网络。有时候，Neutron 还需要创建一个网络来映射外部网络，这个网络称为运营商网络（Provider Network）。</p>\n<p>运营商网络与租户网络，从模型角度来讲，都是 Neutron 的资源模型 Network。两者的区别如下：</p>\n<ol>\n<li>管理的权限和角色不同。租户创建的网络，就是租户网络，而运营商管理员创建的网络，就是运营商网络</li>\n<li>创建网络时，传入的参数不同。创建运营商网络时，需要传入 provider:network_type、provider:physical_network、provider:segmentation_id 三个参数，而创建租户网络时，没有办法传入这三个参数，它们是由 OpenStack 在管理员配置的范围内自动分配的</li>\n</ol>\n<p>Neutron 创建了一个网络，如果这个网络只是为了映射（匹配）另外一个网络，而且这个被映射的网络不在 Neutron 的管理范围内，这样的场景就是运营商网络的一般化使用场景。Neutron 创建的这个网络，也称为运营商网络。运营商网络可以认为是运营商的某个物理网络在 OpenStack （Neutron）上的延伸。</p>\n<h3 id=\"物理网络\"><a href=\"#物理网络\" class=\"headerlink\" title=\"物理网络\"></a>物理网络</h3><p>一般来说，物理网络可以理解为运营商网络需要匹配的那个网络。物理网络的实际意义如下：</p>\n<ol>\n<li>非隧道型网络角度<ul>\n<li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络的名称，这个含义是为了方便阅读和理解</li>\n<li>无论是对于运营商网络还是租户网络，物理网络都意味着 br-ehtx 的选择（背后是主机网卡的选择），这个含义是 Neutron 所需要的，因此创建运营商网络时，需要直接传入这个参数，创建租户网络时，需要间接传入这个参数</li>\n</ul>\n</li>\n<li>隧道型网络角度<ul>\n<li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络名称，之歌含义只为了方便阅读和理解，对 Neutron 无意义</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Trunk-Networking\"><a href=\"#Trunk-Networking\" class=\"headerlink\" title=\"Trunk Networking\"></a>Trunk Networking</h2><p>Trunk Networking 是 OpenStack Newton 版本所增加的特性，目的是为了支持 VLAN aware VM。一般情况下，VM 发送和接收的报文都是不带 VLAN Tag 的，不过有时候，VM 也期望能够发送和接收带有 VLAN Tag 的报文，这种情形即可称为 VLAN aware VM。</p>\n<h3 id=\"Bridge-的-VLAN-接口模式\"><a href=\"#Bridge-的-VLAN-接口模式\" class=\"headerlink\" title=\"Bridge 的 VLAN 接口模式\"></a>Bridge 的 VLAN 接口模式</h3><p>一个 Bridge 可以抽象为两大部分：交换模块（基于 VLAN ID 做报文交换）和接口。</p>\n<p>Bridge 接口关于 VLAN ID 的处理方式有三种模式：Access、Trunk 和 Hybrid。</p>\n<h4 id=\"Access-接口模式\"><a href=\"#Access-接口模式\" class=\"headerlink\" title=\"Access 接口模式\"></a>Access 接口模式</h4><p>Access 模式，在报文入接口，对于 Tag 报文，直接丢弃，对于 Untag 报文，则打上 Default VID Tag 后送入交换模块（进行 VLAN 交换）。在报文出接口，先将报文去除 Tag，然后再从接口转发。</p>\n<h4 id=\"Trunk-接口模式\"><a href=\"#Trunk-接口模式\" class=\"headerlink\" title=\"Trunk 接口模式\"></a>Trunk 接口模式</h4><p>Trunk 模式，首先要配置允许进入接口的 VLAN ID 列表（范围）。在列表范围内的 VLAN ID 可以进入端口，其他的则不允许进入。</p>\n<h4 id=\"Hybrid-接口模式\"><a href=\"#Hybrid-接口模式\" class=\"headerlink\" title=\"Hybrid 接口模式\"></a>Hybrid 接口模式</h4><p>Hybrid 模式，在 Trunk 模式的基础上又多了一部分内容。Trunk 模式，在报文出接口时，如果 VLAN ID 等于 Default ID，那么 VLAN Tag 会去除。而 Hybrid 模式，允许配置哪些 VLAN ID 的报文，在出接口时，需要去除 VLAN Tag，比如配置 VLAN ID 在 40 ~ 50 这个范围内的报文，当其出接口时，需要去除 VLAN Tag。</p>\n<blockquote>\n<p>上述描述中的几个名词解释：</p>\n<ul>\n<li>Tag 报文：指的是报文中有 VLAN ID，简称 Tag</li>\n<li>Untag 报文：指的是报文中没有 VLAN ID，简称 Untag</li>\n<li>Default ID：端口默认 VLAN ID。Bridge 端口的默认 VLAN ID 为 “1”。这个默认值可以被修改</li>\n</ul>\n</blockquote>\n<h3 id=\"VLAN-aware-VM-与-Trunk-Networking\"><a href=\"#VLAN-aware-VM-与-Trunk-Networking\" class=\"headerlink\" title=\"VLAN aware VM 与 Trunk Networking\"></a>VLAN aware VM 与 Trunk Networking</h3><p>VM 能够发送和接收带有 VLAN Tag 的报文，这种情形称作 VLAN aware VM。在没有引入 Trunk Networking 特性之前，Neutron 的模型设计中有这样的约束：一个 Port 只能属于一个 Network。假设一个 VM 只有一个 Port，如果想让 VM 具备 VLAN aware 特性，就意味着这个 Port 必须要属于多个 Network，这与 Neutron 的约束是矛盾的。这里所涉及的 Port，可以简单理解为 VM 的虚拟网口（virtual Network Interface Card，vNIC）。为了解决这个问题，Neutron 提出了 Trunk Networking 方案，主要解决实现 VLAN aware 的以下问题：</p>\n<ol>\n<li>VM aware 的 VLAN ID，在 Host 内部不能冲突</li>\n<li>VM aware 的 VLAN ID，不需要在 Host 之间的物理网络透传（不能要求物理网络透传该 VLAN ID，因为物理网络很可能不在 Neutron 的管理范围内）</li>\n<li>不要打破原来的 Network、Port 模型，否则会引发 Neutron 的源代码大量修改</li>\n</ol>\n<h4 id=\"Trunk-Networking-的实现模型\"><a href=\"#Trunk-Networking-的实现模型\" class=\"headerlink\" title=\"Trunk Networking 的实现模型\"></a>Trunk Networking 的实现模型</h4><p>为了解决 VM aware 的 VLAN ID 与 Host 内部的 VLAN ID 冲突的问题， Neutron 引入了一个 Trunk Bridge。Trunk Bridge 仍然是一个普通的 Bridge，只不过接口模式有所不同。Neutron 利用 br-trunk 做 VLAN ID 的转换，就可以解决上述的 VLAN ID 冲突的问题。</p>\n<h4 id=\"Trunk-Networking-的资源模型\"><a href=\"#Trunk-Networking-的资源模型\" class=\"headerlink\" title=\"Trunk Networking 的资源模型\"></a>Trunk Networking 的资源模型</h4><p>Neutron 最终采取的模型不是“一个 Port 对应多个 Network”，而是增加了一个模型，名为 trunk，这个模型里最核心的就是两个字段：Parent Port 和 Sub Port List，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">port_id</td>\n<td align=\"center\">stirng</td>\n<td align=\"center\">父端口 ID</td>\n</tr>\n<tr>\n<td align=\"center\">sub_ports</td>\n<td align=\"center\">array</td>\n<td align=\"center\">Trunk 关联的子端口列表</td>\n</tr>\n</tbody></table>\n<p>这个模型在不同的视角有不同的解读，并解决了对应的问题。</p>\n<p>从 VM 视角，它仍然相当于一个端口对接多个网络，因为它的端口可以发送带 VLAN ID 的报文，每个 VLAN ID 对应一个网络。这解决了 VM 的端口不能太多的问题。</p>\n<p>从 Neutron 模型的角度，Trunk 模型利用一个 Parent Port （对应字段为 port_id）和多个 Sub Port（对应字段为 sub_ports）与不同的 Network 相对应。Parent Port 与 Sub Port 对应的都是 Port 模型，它们与 Network 的关系仍是一个 Port 对应一个 Network。</p>\n<p>Trunk Networking 方案没有修改原来的实现模型和资源模型，而是在原来的实现模型中引入了 Trunk Bridge。在原来的资源模型中引入了 Trunk 资源模型，对原来的代码修改较少，就支持了 VLAN aware VM 特性。</p>\n<h2 id=\"Subnet\"><a href=\"#Subnet\" class=\"headerlink\" title=\"Subnet\"></a>Subnet</h2><p>Subnet（子网）在一般概念中，有两个基本含义：</p>\n<ol>\n<li>这个子网的网段（CIDR）和 IP 版本</li>\n<li>这个子网的路由信息（含默认路由）</li>\n</ol>\n<p>Neutron 中，Subnet 模型除了标识 CIDR、IP version 这样的纯逻辑资源外，为了解决 VM 的 IP 地址分配和 DNS 设置问题，还蕴含了管理功能，这些管理功能又称为 IP 的核心服务。</p>\n<h3 id=\"IP-核心网络服务\"><a href=\"#IP-核心网络服务\" class=\"headerlink\" title=\"IP 核心网络服务\"></a>IP 核心网络服务</h3><p>IP 核心网络服务（IP Core Network Services），又称 DDI 服务，包括：DNS、DHCP 和 IPAM。这三个服务是所有 IP 网络及应用系统得以顺利运行的基础。</p>\n<h2 id=\"Port\"><a href=\"#Port\" class=\"headerlink\" title=\"Port\"></a>Port</h2><p>如果说 Network 是 Neutron 模型中的“根”，那么 Port 则是 Neutron 模型中的“灵魂”，尤其是对于三层转发来说。因为无论 Neutron 的模型怎么设计，它的三层转发总归是绕不开 IP 地址，而承载 IP 地址的就是 Port。</p>\n<p>Port 是一个逻辑模型，但是也可以理解为其代表一个虚拟网口。所以一个 VM 需要绑定 Port，一个 Router 也需要绑定 Port。作为一个虚拟网口，Port 具备两个基本属性：IP 地址和 MAC 地址。一个 Port 可以有多个 IP 地址，但在一般情况下，一个 Port 只有一个 MAC 地址。但是 Port 模型中有一个 allowed_address_pairs字段，允许多个绑定多个 MAC 地址，其典型的应用场景为 Antispoofing（一种识别和删除有错误源地址的数据包技术）。</p>\n<p>Network、Subnet、Port 三者的关系如下：</p>\n<p>一个 Network 可以有多个 Subnet，一个 Subnet 只能归属一个 Network。同时一个  Network 可以有多个 Port，而一个 Port 可以与其所在的 Network 中的所有 Subnet 相关联。当然，一个 Subnet 也可以有多个 Port。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>如果说 Port 是 Neutron 模型的“灵魂”，那么 Router 就是 Neutron 模型的 “发动机”，它承担着路由转发的功能。Router 可以简单地抽象为三部分：端口、路由表、路由协议处理单元。Router 最关键的两个概念就是端口和路由表。</p>\n<p>Neutron 的 Router 模型中，蕴含三种路由：直连路由、默认静态路由和静态路由。前两种路由不需要显式地增加路由表项（routes 的 [destination (string), nexthop (string)]），也不会体现在路由表（routes）中。</p>\n<p>路由表中的路由也是静态路由，它与默认静态路由一样，都是通往外部网络（Neutron 管理范围外的网络）。静态路由中的外部网络，一般指的是私网，而默认静态路由中的外部网络，一般指的是公网。</p>\n<h3 id=\"Floating-IP\"><a href=\"#Floating-IP\" class=\"headerlink\" title=\"Floating IP\"></a>Floating IP</h3><p>Floating IP 首先是一个 SNAT/DNAT 转换规则：floating_ip_address（外网/公网 IP）与 fixed_ip_address （内网/私网 IP）互相转换。然后，从实现角度来讲，他才是绑定到一个 Router（router_id）的端口（port_id）上，以让报文在进出这个端口时，Router 能对其做 SNAT/DNAT 转换。</p>\n<h2 id=\"BGP-VPN\"><a href=\"#BGP-VPN\" class=\"headerlink\" title=\"BGP VPN\"></a>BGP VPN</h2><p>Neutron 的 BGP VPN，指的是 MP-BGP MPLS L3VPN 或者是 E-VPN （E-VPN 的控制协议也是 MP-BGP）。</p>\n<p>Neutron 中 BGP VPN 的实现模型主要是关于 PE/CE 的实现方法，有如下几种：</p>\n<ol>\n<li>PE/CE 都位于计算节点内，VM 扮演 CE 的角色，PE 则有 br-ehtx/br-tun（OVS）承担</li>\n<li>PE/CE 都位于网络节点内， Router 承担 CE 角色，而由 L3 Agent 承担 PE 角色</li>\n<li>CE 位于网络节点内，PE 位于外部路由器，Router 承担 CE 角色，而由外部路由器承担 PE 角色</li>\n</ol>\n<blockquote>\n<p>名词解释：</p>\n<p>PE：Provider Edge，运营商边缘路由器</p>\n<p>CE：Customer Edge，用户边缘路由器</p>\n</blockquote>\n","site":{"data":{}},"length":4977,"excerpt":"<p>Neutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。</p>","more":"<h2 id=\"Neutron-资源的租户隔离\"><a href=\"#Neutron-资源的租户隔离\" class=\"headerlink\" title=\"Neutron 资源的租户隔离\"></a>Neutron 资源的租户隔离</h2><p>租户隔离指的是将不同的用户隔离开来，用户对其他用户无感知。租户隔离有三种含义：管理面的隔离、数据面的隔离和故障面的隔离。</p>\n<h3 id=\"管理面的隔离\"><a href=\"#管理面的隔离\" class=\"headerlink\" title=\"管理面的隔离\"></a>管理面的隔离</h3><p>管里面的隔离，指的是”管理权限“的隔离，每个租户只知道他自己的网络，对其他网络毫无感觉。</p>\n<h3 id=\"数据面的隔离\"><a href=\"#数据面的隔离\" class=\"headerlink\" title=\"数据面的隔离\"></a>数据面的隔离</h3><p>数据面的隔离，指的是数据转发的隔离。不同租户之间的网络，一般来说是不能互通的。从管理权限的角度，一个租户感知不到另外一个租户的网络。不仅无法感知，而且还可以”重复“。从这个角度来说，数据面的隔离是为了复用。</p>\n<h3 id=\"故障面的隔离\"><a href=\"#故障面的隔离\" class=\"headerlink\" title=\"故障面的隔离\"></a>故障面的隔离</h3><p>故障隔离，主要是管里面的故障、数据面的故障要做到租户隔离，而物理资源层面，无法真正做到故障隔离。Neutron 在故障面的目标不是租户隔离，而是容错——尽量保证不受故障影响。</p>\n<h2 id=\"Network\"><a href=\"#Network\" class=\"headerlink\" title=\"Network\"></a>Network</h2><p>Network 是 Neutron 的一个二层网络的资源模型，它支持的网络类型有：Local、Flat、VLAN、VXLAN、GRE、Geneve 等。其中，Local 仅仅是一个主机内的网络类型，只会用于测试，不会用于生产环境。VXLAN、GRE、Geneve 属于隧道型网络，Flat 和 VLAN 属于非隧道型网络。一般来说，这些网络内的虚拟机之间的二层通信并不需要用到路由器。</p>\n<h3 id=\"运营商网络和租户网络\"><a href=\"#运营商网络和租户网络\" class=\"headerlink\" title=\"运营商网络和租户网络\"></a>运营商网络和租户网络</h3><p>由租户创建并管理的网络，Neutron 称之为租户网络。有时候，Neutron 还需要创建一个网络来映射外部网络，这个网络称为运营商网络（Provider Network）。</p>\n<p>运营商网络与租户网络，从模型角度来讲，都是 Neutron 的资源模型 Network。两者的区别如下：</p>\n<ol>\n<li>管理的权限和角色不同。租户创建的网络，就是租户网络，而运营商管理员创建的网络，就是运营商网络</li>\n<li>创建网络时，传入的参数不同。创建运营商网络时，需要传入 provider:network_type、provider:physical_network、provider:segmentation_id 三个参数，而创建租户网络时，没有办法传入这三个参数，它们是由 OpenStack 在管理员配置的范围内自动分配的</li>\n</ol>\n<p>Neutron 创建了一个网络，如果这个网络只是为了映射（匹配）另外一个网络，而且这个被映射的网络不在 Neutron 的管理范围内，这样的场景就是运营商网络的一般化使用场景。Neutron 创建的这个网络，也称为运营商网络。运营商网络可以认为是运营商的某个物理网络在 OpenStack （Neutron）上的延伸。</p>\n<h3 id=\"物理网络\"><a href=\"#物理网络\" class=\"headerlink\" title=\"物理网络\"></a>物理网络</h3><p>一般来说，物理网络可以理解为运营商网络需要匹配的那个网络。物理网络的实际意义如下：</p>\n<ol>\n<li>非隧道型网络角度<ul>\n<li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络的名称，这个含义是为了方便阅读和理解</li>\n<li>无论是对于运营商网络还是租户网络，物理网络都意味着 br-ehtx 的选择（背后是主机网卡的选择），这个含义是 Neutron 所需要的，因此创建运营商网络时，需要直接传入这个参数，创建租户网络时，需要间接传入这个参数</li>\n</ul>\n</li>\n<li>隧道型网络角度<ul>\n<li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络名称，之歌含义只为了方便阅读和理解，对 Neutron 无意义</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Trunk-Networking\"><a href=\"#Trunk-Networking\" class=\"headerlink\" title=\"Trunk Networking\"></a>Trunk Networking</h2><p>Trunk Networking 是 OpenStack Newton 版本所增加的特性，目的是为了支持 VLAN aware VM。一般情况下，VM 发送和接收的报文都是不带 VLAN Tag 的，不过有时候，VM 也期望能够发送和接收带有 VLAN Tag 的报文，这种情形即可称为 VLAN aware VM。</p>\n<h3 id=\"Bridge-的-VLAN-接口模式\"><a href=\"#Bridge-的-VLAN-接口模式\" class=\"headerlink\" title=\"Bridge 的 VLAN 接口模式\"></a>Bridge 的 VLAN 接口模式</h3><p>一个 Bridge 可以抽象为两大部分：交换模块（基于 VLAN ID 做报文交换）和接口。</p>\n<p>Bridge 接口关于 VLAN ID 的处理方式有三种模式：Access、Trunk 和 Hybrid。</p>\n<h4 id=\"Access-接口模式\"><a href=\"#Access-接口模式\" class=\"headerlink\" title=\"Access 接口模式\"></a>Access 接口模式</h4><p>Access 模式，在报文入接口，对于 Tag 报文，直接丢弃，对于 Untag 报文，则打上 Default VID Tag 后送入交换模块（进行 VLAN 交换）。在报文出接口，先将报文去除 Tag，然后再从接口转发。</p>\n<h4 id=\"Trunk-接口模式\"><a href=\"#Trunk-接口模式\" class=\"headerlink\" title=\"Trunk 接口模式\"></a>Trunk 接口模式</h4><p>Trunk 模式，首先要配置允许进入接口的 VLAN ID 列表（范围）。在列表范围内的 VLAN ID 可以进入端口，其他的则不允许进入。</p>\n<h4 id=\"Hybrid-接口模式\"><a href=\"#Hybrid-接口模式\" class=\"headerlink\" title=\"Hybrid 接口模式\"></a>Hybrid 接口模式</h4><p>Hybrid 模式，在 Trunk 模式的基础上又多了一部分内容。Trunk 模式，在报文出接口时，如果 VLAN ID 等于 Default ID，那么 VLAN Tag 会去除。而 Hybrid 模式，允许配置哪些 VLAN ID 的报文，在出接口时，需要去除 VLAN Tag，比如配置 VLAN ID 在 40 ~ 50 这个范围内的报文，当其出接口时，需要去除 VLAN Tag。</p>\n<blockquote>\n<p>上述描述中的几个名词解释：</p>\n<ul>\n<li>Tag 报文：指的是报文中有 VLAN ID，简称 Tag</li>\n<li>Untag 报文：指的是报文中没有 VLAN ID，简称 Untag</li>\n<li>Default ID：端口默认 VLAN ID。Bridge 端口的默认 VLAN ID 为 “1”。这个默认值可以被修改</li>\n</ul>\n</blockquote>\n<h3 id=\"VLAN-aware-VM-与-Trunk-Networking\"><a href=\"#VLAN-aware-VM-与-Trunk-Networking\" class=\"headerlink\" title=\"VLAN aware VM 与 Trunk Networking\"></a>VLAN aware VM 与 Trunk Networking</h3><p>VM 能够发送和接收带有 VLAN Tag 的报文，这种情形称作 VLAN aware VM。在没有引入 Trunk Networking 特性之前，Neutron 的模型设计中有这样的约束：一个 Port 只能属于一个 Network。假设一个 VM 只有一个 Port，如果想让 VM 具备 VLAN aware 特性，就意味着这个 Port 必须要属于多个 Network，这与 Neutron 的约束是矛盾的。这里所涉及的 Port，可以简单理解为 VM 的虚拟网口（virtual Network Interface Card，vNIC）。为了解决这个问题，Neutron 提出了 Trunk Networking 方案，主要解决实现 VLAN aware 的以下问题：</p>\n<ol>\n<li>VM aware 的 VLAN ID，在 Host 内部不能冲突</li>\n<li>VM aware 的 VLAN ID，不需要在 Host 之间的物理网络透传（不能要求物理网络透传该 VLAN ID，因为物理网络很可能不在 Neutron 的管理范围内）</li>\n<li>不要打破原来的 Network、Port 模型，否则会引发 Neutron 的源代码大量修改</li>\n</ol>\n<h4 id=\"Trunk-Networking-的实现模型\"><a href=\"#Trunk-Networking-的实现模型\" class=\"headerlink\" title=\"Trunk Networking 的实现模型\"></a>Trunk Networking 的实现模型</h4><p>为了解决 VM aware 的 VLAN ID 与 Host 内部的 VLAN ID 冲突的问题， Neutron 引入了一个 Trunk Bridge。Trunk Bridge 仍然是一个普通的 Bridge，只不过接口模式有所不同。Neutron 利用 br-trunk 做 VLAN ID 的转换，就可以解决上述的 VLAN ID 冲突的问题。</p>\n<h4 id=\"Trunk-Networking-的资源模型\"><a href=\"#Trunk-Networking-的资源模型\" class=\"headerlink\" title=\"Trunk Networking 的资源模型\"></a>Trunk Networking 的资源模型</h4><p>Neutron 最终采取的模型不是“一个 Port 对应多个 Network”，而是增加了一个模型，名为 trunk，这个模型里最核心的就是两个字段：Parent Port 和 Sub Port List，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">port_id</td>\n<td align=\"center\">stirng</td>\n<td align=\"center\">父端口 ID</td>\n</tr>\n<tr>\n<td align=\"center\">sub_ports</td>\n<td align=\"center\">array</td>\n<td align=\"center\">Trunk 关联的子端口列表</td>\n</tr>\n</tbody></table>\n<p>这个模型在不同的视角有不同的解读，并解决了对应的问题。</p>\n<p>从 VM 视角，它仍然相当于一个端口对接多个网络，因为它的端口可以发送带 VLAN ID 的报文，每个 VLAN ID 对应一个网络。这解决了 VM 的端口不能太多的问题。</p>\n<p>从 Neutron 模型的角度，Trunk 模型利用一个 Parent Port （对应字段为 port_id）和多个 Sub Port（对应字段为 sub_ports）与不同的 Network 相对应。Parent Port 与 Sub Port 对应的都是 Port 模型，它们与 Network 的关系仍是一个 Port 对应一个 Network。</p>\n<p>Trunk Networking 方案没有修改原来的实现模型和资源模型，而是在原来的实现模型中引入了 Trunk Bridge。在原来的资源模型中引入了 Trunk 资源模型，对原来的代码修改较少，就支持了 VLAN aware VM 特性。</p>\n<h2 id=\"Subnet\"><a href=\"#Subnet\" class=\"headerlink\" title=\"Subnet\"></a>Subnet</h2><p>Subnet（子网）在一般概念中，有两个基本含义：</p>\n<ol>\n<li>这个子网的网段（CIDR）和 IP 版本</li>\n<li>这个子网的路由信息（含默认路由）</li>\n</ol>\n<p>Neutron 中，Subnet 模型除了标识 CIDR、IP version 这样的纯逻辑资源外，为了解决 VM 的 IP 地址分配和 DNS 设置问题，还蕴含了管理功能，这些管理功能又称为 IP 的核心服务。</p>\n<h3 id=\"IP-核心网络服务\"><a href=\"#IP-核心网络服务\" class=\"headerlink\" title=\"IP 核心网络服务\"></a>IP 核心网络服务</h3><p>IP 核心网络服务（IP Core Network Services），又称 DDI 服务，包括：DNS、DHCP 和 IPAM。这三个服务是所有 IP 网络及应用系统得以顺利运行的基础。</p>\n<h2 id=\"Port\"><a href=\"#Port\" class=\"headerlink\" title=\"Port\"></a>Port</h2><p>如果说 Network 是 Neutron 模型中的“根”，那么 Port 则是 Neutron 模型中的“灵魂”，尤其是对于三层转发来说。因为无论 Neutron 的模型怎么设计，它的三层转发总归是绕不开 IP 地址，而承载 IP 地址的就是 Port。</p>\n<p>Port 是一个逻辑模型，但是也可以理解为其代表一个虚拟网口。所以一个 VM 需要绑定 Port，一个 Router 也需要绑定 Port。作为一个虚拟网口，Port 具备两个基本属性：IP 地址和 MAC 地址。一个 Port 可以有多个 IP 地址，但在一般情况下，一个 Port 只有一个 MAC 地址。但是 Port 模型中有一个 allowed_address_pairs字段，允许多个绑定多个 MAC 地址，其典型的应用场景为 Antispoofing（一种识别和删除有错误源地址的数据包技术）。</p>\n<p>Network、Subnet、Port 三者的关系如下：</p>\n<p>一个 Network 可以有多个 Subnet，一个 Subnet 只能归属一个 Network。同时一个  Network 可以有多个 Port，而一个 Port 可以与其所在的 Network 中的所有 Subnet 相关联。当然，一个 Subnet 也可以有多个 Port。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>如果说 Port 是 Neutron 模型的“灵魂”，那么 Router 就是 Neutron 模型的 “发动机”，它承担着路由转发的功能。Router 可以简单地抽象为三部分：端口、路由表、路由协议处理单元。Router 最关键的两个概念就是端口和路由表。</p>\n<p>Neutron 的 Router 模型中，蕴含三种路由：直连路由、默认静态路由和静态路由。前两种路由不需要显式地增加路由表项（routes 的 [destination (string), nexthop (string)]），也不会体现在路由表（routes）中。</p>\n<p>路由表中的路由也是静态路由，它与默认静态路由一样，都是通往外部网络（Neutron 管理范围外的网络）。静态路由中的外部网络，一般指的是私网，而默认静态路由中的外部网络，一般指的是公网。</p>\n<h3 id=\"Floating-IP\"><a href=\"#Floating-IP\" class=\"headerlink\" title=\"Floating IP\"></a>Floating IP</h3><p>Floating IP 首先是一个 SNAT/DNAT 转换规则：floating_ip_address（外网/公网 IP）与 fixed_ip_address （内网/私网 IP）互相转换。然后，从实现角度来讲，他才是绑定到一个 Router（router_id）的端口（port_id）上，以让报文在进出这个端口时，Router 能对其做 SNAT/DNAT 转换。</p>\n<h2 id=\"BGP-VPN\"><a href=\"#BGP-VPN\" class=\"headerlink\" title=\"BGP VPN\"></a>BGP VPN</h2><p>Neutron 的 BGP VPN，指的是 MP-BGP MPLS L3VPN 或者是 E-VPN （E-VPN 的控制协议也是 MP-BGP）。</p>\n<p>Neutron 中 BGP VPN 的实现模型主要是关于 PE/CE 的实现方法，有如下几种：</p>\n<ol>\n<li>PE/CE 都位于计算节点内，VM 扮演 CE 的角色，PE 则有 br-ehtx/br-tun（OVS）承担</li>\n<li>PE/CE 都位于网络节点内， Router 承担 CE 角色，而由 L3 Agent 承担 PE 角色</li>\n<li>CE 位于网络节点内，PE 位于外部路由器，Router 承担 CE 角色，而由外部路由器承担 PE 角色</li>\n</ol>\n<blockquote>\n<p>名词解释：</p>\n<p>PE：Provider Edge，运营商边缘路由器</p>\n<p>CE：Customer Edge，用户边缘路由器</p>\n</blockquote>"},{"title":"Python脚本抓取Bing美图","date":"2017-03-23T06:26:18.000Z","updated":"2019-01-07T13:58:40.000Z","comments":1,"_content":"![post_background](http://api.dujin.org/bing/1920.php)\n\n# 使用Python脚本下载Bing美图\n\n[Bing首页](https://cn.bing.com)每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。\n<!--more-->\n\n## Bing美图API\n\nBing官方有两个API：\nxml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&n=1\njson版： http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n有了API就可以愉快地抓图了:D\n\n## Python抓图\n\n至于为什么要用Python，前段时间学习了廖大的[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000),算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！\n\n## 用到的库\n\n - [Requests](http://cn.python-requests.org/zh_CN/latest/index.html)\n\n## 爬图 (更新于2018-04-04)\n\n这里我用了json版的API，使用`requests`的`json()`函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在`images`所对应的值里面。得到`images`的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值`url`来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上`https:://www.bing.com`，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。\n\n## 源代码\n\n```python\n\n# -*- coding: utf-8 -*-\nimport requests\nimport os\nimport time\n\n\ndef get_content(url):\n    \"\"\"\n    得到API返回的JSON数据\n    :param url: API链接\n    :return: 返回的是一个字典\n    \"\"\"\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.json()\n    except:\n        print(\"ERROR\")\n\n\ndef get_img(url):\n    \"\"\"\n    得到图片的内容\n    :param url: 图片的真实链接\n    :return: 返回的是byte类型的图片内容\n    \"\"\"\n    try:\n        r = requests.get(url)\n        return r.content\n    except:\n        return None\n\n\ndef download(file_name, url):\n    \"\"\"\n    根据得到的链接在指定位置保存图片\n    :param file_name: 要保存图片的位置\n    :param url: 图片的链接\n    :return: \n    \"\"\"\n    if os.path.exists(r'C:\\Users\\Freed\\Pictures\\bingwallpaper'):\n        print('Find Dir...')\n    else:\n        print(\"File dir did not exist, make dir...\")\n        try:\n            os.mkdir(r'C:\\Users\\Freed\\Pictures\\bingwallpaper')\n            print('Make dir success')\n        except:\n            print('Failed in make dir')\n    if os.path.exists(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name):\n        print('Image downloaded already')\n    else:\n        img = get_img(url)\n        with open(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name,\n                  'wb') as f:\n            f.write(img)\n        print('Download success')\n\n\nif __name__ == '__main__':\n    url = \"https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n    content = get_content(url)\n    url_dict = content['images'][0]\n    download_url = 'https://www.bing.com' + url_dict['url']\n\n    file_name = str(\"BingWallPaper-\" + time.strftime('%Y-%m-%d',\n                                                     time.localtime(time.time())) + '.jpg')\n    download(file_name, download_url)\n```\n\n用Python命令运行文件即可。\n到此大功告成!  :D\n","source":"_posts/Python3脚本抓取Bing美图.md","raw":"---\ntitle: Python脚本抓取Bing美图\ndate: 2017-03-23 14:26:18\nupdated: 2019-01-07 21:58:40\ncategory: Python\ntags: Python\ncomments: true\n---\n![post_background](http://api.dujin.org/bing/1920.php)\n\n# 使用Python脚本下载Bing美图\n\n[Bing首页](https://cn.bing.com)每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。\n<!--more-->\n\n## Bing美图API\n\nBing官方有两个API：\nxml版： http://cn.bing.com/HPImageArchive.aspx?idx=0&n=1\njson版： http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n有了API就可以愉快地抓图了:D\n\n## Python抓图\n\n至于为什么要用Python，前段时间学习了廖大的[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000),算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！\n\n## 用到的库\n\n - [Requests](http://cn.python-requests.org/zh_CN/latest/index.html)\n\n## 爬图 (更新于2018-04-04)\n\n这里我用了json版的API，使用`requests`的`json()`函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在`images`所对应的值里面。得到`images`的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值`url`来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上`https:://www.bing.com`，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。\n\n## 源代码\n\n```python\n\n# -*- coding: utf-8 -*-\nimport requests\nimport os\nimport time\n\n\ndef get_content(url):\n    \"\"\"\n    得到API返回的JSON数据\n    :param url: API链接\n    :return: 返回的是一个字典\n    \"\"\"\n    try:\n        r = requests.get(url)\n        r.raise_for_status()\n        r.encoding = r.apparent_encoding\n        return r.json()\n    except:\n        print(\"ERROR\")\n\n\ndef get_img(url):\n    \"\"\"\n    得到图片的内容\n    :param url: 图片的真实链接\n    :return: 返回的是byte类型的图片内容\n    \"\"\"\n    try:\n        r = requests.get(url)\n        return r.content\n    except:\n        return None\n\n\ndef download(file_name, url):\n    \"\"\"\n    根据得到的链接在指定位置保存图片\n    :param file_name: 要保存图片的位置\n    :param url: 图片的链接\n    :return: \n    \"\"\"\n    if os.path.exists(r'C:\\Users\\Freed\\Pictures\\bingwallpaper'):\n        print('Find Dir...')\n    else:\n        print(\"File dir did not exist, make dir...\")\n        try:\n            os.mkdir(r'C:\\Users\\Freed\\Pictures\\bingwallpaper')\n            print('Make dir success')\n        except:\n            print('Failed in make dir')\n    if os.path.exists(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name):\n        print('Image downloaded already')\n    else:\n        img = get_img(url)\n        with open(r'c:\\users\\freed\\pictures\\bingwallpaper\\\\' + file_name,\n                  'wb') as f:\n            f.write(img)\n        print('Download success')\n\n\nif __name__ == '__main__':\n    url = \"https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n    content = get_content(url)\n    url_dict = content['images'][0]\n    download_url = 'https://www.bing.com' + url_dict['url']\n\n    file_name = str(\"BingWallPaper-\" + time.strftime('%Y-%m-%d',\n                                                     time.localtime(time.time())) + '.jpg')\n    download(file_name, download_url)\n```\n\n用Python命令运行文件即可。\n到此大功告成!  :D\n","slug":"Python3脚本抓取Bing美图","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsin000xw8voa4ojg4rs","content":"<p><img data-src=\"http://api.dujin.org/bing/1920.php\" alt=\"post_background\"></p>\n<h1 id=\"使用Python脚本下载Bing美图\"><a href=\"#使用Python脚本下载Bing美图\" class=\"headerlink\" title=\"使用Python脚本下载Bing美图\"></a>使用Python脚本下载Bing美图</h1><p><a href=\"https://cn.bing.com/\">Bing首页</a>每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Bing美图API\"><a href=\"#Bing美图API\" class=\"headerlink\" title=\"Bing美图API\"></a>Bing美图API</h2><p>Bing官方有两个API：<br>xml版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1</a><br>json版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a><br>有了API就可以愉快地抓图了:D</p>\n<h2 id=\"Python抓图\"><a href=\"#Python抓图\" class=\"headerlink\" title=\"Python抓图\"></a>Python抓图</h2><p>至于为什么要用Python，前段时间学习了廖大的<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\">Python教程</a>,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！</p>\n<h2 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h2><ul>\n<li><a href=\"http://cn.python-requests.org/zh_CN/latest/index.html\">Requests</a></li>\n</ul>\n<h2 id=\"爬图-更新于2018-04-04\"><a href=\"#爬图-更新于2018-04-04\" class=\"headerlink\" title=\"爬图 (更新于2018-04-04)\"></a>爬图 (更新于2018-04-04)</h2><p>这里我用了json版的API，使用<code>requests</code>的<code>json()</code>函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在<code>images</code>所对应的值里面。得到<code>images</code>的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值<code>url</code>来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上<code>https:://www.bing.com</code>，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_content</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    得到API返回的JSON数据</span></span><br><span class=\"line\"><span class=\"string\">    :param url: API链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: 返回的是一个字典</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = requests.get(url)</span><br><span class=\"line\">        r.raise_for_status()</span><br><span class=\"line\">        r.encoding = r.apparent_encoding</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.json()</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&quot;ERROR&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_img</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    得到图片的内容</span></span><br><span class=\"line\"><span class=\"string\">    :param url: 图片的真实链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: 返回的是byte类型的图片内容</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = requests.get(url)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.content</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span>(<span class=\"params\">file_name, url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    根据得到的链接在指定位置保存图片</span></span><br><span class=\"line\"><span class=\"string\">    :param file_name: 要保存图片的位置</span></span><br><span class=\"line\"><span class=\"string\">    :param url: 图片的链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: </span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r&#x27;C:\\Users\\Freed\\Pictures\\bingwallpaper&#x27;</span>):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Find Dir...&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&quot;File dir did not exist, make dir...&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            os.mkdir(<span class=\"string\">r&#x27;C:\\Users\\Freed\\Pictures\\bingwallpaper&#x27;</span>)</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;Make dir success&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;Failed in make dir&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r&#x27;c:\\users\\freed\\pictures\\bingwallpaper\\\\&#x27;</span> + file_name):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Image downloaded already&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        img = get_img(url)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">r&#x27;c:\\users\\freed\\pictures\\bingwallpaper\\\\&#x27;</span> + file_name,</span><br><span class=\"line\">                  <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(img)</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Download success&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    url = <span class=\"string\">&quot;https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&quot;</span></span><br><span class=\"line\">    content = get_content(url)</span><br><span class=\"line\">    url_dict = content[<span class=\"string\">&#x27;images&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">    download_url = <span class=\"string\">&#x27;https://www.bing.com&#x27;</span> + url_dict[<span class=\"string\">&#x27;url&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    file_name = <span class=\"built_in\">str</span>(<span class=\"string\">&quot;BingWallPaper-&quot;</span> + time.strftime(<span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>,</span><br><span class=\"line\">                                                     time.localtime(time.time())) + <span class=\"string\">&#x27;.jpg&#x27;</span>)</span><br><span class=\"line\">    download(file_name, download_url)</span><br></pre></td></tr></table></figure>\n\n<p>用Python命令运行文件即可。<br>到此大功告成!  :D</p>\n","site":{"data":{}},"length":2289,"excerpt":"<p><img data-src=\"http://api.dujin.org/bing/1920.php\" alt=\"post_background\"></p>\n<h1 id=\"使用Python脚本下载Bing美图\"><a href=\"#使用Python脚本下载Bing美图\" class=\"headerlink\" title=\"使用Python脚本下载Bing美图\"></a>使用Python脚本下载Bing美图</h1><p><a href=\"https://cn.bing.com/\">Bing首页</a>每天都会展示不同的图片，如果每天都去首页下载就比较麻烦了，于是乎想到了用Python脚本来代替，自动保存到图片目录下，省时省力。</p>","more":"<h2 id=\"Bing美图API\"><a href=\"#Bing美图API\" class=\"headerlink\" title=\"Bing美图API\"></a>Bing美图API</h2><p>Bing官方有两个API：<br>xml版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1</a><br>json版： <a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a><br>有了API就可以愉快地抓图了:D</p>\n<h2 id=\"Python抓图\"><a href=\"#Python抓图\" class=\"headerlink\" title=\"Python抓图\"></a>Python抓图</h2><p>至于为什么要用Python，前段时间学习了廖大的<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\">Python教程</a>,算是跟着把整个教程做完了，就放了一段时间。现在突然想弄个小工具来下Bing美图，嗯，就是它了！</p>\n<h2 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h2><ul>\n<li><a href=\"http://cn.python-requests.org/zh_CN/latest/index.html\">Requests</a></li>\n</ul>\n<h2 id=\"爬图-更新于2018-04-04\"><a href=\"#爬图-更新于2018-04-04\" class=\"headerlink\" title=\"爬图 (更新于2018-04-04)\"></a>爬图 (更新于2018-04-04)</h2><p>这里我用了json版的API，使用<code>requests</code>的<code>json()</code>函数直接返回了API中的json字段，返回的类型是一个字典。我们需要的下载链接在<code>images</code>所对应的值里面。得到<code>images</code>的值后，他是一个列表，且里面嵌套了一个字典，我们提取出列表里的字典，然后根据键值<code>url</code>来得到图片的地址。改地址只是部分地址，我们还需要在地址前面加上<code>https:://www.bing.com</code>，将两个地址合起来就是图片的真实地址了，通过真实地址，就可以下载到bing主页的背景图片了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_content</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    得到API返回的JSON数据</span></span><br><span class=\"line\"><span class=\"string\">    :param url: API链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: 返回的是一个字典</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = requests.get(url)</span><br><span class=\"line\">        r.raise_for_status()</span><br><span class=\"line\">        r.encoding = r.apparent_encoding</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.json()</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&quot;ERROR&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_img</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    得到图片的内容</span></span><br><span class=\"line\"><span class=\"string\">    :param url: 图片的真实链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: 返回的是byte类型的图片内容</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = requests.get(url)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.content</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span>(<span class=\"params\">file_name, url</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    根据得到的链接在指定位置保存图片</span></span><br><span class=\"line\"><span class=\"string\">    :param file_name: 要保存图片的位置</span></span><br><span class=\"line\"><span class=\"string\">    :param url: 图片的链接</span></span><br><span class=\"line\"><span class=\"string\">    :return: </span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r&#x27;C:\\Users\\Freed\\Pictures\\bingwallpaper&#x27;</span>):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Find Dir...&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&quot;File dir did not exist, make dir...&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            os.mkdir(<span class=\"string\">r&#x27;C:\\Users\\Freed\\Pictures\\bingwallpaper&#x27;</span>)</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;Make dir success&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;Failed in make dir&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(<span class=\"string\">r&#x27;c:\\users\\freed\\pictures\\bingwallpaper\\\\&#x27;</span> + file_name):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Image downloaded already&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        img = get_img(url)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">r&#x27;c:\\users\\freed\\pictures\\bingwallpaper\\\\&#x27;</span> + file_name,</span><br><span class=\"line\">                  <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(img)</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;Download success&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    url = <span class=\"string\">&quot;https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&quot;</span></span><br><span class=\"line\">    content = get_content(url)</span><br><span class=\"line\">    url_dict = content[<span class=\"string\">&#x27;images&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">    download_url = <span class=\"string\">&#x27;https://www.bing.com&#x27;</span> + url_dict[<span class=\"string\">&#x27;url&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    file_name = <span class=\"built_in\">str</span>(<span class=\"string\">&quot;BingWallPaper-&quot;</span> + time.strftime(<span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>,</span><br><span class=\"line\">                                                     time.localtime(time.time())) + <span class=\"string\">&#x27;.jpg&#x27;</span>)</span><br><span class=\"line\">    download(file_name, download_url)</span><br></pre></td></tr></table></figure>\n\n<p>用Python命令运行文件即可。<br>到此大功告成!  :D</p>"},{"title":"Python生成词云","date":"2017-03-25T07:02:21.000Z","updated":"2017-03-25T08:02:58.000Z","comments":1,"_content":"![wordcloud](/images/imagesource/17-03-25-1.png )\n\n## Python如何生成词云\n最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P\n通过度娘发现可以用Python库来生成词云， So Let's go!\n<!--more-->\n\n### 用到的库\n#### WorldCloud\n- 官网: https://amueller.github.io/word_cloud\n- github: https://github.com/amueller/word_cloud \n\n\n### 安装WordCloud\n\n#### 通过PIP安装\n\n    pip install wordcloud\n#### 下载WHL包安装\n当然可能通过PIP会安装出错，我们可以下[WHL包](http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud)手动安装\n\n下载完成后，再使用PIP命令安装：\n\n    pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n    \n其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是`wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl`。\n\n### 使用WordlCloud\n安装完成后，就可以用了。可以先测试以下是否安装成功：\n\n    from wordcould import WordCloud\n如果没有报错，表示安装成功了。\n\n#### 源代码\n下面就是源码部分了:\n``` python\n# -*- coding: utf-8 -*-\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\nfrom scipy.misc omport imread\n\n# 读入一个文件\ntext = open('your text file.txt', 'r').read()\n# 读入图片\nbg_pic = imread('your picture.png')\n# 配置词云参数\nwc = WordCloud(\n    # 设置背景色,我这里设置为了黑色\n    background_color = 'black',\n    # 设置词云形状，就是之前读入的图片\n    mask = bg_pic,\n    # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块\n    font_path = 'Sketch Fine Serif.otf'\n)\n# 生成词云\nwordcloud = wc.generate(text)\n# 显示词云图片\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.show()\n# 保存图片\nwordcloud.to_file('wordcloud.jpg')\n```\n\n生成的词云效果如图:\n![my wordcloud](/images/imagesource/17-03-25-2.jpg)\n#### 参数\n\n其中配置词云参数的时候，有多个参数可选：\n\nParameters\n```\nfont_path : string\n```\n> Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.\n\n```\nwidth : int (default=400)\n```\n> Width of the canvas.\n\n```\nheight : int (default=200)\n```\n> Height of canvas\n\n```\nprefer_horizontal : float (default=0.90)\n```\n> The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal < 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)\n\n```\nmask : nd-array or None (default=None)\n```\n> If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]\n\n```\nscale : float (default=1)\n```\n> Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.\n\n```\nmin_font_size : int (default=4)\n```\n> Smallest font size to use. Will stop when there is no more room in this size.\n\n```\nfont_step : int (default=1)\n```\n> Step size for the font. font_step > 1 might speed up computation but give a worse fit.\n\n```\nmax_words : number (default=200)\n```\n> The maximum number of words.\n\n```\nstopwords : set of strings or None\n```\n> The words that will be eliminated. If None, the build-in STOPWORDS list will be used.\n\n```\nbackground_color : color value (default=”black”)\n```\n> Background color for the word cloud image.\n\n```\nmax_font_size : int or None (default=None)\n```\n> Maximum font size for the largest word. If None, height of the image is used.\n\n```\nmode : string (default=”RGB”)\n```\n> Transparent background will be generated when mode is “RGBA” and background_color is None.\n\n```\nrelative_scaling : float (default=.5)\n```\n> Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.\n\n```\ncolor_func : callable, default=None\n```\n> Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.\n\n```\nregexp : string or None (optional)\n```\n> Regular expression to split the input text into tokens in process_text. If None is specified, r\"\\w[\\w']+\" is used.\n\n```\ncollocations : bool, default=True\n```\n> Whether to include collocations (bigrams) of two words.\n\n```\ncolormap : string or matplotlib colormap, default=”viridis”\n```\n> Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.\n\n```\nnormalize_plurals : bool, default=True\n```\n> Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.\n\n以上就是所有可以配置的参数，可以根据需要来用。\n\nEnd~\n\n---\n[1]: 图片出处: https://github.com/amueller/word_cloud\n\n","source":"_posts/Python生成词云.md","raw":"---\ntitle: Python生成词云\ndate: 2017-03-25 15:02:21\nupdated: 2017-03-25 16:02:58\ncategory: Python\ntags: \n- Python\n- 词云\ncomments: true\n---\n![wordcloud](/images/imagesource/17-03-25-1.png )\n\n## Python如何生成词云\n最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P\n通过度娘发现可以用Python库来生成词云， So Let's go!\n<!--more-->\n\n### 用到的库\n#### WorldCloud\n- 官网: https://amueller.github.io/word_cloud\n- github: https://github.com/amueller/word_cloud \n\n\n### 安装WordCloud\n\n#### 通过PIP安装\n\n    pip install wordcloud\n#### 下载WHL包安装\n当然可能通过PIP会安装出错，我们可以下[WHL包](http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud)手动安装\n\n下载完成后，再使用PIP命令安装：\n\n    pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl\n    \n其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是`wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl`。\n\n### 使用WordlCloud\n安装完成后，就可以用了。可以先测试以下是否安装成功：\n\n    from wordcould import WordCloud\n如果没有报错，表示安装成功了。\n\n#### 源代码\n下面就是源码部分了:\n``` python\n# -*- coding: utf-8 -*-\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\nfrom scipy.misc omport imread\n\n# 读入一个文件\ntext = open('your text file.txt', 'r').read()\n# 读入图片\nbg_pic = imread('your picture.png')\n# 配置词云参数\nwc = WordCloud(\n    # 设置背景色,我这里设置为了黑色\n    background_color = 'black',\n    # 设置词云形状，就是之前读入的图片\n    mask = bg_pic,\n    # 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块\n    font_path = 'Sketch Fine Serif.otf'\n)\n# 生成词云\nwordcloud = wc.generate(text)\n# 显示词云图片\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.show()\n# 保存图片\nwordcloud.to_file('wordcloud.jpg')\n```\n\n生成的词云效果如图:\n![my wordcloud](/images/imagesource/17-03-25-2.jpg)\n#### 参数\n\n其中配置词云参数的时候，有多个参数可选：\n\nParameters\n```\nfont_path : string\n```\n> Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.\n\n```\nwidth : int (default=400)\n```\n> Width of the canvas.\n\n```\nheight : int (default=200)\n```\n> Height of canvas\n\n```\nprefer_horizontal : float (default=0.90)\n```\n> The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal < 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)\n\n```\nmask : nd-array or None (default=None)\n```\n> If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]\n\n```\nscale : float (default=1)\n```\n> Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.\n\n```\nmin_font_size : int (default=4)\n```\n> Smallest font size to use. Will stop when there is no more room in this size.\n\n```\nfont_step : int (default=1)\n```\n> Step size for the font. font_step > 1 might speed up computation but give a worse fit.\n\n```\nmax_words : number (default=200)\n```\n> The maximum number of words.\n\n```\nstopwords : set of strings or None\n```\n> The words that will be eliminated. If None, the build-in STOPWORDS list will be used.\n\n```\nbackground_color : color value (default=”black”)\n```\n> Background color for the word cloud image.\n\n```\nmax_font_size : int or None (default=None)\n```\n> Maximum font size for the largest word. If None, height of the image is used.\n\n```\nmode : string (default=”RGB”)\n```\n> Transparent background will be generated when mode is “RGBA” and background_color is None.\n\n```\nrelative_scaling : float (default=.5)\n```\n> Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.\n\n```\ncolor_func : callable, default=None\n```\n> Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.\n\n```\nregexp : string or None (optional)\n```\n> Regular expression to split the input text into tokens in process_text. If None is specified, r\"\\w[\\w']+\" is used.\n\n```\ncollocations : bool, default=True\n```\n> Whether to include collocations (bigrams) of two words.\n\n```\ncolormap : string or matplotlib colormap, default=”viridis”\n```\n> Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.\n\n```\nnormalize_plurals : bool, default=True\n```\n> Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.\n\n以上就是所有可以配置的参数，可以根据需要来用。\n\nEnd~\n\n---\n[1]: 图片出处: https://github.com/amueller/word_cloud\n\n","slug":"Python生成词云","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsin000yw8voedel0ze6","content":"<p><img data-src=\"/images/imagesource/17-03-25-1.png\" alt=\"wordcloud\"></p>\n<h2 id=\"Python如何生成词云\"><a href=\"#Python如何生成词云\" class=\"headerlink\" title=\"Python如何生成词云\"></a>Python如何生成词云</h2><p>最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P<br>通过度娘发现可以用Python库来生成词云， So Let’s go!</p>\n<a id=\"more\"></a>\n\n<h3 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h3><h4 id=\"WorldCloud\"><a href=\"#WorldCloud\" class=\"headerlink\" title=\"WorldCloud\"></a>WorldCloud</h4><ul>\n<li>官网: <a href=\"https://amueller.github.io/word_cloud\">https://amueller.github.io/word_cloud</a></li>\n<li>github: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a> </li>\n</ul>\n<h3 id=\"安装WordCloud\"><a href=\"#安装WordCloud\" class=\"headerlink\" title=\"安装WordCloud\"></a>安装WordCloud</h3><h4 id=\"通过PIP安装\"><a href=\"#通过PIP安装\" class=\"headerlink\" title=\"通过PIP安装\"></a>通过PIP安装</h4><pre><code>pip install wordcloud</code></pre>\n<h4 id=\"下载WHL包安装\"><a href=\"#下载WHL包安装\" class=\"headerlink\" title=\"下载WHL包安装\"></a>下载WHL包安装</h4><p>当然可能通过PIP会安装出错，我们可以下<a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\">WHL包</a>手动安装</p>\n<p>下载完成后，再使用PIP命令安装：</p>\n<pre><code>pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code></pre>\n<p>其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是<code>wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code>。</p>\n<h3 id=\"使用WordlCloud\"><a href=\"#使用WordlCloud\" class=\"headerlink\" title=\"使用WordlCloud\"></a>使用WordlCloud</h3><p>安装完成后，就可以用了。可以先测试以下是否安装成功：</p>\n<pre><code>from wordcould import WordCloud</code></pre>\n<p>如果没有报错，表示安装成功了。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>下面就是源码部分了:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.misc omport imread</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入一个文件</span></span><br><span class=\"line\">text = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;your text file.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>).read()</span><br><span class=\"line\"><span class=\"comment\"># 读入图片</span></span><br><span class=\"line\">bg_pic = imread(<span class=\"string\">&#x27;your picture.png&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 配置词云参数</span></span><br><span class=\"line\">wc = WordCloud(</span><br><span class=\"line\">    <span class=\"comment\"># 设置背景色,我这里设置为了黑色</span></span><br><span class=\"line\">    background_color = <span class=\"string\">&#x27;black&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 设置词云形状，就是之前读入的图片</span></span><br><span class=\"line\">    mask = bg_pic,</span><br><span class=\"line\">    <span class=\"comment\"># 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块</span></span><br><span class=\"line\">    font_path = <span class=\"string\">&#x27;Sketch Fine Serif.otf&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># 生成词云</span></span><br><span class=\"line\">wordcloud = wc.generate(text)</span><br><span class=\"line\"><span class=\"comment\"># 显示词云图片</span></span><br><span class=\"line\">plt.imshow(wordcloud)</span><br><span class=\"line\">plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># 保存图片</span></span><br><span class=\"line\">wordcloud.to_file(<span class=\"string\">&#x27;wordcloud.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>生成的词云效果如图:<br><img data-src=\"/images/imagesource/17-03-25-2.jpg\" alt=\"my wordcloud\"></p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>其中配置词云参数的时候，有多个参数可选：</p>\n<p>Parameters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font_path : string</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width : int (default&#x3D;400)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Width of the canvas.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">height : int (default&#x3D;200)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Height of canvas</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prefer_horizontal : float (default&#x3D;0.90)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask : nd-array or None (default&#x3D;None)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scale : float (default&#x3D;1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_font_size : int (default&#x3D;4)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Smallest font size to use. Will stop when there is no more room in this size.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font_step : int (default&#x3D;1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_words : number (default&#x3D;200)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The maximum number of words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stopwords : set of strings or None</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The words that will be eliminated. If None, the build-in STOPWORDS list will be used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background_color : color value (default&#x3D;”black”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Background color for the word cloud image.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_font_size : int or None (default&#x3D;None)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Maximum font size for the largest word. If None, height of the image is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mode : string (default&#x3D;”RGB”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Transparent background will be generated when mode is “RGBA” and background_color is None.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">relative_scaling : float (default&#x3D;.5)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color_func : callable, default&#x3D;None</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regexp : string or None (optional)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Regular expression to split the input text into tokens in process_text. If None is specified, r”\\w[\\w’]+” is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collocations : bool, default&#x3D;True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to include collocations (bigrams) of two words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colormap : string or matplotlib colormap, default&#x3D;”viridis”</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">normalize_plurals : bool, default&#x3D;True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.</p>\n</blockquote>\n<p>以上就是所有可以配置的参数，可以根据需要来用。</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a></p>\n","site":{"data":{}},"length":3928,"excerpt":"<p><img data-src=\"/images/imagesource/17-03-25-1.png\" alt=\"wordcloud\"></p>\n<h2 id=\"Python如何生成词云\"><a href=\"#Python如何生成词云\" class=\"headerlink\" title=\"Python如何生成词云\"></a>Python如何生成词云</h2><p>最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P<br>通过度娘发现可以用Python库来生成词云， So Let’s go!</p>","more":"<h3 id=\"用到的库\"><a href=\"#用到的库\" class=\"headerlink\" title=\"用到的库\"></a>用到的库</h3><h4 id=\"WorldCloud\"><a href=\"#WorldCloud\" class=\"headerlink\" title=\"WorldCloud\"></a>WorldCloud</h4><ul>\n<li>官网: <a href=\"https://amueller.github.io/word_cloud\">https://amueller.github.io/word_cloud</a></li>\n<li>github: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a> </li>\n</ul>\n<h3 id=\"安装WordCloud\"><a href=\"#安装WordCloud\" class=\"headerlink\" title=\"安装WordCloud\"></a>安装WordCloud</h3><h4 id=\"通过PIP安装\"><a href=\"#通过PIP安装\" class=\"headerlink\" title=\"通过PIP安装\"></a>通过PIP安装</h4><pre><code>pip install wordcloud</code></pre>\n<h4 id=\"下载WHL包安装\"><a href=\"#下载WHL包安装\" class=\"headerlink\" title=\"下载WHL包安装\"></a>下载WHL包安装</h4><p>当然可能通过PIP会安装出错，我们可以下<a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\">WHL包</a>手动安装</p>\n<p>下载完成后，再使用PIP命令安装：</p>\n<pre><code>pip install yourfilepath\\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code></pre>\n<p>其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是<code>wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code>。</p>\n<h3 id=\"使用WordlCloud\"><a href=\"#使用WordlCloud\" class=\"headerlink\" title=\"使用WordlCloud\"></a>使用WordlCloud</h3><p>安装完成后，就可以用了。可以先测试以下是否安装成功：</p>\n<pre><code>from wordcould import WordCloud</code></pre>\n<p>如果没有报错，表示安装成功了。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>下面就是源码部分了:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.misc omport imread</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入一个文件</span></span><br><span class=\"line\">text = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;your text file.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>).read()</span><br><span class=\"line\"><span class=\"comment\"># 读入图片</span></span><br><span class=\"line\">bg_pic = imread(<span class=\"string\">&#x27;your picture.png&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 配置词云参数</span></span><br><span class=\"line\">wc = WordCloud(</span><br><span class=\"line\">    <span class=\"comment\"># 设置背景色,我这里设置为了黑色</span></span><br><span class=\"line\">    background_color = <span class=\"string\">&#x27;black&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 设置词云形状，就是之前读入的图片</span></span><br><span class=\"line\">    mask = bg_pic,</span><br><span class=\"line\">    <span class=\"comment\"># 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块</span></span><br><span class=\"line\">    font_path = <span class=\"string\">&#x27;Sketch Fine Serif.otf&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># 生成词云</span></span><br><span class=\"line\">wordcloud = wc.generate(text)</span><br><span class=\"line\"><span class=\"comment\"># 显示词云图片</span></span><br><span class=\"line\">plt.imshow(wordcloud)</span><br><span class=\"line\">plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># 保存图片</span></span><br><span class=\"line\">wordcloud.to_file(<span class=\"string\">&#x27;wordcloud.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>生成的词云效果如图:<br><img data-src=\"/images/imagesource/17-03-25-2.jpg\" alt=\"my wordcloud\"></p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>其中配置词云参数的时候，有多个参数可选：</p>\n<p>Parameters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font_path : string</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width : int (default&#x3D;400)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Width of the canvas.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">height : int (default&#x3D;200)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Height of canvas</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prefer_horizontal : float (default&#x3D;0.90)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask : nd-array or None (default&#x3D;None)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scale : float (default&#x3D;1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_font_size : int (default&#x3D;4)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Smallest font size to use. Will stop when there is no more room in this size.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font_step : int (default&#x3D;1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_words : number (default&#x3D;200)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The maximum number of words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stopwords : set of strings or None</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The words that will be eliminated. If None, the build-in STOPWORDS list will be used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background_color : color value (default&#x3D;”black”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Background color for the word cloud image.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_font_size : int or None (default&#x3D;None)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Maximum font size for the largest word. If None, height of the image is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mode : string (default&#x3D;”RGB”)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Transparent background will be generated when mode is “RGBA” and background_color is None.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">relative_scaling : float (default&#x3D;.5)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color_func : callable, default&#x3D;None</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regexp : string or None (optional)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Regular expression to split the input text into tokens in process_text. If None is specified, r”\\w[\\w’]+” is used.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collocations : bool, default&#x3D;True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to include collocations (bigrams) of two words.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colormap : string or matplotlib colormap, default&#x3D;”viridis”</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">normalize_plurals : bool, default&#x3D;True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.</p>\n</blockquote>\n<p>以上就是所有可以配置的参数，可以根据需要来用。</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"https://github.com/amueller/word_cloud\">https://github.com/amueller/word_cloud</a></p>"},{"title":"UTF-8 码点","date":"2017-10-09T02:34:48.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\nUTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：\n<!--more-->\n\n | 码点范围    | 码点位数    |  字节1  |字节2|字节3|字节4|\n |:-----------:|:--:         |:--:     |:--: |:--: |:--: |\n |U+0000~U+007F|7            |0xxxxxxx |     |     |     |\n |U+0080~U+07FF|11           |110xxxxx |10xxxxxx|    |    |\n |U+0800~U+FFFF|16           |1110xxxx |10xxxxxx|10xxxxxx| |\n |U+10000~U+10FFFF| 21       |11110xxx |10xxxxxx|10xxxxxx|10xxxxxx|\n \n 1000 0000 -> 80\n 1100 0000 -> C0\n 1110 0000 -> E0\n 1111 0000 -> F0\n \n 1111 1111 -> FF\n 0011 1111 -> 3F\n \n e.g. U+20AC 0x0800 < 0x20AC < 0xFFFF\n 所以0x20AC有16位码点,编成三字节\n 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即\n 0010 0000 1010 1100\n 将其分成三组：\n 0010， 000010， 101100\n 加上前缀：\n 1110 0010, 1000 0010, 1010 1100\n 则得到 0xE2, 0x82, 0xAC\n \n 10 0000 1010 1100 >> 12 -> 10 -> 0000 0010\n 0000 0010 & 1111 1111 -> 0000 0010\n 1110 0000 | 0000 0010 -> 1110 0010 -> 0xE2\n \n 10 0000 1010 1100 >> 6 -> 1000 0010\n 1000 0010 & 0011 1111 -> 0000 0010\n 1000 0000 | 0000 0010 -> 1000 0010 -> 0x82\n \n 10 0000 1010 1100 & 00 0000 1111 1111 -> 00 0000 1010 1100\n 00 0000 1000 0000 | 00 0000 1010 1100 -> 1010 1100 -> 0xAC\n\n 代码表示(C):\n\n``` c\n// u <= 0x007F\nPUTC(c, u & 0xFF);\n\n// u <= 0x07FF\nPUTC(c, 0xC0 | ((u >> 6) & 0xFF));\nPUTC(c, 0x80 | (u & 0x3F);\n\n// u <= 0xFFFF\nPUTC(c, 0xE0 | ((u >> 12) & 0xFF));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n\n// u <= 0x10FFFF\nPUTC(c, 0xF0 | ((u >> 18) & 0xFF));\nPUTC(c, 0x80 | ((u >> 12) & 0x3F));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n```\n\n---","source":"_posts/UTF-8-码点.md","raw":"---\ntitle: UTF-8 码点\ndate: 2017-10-09 10:34:48\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: UTF-8\ncomments: true\n---\n\nUTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：\n<!--more-->\n\n | 码点范围    | 码点位数    |  字节1  |字节2|字节3|字节4|\n |:-----------:|:--:         |:--:     |:--: |:--: |:--: |\n |U+0000~U+007F|7            |0xxxxxxx |     |     |     |\n |U+0080~U+07FF|11           |110xxxxx |10xxxxxx|    |    |\n |U+0800~U+FFFF|16           |1110xxxx |10xxxxxx|10xxxxxx| |\n |U+10000~U+10FFFF| 21       |11110xxx |10xxxxxx|10xxxxxx|10xxxxxx|\n \n 1000 0000 -> 80\n 1100 0000 -> C0\n 1110 0000 -> E0\n 1111 0000 -> F0\n \n 1111 1111 -> FF\n 0011 1111 -> 3F\n \n e.g. U+20AC 0x0800 < 0x20AC < 0xFFFF\n 所以0x20AC有16位码点,编成三字节\n 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即\n 0010 0000 1010 1100\n 将其分成三组：\n 0010， 000010， 101100\n 加上前缀：\n 1110 0010, 1000 0010, 1010 1100\n 则得到 0xE2, 0x82, 0xAC\n \n 10 0000 1010 1100 >> 12 -> 10 -> 0000 0010\n 0000 0010 & 1111 1111 -> 0000 0010\n 1110 0000 | 0000 0010 -> 1110 0010 -> 0xE2\n \n 10 0000 1010 1100 >> 6 -> 1000 0010\n 1000 0010 & 0011 1111 -> 0000 0010\n 1000 0000 | 0000 0010 -> 1000 0010 -> 0x82\n \n 10 0000 1010 1100 & 00 0000 1111 1111 -> 00 0000 1010 1100\n 00 0000 1000 0000 | 00 0000 1010 1100 -> 1010 1100 -> 0xAC\n\n 代码表示(C):\n\n``` c\n// u <= 0x007F\nPUTC(c, u & 0xFF);\n\n// u <= 0x07FF\nPUTC(c, 0xC0 | ((u >> 6) & 0xFF));\nPUTC(c, 0x80 | (u & 0x3F);\n\n// u <= 0xFFFF\nPUTC(c, 0xE0 | ((u >> 12) & 0xFF));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n\n// u <= 0x10FFFF\nPUTC(c, 0xF0 | ((u >> 18) & 0xFF));\nPUTC(c, 0x80 | ((u >> 12) & 0x3F));\nPUTC(c, 0x80 | ((u >> 6) & 0x3F));\nPUTC(c, 0x80 | (u & 0x3F));\n```\n\n---","slug":"UTF-8-码点","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiq0012w8vocx3tcx3p","content":"<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：</p>\n<a id=\"more\"></a>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">码点范围</th>\n<th align=\"center\">码点位数</th>\n<th align=\"center\">字节1</th>\n<th align=\"center\">字节2</th>\n<th align=\"center\">字节3</th>\n<th align=\"center\">字节4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">U+0000~U+007F</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0xxxxxxx</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+0080~U+07FF</td>\n<td align=\"center\">11</td>\n<td align=\"center\">110xxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+0800~U+FFFF</td>\n<td align=\"center\">16</td>\n<td align=\"center\">1110xxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+10000~U+10FFFF</td>\n<td align=\"center\">21</td>\n<td align=\"center\">11110xxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n</tr>\n</tbody></table>\n<p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p>\n<p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p>\n<p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p>\n<p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p>\n<p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p>\n<p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p>\n<p> 代码表示(C):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// u &lt;= 0x007F</span></span><br><span class=\"line\">PUTC(c, u &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0x07FF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xC0</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0xFFFF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xE0</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0x10FFFF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xF0</span> | ((u &gt;&gt; <span class=\"number\">18</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"length":1245,"excerpt":"<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：</p>","more":"<table>\n<thead>\n<tr>\n<th align=\"center\">码点范围</th>\n<th align=\"center\">码点位数</th>\n<th align=\"center\">字节1</th>\n<th align=\"center\">字节2</th>\n<th align=\"center\">字节3</th>\n<th align=\"center\">字节4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">U+0000~U+007F</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0xxxxxxx</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+0080~U+07FF</td>\n<td align=\"center\">11</td>\n<td align=\"center\">110xxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+0800~U+FFFF</td>\n<td align=\"center\">16</td>\n<td align=\"center\">1110xxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">U+10000~U+10FFFF</td>\n<td align=\"center\">21</td>\n<td align=\"center\">11110xxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n<td align=\"center\">10xxxxxx</td>\n</tr>\n</tbody></table>\n<p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p>\n<p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p>\n<p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p>\n<p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p>\n<p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p>\n<p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p>\n<p> 代码表示(C):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// u &lt;= 0x007F</span></span><br><span class=\"line\">PUTC(c, u &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0x07FF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xC0</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0xFFFF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xE0</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u &lt;= 0x10FFFF</span></span><br><span class=\"line\">PUTC(c, <span class=\"number\">0xF0</span> | ((u &gt;&gt; <span class=\"number\">18</span>) &amp; <span class=\"number\">0xFF</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | ((u &gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3F</span>));</span><br><span class=\"line\">PUTC(c, <span class=\"number\">0x80</span> | (u &amp; <span class=\"number\">0x3F</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>"},{"title":"VSCode 常用插件记录","date":"2019-01-08T13:50:16.000Z","updated":"2019-01-14T02:47:08.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-01-08.jpg","_content":"\n![vscode](/images/imagesource/19-01-08.png)\n诈尸更新~~🤣🤣🤣\n这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。\n<!--more-->\n\nVSCode 下载地址：[Visual Studio Code](https://code.visualstudio.com/)\n\n## 语言相关\n\n### C/C++\n\n推荐微软官方推出的 [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)插件，支持智能提示和debug，很方便。\n\n如何在 VSCode 上配置 C/C++ 环境可以参考知乎[Visual Studio Code如何编写运行C、C++？](https://www.zhihu.com/question/30315894/answer/154979413) 这个问题下的高赞回答。\n\n通过 [vscode-fileheader](https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader) 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。\n\n### Python\n\n同样推荐微软官方的 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件。本来是民间大神写的，后来被微软收编了。只要安装好 [Python](https://www.python.org/downloads/) 环境，然后再装这个插件，写起 Python 代码来美滋滋！\n\n同时再推荐 [Visual Studio IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。\n\n## 文章书写\n\n### Markdown\n\nVSCode 对 Markdown 也有很好的支持。推荐如下几个插件：\n\n1. [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。\n2. [Markdown Preview Enhanced](https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced)，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。\n\n### LaTeX\n\nVSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 [TeX Live](https://www.tug.org/texlive/) 作为 TeX 环境。有了 TeX 环境后，再安装 [LaTeX Workshop](https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop) 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。\n\n同时推荐 [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。\n\n## 美化相关\n\nVSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。\n\n### 主题\n\n1. [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)，一款仿照 Atom 的 One Dark 主题\n2. [Material Theme](https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme)，Google Material Design 风格的主题，有多种颜色可以选择\n\n### 图标\n\n这里只推荐一个，个人最喜欢的一套图标 [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。\n\n### 字体\n\nVSCode 同时支持自定义字体，个人的字体设置为 `'Consolas', '思源黑体 Regular', monospace`，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。\n\n## 其他\n\n### HTML 文件预览\n\n写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 [View In Browser](https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser)，通过快捷键 `Ctrl+F1` 即可在默认的浏览器中预览 HTML 文档了。\n\n### GitHub\n\n[GitHub](https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github) 插件支持 GitHub pull/push 等源代码相关操作。\n\n### 代码运行\n\n[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。\n\n### 语言环境\n\n新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如[简体中文](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans)，安装完成后重新加载即可使用中文界面。其他语言同理。\n\n### 同步设置\n\n[Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 [GitHub Gist](https://gist.github.com/) 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。\n\n\n以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。","source":"_posts/VSCode-Extensions.md","raw":"---\ntitle: VSCode 常用插件记录\ndate: 2019-01-08 21:50:16\nupdated: 2019-01-14 10:47:08\ncategory: Development\ntags: VSCode\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-01-08.jpg\n---\n\n![vscode](/images/imagesource/19-01-08.png)\n诈尸更新~~🤣🤣🤣\n这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。\n<!--more-->\n\nVSCode 下载地址：[Visual Studio Code](https://code.visualstudio.com/)\n\n## 语言相关\n\n### C/C++\n\n推荐微软官方推出的 [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)插件，支持智能提示和debug，很方便。\n\n如何在 VSCode 上配置 C/C++ 环境可以参考知乎[Visual Studio Code如何编写运行C、C++？](https://www.zhihu.com/question/30315894/answer/154979413) 这个问题下的高赞回答。\n\n通过 [vscode-fileheader](https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader) 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。\n\n### Python\n\n同样推荐微软官方的 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件。本来是民间大神写的，后来被微软收编了。只要安装好 [Python](https://www.python.org/downloads/) 环境，然后再装这个插件，写起 Python 代码来美滋滋！\n\n同时再推荐 [Visual Studio IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。\n\n## 文章书写\n\n### Markdown\n\nVSCode 对 Markdown 也有很好的支持。推荐如下几个插件：\n\n1. [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。\n2. [Markdown Preview Enhanced](https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced)，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。\n\n### LaTeX\n\nVSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 [TeX Live](https://www.tug.org/texlive/) 作为 TeX 环境。有了 TeX 环境后，再安装 [LaTeX Workshop](https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop) 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。\n\n同时推荐 [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。\n\n## 美化相关\n\nVSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。\n\n### 主题\n\n1. [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)，一款仿照 Atom 的 One Dark 主题\n2. [Material Theme](https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme)，Google Material Design 风格的主题，有多种颜色可以选择\n\n### 图标\n\n这里只推荐一个，个人最喜欢的一套图标 [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。\n\n### 字体\n\nVSCode 同时支持自定义字体，个人的字体设置为 `'Consolas', '思源黑体 Regular', monospace`，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。\n\n## 其他\n\n### HTML 文件预览\n\n写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 [View In Browser](https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser)，通过快捷键 `Ctrl+F1` 即可在默认的浏览器中预览 HTML 文档了。\n\n### GitHub\n\n[GitHub](https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github) 插件支持 GitHub pull/push 等源代码相关操作。\n\n### 代码运行\n\n[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。\n\n### 语言环境\n\n新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如[简体中文](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans)，安装完成后重新加载即可使用中文界面。其他语言同理。\n\n### 同步设置\n\n[Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 [GitHub Gist](https://gist.github.com/) 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。\n\n\n以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。","slug":"VSCode-Extensions","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiq0014w8vo51pvdpoj","content":"<p><img data-src=\"/images/imagesource/19-01-08.png\" alt=\"vscode\"><br>诈尸更新~~🤣🤣🤣<br>这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。</p>\n<a id=\"more\"></a>\n\n<p>VSCode 下载地址：<a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></p>\n<h2 id=\"语言相关\"><a href=\"#语言相关\" class=\"headerlink\" title=\"语言相关\"></a>语言相关</h2><h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><p>推荐微软官方推出的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">C/C++</a>插件，支持智能提示和debug，很方便。</p>\n<p>如何在 VSCode 上配置 C/C++ 环境可以参考知乎<a href=\"https://www.zhihu.com/question/30315894/answer/154979413\">Visual Studio Code如何编写运行C、C++？</a> 这个问题下的高赞回答。</p>\n<p>通过 <a href=\"https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader\">vscode-fileheader</a> 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>同样推荐微软官方的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-python.python\">Python</a> 插件。本来是民间大神写的，后来被微软收编了。只要安装好 <a href=\"https://www.python.org/downloads/\">Python</a> 环境，然后再装这个插件，写起 Python 代码来美滋滋！</p>\n<p>同时再推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode\">Visual Studio IntelliCode</a> 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。</p>\n<h2 id=\"文章书写\"><a href=\"#文章书写\" class=\"headerlink\" title=\"文章书写\"></a>文章书写</h2><h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><p>VSCode 对 Markdown 也有很好的支持。推荐如下几个插件：</p>\n<ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\">Markdown All in One</a>，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced\">Markdown Preview Enhanced</a>，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。</li>\n</ol>\n<h3 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"LaTeX\"></a>LaTeX</h3><p>VSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 <a href=\"https://www.tug.org/texlive/\">TeX Live</a> 作为 TeX 环境。有了 TeX 环境后，再安装 <a href=\"https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop\">LaTeX Workshop</a> 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。</p>\n<p>同时推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\">Code Spell Checker</a>，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。</p>\n<h2 id=\"美化相关\"><a href=\"#美化相关\" class=\"headerlink\" title=\"美化相关\"></a>美化相关</h2><p>VSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme\">One Dark Pro</a>，一款仿照 Atom 的 One Dark 主题</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme\">Material Theme</a>，Google Material Design 风格的主题，有多种颜色可以选择</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p>这里只推荐一个，个人最喜欢的一套图标 <a href=\"https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme\">Material Icon Theme</a>，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。</p>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>VSCode 同时支持自定义字体，个人的字体设置为 <code>&#39;Consolas&#39;, &#39;思源黑体 Regular&#39;, monospace</code>，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"HTML-文件预览\"><a href=\"#HTML-文件预览\" class=\"headerlink\" title=\"HTML 文件预览\"></a>HTML 文件预览</h3><p>写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 <a href=\"https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser\">View In Browser</a>，通过快捷键 <code>Ctrl+F1</code> 即可在默认的浏览器中预览 HTML 文档了。</p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github\">GitHub</a> 插件支持 GitHub pull/push 等源代码相关操作。</p>\n<h3 id=\"代码运行\"><a href=\"#代码运行\" class=\"headerlink\" title=\"代码运行\"></a>代码运行</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\">Code Runner</a> 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。</p>\n<h3 id=\"语言环境\"><a href=\"#语言环境\" class=\"headerlink\" title=\"语言环境\"></a>语言环境</h3><p>新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如<a href=\"https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans\">简体中文</a>，安装完成后重新加载即可使用中文界面。其他语言同理。</p>\n<h3 id=\"同步设置\"><a href=\"#同步设置\" class=\"headerlink\" title=\"同步设置\"></a>同步设置</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\">Settings Sync</a> 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 <a href=\"https://gist.github.com/\">GitHub Gist</a> 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。</p>\n<p>以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。</p>\n","site":{"data":{}},"length":1751,"excerpt":"<p><img data-src=\"/images/imagesource/19-01-08.png\" alt=\"vscode\"><br>诈尸更新~~🤣🤣🤣<br>这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。</p>","more":"<p>VSCode 下载地址：<a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></p>\n<h2 id=\"语言相关\"><a href=\"#语言相关\" class=\"headerlink\" title=\"语言相关\"></a>语言相关</h2><h3 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h3><p>推荐微软官方推出的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">C/C++</a>插件，支持智能提示和debug，很方便。</p>\n<p>如何在 VSCode 上配置 C/C++ 环境可以参考知乎<a href=\"https://www.zhihu.com/question/30315894/answer/154979413\">Visual Studio Code如何编写运行C、C++？</a> 这个问题下的高赞回答。</p>\n<p>通过 <a href=\"https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader\">vscode-fileheader</a> 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>同样推荐微软官方的 <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-python.python\">Python</a> 插件。本来是民间大神写的，后来被微软收编了。只要安装好 <a href=\"https://www.python.org/downloads/\">Python</a> 环境，然后再装这个插件，写起 Python 代码来美滋滋！</p>\n<p>同时再推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode\">Visual Studio IntelliCode</a> 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。</p>\n<h2 id=\"文章书写\"><a href=\"#文章书写\" class=\"headerlink\" title=\"文章书写\"></a>文章书写</h2><h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><p>VSCode 对 Markdown 也有很好的支持。推荐如下几个插件：</p>\n<ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\">Markdown All in One</a>，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced\">Markdown Preview Enhanced</a>，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。</li>\n</ol>\n<h3 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"LaTeX\"></a>LaTeX</h3><p>VSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 <a href=\"https://www.tug.org/texlive/\">TeX Live</a> 作为 TeX 环境。有了 TeX 环境后，再安装 <a href=\"https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop\">LaTeX Workshop</a> 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。</p>\n<p>同时推荐 <a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\">Code Spell Checker</a>，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。</p>\n<h2 id=\"美化相关\"><a href=\"#美化相关\" class=\"headerlink\" title=\"美化相关\"></a>美化相关</h2><p>VSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ol>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme\">One Dark Pro</a>，一款仿照 Atom 的 One Dark 主题</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme\">Material Theme</a>，Google Material Design 风格的主题，有多种颜色可以选择</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p>这里只推荐一个，个人最喜欢的一套图标 <a href=\"https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme\">Material Icon Theme</a>，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。</p>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>VSCode 同时支持自定义字体，个人的字体设置为 <code>&#39;Consolas&#39;, &#39;思源黑体 Regular&#39;, monospace</code>，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"HTML-文件预览\"><a href=\"#HTML-文件预览\" class=\"headerlink\" title=\"HTML 文件预览\"></a>HTML 文件预览</h3><p>写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 <a href=\"https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser\">View In Browser</a>，通过快捷键 <code>Ctrl+F1</code> 即可在默认的浏览器中预览 HTML 文档了。</p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github\">GitHub</a> 插件支持 GitHub pull/push 等源代码相关操作。</p>\n<h3 id=\"代码运行\"><a href=\"#代码运行\" class=\"headerlink\" title=\"代码运行\"></a>代码运行</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\">Code Runner</a> 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。</p>\n<h3 id=\"语言环境\"><a href=\"#语言环境\" class=\"headerlink\" title=\"语言环境\"></a>语言环境</h3><p>新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如<a href=\"https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans\">简体中文</a>，安装完成后重新加载即可使用中文界面。其他语言同理。</p>\n<h3 id=\"同步设置\"><a href=\"#同步设置\" class=\"headerlink\" title=\"同步设置\"></a>同步设置</h3><p><a href=\"https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\">Settings Sync</a> 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 <a href=\"https://gist.github.com/\">GitHub Gist</a> 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。</p>\n<p>以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。</p>"},{"title":"《Vim 教程》指令记录","date":"2019-05-17T05:54:10.000Z","updated":"2019-05-17T05:54:10.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-05-17.jpg","_content":"之前跟着 [Vim](https://www.vim.org/download.php) 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。\n<!--more-->\n\n\n在命令行输入 `vimtutor` 进入 Vim 自带的教程。\n\n## 基本操作\n\n### 移动光标\n\n移动光标分别为 `h`、`j`、`k`、`l` 键，当然也可以通过键盘上的方向键进行移动。不过考虑方向键离主键盘较远，因此使用`h`、`j`、`k`、`l`会更加高效。如果不确定当前的指令，只需要按下 `ESC` 键即可回到正常模式，然后再次输入指令。\n\n### Vim 的进入和退出\n\n在正常模式下，输入 `:q!` 然后再按下回车键即可退出当前打开的文档，该指令会丢弃之前对文件所作的所有改动。\n如果是命令提示符中通过 `vimtutor` 进入教程的，这时会返回至命令行的界面，这时只需重新输入 `vimtutor`，即可重新进入教程，只不过之前对文档的修改都未得到保存（不管保存与否，通过 `vimtutor` 进入教程每次都会打开一个副本）。\n\n> 若未对文档进行修改，输入 `:q` 即可退出 Vim，`:q!` 用于对文档有修改，但是不保存的情况，表示强制退出。\n\n### 文本编辑之删除\n\n在正常模式下（如果不知道是否处于正常模式，可以按下 `ESC` 来确保处于正常模式），可以按下 `x` 键来删除光标所在位置的字符。\n\n### 文编编辑之插入\n\n在正常模式下，按下 `i` 键来插入文本。这时会进入插入模式，当完成插入后，可按下 `ESC` 键返回正常模式。\n\n### 文本编辑之添加\n\n在正常模式下，按下 `A` 键来添加文本。与插入文本不同的是，添加文本操作会将光标移至当前行的行末。同样地，添加完成后，按下 `ESC` 键返回正常模式。\n\n### 编辑文件\n\n之前讲到如何退出 Vim，下面介绍如何保存修改后的文件。\n\n在命令行输入 `vim <filename>` 并回车，会进入名为 `<filename>` 的文档，通过之前的命令对文档进行修改，修改完成后，输入 `:wq` 并按下回车键即可保存改动并退出 Vim。\n\n## 删除与撤销\n\n### 删除类命令\n\n确保处于正常模式，输入 `dw` 即可从光标处删除至一个单词的末尾。\n\n> 当我们输入时，字母 `d` 会同时出现在屏幕的最后一行。Vim 在等待输入字母 `w`。如果看到的是除 `d` 以外的其他字符，表明输入了错误的指令，这时可以按下 `ESC` 键，并重新输入。\n\n### 更多删除类命令\n\n在正常模式下，输入 `d$` 从当前光标删除到行末。\n\n### 关于命令和对象\n\n许多改变文本的命令都由一个操作符和一个动作构成。\n\n使用删除操作符 `d` 的删除命令的格式如下：\n\n**d motion**\n\n其中：\n\n- `d` 表示删除操作符\n- `motion` 表示操作符的操作对象\n\n基本的动作列表如下所示：\n\n|操作对象|含义|\n|:-:|:---|\n|w|从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符|\n|e|从当前光标当前位置直到单词末尾，包括最后一个字符|\n|$|从当前光标当前位置直到当前行末|\n\n因此输入 `de` 会从当前光标位置删除到单词末尾。\n\n> 若不输入操作符，只按下代表相应动作的键，则光标的移动将会按照上述动作进行。\n\n### 使用计数指定动作\n\n在动作前输入数字会使它重复那么多次。例如：\n\n- 输入 `2w` 使光标向前移动两个单词。\n- 输入 `3e` 使光标向前移动到第三个单词的末尾。\n- 输入 `0` 移动光标到行首。\n\n通过输入不同的数值，可以执行相应的操作。\n\n### 使用计数以删除更多\n\n使用操作符时输入数字可以使它重复那么多次。上面已经提到过删除操作和动作的组合，我们还可以在组合中动作之前插入一个数字以删除更多：\n\n**d number motion**\n\n例如：\n\n- 输入 `d2w` 可以删除两个单词\n\n### 操作整行\n\n输入 `dd` 可以删除当前一整行。\n\n鉴于整行删除操作的高频度，Vim 提供了简化的删除操作，我们只需在同一行上输入两次 `d` 即可删除光标所在的行了。同时可以在 `dd` 操作前加入数字，以删除多行，例如：\n\n- 输入 `2dd` 可以删除两行。\n\n### 撤销类命令\n\n正常模式下，输入 `u` 来撤销最后执行的命令，输入 `U` 来撤销对整行的修改。例如按下了 `x` 删除了当前行的一个字符，那么可以通过 `u` 来撤销删除操作。若当前行执行了多个操作，需要全部撤销，则可通过 `U` 来撤销对当前行的所有修改。如果想要重做被撤销的命令，可以按下 `CTRL-R`，也即撤销掉撤销命令，回到原来修改后的状态。\n\n## 置入、更改和替换\n\n### 置入类命令\n\n正常模式下，输入 `p` 将最后一次删除的内容置入光标后。如：\n\n- 输入 `dd` 删除某一行\n- 将光标移至准备置入的位置的**上方**\n- 在正常模式下输入 `p` 将删除的一行粘贴置入\n\n### 替换类命令\n\n正常模式下，输入 `r` 和一个字符替换光标所在位置的字符。\n\n### 更改类命令\n\n正常模式下，要改变本文直到一个单词的末尾，可以使用 `ce`。同时也可以输入 `cw` 修改单词。具体操作为：\n\n- 将光标移动至单词中需要修改的开始位置\n- 输入 `cw` 并输入正确的单词\n- 按下 `ESC` 键退出修改\n\n> 请注意，`ce` 和 `cw` 命令不仅仅是删除了一个单词，它同时会进入插入模式。\n\n### 使用 c 更改更多\n\n更改类操作符可以与删除中使用的同样的动作配合使用。\n\n更改类操作符的工作方式跟删除类是一致的，其操作格式为：\n\n**c [number] motion**\n\n动作参数（motion）也是一样的，比如 `w` 代表单词，`$` 表示行末等。\n\n## 定位、查找和替换\n\n### 定位及文件状态\n\n正常模式下，输入 `CTRL-G` 显示当前编辑文件中当前光标所在行位置以及文件状态信息。\n\n输入 `G` 可以使当前光标直接跳转到文件的最后一行。\n\n输入 `gg` 可以使当前光标直接跳转到文件的第一行。\n\n输入行号，然后再输入 `G` 即可使当前光标直接跳转到指定行。\n\n### 搜索类命令\n\n正常模式下，输入 `/` 加上一个字符串可以用以在当前文档中查找该字符串。\n\n要查找同上一次的字符串，只需按下 `n` 键，如果要反向进行查找，则输入 `N`。\n\n要反向查找字符串，可以用 `?` 代替 `/`。\n\n要返回到之前的位置，可以按下 `CTRL-O`，重复按可以回退更多步。输入 `CTRL-I` 则会跳转到较新的位置，与 `CTRL-O` 执行的操作相反。\n\n> 如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 'wrapscan' 选项被复位。\n\n### 配对括号的查找\n\n正常模式下，输入 `%` 可以查找配对的括号 `)`、`]`、`}`。\n\n若当前光标所在位置的字符为 `)`、`]` 或者是 `}`，输入 `%` 即可使光标跳转至配对的括号处，再次输入 `%` 即可返回之前括号的位置。\n\n### 替换命令\n\n正常模式下，输入 `:s/old/new/g` 可以替换 old 为 new。\n\n若要替换两行之间出现的每个字符串，可以通过以下命令：\n\n- 输入 `:#,#s/old/new/g`， `#,#` 表示替换操作的若干行的首尾行号\n- 输入 `:%s/old/new/g`，表示替换整个文件中的每个匹配串\n- 输入 `:%s/old/new/gc`，则会查找整个文件中的匹配串，并且对每个匹配串提示是否进行替换\n\n## 文件相关操作\n\n### 在 Vim 内执行外部命令的方法\n\n在正常模式下，输入 `:!` 然后紧接着输入一个外部命令即可执行该外部命令。\n\n如输入 `:!ls` 并按下回车，会列出当前目录的内容。\n\n### 关于保存文件的更多信息\n\n正常模式下，输入 `:w FILENAME` 可以将对文件的改动保存到 FILENAME 中。\n\n若要删除保存的文件，可以通过执行外部命令的方法，输入 `:!rm TEST` 进行删除。\n\n### 一个具有选择性的保存命令\n\n在正常模式下，若要保存文件的部分内容，可以输入 `v motion :w FILENAME`。具体操作如下：\n\n- 将光标移动至要保存内容的开始位置\n- 接着按下 `v` 键进入可视模式，并继续移动光标至要保存内容的结束位置，这些内容会高亮显示\n- 然后按下 `:`，这时屏幕底部会出现 `:'<,'>`\n- 接着输入 `w FILENAME`，然后按下回车键\n- 所选中的内容将会被写入 FILENAME 中。\n\n> 按 `v` 键使 Vim 进入可视模式。我们可以移动光标使选取区域变大或变小。接着可以使用一个操作符对选中的文本进行操作。例如：按 `d` 键删除所选中的文本内容。\n\n### 提取和合并文件\n\n可以通过 `:r FILENAME` 命令向当前文件中插入另外文件的内容。\n\n> 除了合并文件外，还可以读取外部命令的输出。例如：`:r !ls` 可以读取 ls 命令的输出，并将其放置在光标打下面。\n\n## 打开、附加、替换、复制和设置类命令\n\n### 打开类命令\n\n正常模式下，输入 `o` 将在光标打下方打开新的一行并进入插入模式。\n\n若要在光标的**上方**打开新的一行，则需要输入 `O`。\n\n### 附加类命令\n\n正常模式下，输入 `a` 将在光标之后插入文本。\n\n> `a`、`i`、`A` 都会进入插入模式，唯一的区别在于字符插入的位置。`i` 将字符插入于光标之前，`a` 将字符插入于光标之后，而 `A` 则将字符插入于光标所在行的末尾。\n\n### 另一个置换命令的版本\n\n正常模式下，输入 `R` 可以连续替换多个字符。具体操作如下：\n\n- 将光标移动至要替换内容的起始位置\n- 输入 `R`，然后逐一输入要替换的字符\n- 按下 `ESC` 键退出替换模式回到正常模式。\n\n> 替换模式与插入模式类似，不过每个输入的字符都会删除一个已有的字符。\n\n### 复制粘贴文本\n\n正常模式下，使用操作符 `y` 复制文本，使用 `p` 粘贴文本。例如：\n\n- 移动光标至所要复制内容的起始位置\n- 按下 `v` 键进入可视模式\n- 移动光标至所要复制内容的结束位置\n- 输入 `y` 复制高亮文本\n- 移动光标至要粘贴的位置，输入 `p` 以复制文本\n\n> 可以把 `y` 当作操作符来使用。例如：`yw` 表示复制一个单词。\n\n### 设置类命令选项\n\n设置可使查找或者替换可忽略大小写的选项。例如：\n\n- 要查找单词 ignore 可以在正常模式下输入 `/ignore` 并回车\n- 然后设置 ic 选项（Ignore Case，忽略大小写），输入：`:set ic`\n- 现在可以通过输入 `n` 键查找单词 ignore，且现在能够查找 Ignore 和 IGNORE\n- 然后设置 hlsearch 和 insearch 这两个选项，输入：`set hls is`\n- 现在在此输入查找命令：`/ignore`，可以发现符合要求的字符串高亮显示了\n- 若要禁用忽略大小写，则输入：`:set noic`\n\n输入 `:set xxx` 可以设置 xxx 选项，一些常用的选项如下：\n\n|缩写|全称|含义|\n|:--:|:--:|:--|\n|ic|ignorecase|查找时忽略字母大小写|\n|is|insearch|查找短语时显示部分匹配|\n|hls|hlsearch|高亮显示所有的匹配短语|\n\n> 若要移除匹配项的高亮显示，可以输入：`:nohlsearch`。在选项前加上 `no` 可以关闭选项。\n> 如果想要仅在一次查找时忽略字母大小写，可以使用 `\\c:/ignore\\c` 并回车\n\n## 其他命令\n\n### 在线帮助系统\n\nVim 拥有一个细致全面的在线帮助系统，可以通过下述命令启动该系统：\n\n- 按下 <HELP> 键\n- 按下 <F1> 键\n- 输入 `:help` 并回车\n\n输入 `CTRL-W` 可以在不同窗口间切换\n\n在 `:help` 命令中添加关键字，可以找到改关键字的帮助，如：\n\n- `:help w`\n- `:help c_CTRL-D`\n- `:help insert-index`\n- `:helo user-manual`\n\n### 创建启动脚本\n\n通过创建启动脚本，可以启用 Vim 的特性。Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，可以创建一个 vimrc 文件。\n\n- 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：\n  - `:edit ~/.vimrc`，这是 Unix 系统所使用的命令\n  - `:edit $VIM/_vimrc`，这是 MS-Windows 系统所使用的命令\n- 接着读取 vimrc 示例文件的内容：\n  - `:r $VIMRUNTIME/vimrc_example.vim`\n- 保存文件，命令为：\n  - `:write`\n\n下次启动 Vim 时，编辑器就会有了语法高亮的功能。我们可以把喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 `:help imrc-intro`。\n\n### 补全功能\n\n使用 `CTRL-D` 和 `TAB` 可以进行命令补全。\n\n> 补全对于许多命令都有效。只需尝试按 CTRL-D 和 TAB。它对于 :help 命令非常有用。","source":"_posts/Vimtutor-commands.md","raw":"---\ntitle: 《Vim 教程》指令记录\ndate: 2019-05-17 13:54:10\nupdated: 2019-05-17 13:54:10\ncategory: Vim\ntags: [Vim教程]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-05-17.jpg\n---\n之前跟着 [Vim](https://www.vim.org/download.php) 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。\n<!--more-->\n\n\n在命令行输入 `vimtutor` 进入 Vim 自带的教程。\n\n## 基本操作\n\n### 移动光标\n\n移动光标分别为 `h`、`j`、`k`、`l` 键，当然也可以通过键盘上的方向键进行移动。不过考虑方向键离主键盘较远，因此使用`h`、`j`、`k`、`l`会更加高效。如果不确定当前的指令，只需要按下 `ESC` 键即可回到正常模式，然后再次输入指令。\n\n### Vim 的进入和退出\n\n在正常模式下，输入 `:q!` 然后再按下回车键即可退出当前打开的文档，该指令会丢弃之前对文件所作的所有改动。\n如果是命令提示符中通过 `vimtutor` 进入教程的，这时会返回至命令行的界面，这时只需重新输入 `vimtutor`，即可重新进入教程，只不过之前对文档的修改都未得到保存（不管保存与否，通过 `vimtutor` 进入教程每次都会打开一个副本）。\n\n> 若未对文档进行修改，输入 `:q` 即可退出 Vim，`:q!` 用于对文档有修改，但是不保存的情况，表示强制退出。\n\n### 文本编辑之删除\n\n在正常模式下（如果不知道是否处于正常模式，可以按下 `ESC` 来确保处于正常模式），可以按下 `x` 键来删除光标所在位置的字符。\n\n### 文编编辑之插入\n\n在正常模式下，按下 `i` 键来插入文本。这时会进入插入模式，当完成插入后，可按下 `ESC` 键返回正常模式。\n\n### 文本编辑之添加\n\n在正常模式下，按下 `A` 键来添加文本。与插入文本不同的是，添加文本操作会将光标移至当前行的行末。同样地，添加完成后，按下 `ESC` 键返回正常模式。\n\n### 编辑文件\n\n之前讲到如何退出 Vim，下面介绍如何保存修改后的文件。\n\n在命令行输入 `vim <filename>` 并回车，会进入名为 `<filename>` 的文档，通过之前的命令对文档进行修改，修改完成后，输入 `:wq` 并按下回车键即可保存改动并退出 Vim。\n\n## 删除与撤销\n\n### 删除类命令\n\n确保处于正常模式，输入 `dw` 即可从光标处删除至一个单词的末尾。\n\n> 当我们输入时，字母 `d` 会同时出现在屏幕的最后一行。Vim 在等待输入字母 `w`。如果看到的是除 `d` 以外的其他字符，表明输入了错误的指令，这时可以按下 `ESC` 键，并重新输入。\n\n### 更多删除类命令\n\n在正常模式下，输入 `d$` 从当前光标删除到行末。\n\n### 关于命令和对象\n\n许多改变文本的命令都由一个操作符和一个动作构成。\n\n使用删除操作符 `d` 的删除命令的格式如下：\n\n**d motion**\n\n其中：\n\n- `d` 表示删除操作符\n- `motion` 表示操作符的操作对象\n\n基本的动作列表如下所示：\n\n|操作对象|含义|\n|:-:|:---|\n|w|从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符|\n|e|从当前光标当前位置直到单词末尾，包括最后一个字符|\n|$|从当前光标当前位置直到当前行末|\n\n因此输入 `de` 会从当前光标位置删除到单词末尾。\n\n> 若不输入操作符，只按下代表相应动作的键，则光标的移动将会按照上述动作进行。\n\n### 使用计数指定动作\n\n在动作前输入数字会使它重复那么多次。例如：\n\n- 输入 `2w` 使光标向前移动两个单词。\n- 输入 `3e` 使光标向前移动到第三个单词的末尾。\n- 输入 `0` 移动光标到行首。\n\n通过输入不同的数值，可以执行相应的操作。\n\n### 使用计数以删除更多\n\n使用操作符时输入数字可以使它重复那么多次。上面已经提到过删除操作和动作的组合，我们还可以在组合中动作之前插入一个数字以删除更多：\n\n**d number motion**\n\n例如：\n\n- 输入 `d2w` 可以删除两个单词\n\n### 操作整行\n\n输入 `dd` 可以删除当前一整行。\n\n鉴于整行删除操作的高频度，Vim 提供了简化的删除操作，我们只需在同一行上输入两次 `d` 即可删除光标所在的行了。同时可以在 `dd` 操作前加入数字，以删除多行，例如：\n\n- 输入 `2dd` 可以删除两行。\n\n### 撤销类命令\n\n正常模式下，输入 `u` 来撤销最后执行的命令，输入 `U` 来撤销对整行的修改。例如按下了 `x` 删除了当前行的一个字符，那么可以通过 `u` 来撤销删除操作。若当前行执行了多个操作，需要全部撤销，则可通过 `U` 来撤销对当前行的所有修改。如果想要重做被撤销的命令，可以按下 `CTRL-R`，也即撤销掉撤销命令，回到原来修改后的状态。\n\n## 置入、更改和替换\n\n### 置入类命令\n\n正常模式下，输入 `p` 将最后一次删除的内容置入光标后。如：\n\n- 输入 `dd` 删除某一行\n- 将光标移至准备置入的位置的**上方**\n- 在正常模式下输入 `p` 将删除的一行粘贴置入\n\n### 替换类命令\n\n正常模式下，输入 `r` 和一个字符替换光标所在位置的字符。\n\n### 更改类命令\n\n正常模式下，要改变本文直到一个单词的末尾，可以使用 `ce`。同时也可以输入 `cw` 修改单词。具体操作为：\n\n- 将光标移动至单词中需要修改的开始位置\n- 输入 `cw` 并输入正确的单词\n- 按下 `ESC` 键退出修改\n\n> 请注意，`ce` 和 `cw` 命令不仅仅是删除了一个单词，它同时会进入插入模式。\n\n### 使用 c 更改更多\n\n更改类操作符可以与删除中使用的同样的动作配合使用。\n\n更改类操作符的工作方式跟删除类是一致的，其操作格式为：\n\n**c [number] motion**\n\n动作参数（motion）也是一样的，比如 `w` 代表单词，`$` 表示行末等。\n\n## 定位、查找和替换\n\n### 定位及文件状态\n\n正常模式下，输入 `CTRL-G` 显示当前编辑文件中当前光标所在行位置以及文件状态信息。\n\n输入 `G` 可以使当前光标直接跳转到文件的最后一行。\n\n输入 `gg` 可以使当前光标直接跳转到文件的第一行。\n\n输入行号，然后再输入 `G` 即可使当前光标直接跳转到指定行。\n\n### 搜索类命令\n\n正常模式下，输入 `/` 加上一个字符串可以用以在当前文档中查找该字符串。\n\n要查找同上一次的字符串，只需按下 `n` 键，如果要反向进行查找，则输入 `N`。\n\n要反向查找字符串，可以用 `?` 代替 `/`。\n\n要返回到之前的位置，可以按下 `CTRL-O`，重复按可以回退更多步。输入 `CTRL-I` 则会跳转到较新的位置，与 `CTRL-O` 执行的操作相反。\n\n> 如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 'wrapscan' 选项被复位。\n\n### 配对括号的查找\n\n正常模式下，输入 `%` 可以查找配对的括号 `)`、`]`、`}`。\n\n若当前光标所在位置的字符为 `)`、`]` 或者是 `}`，输入 `%` 即可使光标跳转至配对的括号处，再次输入 `%` 即可返回之前括号的位置。\n\n### 替换命令\n\n正常模式下，输入 `:s/old/new/g` 可以替换 old 为 new。\n\n若要替换两行之间出现的每个字符串，可以通过以下命令：\n\n- 输入 `:#,#s/old/new/g`， `#,#` 表示替换操作的若干行的首尾行号\n- 输入 `:%s/old/new/g`，表示替换整个文件中的每个匹配串\n- 输入 `:%s/old/new/gc`，则会查找整个文件中的匹配串，并且对每个匹配串提示是否进行替换\n\n## 文件相关操作\n\n### 在 Vim 内执行外部命令的方法\n\n在正常模式下，输入 `:!` 然后紧接着输入一个外部命令即可执行该外部命令。\n\n如输入 `:!ls` 并按下回车，会列出当前目录的内容。\n\n### 关于保存文件的更多信息\n\n正常模式下，输入 `:w FILENAME` 可以将对文件的改动保存到 FILENAME 中。\n\n若要删除保存的文件，可以通过执行外部命令的方法，输入 `:!rm TEST` 进行删除。\n\n### 一个具有选择性的保存命令\n\n在正常模式下，若要保存文件的部分内容，可以输入 `v motion :w FILENAME`。具体操作如下：\n\n- 将光标移动至要保存内容的开始位置\n- 接着按下 `v` 键进入可视模式，并继续移动光标至要保存内容的结束位置，这些内容会高亮显示\n- 然后按下 `:`，这时屏幕底部会出现 `:'<,'>`\n- 接着输入 `w FILENAME`，然后按下回车键\n- 所选中的内容将会被写入 FILENAME 中。\n\n> 按 `v` 键使 Vim 进入可视模式。我们可以移动光标使选取区域变大或变小。接着可以使用一个操作符对选中的文本进行操作。例如：按 `d` 键删除所选中的文本内容。\n\n### 提取和合并文件\n\n可以通过 `:r FILENAME` 命令向当前文件中插入另外文件的内容。\n\n> 除了合并文件外，还可以读取外部命令的输出。例如：`:r !ls` 可以读取 ls 命令的输出，并将其放置在光标打下面。\n\n## 打开、附加、替换、复制和设置类命令\n\n### 打开类命令\n\n正常模式下，输入 `o` 将在光标打下方打开新的一行并进入插入模式。\n\n若要在光标的**上方**打开新的一行，则需要输入 `O`。\n\n### 附加类命令\n\n正常模式下，输入 `a` 将在光标之后插入文本。\n\n> `a`、`i`、`A` 都会进入插入模式，唯一的区别在于字符插入的位置。`i` 将字符插入于光标之前，`a` 将字符插入于光标之后，而 `A` 则将字符插入于光标所在行的末尾。\n\n### 另一个置换命令的版本\n\n正常模式下，输入 `R` 可以连续替换多个字符。具体操作如下：\n\n- 将光标移动至要替换内容的起始位置\n- 输入 `R`，然后逐一输入要替换的字符\n- 按下 `ESC` 键退出替换模式回到正常模式。\n\n> 替换模式与插入模式类似，不过每个输入的字符都会删除一个已有的字符。\n\n### 复制粘贴文本\n\n正常模式下，使用操作符 `y` 复制文本，使用 `p` 粘贴文本。例如：\n\n- 移动光标至所要复制内容的起始位置\n- 按下 `v` 键进入可视模式\n- 移动光标至所要复制内容的结束位置\n- 输入 `y` 复制高亮文本\n- 移动光标至要粘贴的位置，输入 `p` 以复制文本\n\n> 可以把 `y` 当作操作符来使用。例如：`yw` 表示复制一个单词。\n\n### 设置类命令选项\n\n设置可使查找或者替换可忽略大小写的选项。例如：\n\n- 要查找单词 ignore 可以在正常模式下输入 `/ignore` 并回车\n- 然后设置 ic 选项（Ignore Case，忽略大小写），输入：`:set ic`\n- 现在可以通过输入 `n` 键查找单词 ignore，且现在能够查找 Ignore 和 IGNORE\n- 然后设置 hlsearch 和 insearch 这两个选项，输入：`set hls is`\n- 现在在此输入查找命令：`/ignore`，可以发现符合要求的字符串高亮显示了\n- 若要禁用忽略大小写，则输入：`:set noic`\n\n输入 `:set xxx` 可以设置 xxx 选项，一些常用的选项如下：\n\n|缩写|全称|含义|\n|:--:|:--:|:--|\n|ic|ignorecase|查找时忽略字母大小写|\n|is|insearch|查找短语时显示部分匹配|\n|hls|hlsearch|高亮显示所有的匹配短语|\n\n> 若要移除匹配项的高亮显示，可以输入：`:nohlsearch`。在选项前加上 `no` 可以关闭选项。\n> 如果想要仅在一次查找时忽略字母大小写，可以使用 `\\c:/ignore\\c` 并回车\n\n## 其他命令\n\n### 在线帮助系统\n\nVim 拥有一个细致全面的在线帮助系统，可以通过下述命令启动该系统：\n\n- 按下 <HELP> 键\n- 按下 <F1> 键\n- 输入 `:help` 并回车\n\n输入 `CTRL-W` 可以在不同窗口间切换\n\n在 `:help` 命令中添加关键字，可以找到改关键字的帮助，如：\n\n- `:help w`\n- `:help c_CTRL-D`\n- `:help insert-index`\n- `:helo user-manual`\n\n### 创建启动脚本\n\n通过创建启动脚本，可以启用 Vim 的特性。Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，可以创建一个 vimrc 文件。\n\n- 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：\n  - `:edit ~/.vimrc`，这是 Unix 系统所使用的命令\n  - `:edit $VIM/_vimrc`，这是 MS-Windows 系统所使用的命令\n- 接着读取 vimrc 示例文件的内容：\n  - `:r $VIMRUNTIME/vimrc_example.vim`\n- 保存文件，命令为：\n  - `:write`\n\n下次启动 Vim 时，编辑器就会有了语法高亮的功能。我们可以把喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 `:help imrc-intro`。\n\n### 补全功能\n\n使用 `CTRL-D` 和 `TAB` 可以进行命令补全。\n\n> 补全对于许多命令都有效。只需尝试按 CTRL-D 和 TAB。它对于 :help 命令非常有用。","slug":"Vimtutor-commands","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsir0019w8vo5sen81ln","content":"<p>之前跟着 <a href=\"https://www.vim.org/download.php\">Vim</a> 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。</p>\n<a id=\"more\"></a>\n\n\n<p>在命令行输入 <code>vimtutor</code> 进入 Vim 自带的教程。</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"移动光标\"><a href=\"#移动光标\" class=\"headerlink\" title=\"移动光标\"></a>移动光标</h3><p>移动光标分别为 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 键，当然也可以通过键盘上的方向键进行移动。不过考虑方向键离主键盘较远，因此使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>会更加高效。如果不确定当前的指令，只需要按下 <code>ESC</code> 键即可回到正常模式，然后再次输入指令。</p>\n<h3 id=\"Vim-的进入和退出\"><a href=\"#Vim-的进入和退出\" class=\"headerlink\" title=\"Vim 的进入和退出\"></a>Vim 的进入和退出</h3><p>在正常模式下，输入 <code>:q!</code> 然后再按下回车键即可退出当前打开的文档，该指令会丢弃之前对文件所作的所有改动。<br>如果是命令提示符中通过 <code>vimtutor</code> 进入教程的，这时会返回至命令行的界面，这时只需重新输入 <code>vimtutor</code>，即可重新进入教程，只不过之前对文档的修改都未得到保存（不管保存与否，通过 <code>vimtutor</code> 进入教程每次都会打开一个副本）。</p>\n<blockquote>\n<p>若未对文档进行修改，输入 <code>:q</code> 即可退出 Vim，<code>:q!</code> 用于对文档有修改，但是不保存的情况，表示强制退出。</p>\n</blockquote>\n<h3 id=\"文本编辑之删除\"><a href=\"#文本编辑之删除\" class=\"headerlink\" title=\"文本编辑之删除\"></a>文本编辑之删除</h3><p>在正常模式下（如果不知道是否处于正常模式，可以按下 <code>ESC</code> 来确保处于正常模式），可以按下 <code>x</code> 键来删除光标所在位置的字符。</p>\n<h3 id=\"文编编辑之插入\"><a href=\"#文编编辑之插入\" class=\"headerlink\" title=\"文编编辑之插入\"></a>文编编辑之插入</h3><p>在正常模式下，按下 <code>i</code> 键来插入文本。这时会进入插入模式，当完成插入后，可按下 <code>ESC</code> 键返回正常模式。</p>\n<h3 id=\"文本编辑之添加\"><a href=\"#文本编辑之添加\" class=\"headerlink\" title=\"文本编辑之添加\"></a>文本编辑之添加</h3><p>在正常模式下，按下 <code>A</code> 键来添加文本。与插入文本不同的是，添加文本操作会将光标移至当前行的行末。同样地，添加完成后，按下 <code>ESC</code> 键返回正常模式。</p>\n<h3 id=\"编辑文件\"><a href=\"#编辑文件\" class=\"headerlink\" title=\"编辑文件\"></a>编辑文件</h3><p>之前讲到如何退出 Vim，下面介绍如何保存修改后的文件。</p>\n<p>在命令行输入 <code>vim &lt;filename&gt;</code> 并回车，会进入名为 <code>&lt;filename&gt;</code> 的文档，通过之前的命令对文档进行修改，修改完成后，输入 <code>:wq</code> 并按下回车键即可保存改动并退出 Vim。</p>\n<h2 id=\"删除与撤销\"><a href=\"#删除与撤销\" class=\"headerlink\" title=\"删除与撤销\"></a>删除与撤销</h2><h3 id=\"删除类命令\"><a href=\"#删除类命令\" class=\"headerlink\" title=\"删除类命令\"></a>删除类命令</h3><p>确保处于正常模式，输入 <code>dw</code> 即可从光标处删除至一个单词的末尾。</p>\n<blockquote>\n<p>当我们输入时，字母 <code>d</code> 会同时出现在屏幕的最后一行。Vim 在等待输入字母 <code>w</code>。如果看到的是除 <code>d</code> 以外的其他字符，表明输入了错误的指令，这时可以按下 <code>ESC</code> 键，并重新输入。</p>\n</blockquote>\n<h3 id=\"更多删除类命令\"><a href=\"#更多删除类命令\" class=\"headerlink\" title=\"更多删除类命令\"></a>更多删除类命令</h3><p>在正常模式下，输入 <code>d$</code> 从当前光标删除到行末。</p>\n<h3 id=\"关于命令和对象\"><a href=\"#关于命令和对象\" class=\"headerlink\" title=\"关于命令和对象\"></a>关于命令和对象</h3><p>许多改变文本的命令都由一个操作符和一个动作构成。</p>\n<p>使用删除操作符 <code>d</code> 的删除命令的格式如下：</p>\n<p><strong>d motion</strong></p>\n<p>其中：</p>\n<ul>\n<li><code>d</code> 表示删除操作符</li>\n<li><code>motion</code> 表示操作符的操作对象</li>\n</ul>\n<p>基本的动作列表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作对象</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">w</td>\n<td align=\"left\">从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"left\">从当前光标当前位置直到单词末尾，包括最后一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"left\">从当前光标当前位置直到当前行末</td>\n</tr>\n</tbody></table>\n<p>因此输入 <code>de</code> 会从当前光标位置删除到单词末尾。</p>\n<blockquote>\n<p>若不输入操作符，只按下代表相应动作的键，则光标的移动将会按照上述动作进行。</p>\n</blockquote>\n<h3 id=\"使用计数指定动作\"><a href=\"#使用计数指定动作\" class=\"headerlink\" title=\"使用计数指定动作\"></a>使用计数指定动作</h3><p>在动作前输入数字会使它重复那么多次。例如：</p>\n<ul>\n<li>输入 <code>2w</code> 使光标向前移动两个单词。</li>\n<li>输入 <code>3e</code> 使光标向前移动到第三个单词的末尾。</li>\n<li>输入 <code>0</code> 移动光标到行首。</li>\n</ul>\n<p>通过输入不同的数值，可以执行相应的操作。</p>\n<h3 id=\"使用计数以删除更多\"><a href=\"#使用计数以删除更多\" class=\"headerlink\" title=\"使用计数以删除更多\"></a>使用计数以删除更多</h3><p>使用操作符时输入数字可以使它重复那么多次。上面已经提到过删除操作和动作的组合，我们还可以在组合中动作之前插入一个数字以删除更多：</p>\n<p><strong>d number motion</strong></p>\n<p>例如：</p>\n<ul>\n<li>输入 <code>d2w</code> 可以删除两个单词</li>\n</ul>\n<h3 id=\"操作整行\"><a href=\"#操作整行\" class=\"headerlink\" title=\"操作整行\"></a>操作整行</h3><p>输入 <code>dd</code> 可以删除当前一整行。</p>\n<p>鉴于整行删除操作的高频度，Vim 提供了简化的删除操作，我们只需在同一行上输入两次 <code>d</code> 即可删除光标所在的行了。同时可以在 <code>dd</code> 操作前加入数字，以删除多行，例如：</p>\n<ul>\n<li>输入 <code>2dd</code> 可以删除两行。</li>\n</ul>\n<h3 id=\"撤销类命令\"><a href=\"#撤销类命令\" class=\"headerlink\" title=\"撤销类命令\"></a>撤销类命令</h3><p>正常模式下，输入 <code>u</code> 来撤销最后执行的命令，输入 <code>U</code> 来撤销对整行的修改。例如按下了 <code>x</code> 删除了当前行的一个字符，那么可以通过 <code>u</code> 来撤销删除操作。若当前行执行了多个操作，需要全部撤销，则可通过 <code>U</code> 来撤销对当前行的所有修改。如果想要重做被撤销的命令，可以按下 <code>CTRL-R</code>，也即撤销掉撤销命令，回到原来修改后的状态。</p>\n<h2 id=\"置入、更改和替换\"><a href=\"#置入、更改和替换\" class=\"headerlink\" title=\"置入、更改和替换\"></a>置入、更改和替换</h2><h3 id=\"置入类命令\"><a href=\"#置入类命令\" class=\"headerlink\" title=\"置入类命令\"></a>置入类命令</h3><p>正常模式下，输入 <code>p</code> 将最后一次删除的内容置入光标后。如：</p>\n<ul>\n<li>输入 <code>dd</code> 删除某一行</li>\n<li>将光标移至准备置入的位置的<strong>上方</strong></li>\n<li>在正常模式下输入 <code>p</code> 将删除的一行粘贴置入</li>\n</ul>\n<h3 id=\"替换类命令\"><a href=\"#替换类命令\" class=\"headerlink\" title=\"替换类命令\"></a>替换类命令</h3><p>正常模式下，输入 <code>r</code> 和一个字符替换光标所在位置的字符。</p>\n<h3 id=\"更改类命令\"><a href=\"#更改类命令\" class=\"headerlink\" title=\"更改类命令\"></a>更改类命令</h3><p>正常模式下，要改变本文直到一个单词的末尾，可以使用 <code>ce</code>。同时也可以输入 <code>cw</code> 修改单词。具体操作为：</p>\n<ul>\n<li>将光标移动至单词中需要修改的开始位置</li>\n<li>输入 <code>cw</code> 并输入正确的单词</li>\n<li>按下 <code>ESC</code> 键退出修改</li>\n</ul>\n<blockquote>\n<p>请注意，<code>ce</code> 和 <code>cw</code> 命令不仅仅是删除了一个单词，它同时会进入插入模式。</p>\n</blockquote>\n<h3 id=\"使用-c-更改更多\"><a href=\"#使用-c-更改更多\" class=\"headerlink\" title=\"使用 c 更改更多\"></a>使用 c 更改更多</h3><p>更改类操作符可以与删除中使用的同样的动作配合使用。</p>\n<p>更改类操作符的工作方式跟删除类是一致的，其操作格式为：</p>\n<p><strong>c [number] motion</strong></p>\n<p>动作参数（motion）也是一样的，比如 <code>w</code> 代表单词，<code>$</code> 表示行末等。</p>\n<h2 id=\"定位、查找和替换\"><a href=\"#定位、查找和替换\" class=\"headerlink\" title=\"定位、查找和替换\"></a>定位、查找和替换</h2><h3 id=\"定位及文件状态\"><a href=\"#定位及文件状态\" class=\"headerlink\" title=\"定位及文件状态\"></a>定位及文件状态</h3><p>正常模式下，输入 <code>CTRL-G</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</p>\n<p>输入 <code>G</code> 可以使当前光标直接跳转到文件的最后一行。</p>\n<p>输入 <code>gg</code> 可以使当前光标直接跳转到文件的第一行。</p>\n<p>输入行号，然后再输入 <code>G</code> 即可使当前光标直接跳转到指定行。</p>\n<h3 id=\"搜索类命令\"><a href=\"#搜索类命令\" class=\"headerlink\" title=\"搜索类命令\"></a>搜索类命令</h3><p>正常模式下，输入 <code>/</code> 加上一个字符串可以用以在当前文档中查找该字符串。</p>\n<p>要查找同上一次的字符串，只需按下 <code>n</code> 键，如果要反向进行查找，则输入 <code>N</code>。</p>\n<p>要反向查找字符串，可以用 <code>?</code> 代替 <code>/</code>。</p>\n<p>要返回到之前的位置，可以按下 <code>CTRL-O</code>，重复按可以回退更多步。输入 <code>CTRL-I</code> 则会跳转到较新的位置，与 <code>CTRL-O</code> 执行的操作相反。</p>\n<blockquote>\n<p>如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 ‘wrapscan’ 选项被复位。</p>\n</blockquote>\n<h3 id=\"配对括号的查找\"><a href=\"#配对括号的查找\" class=\"headerlink\" title=\"配对括号的查找\"></a>配对括号的查找</h3><p>正常模式下，输入 <code>%</code> 可以查找配对的括号 <code>)</code>、<code>]</code>、<code>&#125;</code>。</p>\n<p>若当前光标所在位置的字符为 <code>)</code>、<code>]</code> 或者是 <code>&#125;</code>，输入 <code>%</code> 即可使光标跳转至配对的括号处，再次输入 <code>%</code> 即可返回之前括号的位置。</p>\n<h3 id=\"替换命令\"><a href=\"#替换命令\" class=\"headerlink\" title=\"替换命令\"></a>替换命令</h3><p>正常模式下，输入 <code>:s/old/new/g</code> 可以替换 old 为 new。</p>\n<p>若要替换两行之间出现的每个字符串，可以通过以下命令：</p>\n<ul>\n<li>输入 <code>:#,#s/old/new/g</code>， <code>#,#</code> 表示替换操作的若干行的首尾行号</li>\n<li>输入 <code>:%s/old/new/g</code>，表示替换整个文件中的每个匹配串</li>\n<li>输入 <code>:%s/old/new/gc</code>，则会查找整个文件中的匹配串，并且对每个匹配串提示是否进行替换</li>\n</ul>\n<h2 id=\"文件相关操作\"><a href=\"#文件相关操作\" class=\"headerlink\" title=\"文件相关操作\"></a>文件相关操作</h2><h3 id=\"在-Vim-内执行外部命令的方法\"><a href=\"#在-Vim-内执行外部命令的方法\" class=\"headerlink\" title=\"在 Vim 内执行外部命令的方法\"></a>在 Vim 内执行外部命令的方法</h3><p>在正常模式下，输入 <code>:!</code> 然后紧接着输入一个外部命令即可执行该外部命令。</p>\n<p>如输入 <code>:!ls</code> 并按下回车，会列出当前目录的内容。</p>\n<h3 id=\"关于保存文件的更多信息\"><a href=\"#关于保存文件的更多信息\" class=\"headerlink\" title=\"关于保存文件的更多信息\"></a>关于保存文件的更多信息</h3><p>正常模式下，输入 <code>:w FILENAME</code> 可以将对文件的改动保存到 FILENAME 中。</p>\n<p>若要删除保存的文件，可以通过执行外部命令的方法，输入 <code>:!rm TEST</code> 进行删除。</p>\n<h3 id=\"一个具有选择性的保存命令\"><a href=\"#一个具有选择性的保存命令\" class=\"headerlink\" title=\"一个具有选择性的保存命令\"></a>一个具有选择性的保存命令</h3><p>在正常模式下，若要保存文件的部分内容，可以输入 <code>v motion :w FILENAME</code>。具体操作如下：</p>\n<ul>\n<li>将光标移动至要保存内容的开始位置</li>\n<li>接着按下 <code>v</code> 键进入可视模式，并继续移动光标至要保存内容的结束位置，这些内容会高亮显示</li>\n<li>然后按下 <code>:</code>，这时屏幕底部会出现 <code>:&#39;&lt;,&#39;&gt;</code></li>\n<li>接着输入 <code>w FILENAME</code>，然后按下回车键</li>\n<li>所选中的内容将会被写入 FILENAME 中。</li>\n</ul>\n<blockquote>\n<p>按 <code>v</code> 键使 Vim 进入可视模式。我们可以移动光标使选取区域变大或变小。接着可以使用一个操作符对选中的文本进行操作。例如：按 <code>d</code> 键删除所选中的文本内容。</p>\n</blockquote>\n<h3 id=\"提取和合并文件\"><a href=\"#提取和合并文件\" class=\"headerlink\" title=\"提取和合并文件\"></a>提取和合并文件</h3><p>可以通过 <code>:r FILENAME</code> 命令向当前文件中插入另外文件的内容。</p>\n<blockquote>\n<p>除了合并文件外，还可以读取外部命令的输出。例如：<code>:r !ls</code> 可以读取 ls 命令的输出，并将其放置在光标打下面。</p>\n</blockquote>\n<h2 id=\"打开、附加、替换、复制和设置类命令\"><a href=\"#打开、附加、替换、复制和设置类命令\" class=\"headerlink\" title=\"打开、附加、替换、复制和设置类命令\"></a>打开、附加、替换、复制和设置类命令</h2><h3 id=\"打开类命令\"><a href=\"#打开类命令\" class=\"headerlink\" title=\"打开类命令\"></a>打开类命令</h3><p>正常模式下，输入 <code>o</code> 将在光标打下方打开新的一行并进入插入模式。</p>\n<p>若要在光标的<strong>上方</strong>打开新的一行，则需要输入 <code>O</code>。</p>\n<h3 id=\"附加类命令\"><a href=\"#附加类命令\" class=\"headerlink\" title=\"附加类命令\"></a>附加类命令</h3><p>正常模式下，输入 <code>a</code> 将在光标之后插入文本。</p>\n<blockquote>\n<p><code>a</code>、<code>i</code>、<code>A</code> 都会进入插入模式，唯一的区别在于字符插入的位置。<code>i</code> 将字符插入于光标之前，<code>a</code> 将字符插入于光标之后，而 <code>A</code> 则将字符插入于光标所在行的末尾。</p>\n</blockquote>\n<h3 id=\"另一个置换命令的版本\"><a href=\"#另一个置换命令的版本\" class=\"headerlink\" title=\"另一个置换命令的版本\"></a>另一个置换命令的版本</h3><p>正常模式下，输入 <code>R</code> 可以连续替换多个字符。具体操作如下：</p>\n<ul>\n<li>将光标移动至要替换内容的起始位置</li>\n<li>输入 <code>R</code>，然后逐一输入要替换的字符</li>\n<li>按下 <code>ESC</code> 键退出替换模式回到正常模式。</li>\n</ul>\n<blockquote>\n<p>替换模式与插入模式类似，不过每个输入的字符都会删除一个已有的字符。</p>\n</blockquote>\n<h3 id=\"复制粘贴文本\"><a href=\"#复制粘贴文本\" class=\"headerlink\" title=\"复制粘贴文本\"></a>复制粘贴文本</h3><p>正常模式下，使用操作符 <code>y</code> 复制文本，使用 <code>p</code> 粘贴文本。例如：</p>\n<ul>\n<li>移动光标至所要复制内容的起始位置</li>\n<li>按下 <code>v</code> 键进入可视模式</li>\n<li>移动光标至所要复制内容的结束位置</li>\n<li>输入 <code>y</code> 复制高亮文本</li>\n<li>移动光标至要粘贴的位置，输入 <code>p</code> 以复制文本</li>\n</ul>\n<blockquote>\n<p>可以把 <code>y</code> 当作操作符来使用。例如：<code>yw</code> 表示复制一个单词。</p>\n</blockquote>\n<h3 id=\"设置类命令选项\"><a href=\"#设置类命令选项\" class=\"headerlink\" title=\"设置类命令选项\"></a>设置类命令选项</h3><p>设置可使查找或者替换可忽略大小写的选项。例如：</p>\n<ul>\n<li>要查找单词 ignore 可以在正常模式下输入 <code>/ignore</code> 并回车</li>\n<li>然后设置 ic 选项（Ignore Case，忽略大小写），输入：<code>:set ic</code></li>\n<li>现在可以通过输入 <code>n</code> 键查找单词 ignore，且现在能够查找 Ignore 和 IGNORE</li>\n<li>然后设置 hlsearch 和 insearch 这两个选项，输入：<code>set hls is</code></li>\n<li>现在在此输入查找命令：<code>/ignore</code>，可以发现符合要求的字符串高亮显示了</li>\n<li>若要禁用忽略大小写，则输入：<code>:set noic</code></li>\n</ul>\n<p>输入 <code>:set xxx</code> 可以设置 xxx 选项，一些常用的选项如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">缩写</th>\n<th align=\"center\">全称</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ic</td>\n<td align=\"center\">ignorecase</td>\n<td align=\"left\">查找时忽略字母大小写</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">insearch</td>\n<td align=\"left\">查找短语时显示部分匹配</td>\n</tr>\n<tr>\n<td align=\"center\">hls</td>\n<td align=\"center\">hlsearch</td>\n<td align=\"left\">高亮显示所有的匹配短语</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>若要移除匹配项的高亮显示，可以输入：<code>:nohlsearch</code>。在选项前加上 <code>no</code> 可以关闭选项。<br>如果想要仅在一次查找时忽略字母大小写，可以使用 <code>\\c:/ignore\\c</code> 并回车</p>\n</blockquote>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><h3 id=\"在线帮助系统\"><a href=\"#在线帮助系统\" class=\"headerlink\" title=\"在线帮助系统\"></a>在线帮助系统</h3><p>Vim 拥有一个细致全面的在线帮助系统，可以通过下述命令启动该系统：</p>\n<ul>\n<li>按下 <HELP> 键</li>\n<li>按下 <F1> 键</li>\n<li>输入 <code>:help</code> 并回车</li>\n</ul>\n<p>输入 <code>CTRL-W</code> 可以在不同窗口间切换</p>\n<p>在 <code>:help</code> 命令中添加关键字，可以找到改关键字的帮助，如：</p>\n<ul>\n<li><code>:help w</code></li>\n<li><code>:help c_CTRL-D</code></li>\n<li><code>:help insert-index</code></li>\n<li><code>:helo user-manual</code></li>\n</ul>\n<h3 id=\"创建启动脚本\"><a href=\"#创建启动脚本\" class=\"headerlink\" title=\"创建启动脚本\"></a>创建启动脚本</h3><p>通过创建启动脚本，可以启用 Vim 的特性。Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，可以创建一个 vimrc 文件。</p>\n<ul>\n<li>开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：<ul>\n<li><code>:edit ~/.vimrc</code>，这是 Unix 系统所使用的命令</li>\n<li><code>:edit $VIM/_vimrc</code>，这是 MS-Windows 系统所使用的命令</li>\n</ul>\n</li>\n<li>接着读取 vimrc 示例文件的内容：<ul>\n<li><code>:r $VIMRUNTIME/vimrc_example.vim</code></li>\n</ul>\n</li>\n<li>保存文件，命令为：<ul>\n<li><code>:write</code></li>\n</ul>\n</li>\n</ul>\n<p>下次启动 Vim 时，编辑器就会有了语法高亮的功能。我们可以把喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 <code>:help imrc-intro</code>。</p>\n<h3 id=\"补全功能\"><a href=\"#补全功能\" class=\"headerlink\" title=\"补全功能\"></a>补全功能</h3><p>使用 <code>CTRL-D</code> 和 <code>TAB</code> 可以进行命令补全。</p>\n<blockquote>\n<p>补全对于许多命令都有效。只需尝试按 CTRL-D 和 TAB。它对于 :help 命令非常有用。</p>\n</blockquote>\n","site":{"data":{}},"length":4434,"excerpt":"<p>之前跟着 <a href=\"https://www.vim.org/download.php\">Vim</a> 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。</p>","more":"<p>在命令行输入 <code>vimtutor</code> 进入 Vim 自带的教程。</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"移动光标\"><a href=\"#移动光标\" class=\"headerlink\" title=\"移动光标\"></a>移动光标</h3><p>移动光标分别为 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 键，当然也可以通过键盘上的方向键进行移动。不过考虑方向键离主键盘较远，因此使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>会更加高效。如果不确定当前的指令，只需要按下 <code>ESC</code> 键即可回到正常模式，然后再次输入指令。</p>\n<h3 id=\"Vim-的进入和退出\"><a href=\"#Vim-的进入和退出\" class=\"headerlink\" title=\"Vim 的进入和退出\"></a>Vim 的进入和退出</h3><p>在正常模式下，输入 <code>:q!</code> 然后再按下回车键即可退出当前打开的文档，该指令会丢弃之前对文件所作的所有改动。<br>如果是命令提示符中通过 <code>vimtutor</code> 进入教程的，这时会返回至命令行的界面，这时只需重新输入 <code>vimtutor</code>，即可重新进入教程，只不过之前对文档的修改都未得到保存（不管保存与否，通过 <code>vimtutor</code> 进入教程每次都会打开一个副本）。</p>\n<blockquote>\n<p>若未对文档进行修改，输入 <code>:q</code> 即可退出 Vim，<code>:q!</code> 用于对文档有修改，但是不保存的情况，表示强制退出。</p>\n</blockquote>\n<h3 id=\"文本编辑之删除\"><a href=\"#文本编辑之删除\" class=\"headerlink\" title=\"文本编辑之删除\"></a>文本编辑之删除</h3><p>在正常模式下（如果不知道是否处于正常模式，可以按下 <code>ESC</code> 来确保处于正常模式），可以按下 <code>x</code> 键来删除光标所在位置的字符。</p>\n<h3 id=\"文编编辑之插入\"><a href=\"#文编编辑之插入\" class=\"headerlink\" title=\"文编编辑之插入\"></a>文编编辑之插入</h3><p>在正常模式下，按下 <code>i</code> 键来插入文本。这时会进入插入模式，当完成插入后，可按下 <code>ESC</code> 键返回正常模式。</p>\n<h3 id=\"文本编辑之添加\"><a href=\"#文本编辑之添加\" class=\"headerlink\" title=\"文本编辑之添加\"></a>文本编辑之添加</h3><p>在正常模式下，按下 <code>A</code> 键来添加文本。与插入文本不同的是，添加文本操作会将光标移至当前行的行末。同样地，添加完成后，按下 <code>ESC</code> 键返回正常模式。</p>\n<h3 id=\"编辑文件\"><a href=\"#编辑文件\" class=\"headerlink\" title=\"编辑文件\"></a>编辑文件</h3><p>之前讲到如何退出 Vim，下面介绍如何保存修改后的文件。</p>\n<p>在命令行输入 <code>vim &lt;filename&gt;</code> 并回车，会进入名为 <code>&lt;filename&gt;</code> 的文档，通过之前的命令对文档进行修改，修改完成后，输入 <code>:wq</code> 并按下回车键即可保存改动并退出 Vim。</p>\n<h2 id=\"删除与撤销\"><a href=\"#删除与撤销\" class=\"headerlink\" title=\"删除与撤销\"></a>删除与撤销</h2><h3 id=\"删除类命令\"><a href=\"#删除类命令\" class=\"headerlink\" title=\"删除类命令\"></a>删除类命令</h3><p>确保处于正常模式，输入 <code>dw</code> 即可从光标处删除至一个单词的末尾。</p>\n<blockquote>\n<p>当我们输入时，字母 <code>d</code> 会同时出现在屏幕的最后一行。Vim 在等待输入字母 <code>w</code>。如果看到的是除 <code>d</code> 以外的其他字符，表明输入了错误的指令，这时可以按下 <code>ESC</code> 键，并重新输入。</p>\n</blockquote>\n<h3 id=\"更多删除类命令\"><a href=\"#更多删除类命令\" class=\"headerlink\" title=\"更多删除类命令\"></a>更多删除类命令</h3><p>在正常模式下，输入 <code>d$</code> 从当前光标删除到行末。</p>\n<h3 id=\"关于命令和对象\"><a href=\"#关于命令和对象\" class=\"headerlink\" title=\"关于命令和对象\"></a>关于命令和对象</h3><p>许多改变文本的命令都由一个操作符和一个动作构成。</p>\n<p>使用删除操作符 <code>d</code> 的删除命令的格式如下：</p>\n<p><strong>d motion</strong></p>\n<p>其中：</p>\n<ul>\n<li><code>d</code> 表示删除操作符</li>\n<li><code>motion</code> 表示操作符的操作对象</li>\n</ul>\n<p>基本的动作列表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作对象</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">w</td>\n<td align=\"left\">从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"left\">从当前光标当前位置直到单词末尾，包括最后一个字符</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"left\">从当前光标当前位置直到当前行末</td>\n</tr>\n</tbody></table>\n<p>因此输入 <code>de</code> 会从当前光标位置删除到单词末尾。</p>\n<blockquote>\n<p>若不输入操作符，只按下代表相应动作的键，则光标的移动将会按照上述动作进行。</p>\n</blockquote>\n<h3 id=\"使用计数指定动作\"><a href=\"#使用计数指定动作\" class=\"headerlink\" title=\"使用计数指定动作\"></a>使用计数指定动作</h3><p>在动作前输入数字会使它重复那么多次。例如：</p>\n<ul>\n<li>输入 <code>2w</code> 使光标向前移动两个单词。</li>\n<li>输入 <code>3e</code> 使光标向前移动到第三个单词的末尾。</li>\n<li>输入 <code>0</code> 移动光标到行首。</li>\n</ul>\n<p>通过输入不同的数值，可以执行相应的操作。</p>\n<h3 id=\"使用计数以删除更多\"><a href=\"#使用计数以删除更多\" class=\"headerlink\" title=\"使用计数以删除更多\"></a>使用计数以删除更多</h3><p>使用操作符时输入数字可以使它重复那么多次。上面已经提到过删除操作和动作的组合，我们还可以在组合中动作之前插入一个数字以删除更多：</p>\n<p><strong>d number motion</strong></p>\n<p>例如：</p>\n<ul>\n<li>输入 <code>d2w</code> 可以删除两个单词</li>\n</ul>\n<h3 id=\"操作整行\"><a href=\"#操作整行\" class=\"headerlink\" title=\"操作整行\"></a>操作整行</h3><p>输入 <code>dd</code> 可以删除当前一整行。</p>\n<p>鉴于整行删除操作的高频度，Vim 提供了简化的删除操作，我们只需在同一行上输入两次 <code>d</code> 即可删除光标所在的行了。同时可以在 <code>dd</code> 操作前加入数字，以删除多行，例如：</p>\n<ul>\n<li>输入 <code>2dd</code> 可以删除两行。</li>\n</ul>\n<h3 id=\"撤销类命令\"><a href=\"#撤销类命令\" class=\"headerlink\" title=\"撤销类命令\"></a>撤销类命令</h3><p>正常模式下，输入 <code>u</code> 来撤销最后执行的命令，输入 <code>U</code> 来撤销对整行的修改。例如按下了 <code>x</code> 删除了当前行的一个字符，那么可以通过 <code>u</code> 来撤销删除操作。若当前行执行了多个操作，需要全部撤销，则可通过 <code>U</code> 来撤销对当前行的所有修改。如果想要重做被撤销的命令，可以按下 <code>CTRL-R</code>，也即撤销掉撤销命令，回到原来修改后的状态。</p>\n<h2 id=\"置入、更改和替换\"><a href=\"#置入、更改和替换\" class=\"headerlink\" title=\"置入、更改和替换\"></a>置入、更改和替换</h2><h3 id=\"置入类命令\"><a href=\"#置入类命令\" class=\"headerlink\" title=\"置入类命令\"></a>置入类命令</h3><p>正常模式下，输入 <code>p</code> 将最后一次删除的内容置入光标后。如：</p>\n<ul>\n<li>输入 <code>dd</code> 删除某一行</li>\n<li>将光标移至准备置入的位置的<strong>上方</strong></li>\n<li>在正常模式下输入 <code>p</code> 将删除的一行粘贴置入</li>\n</ul>\n<h3 id=\"替换类命令\"><a href=\"#替换类命令\" class=\"headerlink\" title=\"替换类命令\"></a>替换类命令</h3><p>正常模式下，输入 <code>r</code> 和一个字符替换光标所在位置的字符。</p>\n<h3 id=\"更改类命令\"><a href=\"#更改类命令\" class=\"headerlink\" title=\"更改类命令\"></a>更改类命令</h3><p>正常模式下，要改变本文直到一个单词的末尾，可以使用 <code>ce</code>。同时也可以输入 <code>cw</code> 修改单词。具体操作为：</p>\n<ul>\n<li>将光标移动至单词中需要修改的开始位置</li>\n<li>输入 <code>cw</code> 并输入正确的单词</li>\n<li>按下 <code>ESC</code> 键退出修改</li>\n</ul>\n<blockquote>\n<p>请注意，<code>ce</code> 和 <code>cw</code> 命令不仅仅是删除了一个单词，它同时会进入插入模式。</p>\n</blockquote>\n<h3 id=\"使用-c-更改更多\"><a href=\"#使用-c-更改更多\" class=\"headerlink\" title=\"使用 c 更改更多\"></a>使用 c 更改更多</h3><p>更改类操作符可以与删除中使用的同样的动作配合使用。</p>\n<p>更改类操作符的工作方式跟删除类是一致的，其操作格式为：</p>\n<p><strong>c [number] motion</strong></p>\n<p>动作参数（motion）也是一样的，比如 <code>w</code> 代表单词，<code>$</code> 表示行末等。</p>\n<h2 id=\"定位、查找和替换\"><a href=\"#定位、查找和替换\" class=\"headerlink\" title=\"定位、查找和替换\"></a>定位、查找和替换</h2><h3 id=\"定位及文件状态\"><a href=\"#定位及文件状态\" class=\"headerlink\" title=\"定位及文件状态\"></a>定位及文件状态</h3><p>正常模式下，输入 <code>CTRL-G</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</p>\n<p>输入 <code>G</code> 可以使当前光标直接跳转到文件的最后一行。</p>\n<p>输入 <code>gg</code> 可以使当前光标直接跳转到文件的第一行。</p>\n<p>输入行号，然后再输入 <code>G</code> 即可使当前光标直接跳转到指定行。</p>\n<h3 id=\"搜索类命令\"><a href=\"#搜索类命令\" class=\"headerlink\" title=\"搜索类命令\"></a>搜索类命令</h3><p>正常模式下，输入 <code>/</code> 加上一个字符串可以用以在当前文档中查找该字符串。</p>\n<p>要查找同上一次的字符串，只需按下 <code>n</code> 键，如果要反向进行查找，则输入 <code>N</code>。</p>\n<p>要反向查找字符串，可以用 <code>?</code> 代替 <code>/</code>。</p>\n<p>要返回到之前的位置，可以按下 <code>CTRL-O</code>，重复按可以回退更多步。输入 <code>CTRL-I</code> 则会跳转到较新的位置，与 <code>CTRL-O</code> 执行的操作相反。</p>\n<blockquote>\n<p>如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 ‘wrapscan’ 选项被复位。</p>\n</blockquote>\n<h3 id=\"配对括号的查找\"><a href=\"#配对括号的查找\" class=\"headerlink\" title=\"配对括号的查找\"></a>配对括号的查找</h3><p>正常模式下，输入 <code>%</code> 可以查找配对的括号 <code>)</code>、<code>]</code>、<code>&#125;</code>。</p>\n<p>若当前光标所在位置的字符为 <code>)</code>、<code>]</code> 或者是 <code>&#125;</code>，输入 <code>%</code> 即可使光标跳转至配对的括号处，再次输入 <code>%</code> 即可返回之前括号的位置。</p>\n<h3 id=\"替换命令\"><a href=\"#替换命令\" class=\"headerlink\" title=\"替换命令\"></a>替换命令</h3><p>正常模式下，输入 <code>:s/old/new/g</code> 可以替换 old 为 new。</p>\n<p>若要替换两行之间出现的每个字符串，可以通过以下命令：</p>\n<ul>\n<li>输入 <code>:#,#s/old/new/g</code>， <code>#,#</code> 表示替换操作的若干行的首尾行号</li>\n<li>输入 <code>:%s/old/new/g</code>，表示替换整个文件中的每个匹配串</li>\n<li>输入 <code>:%s/old/new/gc</code>，则会查找整个文件中的匹配串，并且对每个匹配串提示是否进行替换</li>\n</ul>\n<h2 id=\"文件相关操作\"><a href=\"#文件相关操作\" class=\"headerlink\" title=\"文件相关操作\"></a>文件相关操作</h2><h3 id=\"在-Vim-内执行外部命令的方法\"><a href=\"#在-Vim-内执行外部命令的方法\" class=\"headerlink\" title=\"在 Vim 内执行外部命令的方法\"></a>在 Vim 内执行外部命令的方法</h3><p>在正常模式下，输入 <code>:!</code> 然后紧接着输入一个外部命令即可执行该外部命令。</p>\n<p>如输入 <code>:!ls</code> 并按下回车，会列出当前目录的内容。</p>\n<h3 id=\"关于保存文件的更多信息\"><a href=\"#关于保存文件的更多信息\" class=\"headerlink\" title=\"关于保存文件的更多信息\"></a>关于保存文件的更多信息</h3><p>正常模式下，输入 <code>:w FILENAME</code> 可以将对文件的改动保存到 FILENAME 中。</p>\n<p>若要删除保存的文件，可以通过执行外部命令的方法，输入 <code>:!rm TEST</code> 进行删除。</p>\n<h3 id=\"一个具有选择性的保存命令\"><a href=\"#一个具有选择性的保存命令\" class=\"headerlink\" title=\"一个具有选择性的保存命令\"></a>一个具有选择性的保存命令</h3><p>在正常模式下，若要保存文件的部分内容，可以输入 <code>v motion :w FILENAME</code>。具体操作如下：</p>\n<ul>\n<li>将光标移动至要保存内容的开始位置</li>\n<li>接着按下 <code>v</code> 键进入可视模式，并继续移动光标至要保存内容的结束位置，这些内容会高亮显示</li>\n<li>然后按下 <code>:</code>，这时屏幕底部会出现 <code>:&#39;&lt;,&#39;&gt;</code></li>\n<li>接着输入 <code>w FILENAME</code>，然后按下回车键</li>\n<li>所选中的内容将会被写入 FILENAME 中。</li>\n</ul>\n<blockquote>\n<p>按 <code>v</code> 键使 Vim 进入可视模式。我们可以移动光标使选取区域变大或变小。接着可以使用一个操作符对选中的文本进行操作。例如：按 <code>d</code> 键删除所选中的文本内容。</p>\n</blockquote>\n<h3 id=\"提取和合并文件\"><a href=\"#提取和合并文件\" class=\"headerlink\" title=\"提取和合并文件\"></a>提取和合并文件</h3><p>可以通过 <code>:r FILENAME</code> 命令向当前文件中插入另外文件的内容。</p>\n<blockquote>\n<p>除了合并文件外，还可以读取外部命令的输出。例如：<code>:r !ls</code> 可以读取 ls 命令的输出，并将其放置在光标打下面。</p>\n</blockquote>\n<h2 id=\"打开、附加、替换、复制和设置类命令\"><a href=\"#打开、附加、替换、复制和设置类命令\" class=\"headerlink\" title=\"打开、附加、替换、复制和设置类命令\"></a>打开、附加、替换、复制和设置类命令</h2><h3 id=\"打开类命令\"><a href=\"#打开类命令\" class=\"headerlink\" title=\"打开类命令\"></a>打开类命令</h3><p>正常模式下，输入 <code>o</code> 将在光标打下方打开新的一行并进入插入模式。</p>\n<p>若要在光标的<strong>上方</strong>打开新的一行，则需要输入 <code>O</code>。</p>\n<h3 id=\"附加类命令\"><a href=\"#附加类命令\" class=\"headerlink\" title=\"附加类命令\"></a>附加类命令</h3><p>正常模式下，输入 <code>a</code> 将在光标之后插入文本。</p>\n<blockquote>\n<p><code>a</code>、<code>i</code>、<code>A</code> 都会进入插入模式，唯一的区别在于字符插入的位置。<code>i</code> 将字符插入于光标之前，<code>a</code> 将字符插入于光标之后，而 <code>A</code> 则将字符插入于光标所在行的末尾。</p>\n</blockquote>\n<h3 id=\"另一个置换命令的版本\"><a href=\"#另一个置换命令的版本\" class=\"headerlink\" title=\"另一个置换命令的版本\"></a>另一个置换命令的版本</h3><p>正常模式下，输入 <code>R</code> 可以连续替换多个字符。具体操作如下：</p>\n<ul>\n<li>将光标移动至要替换内容的起始位置</li>\n<li>输入 <code>R</code>，然后逐一输入要替换的字符</li>\n<li>按下 <code>ESC</code> 键退出替换模式回到正常模式。</li>\n</ul>\n<blockquote>\n<p>替换模式与插入模式类似，不过每个输入的字符都会删除一个已有的字符。</p>\n</blockquote>\n<h3 id=\"复制粘贴文本\"><a href=\"#复制粘贴文本\" class=\"headerlink\" title=\"复制粘贴文本\"></a>复制粘贴文本</h3><p>正常模式下，使用操作符 <code>y</code> 复制文本，使用 <code>p</code> 粘贴文本。例如：</p>\n<ul>\n<li>移动光标至所要复制内容的起始位置</li>\n<li>按下 <code>v</code> 键进入可视模式</li>\n<li>移动光标至所要复制内容的结束位置</li>\n<li>输入 <code>y</code> 复制高亮文本</li>\n<li>移动光标至要粘贴的位置，输入 <code>p</code> 以复制文本</li>\n</ul>\n<blockquote>\n<p>可以把 <code>y</code> 当作操作符来使用。例如：<code>yw</code> 表示复制一个单词。</p>\n</blockquote>\n<h3 id=\"设置类命令选项\"><a href=\"#设置类命令选项\" class=\"headerlink\" title=\"设置类命令选项\"></a>设置类命令选项</h3><p>设置可使查找或者替换可忽略大小写的选项。例如：</p>\n<ul>\n<li>要查找单词 ignore 可以在正常模式下输入 <code>/ignore</code> 并回车</li>\n<li>然后设置 ic 选项（Ignore Case，忽略大小写），输入：<code>:set ic</code></li>\n<li>现在可以通过输入 <code>n</code> 键查找单词 ignore，且现在能够查找 Ignore 和 IGNORE</li>\n<li>然后设置 hlsearch 和 insearch 这两个选项，输入：<code>set hls is</code></li>\n<li>现在在此输入查找命令：<code>/ignore</code>，可以发现符合要求的字符串高亮显示了</li>\n<li>若要禁用忽略大小写，则输入：<code>:set noic</code></li>\n</ul>\n<p>输入 <code>:set xxx</code> 可以设置 xxx 选项，一些常用的选项如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">缩写</th>\n<th align=\"center\">全称</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ic</td>\n<td align=\"center\">ignorecase</td>\n<td align=\"left\">查找时忽略字母大小写</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">insearch</td>\n<td align=\"left\">查找短语时显示部分匹配</td>\n</tr>\n<tr>\n<td align=\"center\">hls</td>\n<td align=\"center\">hlsearch</td>\n<td align=\"left\">高亮显示所有的匹配短语</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>若要移除匹配项的高亮显示，可以输入：<code>:nohlsearch</code>。在选项前加上 <code>no</code> 可以关闭选项。<br>如果想要仅在一次查找时忽略字母大小写，可以使用 <code>\\c:/ignore\\c</code> 并回车</p>\n</blockquote>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><h3 id=\"在线帮助系统\"><a href=\"#在线帮助系统\" class=\"headerlink\" title=\"在线帮助系统\"></a>在线帮助系统</h3><p>Vim 拥有一个细致全面的在线帮助系统，可以通过下述命令启动该系统：</p>\n<ul>\n<li>按下 <HELP> 键</li>\n<li>按下 <F1> 键</li>\n<li>输入 <code>:help</code> 并回车</li>\n</ul>\n<p>输入 <code>CTRL-W</code> 可以在不同窗口间切换</p>\n<p>在 <code>:help</code> 命令中添加关键字，可以找到改关键字的帮助，如：</p>\n<ul>\n<li><code>:help w</code></li>\n<li><code>:help c_CTRL-D</code></li>\n<li><code>:help insert-index</code></li>\n<li><code>:helo user-manual</code></li>\n</ul>\n<h3 id=\"创建启动脚本\"><a href=\"#创建启动脚本\" class=\"headerlink\" title=\"创建启动脚本\"></a>创建启动脚本</h3><p>通过创建启动脚本，可以启用 Vim 的特性。Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，可以创建一个 vimrc 文件。</p>\n<ul>\n<li>开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：<ul>\n<li><code>:edit ~/.vimrc</code>，这是 Unix 系统所使用的命令</li>\n<li><code>:edit $VIM/_vimrc</code>，这是 MS-Windows 系统所使用的命令</li>\n</ul>\n</li>\n<li>接着读取 vimrc 示例文件的内容：<ul>\n<li><code>:r $VIMRUNTIME/vimrc_example.vim</code></li>\n</ul>\n</li>\n<li>保存文件，命令为：<ul>\n<li><code>:write</code></li>\n</ul>\n</li>\n</ul>\n<p>下次启动 Vim 时，编辑器就会有了语法高亮的功能。我们可以把喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 <code>:help imrc-intro</code>。</p>\n<h3 id=\"补全功能\"><a href=\"#补全功能\" class=\"headerlink\" title=\"补全功能\"></a>补全功能</h3><p>使用 <code>CTRL-D</code> 和 <code>TAB</code> 可以进行命令补全。</p>\n<blockquote>\n<p>补全对于许多命令都有效。只需尝试按 CTRL-D 和 TAB。它对于 :help 命令非常有用。</p>\n</blockquote>"},{"title":"Visual Studio项目中集成Google Test测试框架","date":"2017-11-17T07:22:38.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"\n本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。\n\n<!--more-->\n\n## VS2015下配置Google Test\n\n### 下载Google Test\n\n[Google Test][1]是Google旗下的一个单元测试框架。下载地址在[Release][2]中，在release页面下，有它的历史版本，我们下载最新的即可。\n\n解压下载的文件，可以看到两个文件夹，这里我们要用的是**googletest**文件夹下的内容，其他的可以不用管。\n\n![googletest](/images/imagesource/17-11-17/17-11-17-1.png)\n\n解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的**include**和**src**。其中**include**用于配置项目时添加到包含目录中；**src**是Google Test框架的源码。\n\n![src&include](/images/imagesource/17-11-17/17-11-17-2.png)\n\n### 配置Google Test(2018-04-04更新)\n\n感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇[博客][6]。\n\n下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。\n\n#### 新建项目\n\n打开VS2105，**新建项目->Win32控制台应用程序**，我们将项目名称设置为SimpleTest。然后选择**空项目**，完成即可。\n\n![newproject](/images/imagesource/17-11-17/17-11-17-3.png)\n![newproject1](/images/imagesource/17-11-17/17-11-17-4.png)\n\n我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：\n\n```c++\n// simple_math.h\n#pragma once\n#include  <cmath>\n\ndouble square(double num)\n{\n\treturn pow(num, 2);\n}\n\n\n// simple_math.cpp\n#include \"simple_math.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tauto ans = square(10);\n\treturn 0;\n}\n```\n\n我们在`simple_math.h`中定义了一个`square`函数，返回传入的参数的平方值。并在`simple_math.cpp`中调用了该函数。可以按**Ctrl+F5**来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。\n\n#### 配置Google Test\n\n接下来我们右键最上面的**解决方案**，选择**添加->新建项目->Win32项目**，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择**静态库**，取消预编译头，然后点击完成。\n\n![googletestproject](/images/imagesource/17-11-17/17-11-17-6.png)\n\n现在解决方案下面有两个项目，一个是我们之前创建的项目**SimpleTest**，一个是刚刚创建的**GoogleTest**。\n\n![project2](/images/imagesource/17-11-17/17-11-17-7.png)\n\n下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。**右键GoogleTest->属性->配置属性->VC++目录->包含目录**，我们在包含目录中添加Google Test相关文件。我们**googletest文件夹**和googletest目录下的**include**文件夹都添加进去，然后点击确定。\n\n![includefile](/images/imagesource/17-11-17/17-11-17-8.png)\n\n接着再给GoogleTest项目添加源文件。**右键GoogleTest的源文件->添加->现有项**，把之前提到的**src**目录下的**gtest_main.cc**和**gtest-all.cc**添加进去。\n\n![addfile](/images/imagesource/17-11-17/17-11-17-9.png)\n\n现在GoogleTest项目下有两个源文件。\n\n![sourcefiles](/images/imagesource/17-11-17/17-11-17-10.png)\n\n#### 生成静态库\n\n上述配置完成后，我们**右键GoogleTest->生成**，就可以生成GoogleTest的静态库了。\n\n![build](/images/imagesource/17-11-17/17-11-17-11.png)\n\n#### 添加单元测试\n\n下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目**UnittestSimpleTest**，**右键解决方案->添加->新建项目->Win32控制台应用程序**，选择空项目，然后完成即可。\n\n现在我们的解决方案中共有三个项目：**GoogleTest，SimpleTest，UnittestSimpleTest**。\n\n![project3](/images/imagesource/17-11-17/17-11-17-12.png)\n\n同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。\n\n![includepath](/images/imagesource/17-11-17/17-11-17-13.png)\n\n添加完包含目录后，再为其添加引用：**右键UnittestSimpleTest->添加->引用**，将**GoogleTest**和**SimpleTest**全勾上\n\n![references](/images/imagesource/17-11-17/17-11-17-14.png)\n\n单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。\n\n![references1](/images/imagesource/17-11-17/17-11-17-15.png)\n\n#### 新建测试\n\n我们现在可以添加源文件，编写单元测试了。新建一个源文件**test.cpp**，编写代码如下：\n```c++\n// test.cpp\n#include \"simple_math.h\"\n#include \"gtest/gtest.h\"\n\nTEST(testSquare, mySquareTest)\n{\n\tEXPECT_EQ(100, square(10));\n}\n```\n然后我们将UnittestSimpleTest作为启动项目（**右键项目->设为启动项目**），然后运行即可。运行结果如图所示。\n\n![result](/images/imagesource/17-11-17/17-11-17-16.png)\n\n## 将现有的项目作为引用添加到其他项目中\n\n在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。\n\n![errorlnk2019](/images/imagesource/17-11-17/17-11-17-17.png)\n\n百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为**静态库**给新的项目引用，解决方法如下：**右键项目->属性->配置属性->常规**，将目标文件扩展名改为**.lib**，然后在下面的项目默认值中的**配置类型**改为**静态库**。\n\n![buildall](/images/imagesource/17-11-17/17-11-17-18.png)\n\n然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：\n\n![result1](/images/imagesource/17-11-17/17-11-17-19.png)\n\n在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。\n\n## 参考链接\n\n1. [C++ TUTORIAL - GOOGLE TEST (GTEST)][3]\n2. [带你玩转Visual Studio——带你发布自己的工程库][4]\n3. [带你玩转Visual Studio——带你多工程开发][5]\n4. [GTEST基础学习][6]\n\n  [1]: https://github.com/google/googletest \"Google Test\"\n  [2]: https://github.com/google/googletest/releases \"Google Test Release\"\n  [3]: http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php \"GTEST\"\n  [4]: http://blog.csdn.net/luoweifu/article/details/48895765 \"发布自己的程序库\"\n  [5]: http://blog.csdn.net/luoweifu/article/details/48915347 \"多工程开发\"\n  [6]: https://blog.csdn.net/lywzgzl/article/details/52203558 \"GTEST基础学习\"\n","source":"_posts/Visual-Studio项目中集成Google-Test测试框架.md","raw":"---\ntitle: Visual Studio项目中集成Google Test测试框架\ndate: 2017-11-17 15:22:38\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: [C++, IDE]\ncomments: true\n---\n\n本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。\n\n<!--more-->\n\n## VS2015下配置Google Test\n\n### 下载Google Test\n\n[Google Test][1]是Google旗下的一个单元测试框架。下载地址在[Release][2]中，在release页面下，有它的历史版本，我们下载最新的即可。\n\n解压下载的文件，可以看到两个文件夹，这里我们要用的是**googletest**文件夹下的内容，其他的可以不用管。\n\n![googletest](/images/imagesource/17-11-17/17-11-17-1.png)\n\n解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的**include**和**src**。其中**include**用于配置项目时添加到包含目录中；**src**是Google Test框架的源码。\n\n![src&include](/images/imagesource/17-11-17/17-11-17-2.png)\n\n### 配置Google Test(2018-04-04更新)\n\n感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇[博客][6]。\n\n下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。\n\n#### 新建项目\n\n打开VS2105，**新建项目->Win32控制台应用程序**，我们将项目名称设置为SimpleTest。然后选择**空项目**，完成即可。\n\n![newproject](/images/imagesource/17-11-17/17-11-17-3.png)\n![newproject1](/images/imagesource/17-11-17/17-11-17-4.png)\n\n我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：\n\n```c++\n// simple_math.h\n#pragma once\n#include  <cmath>\n\ndouble square(double num)\n{\n\treturn pow(num, 2);\n}\n\n\n// simple_math.cpp\n#include \"simple_math.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tauto ans = square(10);\n\treturn 0;\n}\n```\n\n我们在`simple_math.h`中定义了一个`square`函数，返回传入的参数的平方值。并在`simple_math.cpp`中调用了该函数。可以按**Ctrl+F5**来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。\n\n#### 配置Google Test\n\n接下来我们右键最上面的**解决方案**，选择**添加->新建项目->Win32项目**，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择**静态库**，取消预编译头，然后点击完成。\n\n![googletestproject](/images/imagesource/17-11-17/17-11-17-6.png)\n\n现在解决方案下面有两个项目，一个是我们之前创建的项目**SimpleTest**，一个是刚刚创建的**GoogleTest**。\n\n![project2](/images/imagesource/17-11-17/17-11-17-7.png)\n\n下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。**右键GoogleTest->属性->配置属性->VC++目录->包含目录**，我们在包含目录中添加Google Test相关文件。我们**googletest文件夹**和googletest目录下的**include**文件夹都添加进去，然后点击确定。\n\n![includefile](/images/imagesource/17-11-17/17-11-17-8.png)\n\n接着再给GoogleTest项目添加源文件。**右键GoogleTest的源文件->添加->现有项**，把之前提到的**src**目录下的**gtest_main.cc**和**gtest-all.cc**添加进去。\n\n![addfile](/images/imagesource/17-11-17/17-11-17-9.png)\n\n现在GoogleTest项目下有两个源文件。\n\n![sourcefiles](/images/imagesource/17-11-17/17-11-17-10.png)\n\n#### 生成静态库\n\n上述配置完成后，我们**右键GoogleTest->生成**，就可以生成GoogleTest的静态库了。\n\n![build](/images/imagesource/17-11-17/17-11-17-11.png)\n\n#### 添加单元测试\n\n下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目**UnittestSimpleTest**，**右键解决方案->添加->新建项目->Win32控制台应用程序**，选择空项目，然后完成即可。\n\n现在我们的解决方案中共有三个项目：**GoogleTest，SimpleTest，UnittestSimpleTest**。\n\n![project3](/images/imagesource/17-11-17/17-11-17-12.png)\n\n同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。\n\n![includepath](/images/imagesource/17-11-17/17-11-17-13.png)\n\n添加完包含目录后，再为其添加引用：**右键UnittestSimpleTest->添加->引用**，将**GoogleTest**和**SimpleTest**全勾上\n\n![references](/images/imagesource/17-11-17/17-11-17-14.png)\n\n单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。\n\n![references1](/images/imagesource/17-11-17/17-11-17-15.png)\n\n#### 新建测试\n\n我们现在可以添加源文件，编写单元测试了。新建一个源文件**test.cpp**，编写代码如下：\n```c++\n// test.cpp\n#include \"simple_math.h\"\n#include \"gtest/gtest.h\"\n\nTEST(testSquare, mySquareTest)\n{\n\tEXPECT_EQ(100, square(10));\n}\n```\n然后我们将UnittestSimpleTest作为启动项目（**右键项目->设为启动项目**），然后运行即可。运行结果如图所示。\n\n![result](/images/imagesource/17-11-17/17-11-17-16.png)\n\n## 将现有的项目作为引用添加到其他项目中\n\n在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。\n\n![errorlnk2019](/images/imagesource/17-11-17/17-11-17-17.png)\n\n百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为**静态库**给新的项目引用，解决方法如下：**右键项目->属性->配置属性->常规**，将目标文件扩展名改为**.lib**，然后在下面的项目默认值中的**配置类型**改为**静态库**。\n\n![buildall](/images/imagesource/17-11-17/17-11-17-18.png)\n\n然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：\n\n![result1](/images/imagesource/17-11-17/17-11-17-19.png)\n\n在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。\n\n## 参考链接\n\n1. [C++ TUTORIAL - GOOGLE TEST (GTEST)][3]\n2. [带你玩转Visual Studio——带你发布自己的工程库][4]\n3. [带你玩转Visual Studio——带你多工程开发][5]\n4. [GTEST基础学习][6]\n\n  [1]: https://github.com/google/googletest \"Google Test\"\n  [2]: https://github.com/google/googletest/releases \"Google Test Release\"\n  [3]: http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php \"GTEST\"\n  [4]: http://blog.csdn.net/luoweifu/article/details/48895765 \"发布自己的程序库\"\n  [5]: http://blog.csdn.net/luoweifu/article/details/48915347 \"多工程开发\"\n  [6]: https://blog.csdn.net/lywzgzl/article/details/52203558 \"GTEST基础学习\"\n","slug":"Visual-Studio项目中集成Google-Test测试框架","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsis001bw8voase71v4i","content":"<p>本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"VS2015下配置Google-Test\"><a href=\"#VS2015下配置Google-Test\" class=\"headerlink\" title=\"VS2015下配置Google Test\"></a>VS2015下配置Google Test</h2><h3 id=\"下载Google-Test\"><a href=\"#下载Google-Test\" class=\"headerlink\" title=\"下载Google Test\"></a>下载Google Test</h3><p><a href=\"https://github.com/google/googletest\" title=\"Google Test\">Google Test</a>是Google旗下的一个单元测试框架。下载地址在<a href=\"https://github.com/google/googletest/releases\" title=\"Google Test Release\">Release</a>中，在release页面下，有它的历史版本，我们下载最新的即可。</p>\n<p>解压下载的文件，可以看到两个文件夹，这里我们要用的是<strong>googletest</strong>文件夹下的内容，其他的可以不用管。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-1.png\" alt=\"googletest\"></p>\n<p>解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的<strong>include</strong>和<strong>src</strong>。其中<strong>include</strong>用于配置项目时添加到包含目录中；<strong>src</strong>是Google Test框架的源码。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-2.png\" alt=\"src&amp;include\"></p>\n<h3 id=\"配置Google-Test-2018-04-04更新\"><a href=\"#配置Google-Test-2018-04-04更新\" class=\"headerlink\" title=\"配置Google Test(2018-04-04更新)\"></a>配置Google Test(2018-04-04更新)</h3><p>感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇<a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">博客</a>。</p>\n<p>下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。</p>\n<h4 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h4><p>打开VS2105，<strong>新建项目-&gt;Win32控制台应用程序</strong>，我们将项目名称设置为SimpleTest。然后选择<strong>空项目</strong>，完成即可。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-3.png\" alt=\"newproject\"><br><img data-src=\"/images/imagesource/17-11-17/17-11-17-4.png\" alt=\"newproject1\"></p>\n<p>我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// simple_math.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(num, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// simple_math.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ans = square(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在<code>simple_math.h</code>中定义了一个<code>square</code>函数，返回传入的参数的平方值。并在<code>simple_math.cpp</code>中调用了该函数。可以按<strong>Ctrl+F5</strong>来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。</p>\n<h4 id=\"配置Google-Test\"><a href=\"#配置Google-Test\" class=\"headerlink\" title=\"配置Google Test\"></a>配置Google Test</h4><p>接下来我们右键最上面的<strong>解决方案</strong>，选择<strong>添加-&gt;新建项目-&gt;Win32项目</strong>，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择<strong>静态库</strong>，取消预编译头，然后点击完成。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-6.png\" alt=\"googletestproject\"></p>\n<p>现在解决方案下面有两个项目，一个是我们之前创建的项目<strong>SimpleTest</strong>，一个是刚刚创建的<strong>GoogleTest</strong>。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-7.png\" alt=\"project2\"></p>\n<p>下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。<strong>右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</strong>，我们在包含目录中添加Google Test相关文件。我们<strong>googletest文件夹</strong>和googletest目录下的<strong>include</strong>文件夹都添加进去，然后点击确定。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-8.png\" alt=\"includefile\"></p>\n<p>接着再给GoogleTest项目添加源文件。<strong>右键GoogleTest的源文件-&gt;添加-&gt;现有项</strong>，把之前提到的<strong>src</strong>目录下的<strong>gtest_main.cc</strong>和<strong>gtest-all.cc</strong>添加进去。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-9.png\" alt=\"addfile\"></p>\n<p>现在GoogleTest项目下有两个源文件。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-10.png\" alt=\"sourcefiles\"></p>\n<h4 id=\"生成静态库\"><a href=\"#生成静态库\" class=\"headerlink\" title=\"生成静态库\"></a>生成静态库</h4><p>上述配置完成后，我们<strong>右键GoogleTest-&gt;生成</strong>，就可以生成GoogleTest的静态库了。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-11.png\" alt=\"build\"></p>\n<h4 id=\"添加单元测试\"><a href=\"#添加单元测试\" class=\"headerlink\" title=\"添加单元测试\"></a>添加单元测试</h4><p>下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目<strong>UnittestSimpleTest</strong>，<strong>右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序</strong>，选择空项目，然后完成即可。</p>\n<p>现在我们的解决方案中共有三个项目：<strong>GoogleTest，SimpleTest，UnittestSimpleTest</strong>。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-12.png\" alt=\"project3\"></p>\n<p>同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-13.png\" alt=\"includepath\"></p>\n<p>添加完包含目录后，再为其添加引用：<strong>右键UnittestSimpleTest-&gt;添加-&gt;引用</strong>，将<strong>GoogleTest</strong>和<strong>SimpleTest</strong>全勾上</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-14.png\" alt=\"references\"></p>\n<p>单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-15.png\" alt=\"references1\"></p>\n<h4 id=\"新建测试\"><a href=\"#新建测试\" class=\"headerlink\" title=\"新建测试\"></a>新建测试</h4><p>我们现在可以添加源文件，编写单元测试了。新建一个源文件<strong>test.cpp</strong>，编写代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;gtest/gtest.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">TEST(testSquare, mySquareTest)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEXPECT_EQ(<span class=\"number\">100</span>, square(<span class=\"number\">10</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们将UnittestSimpleTest作为启动项目（<strong>右键项目-&gt;设为启动项目</strong>），然后运行即可。运行结果如图所示。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-16.png\" alt=\"result\"></p>\n<h2 id=\"将现有的项目作为引用添加到其他项目中\"><a href=\"#将现有的项目作为引用添加到其他项目中\" class=\"headerlink\" title=\"将现有的项目作为引用添加到其他项目中\"></a>将现有的项目作为引用添加到其他项目中</h2><p>在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-17.png\" alt=\"errorlnk2019\"></p>\n<p>百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为<strong>静态库</strong>给新的项目引用，解决方法如下：<strong>右键项目-&gt;属性-&gt;配置属性-&gt;常规</strong>，将目标文件扩展名改为**.lib<strong>，然后在下面的项目默认值中的</strong>配置类型<strong>改为</strong>静态库**。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-18.png\" alt=\"buildall\"></p>\n<p>然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-19.png\" alt=\"result1\"></p>\n<p>在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php\" title=\"GTEST\">C++ TUTORIAL - GOOGLE TEST (GTEST)</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48895765\" title=\"发布自己的程序库\">带你玩转Visual Studio——带你发布自己的工程库</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48915347\" title=\"多工程开发\">带你玩转Visual Studio——带你多工程开发</a></li>\n<li><a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">GTEST基础学习</a></li>\n</ol>\n","site":{"data":{}},"length":2563,"excerpt":"<p>本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。</p>","more":"<h2 id=\"VS2015下配置Google-Test\"><a href=\"#VS2015下配置Google-Test\" class=\"headerlink\" title=\"VS2015下配置Google Test\"></a>VS2015下配置Google Test</h2><h3 id=\"下载Google-Test\"><a href=\"#下载Google-Test\" class=\"headerlink\" title=\"下载Google Test\"></a>下载Google Test</h3><p><a href=\"https://github.com/google/googletest\" title=\"Google Test\">Google Test</a>是Google旗下的一个单元测试框架。下载地址在<a href=\"https://github.com/google/googletest/releases\" title=\"Google Test Release\">Release</a>中，在release页面下，有它的历史版本，我们下载最新的即可。</p>\n<p>解压下载的文件，可以看到两个文件夹，这里我们要用的是<strong>googletest</strong>文件夹下的内容，其他的可以不用管。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-1.png\" alt=\"googletest\"></p>\n<p>解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的<strong>include</strong>和<strong>src</strong>。其中<strong>include</strong>用于配置项目时添加到包含目录中；<strong>src</strong>是Google Test框架的源码。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-2.png\" alt=\"src&amp;include\"></p>\n<h3 id=\"配置Google-Test-2018-04-04更新\"><a href=\"#配置Google-Test-2018-04-04更新\" class=\"headerlink\" title=\"配置Google Test(2018-04-04更新)\"></a>配置Google Test(2018-04-04更新)</h3><p>感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇<a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">博客</a>。</p>\n<p>下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。</p>\n<h4 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h4><p>打开VS2105，<strong>新建项目-&gt;Win32控制台应用程序</strong>，我们将项目名称设置为SimpleTest。然后选择<strong>空项目</strong>，完成即可。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-3.png\" alt=\"newproject\"><br><img data-src=\"/images/imagesource/17-11-17/17-11-17-4.png\" alt=\"newproject1\"></p>\n<p>我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// simple_math.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(num, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// simple_math.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ans = square(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在<code>simple_math.h</code>中定义了一个<code>square</code>函数，返回传入的参数的平方值。并在<code>simple_math.cpp</code>中调用了该函数。可以按<strong>Ctrl+F5</strong>来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。</p>\n<h4 id=\"配置Google-Test\"><a href=\"#配置Google-Test\" class=\"headerlink\" title=\"配置Google Test\"></a>配置Google Test</h4><p>接下来我们右键最上面的<strong>解决方案</strong>，选择<strong>添加-&gt;新建项目-&gt;Win32项目</strong>，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择<strong>静态库</strong>，取消预编译头，然后点击完成。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-6.png\" alt=\"googletestproject\"></p>\n<p>现在解决方案下面有两个项目，一个是我们之前创建的项目<strong>SimpleTest</strong>，一个是刚刚创建的<strong>GoogleTest</strong>。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-7.png\" alt=\"project2\"></p>\n<p>下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。<strong>右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</strong>，我们在包含目录中添加Google Test相关文件。我们<strong>googletest文件夹</strong>和googletest目录下的<strong>include</strong>文件夹都添加进去，然后点击确定。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-8.png\" alt=\"includefile\"></p>\n<p>接着再给GoogleTest项目添加源文件。<strong>右键GoogleTest的源文件-&gt;添加-&gt;现有项</strong>，把之前提到的<strong>src</strong>目录下的<strong>gtest_main.cc</strong>和<strong>gtest-all.cc</strong>添加进去。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-9.png\" alt=\"addfile\"></p>\n<p>现在GoogleTest项目下有两个源文件。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-10.png\" alt=\"sourcefiles\"></p>\n<h4 id=\"生成静态库\"><a href=\"#生成静态库\" class=\"headerlink\" title=\"生成静态库\"></a>生成静态库</h4><p>上述配置完成后，我们<strong>右键GoogleTest-&gt;生成</strong>，就可以生成GoogleTest的静态库了。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-11.png\" alt=\"build\"></p>\n<h4 id=\"添加单元测试\"><a href=\"#添加单元测试\" class=\"headerlink\" title=\"添加单元测试\"></a>添加单元测试</h4><p>下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目<strong>UnittestSimpleTest</strong>，<strong>右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序</strong>，选择空项目，然后完成即可。</p>\n<p>现在我们的解决方案中共有三个项目：<strong>GoogleTest，SimpleTest，UnittestSimpleTest</strong>。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-12.png\" alt=\"project3\"></p>\n<p>同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-13.png\" alt=\"includepath\"></p>\n<p>添加完包含目录后，再为其添加引用：<strong>右键UnittestSimpleTest-&gt;添加-&gt;引用</strong>，将<strong>GoogleTest</strong>和<strong>SimpleTest</strong>全勾上</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-14.png\" alt=\"references\"></p>\n<p>单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-15.png\" alt=\"references1\"></p>\n<h4 id=\"新建测试\"><a href=\"#新建测试\" class=\"headerlink\" title=\"新建测试\"></a>新建测试</h4><p>我们现在可以添加源文件，编写单元测试了。新建一个源文件<strong>test.cpp</strong>，编写代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;gtest/gtest.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">TEST(testSquare, mySquareTest)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEXPECT_EQ(<span class=\"number\">100</span>, square(<span class=\"number\">10</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们将UnittestSimpleTest作为启动项目（<strong>右键项目-&gt;设为启动项目</strong>），然后运行即可。运行结果如图所示。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-16.png\" alt=\"result\"></p>\n<h2 id=\"将现有的项目作为引用添加到其他项目中\"><a href=\"#将现有的项目作为引用添加到其他项目中\" class=\"headerlink\" title=\"将现有的项目作为引用添加到其他项目中\"></a>将现有的项目作为引用添加到其他项目中</h2><p>在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-17.png\" alt=\"errorlnk2019\"></p>\n<p>百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为<strong>静态库</strong>给新的项目引用，解决方法如下：<strong>右键项目-&gt;属性-&gt;配置属性-&gt;常规</strong>，将目标文件扩展名改为**.lib<strong>，然后在下面的项目默认值中的</strong>配置类型<strong>改为</strong>静态库**。</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-18.png\" alt=\"buildall\"></p>\n<p>然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：</p>\n<p><img data-src=\"/images/imagesource/17-11-17/17-11-17-19.png\" alt=\"result1\"></p>\n<p>在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php\" title=\"GTEST\">C++ TUTORIAL - GOOGLE TEST (GTEST)</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48895765\" title=\"发布自己的程序库\">带你玩转Visual Studio——带你发布自己的工程库</a></li>\n<li><a href=\"http://blog.csdn.net/luoweifu/article/details/48915347\" title=\"多工程开发\">带你玩转Visual Studio——带你多工程开发</a></li>\n<li><a href=\"https://blog.csdn.net/lywzgzl/article/details/52203558\" title=\"GTEST基础学习\">GTEST基础学习</a></li>\n</ol>"},{"title":"Hello World","date":"2017-03-21T13:41:15.000Z","updated":"2017-03-24T10:18:57.000Z","comments":1,"_content":"![background](/images/background.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-03-21 21:41:15\nupdated: 2017-03-24 18:18:57\ncategory: helloworld\ntag: helloworld\ncomments: true\n---\n![background](/images/background.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsit001gw8voduk86dqc","content":"<p><img data-src=\"/images/background.jpg\" alt=\"background\"><br>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{}},"length":367,"excerpt":"<p><img data-src=\"/images/background.jpg\" alt=\"background\"><br>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"【每周一坑】杨辉三角形","date":"2017-05-19T06:28:26.000Z","updated":"2017-05-28T01:46:45.000Z","comments":1,"_content":"\n## 问题描述\n\n**本周题目**\n> 杨辉三角形，也称帕斯卡三角，其定义为：\n顶端是1，视为(row0).\n第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).\n以此类推\n第2行(row2)：0+1=1; 1+1=2; 1+0=1.\n第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.\n\n<!--more-->\n\n根据上述方法可产生杨辉三角。如下所示：\n\n```ptyhon\nn = 0              1                     \nn = 1            1   1                   \nn = 2          1   2   1                 \nn = 3        1   3   3   1               \nn = 4      1   4   6   4   1             \nn = 5    1   5   10  10  5   1           \nn = ...         ...  ...                             \n```\n\n根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 `Invalid query`。\n\n示例代码：\n```python\ndef yang_hui(m, n):\n    '''\n    >>>yang_hui(1, 1)\n    1\n    >>>yang_hui(3,2)\n    3\n    >>>yang_hui(1,4)\n    Invalid query\n    '''\n```\n\n**附加题**\n生成杨辉三角形\n定义一个函数，传入M<1000,生成前M行杨辉三角形。\n示例代码：\n\n```python\ndef generate_yh(m):\n    '''\n    generate_yh(3):\n    1\n    1 1\n    1 2 1\n    '''\n```\n\n\n## 思路\n根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：`N > M`时，返回的应该是 `Invalidquery`。还有 `n=0` 或 `n=m`     时，返回的值应该为1.\n要求第(M,N)个数字，可以用递归的方式来求得：\n```python\nyang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n## Python实现\n**yang_hui(m,n):**\n```python\n# 输出杨辉三角中第m行第n列的数值\ndef yang_hui(m, n):\n    if n and n > m:\n        return  \"Invalid query!\"\n    if n == 0 or n == m:\n        return  1\n    return yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n**triangles(m):**\n```python\n打印输出杨辉三角\ndef triangles(m):\n    ret = [1]\n    while m:\n        yield ret\n        for i in range(1,len(ret)):\n            ret[i] = pre[i] + pre[i-1]\n        ret.append(1)\n        pre = ret[:]\n        m = m - 1\n```\n\n在生成杨辉三角的时候，用到了**生成器(generator)**。generator在执行过程中，遇到`yield`语句就返回，再次执行时从上次返回的`yield`语句处继续执行。\n**普通函数和generator函数的区别：**\n普通函数调用直接返回结果：\n```python\n>>> r = abs(6)\n>>> r\n6\n```\ngenerator函数的“调用”实际返回一个generator对象：\n```python\n>>> g = fib(6)\n>>> g\n<generator object fib at 0x1022ef498>\n```\n关于generator，可以参考[这里](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0)。\n\n\n**测试**\n```python\n# 测试\nif __name__ == '__main__':\n    print(yang_hui(0, 0))\n    print(yang_hui(1, 1))\n    print(yang_hui(1, 2))\n    print(yang_hui(6, 3))\n    print(yang_hui(4, 9))\n    \n    # 打印杨辉三角\n    triangle = triangles(10)\n    for i in triangle:\n        print(i)\n```\n\n## 输出结果\n输出结果如下：\n> 1\n1\nInvalid query\n20\nInvalid query\n[1]\n[1, 1]\n[1, 2, 1]\n[1, 3, 3, 1]\n[1, 4, 6, 4, 1]\n[1, 5, 10, 10, 5, 1]\n[1, 6, 15, 20, 15, 6, 1]\n[1, 7, 21, 35, 35, 21, 7, 1]\n[1, 8, 28, 56, 70, 56, 28, 8, 1]\n[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n\nEnd~\n\n---","source":"_posts/【每周一坑】杨辉三角形.md","raw":"---\ntitle: 【每周一坑】杨辉三角形\ndate: 2017-05-19 14:28:26\nupdated: 2017-05-28 09:46:45\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n## 问题描述\n\n**本周题目**\n> 杨辉三角形，也称帕斯卡三角，其定义为：\n顶端是1，视为(row0).\n第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).\n以此类推\n第2行(row2)：0+1=1; 1+1=2; 1+0=1.\n第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.\n\n<!--more-->\n\n根据上述方法可产生杨辉三角。如下所示：\n\n```ptyhon\nn = 0              1                     \nn = 1            1   1                   \nn = 2          1   2   1                 \nn = 3        1   3   3   1               \nn = 4      1   4   6   4   1             \nn = 5    1   5   10  10  5   1           \nn = ...         ...  ...                             \n```\n\n根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 `Invalid query`。\n\n示例代码：\n```python\ndef yang_hui(m, n):\n    '''\n    >>>yang_hui(1, 1)\n    1\n    >>>yang_hui(3,2)\n    3\n    >>>yang_hui(1,4)\n    Invalid query\n    '''\n```\n\n**附加题**\n生成杨辉三角形\n定义一个函数，传入M<1000,生成前M行杨辉三角形。\n示例代码：\n\n```python\ndef generate_yh(m):\n    '''\n    generate_yh(3):\n    1\n    1 1\n    1 2 1\n    '''\n```\n\n\n## 思路\n根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：`N > M`时，返回的应该是 `Invalidquery`。还有 `n=0` 或 `n=m`     时，返回的值应该为1.\n要求第(M,N)个数字，可以用递归的方式来求得：\n```python\nyang_hui(m, n) = yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n## Python实现\n**yang_hui(m,n):**\n```python\n# 输出杨辉三角中第m行第n列的数值\ndef yang_hui(m, n):\n    if n and n > m:\n        return  \"Invalid query!\"\n    if n == 0 or n == m:\n        return  1\n    return yang_hui(m-1,n-1) + yang_hui(m-1,n)\n```\n\n**triangles(m):**\n```python\n打印输出杨辉三角\ndef triangles(m):\n    ret = [1]\n    while m:\n        yield ret\n        for i in range(1,len(ret)):\n            ret[i] = pre[i] + pre[i-1]\n        ret.append(1)\n        pre = ret[:]\n        m = m - 1\n```\n\n在生成杨辉三角的时候，用到了**生成器(generator)**。generator在执行过程中，遇到`yield`语句就返回，再次执行时从上次返回的`yield`语句处继续执行。\n**普通函数和generator函数的区别：**\n普通函数调用直接返回结果：\n```python\n>>> r = abs(6)\n>>> r\n6\n```\ngenerator函数的“调用”实际返回一个generator对象：\n```python\n>>> g = fib(6)\n>>> g\n<generator object fib at 0x1022ef498>\n```\n关于generator，可以参考[这里](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0)。\n\n\n**测试**\n```python\n# 测试\nif __name__ == '__main__':\n    print(yang_hui(0, 0))\n    print(yang_hui(1, 1))\n    print(yang_hui(1, 2))\n    print(yang_hui(6, 3))\n    print(yang_hui(4, 9))\n    \n    # 打印杨辉三角\n    triangle = triangles(10)\n    for i in triangle:\n        print(i)\n```\n\n## 输出结果\n输出结果如下：\n> 1\n1\nInvalid query\n20\nInvalid query\n[1]\n[1, 1]\n[1, 2, 1]\n[1, 3, 3, 1]\n[1, 4, 6, 4, 1]\n[1, 5, 10, 10, 5, 1]\n[1, 6, 15, 20, 15, 6, 1]\n[1, 7, 21, 35, 35, 21, 7, 1]\n[1, 8, 28, 56, 70, 56, 28, 8, 1]\n[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n\nEnd~\n\n---","slug":"【每周一坑】杨辉三角形","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiu001jw8vobohkhi6a","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>杨辉三角形，也称帕斯卡三角，其定义为：<br>顶端是1，视为(row0).<br>第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).<br>以此类推<br>第2行(row2)：0+1=1; 1+1=2; 1+0=1.<br>第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>根据上述方法可产生杨辉三角。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0              1                     </span><br><span class=\"line\">n &#x3D; 1            1   1                   </span><br><span class=\"line\">n &#x3D; 2          1   2   1                 </span><br><span class=\"line\">n &#x3D; 3        1   3   3   1               </span><br><span class=\"line\">n &#x3D; 4      1   4   6   4   1             </span><br><span class=\"line\">n &#x3D; 5    1   5   10  10  5   1           </span><br><span class=\"line\">n &#x3D; ...         ...  ...                             </span><br></pre></td></tr></table></figure>\n\n<p>根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 <code>Invalid query</code>。</p>\n<p>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(1, 1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(3,2)</span></span><br><span class=\"line\"><span class=\"string\">    3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(1,4)</span></span><br><span class=\"line\"><span class=\"string\">    Invalid query</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>附加题</strong><br>生成杨辉三角形<br>定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。<br>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_yh</span>(<span class=\"params\">m</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    generate_yh(3):</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    1 1</span></span><br><span class=\"line\"><span class=\"string\">    1 2 1</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：<code>N &gt; M</code>时，返回的应该是 <code>Invalidquery</code>。还有 <code>n=0</code> 或 <code>n=m</code>     时，返回的值应该为1.<br>要求第(M,N)个数字，可以用递归的方式来求得：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yang_hui(m, n) = yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><p><strong>yang_hui(m,n):</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输出杨辉三角中第m行第n列的数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n <span class=\"keyword\">and</span> n &gt; m:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"string\">&quot;Invalid query!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> <span class=\"keyword\">or</span> n == m:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</span><br></pre></td></tr></table></figure>\n\n<p><strong>triangles(m):</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">打印输出杨辉三角</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">triangles</span>(<span class=\"params\">m</span>):</span></span><br><span class=\"line\">    ret = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> m:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> ret</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(ret)):</span><br><span class=\"line\">            ret[i] = pre[i] + pre[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        ret.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">        pre = ret[:]</span><br><span class=\"line\">        m = m - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>在生成杨辉三角的时候，用到了<strong>生成器(generator)**。generator在执行过程中，遇到<code>yield</code>语句就返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br>**普通函数和generator函数的区别：</strong><br>普通函数调用直接返回结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = <span class=\"built_in\">abs</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>generator函数的“调用”实际返回一个generator对象：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = fib(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g</span><br><span class=\"line\">&lt;generator <span class=\"built_in\">object</span> fib at <span class=\"number\">0x1022ef498</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>关于generator，可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0\">这里</a>。</p>\n<p><strong>测试</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">4</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 打印杨辉三角</span></span><br><span class=\"line\">    triangle = triangles(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> triangle:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>输出结果如下：</p>\n<blockquote>\n<p>1<br>1<br>Invalid query<br>20<br>Invalid query<br>[1]<br>[1, 1]<br>[1, 2, 1]<br>[1, 3, 3, 1]<br>[1, 4, 6, 4, 1]<br>[1, 5, 10, 10, 5, 1]<br>[1, 6, 15, 20, 15, 6, 1]<br>[1, 7, 21, 35, 35, 21, 7, 1]<br>[1, 8, 28, 56, 70, 56, 28, 8, 1]<br>[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</p>\n</blockquote>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1768,"excerpt":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>杨辉三角形，也称帕斯卡三角，其定义为：<br>顶端是1，视为(row0).<br>第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).<br>以此类推<br>第2行(row2)：0+1=1; 1+1=2; 1+0=1.<br>第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.</p>\n</blockquote>","more":"<p>根据上述方法可产生杨辉三角。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0              1                     </span><br><span class=\"line\">n &#x3D; 1            1   1                   </span><br><span class=\"line\">n &#x3D; 2          1   2   1                 </span><br><span class=\"line\">n &#x3D; 3        1   3   3   1               </span><br><span class=\"line\">n &#x3D; 4      1   4   6   4   1             </span><br><span class=\"line\">n &#x3D; 5    1   5   10  10  5   1           </span><br><span class=\"line\">n &#x3D; ...         ...  ...                             </span><br></pre></td></tr></table></figure>\n\n<p>根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 <code>Invalid query</code>。</p>\n<p>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(1, 1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(3,2)</span></span><br><span class=\"line\"><span class=\"string\">    3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;yang_hui(1,4)</span></span><br><span class=\"line\"><span class=\"string\">    Invalid query</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>附加题</strong><br>生成杨辉三角形<br>定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。<br>示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_yh</span>(<span class=\"params\">m</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    generate_yh(3):</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    1 1</span></span><br><span class=\"line\"><span class=\"string\">    1 2 1</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：<code>N &gt; M</code>时，返回的应该是 <code>Invalidquery</code>。还有 <code>n=0</code> 或 <code>n=m</code>     时，返回的值应该为1.<br>要求第(M,N)个数字，可以用递归的方式来求得：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yang_hui(m, n) = yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><p><strong>yang_hui(m,n):</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输出杨辉三角中第m行第n列的数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yang_hui</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n <span class=\"keyword\">and</span> n &gt; m:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"string\">&quot;Invalid query!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> <span class=\"keyword\">or</span> n == m:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> yang_hui(m<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>) + yang_hui(m<span class=\"number\">-1</span>,n)</span><br></pre></td></tr></table></figure>\n\n<p><strong>triangles(m):</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">打印输出杨辉三角</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">triangles</span>(<span class=\"params\">m</span>):</span></span><br><span class=\"line\">    ret = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> m:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> ret</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"built_in\">len</span>(ret)):</span><br><span class=\"line\">            ret[i] = pre[i] + pre[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        ret.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">        pre = ret[:]</span><br><span class=\"line\">        m = m - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>在生成杨辉三角的时候，用到了<strong>生成器(generator)**。generator在执行过程中，遇到<code>yield</code>语句就返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br>**普通函数和generator函数的区别：</strong><br>普通函数调用直接返回结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = <span class=\"built_in\">abs</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>generator函数的“调用”实际返回一个generator对象：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g = fib(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g</span><br><span class=\"line\">&lt;generator <span class=\"built_in\">object</span> fib at <span class=\"number\">0x1022ef498</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>关于generator，可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0\">这里</a>。</p>\n<p><strong>测试</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    print(yang_hui(<span class=\"number\">4</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 打印杨辉三角</span></span><br><span class=\"line\">    triangle = triangles(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> triangle:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>输出结果如下：</p>\n<blockquote>\n<p>1<br>1<br>Invalid query<br>20<br>Invalid query<br>[1]<br>[1, 1]<br>[1, 2, 1]<br>[1, 3, 3, 1]<br>[1, 4, 6, 4, 1]<br>[1, 5, 10, 10, 5, 1]<br>[1, 6, 15, 20, 15, 6, 1]<br>[1, 7, 21, 35, 35, 21, 7, 1]<br>[1, 8, 28, 56, 70, 56, 28, 8, 1]<br>[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</p>\n</blockquote>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】校验文件哈希","date":"2017-06-09T11:18:25.000Z","updated":"2017-06-12T08:22:34.000Z","comments":1,"_content":"\n![hash](/images/imagesource/17-06-09.png )\n\n我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。\n早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。\n\n<!--more-->\n\n## 问题\n\n> 请使用Python写一个小程序，用来计算指定文件的哈希值。\n\n**附加题**\n> 可以指定哈希加密算法，并让程序尽可能简单易用。\n\n## 思路\n\n问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库[【每周一坑】程序员的浪漫](https://feilongjiang.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/),具体用法在之前的文章中也讲过了。\n\n## Python实现\n\n### 计算哈希值的函数\n\n```python\n# 计算哈希值\ndef generate_hash(file):\n    with open(file, 'rb') as f:\n        s = f.read()\n        md5 = hashlib.md5(s).hexdigest()  # 生成MD5\n        sha1 = hashlib.sha1(s).hexdigest()  # 生成SHA1\n        sha256 = hashlib.sha256(s).hexdigest()  # 生成SHA256\n        sha512 = hashlib.sha512(s).hexdigest()  # 生成SHA512\n    return md5, sha1, sha256, sha512\n```\n\n### 可以指定哈希加密算法的函数\n\n```python\n# 计算哈希值\ndef generate_hash_type(file, hash_type):\n     with open(file, 'rb') as f:\n        s = f.read()\n        if hash_type.lower() == 'md5':\n            hash_res = hashlib.md5(s).hexdigest()\n        elif hash_type.lower() == 'sha1':\n            hash_res = hashlib.sha1(s).hexdigest()\n        elif hash_type.lower() == 'sha256':\n            hash_res = hashlib.sha256(s).hexdigest()\n        elif hash_type.lower() == 'sha512':\n            hash_res = hashlib.sha512(s).hexdigest()\n         else:\n            print(\"Hash type error!\")\n            hash_res = \"Type Error\"\n    return hash_type, hash_res\n```\n\n### 测试程序\n\n```python\nif __name__ == '__main__':\n    file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split())\n    md = generate_hash_type(file_path, hash_t)\n    print(md,'\\n')\n    md = generate_hash(file_path)\n    for i in md:\n        print(i)\n```\n\n最后别忘了引入**hashlib**库:\n\n```python\nimport hashlib\n```\n\n还有设置编码格式以防万一\n\n```python\n# -*- coding: utf-8 -*-\n```\n\n## 测试\n\n这里我使用的是[Python官网](https://www.python.org/)下载的*python-3.6.1-amd64.exe*做的测试，官网也给出了它的md5哈希值，方便校验。\n首先是用`generate_hash()`函数，分别生成**md5**,**sha1**,**sha256**和**sha512**的校验码：\n\n```python\n>>> please enter the path of the file:\n>>> 文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe\n```\n\n输出结果为：\n> \n**md5**  \nad69fdacde90f2ce8286c279b11ca188\n**sha1**  \nbf54252c4065b20f4a111cc39cf5215fb1edccff  \n**sha256**  \n591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8\n**sha512**  \nf0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7\nb9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873\n\n然后是输入路径+指定加密算法：\n\n```python\n>>> please enter the path of the file and hash type:\n>>> C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe md5\n```\n\n输出结果为：\n> ('md5', 'ad69fdacde90f2ce8286c279b11ca188')\n\n再来看看官网给出的md5：\n> ad69fdacde90f2ce8286c279b11ca188\n\n和程序计算的结果一致。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】校验文件哈希.md","raw":"---\ntitle: 【每周一坑】校验文件哈希\ndate: 2017-06-09 19:18:25\nupdated: 2017-06-12 16:22:34\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![hash](/images/imagesource/17-06-09.png )\n\n我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。\n早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。\n\n<!--more-->\n\n## 问题\n\n> 请使用Python写一个小程序，用来计算指定文件的哈希值。\n\n**附加题**\n> 可以指定哈希加密算法，并让程序尽可能简单易用。\n\n## 思路\n\n问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库[【每周一坑】程序员的浪漫](https://feilongjiang.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/),具体用法在之前的文章中也讲过了。\n\n## Python实现\n\n### 计算哈希值的函数\n\n```python\n# 计算哈希值\ndef generate_hash(file):\n    with open(file, 'rb') as f:\n        s = f.read()\n        md5 = hashlib.md5(s).hexdigest()  # 生成MD5\n        sha1 = hashlib.sha1(s).hexdigest()  # 生成SHA1\n        sha256 = hashlib.sha256(s).hexdigest()  # 生成SHA256\n        sha512 = hashlib.sha512(s).hexdigest()  # 生成SHA512\n    return md5, sha1, sha256, sha512\n```\n\n### 可以指定哈希加密算法的函数\n\n```python\n# 计算哈希值\ndef generate_hash_type(file, hash_type):\n     with open(file, 'rb') as f:\n        s = f.read()\n        if hash_type.lower() == 'md5':\n            hash_res = hashlib.md5(s).hexdigest()\n        elif hash_type.lower() == 'sha1':\n            hash_res = hashlib.sha1(s).hexdigest()\n        elif hash_type.lower() == 'sha256':\n            hash_res = hashlib.sha256(s).hexdigest()\n        elif hash_type.lower() == 'sha512':\n            hash_res = hashlib.sha512(s).hexdigest()\n         else:\n            print(\"Hash type error!\")\n            hash_res = \"Type Error\"\n    return hash_type, hash_res\n```\n\n### 测试程序\n\n```python\nif __name__ == '__main__':\n    file_path, hash_t = map(str, input('Please enter the path of the file and hash type:').split())\n    md = generate_hash_type(file_path, hash_t)\n    print(md,'\\n')\n    md = generate_hash(file_path)\n    for i in md:\n        print(i)\n```\n\n最后别忘了引入**hashlib**库:\n\n```python\nimport hashlib\n```\n\n还有设置编码格式以防万一\n\n```python\n# -*- coding: utf-8 -*-\n```\n\n## 测试\n\n这里我使用的是[Python官网](https://www.python.org/)下载的*python-3.6.1-amd64.exe*做的测试，官网也给出了它的md5哈希值，方便校验。\n首先是用`generate_hash()`函数，分别生成**md5**,**sha1**,**sha256**和**sha512**的校验码：\n\n```python\n>>> please enter the path of the file:\n>>> 文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe\n```\n\n输出结果为：\n> \n**md5**  \nad69fdacde90f2ce8286c279b11ca188\n**sha1**  \nbf54252c4065b20f4a111cc39cf5215fb1edccff  \n**sha256**  \n591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8\n**sha512**  \nf0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7\nb9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873\n\n然后是输入路径+指定加密算法：\n\n```python\n>>> please enter the path of the file and hash type:\n>>> C:\\Users\\Freed\\Downloads\\python-3.6.1-amd64.exe md5\n```\n\n输出结果为：\n> ('md5', 'ad69fdacde90f2ce8286c279b11ca188')\n\n再来看看官网给出的md5：\n> ad69fdacde90f2ce8286c279b11ca188\n\n和程序计算的结果一致。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】校验文件哈希","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiv001mw8vo240s4etn","content":"<p><img data-src=\"/images/imagesource/17-06-09.png\" alt=\"hash\"></p>\n<p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>可以指定哈希加密算法，并让程序尽可能简单易用。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href=\"https://feilongjiang.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/\">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><h3 id=\"计算哈希值的函数\"><a href=\"#计算哈希值的函数\" class=\"headerlink\" title=\"计算哈希值的函数\"></a>计算哈希值的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算哈希值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash</span>(<span class=\"params\">file</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        s = f.read()</span><br><span class=\"line\">        md5 = hashlib.md5(s).hexdigest()  <span class=\"comment\"># 生成MD5</span></span><br><span class=\"line\">        sha1 = hashlib.sha1(s).hexdigest()  <span class=\"comment\"># 生成SHA1</span></span><br><span class=\"line\">        sha256 = hashlib.sha256(s).hexdigest()  <span class=\"comment\"># 生成SHA256</span></span><br><span class=\"line\">        sha512 = hashlib.sha512(s).hexdigest()  <span class=\"comment\"># 生成SHA512</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> md5, sha1, sha256, sha512</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可以指定哈希加密算法的函数\"><a href=\"#可以指定哈希加密算法的函数\" class=\"headerlink\" title=\"可以指定哈希加密算法的函数\"></a>可以指定哈希加密算法的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算哈希值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash_type</span>(<span class=\"params\">file, hash_type</span>):</span></span><br><span class=\"line\">     <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        s = f.read()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hash_type.lower() == <span class=\"string\">&#x27;md5&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.md5(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha1&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha1(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha256&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha256(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha512&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha512(s).hexdigest()</span><br><span class=\"line\">         <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&quot;Hash type error!&quot;</span>)</span><br><span class=\"line\">            hash_res = <span class=\"string\">&quot;Type Error&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash_type, hash_res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    file_path, hash_t = <span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;Please enter the path of the file and hash type:&#x27;</span>).split())</span><br><span class=\"line\">    md = generate_hash_type(file_path, hash_t)</span><br><span class=\"line\">    print(md,<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    md = generate_hash(file_path)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> md:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure>\n\n<p>最后别忘了引入<strong>hashlib</strong>库:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br></pre></td></tr></table></figure>\n\n<p>还有设置编码格式以防万一</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这里我使用的是<a href=\"https://www.python.org/\">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<blockquote>\n</blockquote>\n<p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p>\n<p>然后是输入路径+指定加密算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file <span class=\"keyword\">and</span> <span class=\"built_in\">hash</span> <span class=\"built_in\">type</span>:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe md5</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<blockquote>\n<p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p>\n</blockquote>\n<p>再来看看官网给出的md5：</p>\n<blockquote>\n<p>ad69fdacde90f2ce8286c279b11ca188</p>\n</blockquote>\n<p>和程序计算的结果一致。</p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":2150,"excerpt":"<p><img data-src=\"/images/imagesource/17-06-09.png\" alt=\"hash\"></p>\n<p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>可以指定哈希加密算法，并让程序尽可能简单易用。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href=\"https://feilongjiang.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/\">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><h3 id=\"计算哈希值的函数\"><a href=\"#计算哈希值的函数\" class=\"headerlink\" title=\"计算哈希值的函数\"></a>计算哈希值的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算哈希值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash</span>(<span class=\"params\">file</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        s = f.read()</span><br><span class=\"line\">        md5 = hashlib.md5(s).hexdigest()  <span class=\"comment\"># 生成MD5</span></span><br><span class=\"line\">        sha1 = hashlib.sha1(s).hexdigest()  <span class=\"comment\"># 生成SHA1</span></span><br><span class=\"line\">        sha256 = hashlib.sha256(s).hexdigest()  <span class=\"comment\"># 生成SHA256</span></span><br><span class=\"line\">        sha512 = hashlib.sha512(s).hexdigest()  <span class=\"comment\"># 生成SHA512</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> md5, sha1, sha256, sha512</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可以指定哈希加密算法的函数\"><a href=\"#可以指定哈希加密算法的函数\" class=\"headerlink\" title=\"可以指定哈希加密算法的函数\"></a>可以指定哈希加密算法的函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计算哈希值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate_hash_type</span>(<span class=\"params\">file, hash_type</span>):</span></span><br><span class=\"line\">     <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        s = f.read()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hash_type.lower() == <span class=\"string\">&#x27;md5&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.md5(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha1&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha1(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha256&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha256(s).hexdigest()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hash_type.lower() == <span class=\"string\">&#x27;sha512&#x27;</span>:</span><br><span class=\"line\">            hash_res = hashlib.sha512(s).hexdigest()</span><br><span class=\"line\">         <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&quot;Hash type error!&quot;</span>)</span><br><span class=\"line\">            hash_res = <span class=\"string\">&quot;Type Error&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash_type, hash_res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    file_path, hash_t = <span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;Please enter the path of the file and hash type:&#x27;</span>).split())</span><br><span class=\"line\">    md = generate_hash_type(file_path, hash_t)</span><br><span class=\"line\">    print(md,<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    md = generate_hash(file_path)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> md:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure>\n\n<p>最后别忘了引入<strong>hashlib</strong>库:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br></pre></td></tr></table></figure>\n\n<p>还有设置编码格式以防万一</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这里我使用的是<a href=\"https://www.python.org/\">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>文件路径，我这里是 C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<blockquote>\n</blockquote>\n<p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p>\n<p>然后是输入路径+指定加密算法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>please enter the path of the file <span class=\"keyword\">and</span> <span class=\"built_in\">hash</span> <span class=\"built_in\">type</span>:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>C:\\Users\\Freed\\Downloads\\python<span class=\"number\">-3.6</span><span class=\"number\">.1</span>-amd64.exe md5</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<blockquote>\n<p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p>\n</blockquote>\n<p>再来看看官网给出的md5：</p>\n<blockquote>\n<p>ad69fdacde90f2ce8286c279b11ca188</p>\n</blockquote>\n<p>和程序计算的结果一致。</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】求乘积最大","date":"2017-05-03T13:58:01.000Z","updated":"2017-08-04T10:52:22.000Z","comments":1,"_content":"\n本周题目：\n> 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值\n\n示例：\n```python\ndef product(num):\n    '''\n    >>>product(312)\n    62\n    >>>product(1234)\n    492\n    >>>product(12345)\n    6170\n    >>>product(123456)\n    74070\n    '''\n```\n<!--more-->\n\n## 思路\n\n从头到尾遍历这个数字串，\n1. 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果\n2. 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果\n3. 以此类推...\n直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。\n\n可以将每一步求出的值存入初始值为0的`max_num`中，每次求出的值都与`max_num`比较，若大于`max_num`，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。\n\n\n## Python实现\n\n```python\n# coding: utf-8\ndef product(num):\n    i = 1               \n    max_num = 0\n    while i != len(str(num)):\n        num1 = int(str(num)[:i])\n        num2 = int(str(num)[i:])\n        result = num1 * num2\n        # result = int(str(num)[:i]) * int(str(num)[i:])\n        if result > max_num:\n            max_num = result\n        i += 1\n    return max_num\n\n# 测试\nprint(product(312))\nprint(product(1234))\nprint(product(12345))\nprint(product(123456))\n```\n\n## 输出结果\n结果为：\n> 62\n492\n6170\n74070\n\n结果与示例相符合\n\n## 附加题\n\n上述的题目感觉还是比较简单的，因此多了一个附加题：\n> 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。\n\n示例：\n```python\ndef product_2(num):\n  '''\n  >>>product_2(1234)\n  1312\n  >>>product_2(12345)\n  22412\n  >>>product_2(123456)\n  342002\n  '''\n```\n\n## 思路\n\n可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：[**itertools**](https://docs.python.org/3.6/library/itertools.html#module-itertools)。\n它属于Python标准库，今天用到的是[**permutations()**](https://docs.python.org/3.6/library/itertools.html#itertools.permutations)这个函数：\n> permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同\n返回p中任意取r个元素做排列的元组的迭代器\n\n例如：\n> permutations('ABCD', 2)\n\n返回的结果为：\n> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD\n\n有了这个函数，我们就可以完成附加题了\n\n## Python实现\n```python\n# coding: utf-8\nfrom itertools import permutations\n\n\ndef product_2(num):\n    i = 1\n    max_num = 0\n    for p in permutations(str(num)):\n        new_num = \"\".join(p)            # 排列后返回的是一个元组，通过join()来重新生成数字串\n        # print(new_num)\n        result = product(new_num)       # 就是上面的product()\n        if result > max_num:\n            max_num = result\n    return max_num\n    \n\n# 测试\nprint(product_2(1234))\nprint(product_2(12345))\nprint(product_2(123456))\n```\n## 输出结果\n结果为：\n>1312\n22412\n342002\n\n与示例一致\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】求乘积最大.md","raw":"---\ntitle: 【每周一坑】求乘积最大\ndate: 2017-05-03 21:58:01\nupdated: 2017-08-04 18:52:22\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本周题目：\n> 设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值\n\n示例：\n```python\ndef product(num):\n    '''\n    >>>product(312)\n    62\n    >>>product(1234)\n    492\n    >>>product(12345)\n    6170\n    >>>product(123456)\n    74070\n    '''\n```\n<!--more-->\n\n## 思路\n\n从头到尾遍历这个数字串，\n1. 先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果\n2. 然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果\n3. 以此类推...\n直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。\n\n可以将每一步求出的值存入初始值为0的`max_num`中，每次求出的值都与`max_num`比较，若大于`max_num`，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。\n\n\n## Python实现\n\n```python\n# coding: utf-8\ndef product(num):\n    i = 1               \n    max_num = 0\n    while i != len(str(num)):\n        num1 = int(str(num)[:i])\n        num2 = int(str(num)[i:])\n        result = num1 * num2\n        # result = int(str(num)[:i]) * int(str(num)[i:])\n        if result > max_num:\n            max_num = result\n        i += 1\n    return max_num\n\n# 测试\nprint(product(312))\nprint(product(1234))\nprint(product(12345))\nprint(product(123456))\n```\n\n## 输出结果\n结果为：\n> 62\n492\n6170\n74070\n\n结果与示例相符合\n\n## 附加题\n\n上述的题目感觉还是比较简单的，因此多了一个附加题：\n> 输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。\n\n示例：\n```python\ndef product_2(num):\n  '''\n  >>>product_2(1234)\n  1312\n  >>>product_2(12345)\n  22412\n  >>>product_2(123456)\n  342002\n  '''\n```\n\n## 思路\n\n可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：[**itertools**](https://docs.python.org/3.6/library/itertools.html#module-itertools)。\n它属于Python标准库，今天用到的是[**permutations()**](https://docs.python.org/3.6/library/itertools.html#itertools.permutations)这个函数：\n> permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同\n返回p中任意取r个元素做排列的元组的迭代器\n\n例如：\n> permutations('ABCD', 2)\n\n返回的结果为：\n> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD\n\n有了这个函数，我们就可以完成附加题了\n\n## Python实现\n```python\n# coding: utf-8\nfrom itertools import permutations\n\n\ndef product_2(num):\n    i = 1\n    max_num = 0\n    for p in permutations(str(num)):\n        new_num = \"\".join(p)            # 排列后返回的是一个元组，通过join()来重新生成数字串\n        # print(new_num)\n        result = product(new_num)       # 就是上面的product()\n        if result > max_num:\n            max_num = result\n    return max_num\n    \n\n# 测试\nprint(product_2(1234))\nprint(product_2(12345))\nprint(product_2(123456))\n```\n## 输出结果\n结果为：\n>1312\n22412\n342002\n\n与示例一致\n\nEnd~\n\n---\n\n","slug":"【每周一坑】求乘积最大","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiv001pw8vobzp1gpy6","content":"<p>本周题目：</p>\n<blockquote>\n<p>设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(312)</span></span><br><span class=\"line\"><span class=\"string\">    62</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(1234)</span></span><br><span class=\"line\"><span class=\"string\">    492</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(12345)</span></span><br><span class=\"line\"><span class=\"string\">    6170</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(123456)</span></span><br><span class=\"line\"><span class=\"string\">    74070</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>从头到尾遍历这个数字串，</p>\n<ol>\n<li>先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果</li>\n<li>然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果</li>\n<li>以此类推…<br>直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。</li>\n</ol>\n<p>可以将每一步求出的值存入初始值为0的<code>max_num</code>中，每次求出的值都与<code>max_num</code>比较，若大于<code>max_num</code>，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span>               </span><br><span class=\"line\">    max_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i != <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(num)):</span><br><span class=\"line\">        num1 = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(num)[:i])</span><br><span class=\"line\">        num2 = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(num)[i:])</span><br><span class=\"line\">        result = num1 * num2</span><br><span class=\"line\">        <span class=\"comment\"># result = int(str(num)[:i]) * int(str(num)[i:])</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</span><br><span class=\"line\">            max_num = result</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_num</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">print(product(<span class=\"number\">312</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">1234</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">12345</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">123456</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>62<br>492<br>6170<br>74070</p>\n</blockquote>\n<p>结果与示例相符合</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><p>上述的题目感觉还是比较简单的，因此多了一个附加题：</p>\n<blockquote>\n<p>输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(1234)</span></span><br><span class=\"line\"><span class=\"string\">  1312</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(12345)</span></span><br><span class=\"line\"><span class=\"string\">  22412</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(123456)</span></span><br><span class=\"line\"><span class=\"string\">  342002</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：<a href=\"https://docs.python.org/3.6/library/itertools.html#module-itertools\"><strong>itertools</strong></a>。<br>它属于Python标准库，今天用到的是<a href=\"https://docs.python.org/3.6/library/itertools.html#itertools.permutations\"><strong>permutations()</strong></a>这个函数：</p>\n<blockquote>\n<p>permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同<br>返回p中任意取r个元素做排列的元组的迭代器</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>permutations(‘ABCD’, 2)</p>\n</blockquote>\n<p>返回的结果为：</p>\n<blockquote>\n<p>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</p>\n</blockquote>\n<p>有了这个函数，我们就可以完成附加题了</p>\n<h2 id=\"Python实现-1\"><a href=\"#Python实现-1\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    max_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> permutations(<span class=\"built_in\">str</span>(num)):</span><br><span class=\"line\">        new_num = <span class=\"string\">&quot;&quot;</span>.join(p)            <span class=\"comment\"># 排列后返回的是一个元组，通过join()来重新生成数字串</span></span><br><span class=\"line\">        <span class=\"comment\"># print(new_num)</span></span><br><span class=\"line\">        result = product(new_num)       <span class=\"comment\"># 就是上面的product()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</span><br><span class=\"line\">            max_num = result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_num</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">print(product_2(<span class=\"number\">1234</span>))</span><br><span class=\"line\">print(product_2(<span class=\"number\">12345</span>))</span><br><span class=\"line\">print(product_2(<span class=\"number\">123456</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出结果-1\"><a href=\"#输出结果-1\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>1312<br>22412<br>342002</p>\n</blockquote>\n<p>与示例一致</p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1810,"excerpt":"<p>本周题目：</p>\n<blockquote>\n<p>设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(312)</span></span><br><span class=\"line\"><span class=\"string\">    62</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(1234)</span></span><br><span class=\"line\"><span class=\"string\">    492</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(12345)</span></span><br><span class=\"line\"><span class=\"string\">    6170</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt;product(123456)</span></span><br><span class=\"line\"><span class=\"string\">    74070</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>从头到尾遍历这个数字串，</p>\n<ol>\n<li>先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果</li>\n<li>然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果</li>\n<li>以此类推…<br>直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。</li>\n</ol>\n<p>可以将每一步求出的值存入初始值为0的<code>max_num</code>中，每次求出的值都与<code>max_num</code>比较，若大于<code>max_num</code>，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span>               </span><br><span class=\"line\">    max_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i != <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(num)):</span><br><span class=\"line\">        num1 = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(num)[:i])</span><br><span class=\"line\">        num2 = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(num)[i:])</span><br><span class=\"line\">        result = num1 * num2</span><br><span class=\"line\">        <span class=\"comment\"># result = int(str(num)[:i]) * int(str(num)[i:])</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</span><br><span class=\"line\">            max_num = result</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_num</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">print(product(<span class=\"number\">312</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">1234</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">12345</span>))</span><br><span class=\"line\">print(product(<span class=\"number\">123456</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>62<br>492<br>6170<br>74070</p>\n</blockquote>\n<p>结果与示例相符合</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><p>上述的题目感觉还是比较简单的，因此多了一个附加题：</p>\n<blockquote>\n<p>输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(1234)</span></span><br><span class=\"line\"><span class=\"string\">  1312</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(12345)</span></span><br><span class=\"line\"><span class=\"string\">  22412</span></span><br><span class=\"line\"><span class=\"string\">  &gt;&gt;&gt;product_2(123456)</span></span><br><span class=\"line\"><span class=\"string\">  342002</span></span><br><span class=\"line\"><span class=\"string\">  &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：<a href=\"https://docs.python.org/3.6/library/itertools.html#module-itertools\"><strong>itertools</strong></a>。<br>它属于Python标准库，今天用到的是<a href=\"https://docs.python.org/3.6/library/itertools.html#itertools.permutations\"><strong>permutations()</strong></a>这个函数：</p>\n<blockquote>\n<p>permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同<br>返回p中任意取r个元素做排列的元组的迭代器</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>permutations(‘ABCD’, 2)</p>\n</blockquote>\n<p>返回的结果为：</p>\n<blockquote>\n<p>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</p>\n</blockquote>\n<p>有了这个函数，我们就可以完成附加题了</p>\n<h2 id=\"Python实现-1\"><a href=\"#Python实现-1\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">product_2</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    max_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> permutations(<span class=\"built_in\">str</span>(num)):</span><br><span class=\"line\">        new_num = <span class=\"string\">&quot;&quot;</span>.join(p)            <span class=\"comment\"># 排列后返回的是一个元组，通过join()来重新生成数字串</span></span><br><span class=\"line\">        <span class=\"comment\"># print(new_num)</span></span><br><span class=\"line\">        result = product(new_num)       <span class=\"comment\"># 就是上面的product()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result &gt; max_num:</span><br><span class=\"line\">            max_num = result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_num</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">print(product_2(<span class=\"number\">1234</span>))</span><br><span class=\"line\">print(product_2(<span class=\"number\">12345</span>))</span><br><span class=\"line\">print(product_2(<span class=\"number\">123456</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出结果-1\"><a href=\"#输出结果-1\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>结果为：</p>\n<blockquote>\n<p>1312<br>22412<br>342002</p>\n</blockquote>\n<p>与示例一致</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】注册表单验证","date":"2017-10-13T07:01:08.000Z","updated":"2017-10-13T07:16:40.000Z","comments":1,"_content":"\n用Python实现类似于网页表单信息验证的功能。\n\n基本要求：\n\n1. 需要输入邮箱地址、密码两项\n2. 邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格\n3. 密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）\n4. 重名验证\n\n<!--more-->\n\n思路：\n通过正则表达式来实现\n\n## 正则表达式\n\n### 正则表达式库\n\nPython中有正则表达式标准库，引入正则表达式库Re即可:\n\n```python\nimport re\n```\n\n由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。\n\n### 正则表达式特殊字符\n\n在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考[正则表达式-菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)。\n\n特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如`*`表示匹配某字符串零次或多次，如果想要匹配`*`，则需要转义，即匹配`\\*`，这样就是匹配`*`这个字符。正则表达式的特殊字符如下表所示：\n\n|特殊字符 | 描述 |\n|:--- |:-----|\n|\\$   |匹配输入字符串的结尾位置 |\n|()   |标记一个子表达式的开始和结束位置|\n|*    |匹配前面的子表达式零次或多次|\n|+    |匹配前面的子表达式一次或多次|\n|.    |匹配除换行符\\n之外的任何单字符|\n|[]   |标记一个中括号表达式的开始和结束位置|\n|?    |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符|\n|\\    |将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符|\n|^    |匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集|\n|{}   |标记限定符表达式的开始|\n|&#124;|指明两项之间的一个选择|\n\n## 验证邮箱\n\n```python\ncheckEmail = re.compile(r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)')\n```\n\n## 验证密码\n\n```python\ncheckPwd = re.compile(r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).{8,}$')\n```\n\n## 重名验证\n\n没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。\n\n```python\n# 打开存储邮箱地址的文档，如果不存在则新建\nif no os.path.exists('./users.txt'):\n    f = open('./users.txt', 'w')\n    f.close()\n    \n# 读取文本中的邮箱地址，存入一个list，后面验证重名时使用\nwith open('./users.txt', 'r') as f:\n    userName = f.readlines()\n\n# 验证重名\ndef check_email(email_address):\n    while not checkEmail.match(email_address):\n        email_address = input('邮箱地址格式不正确，请重新输入: ')\n    if email_address + '\\n' in userName:\n        email_address = input('邮箱地址已注册，请输入其他邮箱: ')\n        check_email(email_address)\n    else:\n        print('邮箱地址可用!')\n    return email_address\n```\n\n## 验证密码是否符合要求\n\n```python\ndef check_pwd(password):\n    while not checkPwd.match(password):\n        print('密码需要8位以上，包含大小写和数字。请重新输入。')\n        password = input('密码: ')\n    return password\n```\n\n\n## 主程序\n\n```python\n# check email address\nemailAdd = input('请输入邮箱地址: ')\nemailAdd = check_email(emailAdd)\nprint('邮箱地址: ', emailAdd)\n\n# check password\npwd = input('密码: ')\npwd = check_pwd(pwd)\n\n# 保存新注册的邮箱\nwith open('./users.txt', 'a') as f:\n    f.write(emailAdd + '\\n')\nprint('注册成功!')\n```\n\n---\n","source":"_posts/【每周一坑】注册表单验证.md","raw":"---\ntitle: 【每周一坑】注册表单验证\ndate: 2017-10-13 15:01:08\nupdated: 2017-10-13 15:16:40\ncategory: Python\ntags: [每周一坑 ,正则表达式]\ncomments: true\n---\n\n用Python实现类似于网页表单信息验证的功能。\n\n基本要求：\n\n1. 需要输入邮箱地址、密码两项\n2. 邮箱地址需要满足形如xxx@xxx.xx的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格\n3. 密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）\n4. 重名验证\n\n<!--more-->\n\n思路：\n通过正则表达式来实现\n\n## 正则表达式\n\n### 正则表达式库\n\nPython中有正则表达式标准库，引入正则表达式库Re即可:\n\n```python\nimport re\n```\n\n由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。\n\n### 正则表达式特殊字符\n\n在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考[正则表达式-菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)。\n\n特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如`*`表示匹配某字符串零次或多次，如果想要匹配`*`，则需要转义，即匹配`\\*`，这样就是匹配`*`这个字符。正则表达式的特殊字符如下表所示：\n\n|特殊字符 | 描述 |\n|:--- |:-----|\n|\\$   |匹配输入字符串的结尾位置 |\n|()   |标记一个子表达式的开始和结束位置|\n|*    |匹配前面的子表达式零次或多次|\n|+    |匹配前面的子表达式一次或多次|\n|.    |匹配除换行符\\n之外的任何单字符|\n|[]   |标记一个中括号表达式的开始和结束位置|\n|?    |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符|\n|\\    |将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符|\n|^    |匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集|\n|{}   |标记限定符表达式的开始|\n|&#124;|指明两项之间的一个选择|\n\n## 验证邮箱\n\n```python\ncheckEmail = re.compile(r'^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)')\n```\n\n## 验证密码\n\n```python\ncheckPwd = re.compile(r'^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).{8,}$')\n```\n\n## 重名验证\n\n没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。\n\n```python\n# 打开存储邮箱地址的文档，如果不存在则新建\nif no os.path.exists('./users.txt'):\n    f = open('./users.txt', 'w')\n    f.close()\n    \n# 读取文本中的邮箱地址，存入一个list，后面验证重名时使用\nwith open('./users.txt', 'r') as f:\n    userName = f.readlines()\n\n# 验证重名\ndef check_email(email_address):\n    while not checkEmail.match(email_address):\n        email_address = input('邮箱地址格式不正确，请重新输入: ')\n    if email_address + '\\n' in userName:\n        email_address = input('邮箱地址已注册，请输入其他邮箱: ')\n        check_email(email_address)\n    else:\n        print('邮箱地址可用!')\n    return email_address\n```\n\n## 验证密码是否符合要求\n\n```python\ndef check_pwd(password):\n    while not checkPwd.match(password):\n        print('密码需要8位以上，包含大小写和数字。请重新输入。')\n        password = input('密码: ')\n    return password\n```\n\n\n## 主程序\n\n```python\n# check email address\nemailAdd = input('请输入邮箱地址: ')\nemailAdd = check_email(emailAdd)\nprint('邮箱地址: ', emailAdd)\n\n# check password\npwd = input('密码: ')\npwd = check_pwd(pwd)\n\n# 保存新注册的邮箱\nwith open('./users.txt', 'a') as f:\n    f.write(emailAdd + '\\n')\nprint('注册成功!')\n```\n\n---\n","slug":"【每周一坑】注册表单验证","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiw001sw8vo1gtdgbgk","content":"<p>用Python实现类似于网页表单信息验证的功能。</p>\n<p>基本要求：</p>\n<ol>\n<li>需要输入邮箱地址、密码两项</li>\n<li>邮箱地址需要满足形如<a href=\"mailto:&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;\">&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;</a>的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格</li>\n<li>密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）</li>\n<li>重名验证</li>\n</ol>\n<a id=\"more\"></a>\n\n<p>思路：<br>通过正则表达式来实现</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><h3 id=\"正则表达式库\"><a href=\"#正则表达式库\" class=\"headerlink\" title=\"正则表达式库\"></a>正则表达式库</h3><p>Python中有正则表达式标准库，引入正则表达式库Re即可:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\n\n<p>由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。</p>\n<h3 id=\"正则表达式特殊字符\"><a href=\"#正则表达式特殊字符\" class=\"headerlink\" title=\"正则表达式特殊字符\"></a>正则表达式特殊字符</h3><p>在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考<a href=\"http://www.runoob.com/regexp/regexp-tutorial.html\">正则表达式-菜鸟教程</a>。</p>\n<p>特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如<code>*</code>表示匹配某字符串零次或多次，如果想要匹配<code>*</code>，则需要转义，即匹配<code>\\*</code>，这样就是匹配<code>*</code>这个字符。正则表达式的特殊字符如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特殊字符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$</td>\n<td align=\"left\">匹配输入字符串的结尾位置</td>\n</tr>\n<tr>\n<td align=\"left\">()</td>\n<td align=\"left\">标记一个子表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\">匹配前面的子表达式零次或多次</td>\n</tr>\n<tr>\n<td align=\"left\">+</td>\n<td align=\"left\">匹配前面的子表达式一次或多次</td>\n</tr>\n<tr>\n<td align=\"left\">.</td>\n<td align=\"left\">匹配除换行符\\n之外的任何单字符</td>\n</tr>\n<tr>\n<td align=\"left\">[]</td>\n<td align=\"left\">标记一个中括号表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td align=\"left\">?</td>\n<td align=\"left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>\n</tr>\n<tr>\n<td align=\"left\">\\</td>\n<td align=\"left\">将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符</td>\n</tr>\n<tr>\n<td align=\"left\">^</td>\n<td align=\"left\">匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集</td>\n</tr>\n<tr>\n<td align=\"left\">{}</td>\n<td align=\"left\">标记限定符表达式的开始</td>\n</tr>\n<tr>\n<td align=\"left\">&#124;</td>\n<td align=\"left\">指明两项之间的一个选择</td>\n</tr>\n</tbody></table>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkEmail = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证密码\"><a href=\"#验证密码\" class=\"headerlink\" title=\"验证密码\"></a>验证密码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkPwd = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重名验证\"><a href=\"#重名验证\" class=\"headerlink\" title=\"重名验证\"></a>重名验证</h2><p>没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打开存储邮箱地址的文档，如果不存在则新建</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> no os.path.exists(<span class=\"string\">&#x27;./users.txt&#x27;</span>):</span><br><span class=\"line\">    f = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 读取文本中的邮箱地址，存入一个list，后面验证重名时使用</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    userName = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证重名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_email</span>(<span class=\"params\">email_address</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkEmail.match(email_address):</span><br><span class=\"line\">        email_address = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;邮箱地址格式不正确，请重新输入: &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> email_address + <span class=\"string\">&#x27;\\n&#x27;</span> <span class=\"keyword\">in</span> userName:</span><br><span class=\"line\">        email_address = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;邮箱地址已注册，请输入其他邮箱: &#x27;</span>)</span><br><span class=\"line\">        check_email(email_address)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;邮箱地址可用!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> email_address</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证密码是否符合要求\"><a href=\"#验证密码是否符合要求\" class=\"headerlink\" title=\"验证密码是否符合要求\"></a>验证密码是否符合要求</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_pwd</span>(<span class=\"params\">password</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkPwd.match(password):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;密码需要8位以上，包含大小写和数字。请重新输入。&#x27;</span>)</span><br><span class=\"line\">        password = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;密码: &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> password</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># check email address</span></span><br><span class=\"line\">emailAdd = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入邮箱地址: &#x27;</span>)</span><br><span class=\"line\">emailAdd = check_email(emailAdd)</span><br><span class=\"line\">print(<span class=\"string\">&#x27;邮箱地址: &#x27;</span>, emailAdd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># check password</span></span><br><span class=\"line\">pwd = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;密码: &#x27;</span>)</span><br><span class=\"line\">pwd = check_pwd(pwd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存新注册的邮箱</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(emailAdd + <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">print(<span class=\"string\">&#x27;注册成功!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"length":1959,"excerpt":"<p>用Python实现类似于网页表单信息验证的功能。</p>\n<p>基本要求：</p>\n<ol>\n<li>需要输入邮箱地址、密码两项</li>\n<li>邮箱地址需要满足形如<a href=\"mailto:&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;\">&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x78;&#120;</a>的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格</li>\n<li>密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）</li>\n<li>重名验证</li>\n</ol>","more":"<p>思路：<br>通过正则表达式来实现</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><h3 id=\"正则表达式库\"><a href=\"#正则表达式库\" class=\"headerlink\" title=\"正则表达式库\"></a>正则表达式库</h3><p>Python中有正则表达式标准库，引入正则表达式库Re即可:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\n\n<p>由于Python的字符串本身也用\\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。</p>\n<h3 id=\"正则表达式特殊字符\"><a href=\"#正则表达式特殊字符\" class=\"headerlink\" title=\"正则表达式特殊字符\"></a>正则表达式特殊字符</h3><p>在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考<a href=\"http://www.runoob.com/regexp/regexp-tutorial.html\">正则表达式-菜鸟教程</a>。</p>\n<p>特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如<code>*</code>表示匹配某字符串零次或多次，如果想要匹配<code>*</code>，则需要转义，即匹配<code>\\*</code>，这样就是匹配<code>*</code>这个字符。正则表达式的特殊字符如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特殊字符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$</td>\n<td align=\"left\">匹配输入字符串的结尾位置</td>\n</tr>\n<tr>\n<td align=\"left\">()</td>\n<td align=\"left\">标记一个子表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\">匹配前面的子表达式零次或多次</td>\n</tr>\n<tr>\n<td align=\"left\">+</td>\n<td align=\"left\">匹配前面的子表达式一次或多次</td>\n</tr>\n<tr>\n<td align=\"left\">.</td>\n<td align=\"left\">匹配除换行符\\n之外的任何单字符</td>\n</tr>\n<tr>\n<td align=\"left\">[]</td>\n<td align=\"left\">标记一个中括号表达式的开始和结束位置</td>\n</tr>\n<tr>\n<td align=\"left\">?</td>\n<td align=\"left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>\n</tr>\n<tr>\n<td align=\"left\">\\</td>\n<td align=\"left\">将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符</td>\n</tr>\n<tr>\n<td align=\"left\">^</td>\n<td align=\"left\">匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集</td>\n</tr>\n<tr>\n<td align=\"left\">{}</td>\n<td align=\"left\">标记限定符表达式的开始</td>\n</tr>\n<tr>\n<td align=\"left\">&#124;</td>\n<td align=\"left\">指明两项之间的一个选择</td>\n</tr>\n</tbody></table>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkEmail = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;^(\\w+_?-?\\.?\\w*)@([\\w+\\.]+[a-zA-Z]+$)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证密码\"><a href=\"#验证密码\" class=\"headerlink\" title=\"验证密码\"></a>验证密码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkPwd = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重名验证\"><a href=\"#重名验证\" class=\"headerlink\" title=\"重名验证\"></a>重名验证</h2><p>没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打开存储邮箱地址的文档，如果不存在则新建</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> no os.path.exists(<span class=\"string\">&#x27;./users.txt&#x27;</span>):</span><br><span class=\"line\">    f = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 读取文本中的邮箱地址，存入一个list，后面验证重名时使用</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    userName = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证重名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_email</span>(<span class=\"params\">email_address</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkEmail.match(email_address):</span><br><span class=\"line\">        email_address = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;邮箱地址格式不正确，请重新输入: &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> email_address + <span class=\"string\">&#x27;\\n&#x27;</span> <span class=\"keyword\">in</span> userName:</span><br><span class=\"line\">        email_address = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;邮箱地址已注册，请输入其他邮箱: &#x27;</span>)</span><br><span class=\"line\">        check_email(email_address)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;邮箱地址可用!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> email_address</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证密码是否符合要求\"><a href=\"#验证密码是否符合要求\" class=\"headerlink\" title=\"验证密码是否符合要求\"></a>验证密码是否符合要求</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_pwd</span>(<span class=\"params\">password</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> checkPwd.match(password):</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;密码需要8位以上，包含大小写和数字。请重新输入。&#x27;</span>)</span><br><span class=\"line\">        password = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;密码: &#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> password</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># check email address</span></span><br><span class=\"line\">emailAdd = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入邮箱地址: &#x27;</span>)</span><br><span class=\"line\">emailAdd = check_email(emailAdd)</span><br><span class=\"line\">print(<span class=\"string\">&#x27;邮箱地址: &#x27;</span>, emailAdd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># check password</span></span><br><span class=\"line\">pwd = <span class=\"built_in\">input</span>(<span class=\"string\">&#x27;密码: &#x27;</span>)</span><br><span class=\"line\">pwd = check_pwd(pwd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存新注册的邮箱</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./users.txt&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(emailAdd + <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">print(<span class=\"string\">&#x27;注册成功!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>"},{"title":"【每周一坑】矩阵旋转","date":"2017-09-06T11:46:37.000Z","updated":"2017-09-06T11:55:05.000Z","comments":1,"_content":"\n本次的题目是关于矩阵旋转的\n<!--more-->\n\n## 问题\n\n> 给定一个N*N的矩阵(N>=0)，将其顺时针旋转90°。输出旋转后的矩阵。\n举例：\n1 2 3\n4 5 6\n7 8 9\n旋转后输出的结果应该是：\n7 4 1\n8 5 2\n9 6 3\n\n## 附加要求\n\n> 在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。\n\n## 解法\n\n### 1. 使用额外的空间\n\n顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。\n> 如： \n1 2 3\n4 5 6\n7 8 9\n取出每一列作为新的行：\n1 4 7\n2 5 8\n3 6 9\n再将每一行反转就得到了：\n7 4 1\n8 5 2\n9 6 3\n\n代码如下：\n\n```python\ndef rotate(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: List(List(int))\n    \"\"\"\n    res = []\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix[0])):\n        l = []\n        for subList in matrix:\n            l.append(subList[i])\n        l.reverse()\n        res.append(l)\n    return res\n```\n\n### 2. 在原矩阵上进行操作\n\n旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 ([原博客][1])\n\n代码如下：\n\n```python\n'''\n将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照\n对角线对称交换以后再进行反转后得到的\n'''\ndef rotate1(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: matrix\n    \"\"\"\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix)):\n        j = i + 1\n        while j < len(matrix[0]):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            j += 1\n    for i in range(len(matrix)):\n        # print(matrix[i])\n        matrix[i].reverse()\n        # print(matrix[i])\n    # matrix.reverse()\n    # print(matrix)\n    return matrix\n```\n\n[1]: http://blog.csdn.net/lion19930924/article/details/51661248\n\n## 参考资料\n\n[CSDN Blog -- 二维数组旋转90度(by @lynne233)](http://blog.csdn.net/lion19930924/article/details/51661248)\n\nEnd~\n\n---\n","source":"_posts/【每周一坑】矩阵旋转.md","raw":"---\ntitle: 【每周一坑】矩阵旋转\ndate: 2017-09-06 19:46:37\nupdated: 2017-09-06 19:55:05\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本次的题目是关于矩阵旋转的\n<!--more-->\n\n## 问题\n\n> 给定一个N*N的矩阵(N>=0)，将其顺时针旋转90°。输出旋转后的矩阵。\n举例：\n1 2 3\n4 5 6\n7 8 9\n旋转后输出的结果应该是：\n7 4 1\n8 5 2\n9 6 3\n\n## 附加要求\n\n> 在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。\n\n## 解法\n\n### 1. 使用额外的空间\n\n顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。\n> 如： \n1 2 3\n4 5 6\n7 8 9\n取出每一列作为新的行：\n1 4 7\n2 5 8\n3 6 9\n再将每一行反转就得到了：\n7 4 1\n8 5 2\n9 6 3\n\n代码如下：\n\n```python\ndef rotate(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: List(List(int))\n    \"\"\"\n    res = []\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix[0])):\n        l = []\n        for subList in matrix:\n            l.append(subList[i])\n        l.reverse()\n        res.append(l)\n    return res\n```\n\n### 2. 在原矩阵上进行操作\n\n旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 ([原博客][1])\n\n代码如下：\n\n```python\n'''\n将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照\n对角线对称交换以后再进行反转后得到的\n'''\ndef rotate1(matrix):\n    \"\"\"\n    :param matrix: List(List(int))\n    :return: matrix\n    \"\"\"\n    if len(matrix[0]) == 0:\n        return matrix\n    for i in range(len(matrix)):\n        j = i + 1\n        while j < len(matrix[0]):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n            j += 1\n    for i in range(len(matrix)):\n        # print(matrix[i])\n        matrix[i].reverse()\n        # print(matrix[i])\n    # matrix.reverse()\n    # print(matrix)\n    return matrix\n```\n\n[1]: http://blog.csdn.net/lion19930924/article/details/51661248\n\n## 参考资料\n\n[CSDN Blog -- 二维数组旋转90度(by @lynne233)](http://blog.csdn.net/lion19930924/article/details/51661248)\n\nEnd~\n\n---\n","slug":"【每周一坑】矩阵旋转","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsix001uw8vo6xbz7z8l","content":"<p>本次的题目是关于矩阵旋转的</p>\n<a id=\"more\"></a>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<h2 id=\"附加要求\"><a href=\"#附加要求\" class=\"headerlink\" title=\"附加要求\"></a>附加要求</h2><blockquote>\n<p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p>\n</blockquote>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><h3 id=\"1-使用额外的空间\"><a href=\"#1-使用额外的空间\" class=\"headerlink\" title=\"1. 使用额外的空间\"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p>\n<blockquote>\n<p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span>(<span class=\"params\">matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :param matrix: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    :return: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        l = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> subList <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            l.append(subList[i])</span><br><span class=\"line\">        l.reverse()</span><br><span class=\"line\">        res.append(l)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-在原矩阵上进行操作\"><a href=\"#2-在原矩阵上进行操作\" class=\"headerlink\" title=\"2. 在原矩阵上进行操作\"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">原博客</a>)</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</span></span><br><span class=\"line\"><span class=\"string\">对角线对称交换以后再进行反转后得到的</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate1</span>(<span class=\"params\">matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :param matrix: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    :return: matrix</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        j = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></span><br><span class=\"line\">        matrix[i].reverse()</span><br><span class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></span><br><span class=\"line\">    <span class=\"comment\"># matrix.reverse()</span></span><br><span class=\"line\">    <span class=\"comment\"># print(matrix)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1072,"excerpt":"<p>本次的题目是关于矩阵旋转的</p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<h2 id=\"附加要求\"><a href=\"#附加要求\" class=\"headerlink\" title=\"附加要求\"></a>附加要求</h2><blockquote>\n<p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p>\n</blockquote>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><h3 id=\"1-使用额外的空间\"><a href=\"#1-使用额外的空间\" class=\"headerlink\" title=\"1. 使用额外的空间\"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p>\n<blockquote>\n<p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span>(<span class=\"params\">matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :param matrix: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    :return: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        l = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> subList <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            l.append(subList[i])</span><br><span class=\"line\">        l.reverse()</span><br><span class=\"line\">        res.append(l)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-在原矩阵上进行操作\"><a href=\"#2-在原矩阵上进行操作\" class=\"headerlink\" title=\"2. 在原矩阵上进行操作\"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">原博客</a>)</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</span></span><br><span class=\"line\"><span class=\"string\">对角线对称交换以后再进行反转后得到的</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate1</span>(<span class=\"params\">matrix</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    :param matrix: List(List(int))</span></span><br><span class=\"line\"><span class=\"string\">    :return: matrix</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        j = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>]):</span><br><span class=\"line\">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix)):</span><br><span class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></span><br><span class=\"line\">        matrix[i].reverse()</span><br><span class=\"line\">        <span class=\"comment\"># print(matrix[i])</span></span><br><span class=\"line\">    <span class=\"comment\"># matrix.reverse()</span></span><br><span class=\"line\">    <span class=\"comment\"># print(matrix)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/lion19930924/article/details/51661248\">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】神奇的九宫格","date":"2017-05-15T14:09:03.000Z","updated":"2017-05-26T08:14:58.000Z","comments":1,"_content":"\n本周题目：\n>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。\n\n\n示例：\n```python\ndef Jiugongge():\n    '''\n    >>> Jiugongge()\n    4 9 2\n    3 5 7\n    8 1 6\n    '''\n```\n\n<!--more-->\n\n附加题：\n\n>给定一个正整数 N（N >= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。\n\n比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。\n## 思路\n\n在解决问题之前，要先了解一个东西 —— \"幻方\"。\nWiki上给出的中文定义：\n>**幻方**(Magic Square)，有时又称**魔方**（该称呼现一般指立方体的魔术方块）或**纵横图**，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。\n\n>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M\\_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有\n$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$\n\n$N$阶幻方的解题思路分为三种情况：\n1. $N$为奇数\n2. $N$为4的倍数\n3. $N$为其他偶数\n\n### 1. $N$为奇数\n\n - 将$1$放在第一行中间一列；\n - 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；\n - 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；\n - 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。\n\n### 2. $N$为$4$的倍数\n采用对称元素交换法。首先把数$1$到$n\\*n$按从上至下、从左至又的顺序填入矩阵。\n然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。\n\n### 3. $N$为非$4$的倍数的偶数(即$4n+2$)\n首先把大方阵分解为$4$个奇数字方阵。\n按上述奇数幻方给分解的4个子方阵对应赋值,其中：\n上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$\n即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$\n四个子矩阵由小到大排列方式为\n\n$$\n        \\begin{bmatrix}\n        1 & 3 \\\\\n        4 & 2 \\\\\n        \\end{bmatrix}\n$$\n\n然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中\n$k = n//2，t=(n-2)//4$。\n\n## Python实现\n```python\n# n为奇数\ndef oddN():\n    # 构造二维列表\n    lst = [[0 for i in range(n)] for i in range(n)]\n    # 初始化列表位置\n    x, y = 0, n//2\n    for num in range(1, n*n+1):\n        lst[x][y] = num\n        xa, ya = x-1, y+1\n        # 回绕情况\n        if xa < 0:\n            xa = n-1\n        if ya > n-1:\n            ya = 0\n        # 占位情况\n        if lst[xa][ya] != 0:\n            x = x+1\n            if x > n-1:\n                x = 0\n        else:\n            x, y = xa, ya\n    return lst\n    \n# n为4的倍数\ndef fourN(n):\n    # 初始化列表\n    lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)]\n    # 交换对角线位置\n    for i in range(n//2):\n        lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i]\n        lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i]\n    return lst\n\n# n为非4倍数的偶数\n# 累加子矩阵\ndef acc(p, lst):\n    # print(lst)\n    for row in lst:\n        for index in range(len(row)):\n            row[index] += p\n\n    return lst\n\n\ndef fourNplus2(n):\n    m = n // 2\n    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)\n    B = acc(m ** 2, B)\n    C = acc(m ** 2 * 2, C)\n    D = acc(m ** 2 * 3, D)\n    for row_index in range(len(A)):\n        A[row_index].extend(C[row_index])\n        D[row_index].extend(B[row_index])\n    # 合并子矩阵\n    matrix = A + D\n    t = (n - 2) // 4\n    # 列交换\n    for col_index in range(len(matrix[0])):\n        if col_index < t or col_index > n - t:\n            for row_index in range(len(matrix) // 2):\n                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\\n                    matrix[row_index + m][col_index], matrix[row_index][col_index]\n                # 交换特殊位置\n    matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0]\n    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]\n    return matrix\n```\n\n\nEnd~\n\n---","source":"_posts/【每周一坑】神奇的九宫格.md","raw":"---\ntitle: 【每周一坑】神奇的九宫格\ndate: 2017-05-15 22:09:03\nupdated: 2017-05-26 16:14:58\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n本周题目：\n>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。\n\n\n示例：\n```python\ndef Jiugongge():\n    '''\n    >>> Jiugongge()\n    4 9 2\n    3 5 7\n    8 1 6\n    '''\n```\n\n<!--more-->\n\n附加题：\n\n>给定一个正整数 N（N >= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。\n\n比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。\n## 思路\n\n在解决问题之前，要先了解一个东西 —— \"幻方\"。\nWiki上给出的中文定义：\n>**幻方**(Magic Square)，有时又称**魔方**（该称呼现一般指立方体的魔术方块）或**纵横图**，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。\n\n>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M\\_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有\n$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$\n\n$N$阶幻方的解题思路分为三种情况：\n1. $N$为奇数\n2. $N$为4的倍数\n3. $N$为其他偶数\n\n### 1. $N$为奇数\n\n - 将$1$放在第一行中间一列；\n - 从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；\n - 如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；\n - 如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。\n\n### 2. $N$为$4$的倍数\n采用对称元素交换法。首先把数$1$到$n\\*n$按从上至下、从左至又的顺序填入矩阵。\n然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。\n\n### 3. $N$为非$4$的倍数的偶数(即$4n+2$)\n首先把大方阵分解为$4$个奇数字方阵。\n按上述奇数幻方给分解的4个子方阵对应赋值,其中：\n上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$\n即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$\n四个子矩阵由小到大排列方式为\n\n$$\n        \\begin{bmatrix}\n        1 & 3 \\\\\n        4 & 2 \\\\\n        \\end{bmatrix}\n$$\n\n然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中\n$k = n//2，t=(n-2)//4$。\n\n## Python实现\n```python\n# n为奇数\ndef oddN():\n    # 构造二维列表\n    lst = [[0 for i in range(n)] for i in range(n)]\n    # 初始化列表位置\n    x, y = 0, n//2\n    for num in range(1, n*n+1):\n        lst[x][y] = num\n        xa, ya = x-1, y+1\n        # 回绕情况\n        if xa < 0:\n            xa = n-1\n        if ya > n-1:\n            ya = 0\n        # 占位情况\n        if lst[xa][ya] != 0:\n            x = x+1\n            if x > n-1:\n                x = 0\n        else:\n            x, y = xa, ya\n    return lst\n    \n# n为4的倍数\ndef fourN(n):\n    # 初始化列表\n    lst = [[i+j for i in list(range(1,n*n+1))[::n]] for j in range(n)]\n    # 交换对角线位置\n    for i in range(n//2):\n        lst[i][i],lst[n-1-i][n-1-i] = lst[n-1-i][n-1-i],lst[i][i]\n        lst[i][n-1-i],lst[n-1-i][i] = lst[n-1-i][i],lst[i][n-1-i]\n    return lst\n\n# n为非4倍数的偶数\n# 累加子矩阵\ndef acc(p, lst):\n    # print(lst)\n    for row in lst:\n        for index in range(len(row)):\n            row[index] += p\n\n    return lst\n\n\ndef fourNplus2(n):\n    m = n // 2\n    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)\n    B = acc(m ** 2, B)\n    C = acc(m ** 2 * 2, C)\n    D = acc(m ** 2 * 3, D)\n    for row_index in range(len(A)):\n        A[row_index].extend(C[row_index])\n        D[row_index].extend(B[row_index])\n    # 合并子矩阵\n    matrix = A + D\n    t = (n - 2) // 4\n    # 列交换\n    for col_index in range(len(matrix[0])):\n        if col_index < t or col_index > n - t:\n            for row_index in range(len(matrix) // 2):\n                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\\n                    matrix[row_index + m][col_index], matrix[row_index][col_index]\n                # 交换特殊位置\n    matrix[t][0], matrix[m + t][0] = matrix[m + t][0], matrix[t][0]\n    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]\n    return matrix\n```\n\n\nEnd~\n\n---","slug":"【每周一坑】神奇的九宫格","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiy001xw8vodiowc1li","content":"<p>本周题目：</p>\n<blockquote>\n<p>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Jiugongge</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; Jiugongge()</span></span><br><span class=\"line\"><span class=\"string\">    4 9 2</span></span><br><span class=\"line\"><span class=\"string\">    3 5 7</span></span><br><span class=\"line\"><span class=\"string\">    8 1 6</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>附加题：</p>\n<blockquote>\n<p>给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。</p>\n</blockquote>\n<p>比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>在解决问题之前，要先了解一个东西 —— “幻方”。<br>Wiki上给出的中文定义：</p>\n<blockquote>\n<p><strong>幻方</strong>(Magic Square)，有时又称<strong>魔方</strong>（该称呼现一般指立方体的魔术方块）或<strong>纵横图</strong>，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。</p>\n</blockquote>\n<blockquote>\n<p>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有<br>$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$</p>\n</blockquote>\n<p>$N$阶幻方的解题思路分为三种情况：</p>\n<ol>\n<li>$N$为奇数</li>\n<li>$N$为4的倍数</li>\n<li>$N$为其他偶数</li>\n</ol>\n<h3 id=\"1-N-为奇数\"><a href=\"#1-N-为奇数\" class=\"headerlink\" title=\"1. $N$为奇数\"></a>1. $N$为奇数</h3><ul>\n<li>将$1$放在第一行中间一列；</li>\n<li>从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；</li>\n<li>如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；</li>\n<li>如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。</li>\n</ul>\n<h3 id=\"2-N-为-4-的倍数\"><a href=\"#2-N-为-4-的倍数\" class=\"headerlink\" title=\"2. $N$为$4$的倍数\"></a>2. $N$为$4$的倍数</h3><p>采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。<br>然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。</p>\n<h3 id=\"3-N-为非-4-的倍数的偶数-即-4n-2\"><a href=\"#3-N-为非-4-的倍数的偶数-即-4n-2\" class=\"headerlink\" title=\"3. $N$为非$4$的倍数的偶数(即$4n+2$)\"></a>3. $N$为非$4$的倍数的偶数(即$4n+2$)</h3><p>首先把大方阵分解为$4$个奇数字方阵。<br>按上述奇数幻方给分解的4个子方阵对应赋值,其中：<br>上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$<br>即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$<br>四个子矩阵由小到大排列方式为</p>\n<p>$$<br>        \\begin{bmatrix}<br>        1 &amp; 3 \\<br>        4 &amp; 2 \\<br>        \\end{bmatrix}<br>$$</p>\n<p>然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中<br>$k = n//2，t=(n-2)//4$。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># n为奇数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddN</span>():</span></span><br><span class=\"line\">    <span class=\"comment\"># 构造二维列表</span></span><br><span class=\"line\">    lst = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"comment\"># 初始化列表位置</span></span><br><span class=\"line\">    x, y = <span class=\"number\">0</span>, n//<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n*n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        lst[x][y] = num</span><br><span class=\"line\">        xa, ya = x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 回绕情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> xa &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            xa = n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ya &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            ya = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 占位情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lst[xa][ya] != <span class=\"number\">0</span>:</span><br><span class=\"line\">            x = x+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                x = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            x, y = xa, ya</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># n为4的倍数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourN</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 初始化列表</span></span><br><span class=\"line\">    lst = [[i+j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n*n+<span class=\"number\">1</span>))[::n]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"comment\"># 交换对角线位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">        lst[i][i],lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i] = lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i],lst[i][i]</span><br><span class=\"line\">        lst[i][n<span class=\"number\">-1</span>-i],lst[n<span class=\"number\">-1</span>-i][i] = lst[n<span class=\"number\">-1</span>-i][i],lst[i][n<span class=\"number\">-1</span>-i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># n为非4倍数的偶数</span></span><br><span class=\"line\"><span class=\"comment\"># 累加子矩阵</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">acc</span>(<span class=\"params\">p, lst</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># print(lst)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> lst:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(row)):</span><br><span class=\"line\">            row[index] += p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourNplus2</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    m = n // <span class=\"number\">2</span></span><br><span class=\"line\">    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)</span><br><span class=\"line\">    B = acc(m ** <span class=\"number\">2</span>, B)</span><br><span class=\"line\">    C = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">2</span>, C)</span><br><span class=\"line\">    D = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">3</span>, D)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(A)):</span><br><span class=\"line\">        A[row_index].extend(C[row_index])</span><br><span class=\"line\">        D[row_index].extend(B[row_index])</span><br><span class=\"line\">    <span class=\"comment\"># 合并子矩阵</span></span><br><span class=\"line\">    matrix = A + D</span><br><span class=\"line\">    t = (n - <span class=\"number\">2</span>) // <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"comment\"># 列交换</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> col_index &lt; t <span class=\"keyword\">or</span> col_index &gt; n - t:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix) // <span class=\"number\">2</span>):</span><br><span class=\"line\">                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\</span><br><span class=\"line\">                    matrix[row_index + m][col_index], matrix[row_index][col_index]</span><br><span class=\"line\">                <span class=\"comment\"># 交换特殊位置</span></span><br><span class=\"line\">    matrix[t][<span class=\"number\">0</span>], matrix[m + t][<span class=\"number\">0</span>] = matrix[m + t][<span class=\"number\">0</span>], matrix[t][<span class=\"number\">0</span>]</span><br><span class=\"line\">    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>\n\n\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":2555,"excerpt":"<p>本周题目：</p>\n<blockquote>\n<p>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Jiugongge</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; Jiugongge()</span></span><br><span class=\"line\"><span class=\"string\">    4 9 2</span></span><br><span class=\"line\"><span class=\"string\">    3 5 7</span></span><br><span class=\"line\"><span class=\"string\">    8 1 6</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>","more":"<p>附加题：</p>\n<blockquote>\n<p>给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。</p>\n</blockquote>\n<p>比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>在解决问题之前，要先了解一个东西 —— “幻方”。<br>Wiki上给出的中文定义：</p>\n<blockquote>\n<p><strong>幻方</strong>(Magic Square)，有时又称<strong>魔方</strong>（该称呼现一般指立方体的魔术方块）或<strong>纵横图</strong>，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。</p>\n</blockquote>\n<blockquote>\n<p>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\\dots ,N^{2}$，那么有<br>$$M_{2}(N)={\\frac  {N(N^{2}+1)}{2}}$$</p>\n</blockquote>\n<p>$N$阶幻方的解题思路分为三种情况：</p>\n<ol>\n<li>$N$为奇数</li>\n<li>$N$为4的倍数</li>\n<li>$N$为其他偶数</li>\n</ol>\n<h3 id=\"1-N-为奇数\"><a href=\"#1-N-为奇数\" class=\"headerlink\" title=\"1. $N$为奇数\"></a>1. $N$为奇数</h3><ul>\n<li>将$1$放在第一行中间一列；</li>\n<li>从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；</li>\n<li>如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；</li>\n<li>如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。</li>\n</ul>\n<h3 id=\"2-N-为-4-的倍数\"><a href=\"#2-N-为-4-的倍数\" class=\"headerlink\" title=\"2. $N$为$4$的倍数\"></a>2. $N$为$4$的倍数</h3><p>采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。<br>然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。</p>\n<h3 id=\"3-N-为非-4-的倍数的偶数-即-4n-2\"><a href=\"#3-N-为非-4-的倍数的偶数-即-4n-2\" class=\"headerlink\" title=\"3. $N$为非$4$的倍数的偶数(即$4n+2$)\"></a>3. $N$为非$4$的倍数的偶数(即$4n+2$)</h3><p>首先把大方阵分解为$4$个奇数字方阵。<br>按上述奇数幻方给分解的4个子方阵对应赋值,其中：<br>上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$<br>即$4$个子方阵对应元素相差$v$，其中$v={\\frac {n*n}{4}}$<br>四个子矩阵由小到大排列方式为</p>\n<p>$$<br>        \\begin{bmatrix}<br>        1 &amp; 3 \\<br>        4 &amp; 2 \\<br>        \\end{bmatrix}<br>$$</p>\n<p>然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\\lt t或j\\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中<br>$k = n//2，t=(n-2)//4$。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># n为奇数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddN</span>():</span></span><br><span class=\"line\">    <span class=\"comment\"># 构造二维列表</span></span><br><span class=\"line\">    lst = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"comment\"># 初始化列表位置</span></span><br><span class=\"line\">    x, y = <span class=\"number\">0</span>, n//<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n*n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        lst[x][y] = num</span><br><span class=\"line\">        xa, ya = x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 回绕情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> xa &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            xa = n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ya &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            ya = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 占位情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lst[xa][ya] != <span class=\"number\">0</span>:</span><br><span class=\"line\">            x = x+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                x = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            x, y = xa, ya</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># n为4的倍数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourN</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 初始化列表</span></span><br><span class=\"line\">    lst = [[i+j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n*n+<span class=\"number\">1</span>))[::n]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"comment\"># 交换对角线位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">        lst[i][i],lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i] = lst[n<span class=\"number\">-1</span>-i][n<span class=\"number\">-1</span>-i],lst[i][i]</span><br><span class=\"line\">        lst[i][n<span class=\"number\">-1</span>-i],lst[n<span class=\"number\">-1</span>-i][i] = lst[n<span class=\"number\">-1</span>-i][i],lst[i][n<span class=\"number\">-1</span>-i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># n为非4倍数的偶数</span></span><br><span class=\"line\"><span class=\"comment\"># 累加子矩阵</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">acc</span>(<span class=\"params\">p, lst</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># print(lst)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> lst:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(row)):</span><br><span class=\"line\">            row[index] += p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lst</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourNplus2</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    m = n // <span class=\"number\">2</span></span><br><span class=\"line\">    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)</span><br><span class=\"line\">    B = acc(m ** <span class=\"number\">2</span>, B)</span><br><span class=\"line\">    C = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">2</span>, C)</span><br><span class=\"line\">    D = acc(m ** <span class=\"number\">2</span> * <span class=\"number\">3</span>, D)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(A)):</span><br><span class=\"line\">        A[row_index].extend(C[row_index])</span><br><span class=\"line\">        D[row_index].extend(B[row_index])</span><br><span class=\"line\">    <span class=\"comment\"># 合并子矩阵</span></span><br><span class=\"line\">    matrix = A + D</span><br><span class=\"line\">    t = (n - <span class=\"number\">2</span>) // <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"comment\"># 列交换</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> col_index &lt; t <span class=\"keyword\">or</span> col_index &gt; n - t:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> row_index <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(matrix) // <span class=\"number\">2</span>):</span><br><span class=\"line\">                matrix[row_index][col_index], matrix[row_index + m][col_index] = \\</span><br><span class=\"line\">                    matrix[row_index + m][col_index], matrix[row_index][col_index]</span><br><span class=\"line\">                <span class=\"comment\"># 交换特殊位置</span></span><br><span class=\"line\">    matrix[t][<span class=\"number\">0</span>], matrix[m + t][<span class=\"number\">0</span>] = matrix[m + t][<span class=\"number\">0</span>], matrix[t][<span class=\"number\">0</span>]</span><br><span class=\"line\">    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>\n\n\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】程序员的浪漫","date":"2017-04-27T07:39:22.000Z","updated":"2017-05-28T13:19:15.000Z","comments":1,"_content":"\n![wordcloud](/images/imagesource/17-04-27.jpg )\n\n关注了**Crossin的编程教室**，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。\n\n问题如下：\n\n在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：\n> 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'\n\n在此给出4个选项\n\n1. 我们在一起吧\n2. 我选择原谅你\n3. 别说话，吻我\n4. 多喝热水\n\n使用科学的方法算出说的是什么。\n<!--more-->\n\n## 思路\n\n其实思路也挺简单，hashlib里有MD5模块，只需调用\n>hashlib.md5(\"要生成MD5的字符串\")\n\n即可生成。\n\n而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：\n>base64.b64decode(\"已知的字符串\")\n\n即可得到解码后的内容。\n\n\n最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。\n\n## Python实现\n\n``` python\nimport base64, hashlib      # 引入需要使用的库\n\nanswer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'   # 问题中的字符串\ncheckStr = {'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'}     # 将选项存入字典，后面使用\n\ndef main():\n    for x in checkStr:      # 遍历字典中的个字符串\n        md5 = hashlib.md5(x.encode('utf-8'))        # 使用hashlib.md5()进行编码\n        md5_byte = bytes(md5.hexdigest().encode('utf-8'))       # base64.decode()得到的是bytes类型的，\n\t\t # 无法直接与string比较，这里把string类型的md5转换成bytes类型的\n        b64_byte = base64.decode(answer)\n        if md5_byte == b64_byte:\n            print('The answer is', x)\n            \n\nif __name__ == '__main__':\n    main()\n\n```\n\n## 输出结果\n\n万！万！没！想！到！ 结果居然是....\n\n> 多喝热水\n\n说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧...\n\n然而...\n\n\n\n\n\n\n\n和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭\n\n\n\nEnd~\n\n---\n[1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\n\n","source":"_posts/【每周一坑】程序员的浪漫.md","raw":"---\ntitle: 【每周一坑】程序员的浪漫\ndate: 2017-04-27 15:39:22\nupdated: 2017-05-28 21:19:15\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![wordcloud](/images/imagesource/17-04-27.jpg )\n\n关注了**Crossin的编程教室**，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。\n\n问题如下：\n\n在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：\n> 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'\n\n在此给出4个选项\n\n1. 我们在一起吧\n2. 我选择原谅你\n3. 别说话，吻我\n4. 多喝热水\n\n使用科学的方法算出说的是什么。\n<!--more-->\n\n## 思路\n\n其实思路也挺简单，hashlib里有MD5模块，只需调用\n>hashlib.md5(\"要生成MD5的字符串\")\n\n即可生成。\n\n而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：\n>base64.b64decode(\"已知的字符串\")\n\n即可得到解码后的内容。\n\n\n最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。\n\n## Python实现\n\n``` python\nimport base64, hashlib      # 引入需要使用的库\n\nanswer = 'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n'   # 问题中的字符串\ncheckStr = {'我们在一起吧', '我选择原谅你', '别说话，吻我', '多喝热水'}     # 将选项存入字典，后面使用\n\ndef main():\n    for x in checkStr:      # 遍历字典中的个字符串\n        md5 = hashlib.md5(x.encode('utf-8'))        # 使用hashlib.md5()进行编码\n        md5_byte = bytes(md5.hexdigest().encode('utf-8'))       # base64.decode()得到的是bytes类型的，\n\t\t # 无法直接与string比较，这里把string类型的md5转换成bytes类型的\n        b64_byte = base64.decode(answer)\n        if md5_byte == b64_byte:\n            print('The answer is', x)\n            \n\nif __name__ == '__main__':\n    main()\n\n```\n\n## 输出结果\n\n万！万！没！想！到！ 结果居然是....\n\n> 多喝热水\n\n说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧...\n\n然而...\n\n\n\n\n\n\n\n和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭\n\n\n\nEnd~\n\n---\n[1]: 图片出处: http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\n\n","slug":"【每周一坑】程序员的浪漫","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiz0021w8vodht62xqc","content":"<p><img data-src=\"/images/imagesource/17-04-27.jpg\" alt=\"wordcloud\"></p>\n<p>关注了<strong>Crossin的编程教室</strong>，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。</p>\n<p>问题如下：</p>\n<p>在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：</p>\n<blockquote>\n<p>‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n’</p>\n</blockquote>\n<p>在此给出4个选项</p>\n<ol>\n<li>我们在一起吧</li>\n<li>我选择原谅你</li>\n<li>别说话，吻我</li>\n<li>多喝热水</li>\n</ol>\n<p>使用科学的方法算出说的是什么。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>其实思路也挺简单，hashlib里有MD5模块，只需调用</p>\n<blockquote>\n<p>hashlib.md5(“要生成MD5的字符串”)</p>\n</blockquote>\n<p>即可生成。</p>\n<p>而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：</p>\n<blockquote>\n<p>base64.b64decode(“已知的字符串”)</p>\n</blockquote>\n<p>即可得到解码后的内容。</p>\n<p>最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64, hashlib      <span class=\"comment\"># 引入需要使用的库</span></span><br><span class=\"line\"></span><br><span class=\"line\">answer = <span class=\"string\">&#x27;NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n&#x27;</span>   <span class=\"comment\"># 问题中的字符串</span></span><br><span class=\"line\">checkStr = &#123;<span class=\"string\">&#x27;我们在一起吧&#x27;</span>, <span class=\"string\">&#x27;我选择原谅你&#x27;</span>, <span class=\"string\">&#x27;别说话，吻我&#x27;</span>, <span class=\"string\">&#x27;多喝热水&#x27;</span>&#125;     <span class=\"comment\"># 将选项存入字典，后面使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> checkStr:      <span class=\"comment\"># 遍历字典中的个字符串</span></span><br><span class=\"line\">        md5 = hashlib.md5(x.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))        <span class=\"comment\"># 使用hashlib.md5()进行编码</span></span><br><span class=\"line\">        md5_byte = <span class=\"built_in\">bytes</span>(md5.hexdigest().encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))       <span class=\"comment\"># base64.decode()得到的是bytes类型的，</span></span><br><span class=\"line\">\t\t <span class=\"comment\"># 无法直接与string比较，这里把string类型的md5转换成bytes类型的</span></span><br><span class=\"line\">        b64_byte = base64.decode(answer)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> md5_byte == b64_byte:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;The answer is&#x27;</span>, x)</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>万！万！没！想！到！ 结果居然是….</p>\n<blockquote>\n<p>多喝热水</p>\n</blockquote>\n<p>说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧…</p>\n<p>然而…</p>\n<p>和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\">http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA</a></p>\n","site":{"data":{}},"length":1195,"excerpt":"<p><img data-src=\"/images/imagesource/17-04-27.jpg\" alt=\"wordcloud\"></p>\n<p>关注了<strong>Crossin的编程教室</strong>，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。</p>\n<p>问题如下：</p>\n<p>在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：</p>\n<blockquote>\n<p>‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n’</p>\n</blockquote>\n<p>在此给出4个选项</p>\n<ol>\n<li>我们在一起吧</li>\n<li>我选择原谅你</li>\n<li>别说话，吻我</li>\n<li>多喝热水</li>\n</ol>\n<p>使用科学的方法算出说的是什么。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>其实思路也挺简单，hashlib里有MD5模块，只需调用</p>\n<blockquote>\n<p>hashlib.md5(“要生成MD5的字符串”)</p>\n</blockquote>\n<p>即可生成。</p>\n<p>而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：</p>\n<blockquote>\n<p>base64.b64decode(“已知的字符串”)</p>\n</blockquote>\n<p>即可得到解码后的内容。</p>\n<p>最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64, hashlib      <span class=\"comment\"># 引入需要使用的库</span></span><br><span class=\"line\"></span><br><span class=\"line\">answer = <span class=\"string\">&#x27;NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\\n&#x27;</span>   <span class=\"comment\"># 问题中的字符串</span></span><br><span class=\"line\">checkStr = &#123;<span class=\"string\">&#x27;我们在一起吧&#x27;</span>, <span class=\"string\">&#x27;我选择原谅你&#x27;</span>, <span class=\"string\">&#x27;别说话，吻我&#x27;</span>, <span class=\"string\">&#x27;多喝热水&#x27;</span>&#125;     <span class=\"comment\"># 将选项存入字典，后面使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> checkStr:      <span class=\"comment\"># 遍历字典中的个字符串</span></span><br><span class=\"line\">        md5 = hashlib.md5(x.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))        <span class=\"comment\"># 使用hashlib.md5()进行编码</span></span><br><span class=\"line\">        md5_byte = <span class=\"built_in\">bytes</span>(md5.hexdigest().encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))       <span class=\"comment\"># base64.decode()得到的是bytes类型的，</span></span><br><span class=\"line\">\t\t <span class=\"comment\"># 无法直接与string比较，这里把string类型的md5转换成bytes类型的</span></span><br><span class=\"line\">        b64_byte = base64.decode(answer)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> md5_byte == b64_byte:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;The answer is&#x27;</span>, x)</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>万！万！没！想！到！ 结果居然是….</p>\n<blockquote>\n<p>多喝热水</p>\n</blockquote>\n<p>说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧…</p>\n<p>然而…</p>\n<p>和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭</p>\n<p>End~</p>\n<hr>\n<p>[1]: 图片出处: <a href=\"http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA\">http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA</a></p>"},{"title":"【每周一坑】罗马数字转换","date":"2017-07-08T06:38:47.000Z","updated":"2017-07-08T06:53:31.000Z","comments":1,"_content":"\n![roman](/images/imagesource/17-07-08.jpg)\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。\n\n罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：\n\n1. 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3\n2. 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12\n3. 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9\n4. 在一个数的上面画一条横线，表示这个数曾1000倍\n\n<!--more-->\n\n**常见罗马字符表**\n\n数字|罗马字符|数字|罗马字符\n:-:|:-:|:--:|:--:|\n1|Ⅰ|2|Ⅱ\n3|Ⅲ|4|Ⅳ\n5|Ⅴ|6|Ⅵ\n7|Ⅶ|8|Ⅷ\n9|Ⅸ|10|Ⅹ\n40|XL|50|L\n90|XC|100|C\n400|CD|500|D\n900|CM|1000|M\n2000|MM|2500|MMD\n\n## 问题\n\n编写一个罗马数字和阿拉伯数字的转换器：\n> 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980\n\n**附加题**\n\n> 给定一个小于3999的整数，将其转换为罗马数\n\n示例：\n\n```python\ndef romanToInt(s):\n    # your code\n    return i\n\nassert romanToInt('III') == 3\nassert romanToInt('IV') == 4\nassert romanToInt('VI') == 6\nassert romanToInt('XIX') == 19\nassert romanToInt('XX') == 20\nassert romaToInt('XLV') == 45\nassert romanToInt('MCMLXXX') == 1980\n```\n\n## 思路\n\n### 罗马数转阿拉伯数\n\n根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要**注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况**。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，**左边的罗马数均比右边的小**，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以**将罗马数字符反转**，然后从头遍历，如果**当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字**。\n\n> 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：\n1. 第一位是X，表示10，pre = 0，res = 0 + 10\n2. 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10\n3. 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10\n4. 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50\n5. 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000\n6. 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100\n7. 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000\n\n经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确\n\n### 阿拉伯数(整数)转罗马数\n\n将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0\n\n> 如1980，(res表示结果):\n1. 1980 // 1000 = 1, res += M, 1980 % 1000 = 980\n2. 980 // 900 = 1, res += CM, 980 % 900 = 80\n3. 80 // 50 = 1, res += L, 80 % 50 = 30\n4. 30 // 10 = 3, res += 3*X, 30 % 10 = 0\n\n经过上述步骤即可得整数1980 = MCMLXXX\n\n## Python实现\n\n```python\n# -*- coding: utf-8 -*-\n# 罗马数字转换\n# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC\n# 400CCC;CD 500D 900CM 1000M 2500MMD\n\n# e.g.\n# 3->III\n# 4->IV\n# 6->VI\n# 19->XIX\n# 45->XLV\n# 999->CMXCIX\n# 1980->MCMLXXX\n# 3999->MMMCMXCIX\n\n# 罗马转数字\ndef roman_to_int(s):\n    roman_int_dic = {\n        'I': 1, 'V': 5, 'X': 10,\n        'L': 50, 'C': 100, 'D': 500,\n        'M': 1000\n    }\n    s = s[::-1]\n    res, pre = 0, 0\n    for x in s:\n        if roman_int_dic[x] >= pre:\n            res += roman_int_dic[x]\n            pre = roman_int_dic[x]\n        else:\n            res -= roman_int_dic[x]\n            pre = roman_int_dic[x]\n    return res\n \n\n# 数字转罗马\ndef int_to_roman(i):\n    dic = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'\n    }\n    res = \"\"\n    for k in dic:\n        if i != 0:\n            res += i // k * dic[k]\n            i %= k\n    return res\n\n\n# 测试\nif __name__ == '__main__':\n    result = roman_to_int('MMMCMXCIX')\n    print(result)\n\n    int_res = int_to_roman(3999)\n    print(int_res)\n\n    result = roman_to_int('MCMLXXX')\n    print(result)\n\n    int_res = int_to_roman(1980)\n    print(int_res)\n\n    assert roman_to_int('III') == 3\n    assert roman_to_int('IV') == 4\n    assert roman_to_int('VI') == 6\n    assert roman_to_int('XIX') == 19\n    assert roman_to_int('XLV') == 45\n    assert roman_to_int('MCMLXXX') == 1980\n    assert roman_to_int('CMXCIX') == 999\n    print(\"OK\")\n```\n\n## 测试\n\n输出结果\n\n```python\n>>> roman_to_int('MMMCMXCIX')\n3999\n\n>>> int_to_roman(3999)\nMMMCMXCIX\n\n>>> roman_to_int(MCMLXXX)\n1980\n\n>>> int_to_roman(1980)\nMCMLXXX\n```\n\n结果与要求一致\n\nEnd~\n\n---\n","source":"_posts/【每周一坑】罗马数字转换.md","raw":"---\ntitle: 【每周一坑】罗马数字转换\ndate: 2017-07-08 14:38:47\nupdated: 2017-07-08 14:53:31\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![roman](/images/imagesource/17-07-08.jpg)\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。\n\n罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：\n\n1. 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3\n2. 小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12\n3. 小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9\n4. 在一个数的上面画一条横线，表示这个数曾1000倍\n\n<!--more-->\n\n**常见罗马字符表**\n\n数字|罗马字符|数字|罗马字符\n:-:|:-:|:--:|:--:|\n1|Ⅰ|2|Ⅱ\n3|Ⅲ|4|Ⅳ\n5|Ⅴ|6|Ⅵ\n7|Ⅶ|8|Ⅷ\n9|Ⅸ|10|Ⅹ\n40|XL|50|L\n90|XC|100|C\n400|CD|500|D\n900|CM|1000|M\n2000|MM|2500|MMD\n\n## 问题\n\n编写一个罗马数字和阿拉伯数字的转换器：\n> 给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980\n\n**附加题**\n\n> 给定一个小于3999的整数，将其转换为罗马数\n\n示例：\n\n```python\ndef romanToInt(s):\n    # your code\n    return i\n\nassert romanToInt('III') == 3\nassert romanToInt('IV') == 4\nassert romanToInt('VI') == 6\nassert romanToInt('XIX') == 19\nassert romanToInt('XX') == 20\nassert romaToInt('XLV') == 45\nassert romanToInt('MCMLXXX') == 1980\n```\n\n## 思路\n\n### 罗马数转阿拉伯数\n\n根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要**注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况**。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，**左边的罗马数均比右边的小**，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以**将罗马数字符反转**，然后从头遍历，如果**当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字**。\n\n> 如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：\n1. 第一位是X，表示10，pre = 0，res = 0 + 10\n2. 第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10\n3. 第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10\n4. 第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50\n5. 第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000\n6. 第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100\n7. 第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000\n\n经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确\n\n### 阿拉伯数(整数)转罗马数\n\n将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0\n\n> 如1980，(res表示结果):\n1. 1980 // 1000 = 1, res += M, 1980 % 1000 = 980\n2. 980 // 900 = 1, res += CM, 980 % 900 = 80\n3. 80 // 50 = 1, res += L, 80 % 50 = 30\n4. 30 // 10 = 3, res += 3*X, 30 % 10 = 0\n\n经过上述步骤即可得整数1980 = MCMLXXX\n\n## Python实现\n\n```python\n# -*- coding: utf-8 -*-\n# 罗马数字转换\n# 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC\n# 400CCC;CD 500D 900CM 1000M 2500MMD\n\n# e.g.\n# 3->III\n# 4->IV\n# 6->VI\n# 19->XIX\n# 45->XLV\n# 999->CMXCIX\n# 1980->MCMLXXX\n# 3999->MMMCMXCIX\n\n# 罗马转数字\ndef roman_to_int(s):\n    roman_int_dic = {\n        'I': 1, 'V': 5, 'X': 10,\n        'L': 50, 'C': 100, 'D': 500,\n        'M': 1000\n    }\n    s = s[::-1]\n    res, pre = 0, 0\n    for x in s:\n        if roman_int_dic[x] >= pre:\n            res += roman_int_dic[x]\n            pre = roman_int_dic[x]\n        else:\n            res -= roman_int_dic[x]\n            pre = roman_int_dic[x]\n    return res\n \n\n# 数字转罗马\ndef int_to_roman(i):\n    dic = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'\n    }\n    res = \"\"\n    for k in dic:\n        if i != 0:\n            res += i // k * dic[k]\n            i %= k\n    return res\n\n\n# 测试\nif __name__ == '__main__':\n    result = roman_to_int('MMMCMXCIX')\n    print(result)\n\n    int_res = int_to_roman(3999)\n    print(int_res)\n\n    result = roman_to_int('MCMLXXX')\n    print(result)\n\n    int_res = int_to_roman(1980)\n    print(int_res)\n\n    assert roman_to_int('III') == 3\n    assert roman_to_int('IV') == 4\n    assert roman_to_int('VI') == 6\n    assert roman_to_int('XIX') == 19\n    assert roman_to_int('XLV') == 45\n    assert roman_to_int('MCMLXXX') == 1980\n    assert roman_to_int('CMXCIX') == 999\n    print(\"OK\")\n```\n\n## 测试\n\n输出结果\n\n```python\n>>> roman_to_int('MMMCMXCIX')\n3999\n\n>>> int_to_roman(3999)\nMMMCMXCIX\n\n>>> roman_to_int(MCMLXXX)\n1980\n\n>>> int_to_roman(1980)\nMCMLXXX\n```\n\n结果与要求一致\n\nEnd~\n\n---\n","slug":"【每周一坑】罗马数字转换","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsiz0023w8vo4tjk9nkq","content":"<p><img data-src=\"/images/imagesource/17-07-08.jpg\" alt=\"roman\"></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p>\n<p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p>\n<ol>\n<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li>\n<li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li>\n<li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li>\n<li>在一个数的上面画一条横线，表示这个数曾1000倍</li>\n</ol>\n<a id=\"more\"></a>\n\n<p><strong>常见罗马字符表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数字</th>\n<th align=\"center\">罗马字符</th>\n<th align=\"center\">数字</th>\n<th align=\"center\">罗马字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">Ⅰ</td>\n<td align=\"center\">2</td>\n<td align=\"center\">Ⅱ</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Ⅲ</td>\n<td align=\"center\">4</td>\n<td align=\"center\">Ⅳ</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">Ⅴ</td>\n<td align=\"center\">6</td>\n<td align=\"center\">Ⅵ</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">Ⅶ</td>\n<td align=\"center\">8</td>\n<td align=\"center\">Ⅷ</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">Ⅸ</td>\n<td align=\"center\">10</td>\n<td align=\"center\">Ⅹ</td>\n</tr>\n<tr>\n<td align=\"center\">40</td>\n<td align=\"center\">XL</td>\n<td align=\"center\">50</td>\n<td align=\"center\">L</td>\n</tr>\n<tr>\n<td align=\"center\">90</td>\n<td align=\"center\">XC</td>\n<td align=\"center\">100</td>\n<td align=\"center\">C</td>\n</tr>\n<tr>\n<td align=\"center\">400</td>\n<td align=\"center\">CD</td>\n<td align=\"center\">500</td>\n<td align=\"center\">D</td>\n</tr>\n<tr>\n<td align=\"center\">900</td>\n<td align=\"center\">CM</td>\n<td align=\"center\">1000</td>\n<td align=\"center\">M</td>\n</tr>\n<tr>\n<td align=\"center\">2000</td>\n<td align=\"center\">MM</td>\n<td align=\"center\">2500</td>\n<td align=\"center\">MMD</td>\n</tr>\n</tbody></table>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p>\n<blockquote>\n<p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>给定一个小于3999的整数，将其转换为罗马数</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span>(<span class=\"params\">s</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># your code</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;III&#x27;</span>) == <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;IV&#x27;</span>) == <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;VI&#x27;</span>) == <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;XIX&#x27;</span>) == <span class=\"number\">19</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;XX&#x27;</span>) == <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romaToInt(<span class=\"string\">&#x27;XLV&#x27;</span>) == <span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>) == <span class=\"number\">1980</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"罗马数转阿拉伯数\"><a href=\"#罗马数转阿拉伯数\" class=\"headerlink\" title=\"罗马数转阿拉伯数\"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p>\n<blockquote>\n<p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p>\n</blockquote>\n<ol>\n<li>第一位是X，表示10，pre = 0，res = 0 + 10</li>\n<li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li>\n<li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li>\n<li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li>\n<li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li>\n<li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li>\n<li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li>\n</ol>\n<p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p>\n<h3 id=\"阿拉伯数-整数-转罗马数\"><a href=\"#阿拉伯数-整数-转罗马数\" class=\"headerlink\" title=\"阿拉伯数(整数)转罗马数\"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p>\n<blockquote>\n<p>如1980，(res表示结果):</p>\n</blockquote>\n<ol>\n<li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li>\n<li>980 // 900 = 1, res += CM, 980 % 900 = 80</li>\n<li>80 // 50 = 1, res += L, 80 % 50 = 30</li>\n<li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li>\n</ol>\n<p>经过上述步骤即可得整数1980 = MCMLXXX</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># 罗马数字转换</span></span><br><span class=\"line\"><span class=\"comment\"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></span><br><span class=\"line\"><span class=\"comment\"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># e.g.</span></span><br><span class=\"line\"><span class=\"comment\"># 3-&gt;III</span></span><br><span class=\"line\"><span class=\"comment\"># 4-&gt;IV</span></span><br><span class=\"line\"><span class=\"comment\"># 6-&gt;VI</span></span><br><span class=\"line\"><span class=\"comment\"># 19-&gt;XIX</span></span><br><span class=\"line\"><span class=\"comment\"># 45-&gt;XLV</span></span><br><span class=\"line\"><span class=\"comment\"># 999-&gt;CMXCIX</span></span><br><span class=\"line\"><span class=\"comment\"># 1980-&gt;MCMLXXX</span></span><br><span class=\"line\"><span class=\"comment\"># 3999-&gt;MMMCMXCIX</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 罗马转数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">roman_to_int</span>(<span class=\"params\">s</span>):</span></span><br><span class=\"line\">    roman_int_dic = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;I&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;V&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;X&#x27;</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;L&#x27;</span>: <span class=\"number\">50</span>, <span class=\"string\">&#x27;C&#x27;</span>: <span class=\"number\">100</span>, <span class=\"string\">&#x27;D&#x27;</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;M&#x27;</span>: <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    res, pre = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> roman_int_dic[x] &gt;= pre:</span><br><span class=\"line\">            res += roman_int_dic[x]</span><br><span class=\"line\">            pre = roman_int_dic[x]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res -= roman_int_dic[x]</span><br><span class=\"line\">            pre = roman_int_dic[x]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 数字转罗马</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int_to_roman</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">    dic = &#123;</span><br><span class=\"line\">        <span class=\"number\">1000</span>: <span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">900</span>: <span class=\"string\">&#x27;CM&#x27;</span>, <span class=\"number\">500</span>: <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">400</span>: <span class=\"string\">&#x27;CD&#x27;</span>,</span><br><span class=\"line\">        <span class=\"number\">100</span>: <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">90</span>: <span class=\"string\">&#x27;XC&#x27;</span>, <span class=\"number\">50</span>: <span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">40</span>: <span class=\"string\">&#x27;XL&#x27;</span>,</span><br><span class=\"line\">        <span class=\"number\">10</span>: <span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">9</span>: <span class=\"string\">&#x27;IX&#x27;</span>, <span class=\"number\">5</span>: <span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">4</span>: <span class=\"string\">&#x27;IV&#x27;</span>, <span class=\"number\">1</span>: <span class=\"string\">&#x27;I&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">            res += i // k * dic[k]</span><br><span class=\"line\">            i %= k</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = roman_to_int(<span class=\"string\">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    int_res = int_to_roman(<span class=\"number\">3999</span>)</span><br><span class=\"line\">    print(int_res)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = roman_to_int(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    int_res = int_to_roman(<span class=\"number\">1980</span>)</span><br><span class=\"line\">    print(int_res)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;III&#x27;</span>) == <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;IV&#x27;</span>) == <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;VI&#x27;</span>) == <span class=\"number\">6</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;XIX&#x27;</span>) == <span class=\"number\">19</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;XLV&#x27;</span>) == <span class=\"number\">45</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>) == <span class=\"number\">1980</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;CMXCIX&#x27;</span>) == <span class=\"number\">999</span></span><br><span class=\"line\">    print(<span class=\"string\">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(<span class=\"string\">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class=\"line\"><span class=\"number\">3999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">3999</span>)</span><br><span class=\"line\">MMMCMXCIX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</span><br><span class=\"line\"><span class=\"number\">1980</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">1980</span>)</span><br><span class=\"line\">MCMLXXX</span><br></pre></td></tr></table></figure>\n\n<p>结果与要求一致</p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":3349,"excerpt":"<p><img data-src=\"/images/imagesource/17-07-08.jpg\" alt=\"roman\"></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p>\n<p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p>\n<ol>\n<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li>\n<li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li>\n<li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li>\n<li>在一个数的上面画一条横线，表示这个数曾1000倍</li>\n</ol>","more":"<p><strong>常见罗马字符表</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数字</th>\n<th align=\"center\">罗马字符</th>\n<th align=\"center\">数字</th>\n<th align=\"center\">罗马字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">Ⅰ</td>\n<td align=\"center\">2</td>\n<td align=\"center\">Ⅱ</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Ⅲ</td>\n<td align=\"center\">4</td>\n<td align=\"center\">Ⅳ</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">Ⅴ</td>\n<td align=\"center\">6</td>\n<td align=\"center\">Ⅵ</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">Ⅶ</td>\n<td align=\"center\">8</td>\n<td align=\"center\">Ⅷ</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\">Ⅸ</td>\n<td align=\"center\">10</td>\n<td align=\"center\">Ⅹ</td>\n</tr>\n<tr>\n<td align=\"center\">40</td>\n<td align=\"center\">XL</td>\n<td align=\"center\">50</td>\n<td align=\"center\">L</td>\n</tr>\n<tr>\n<td align=\"center\">90</td>\n<td align=\"center\">XC</td>\n<td align=\"center\">100</td>\n<td align=\"center\">C</td>\n</tr>\n<tr>\n<td align=\"center\">400</td>\n<td align=\"center\">CD</td>\n<td align=\"center\">500</td>\n<td align=\"center\">D</td>\n</tr>\n<tr>\n<td align=\"center\">900</td>\n<td align=\"center\">CM</td>\n<td align=\"center\">1000</td>\n<td align=\"center\">M</td>\n</tr>\n<tr>\n<td align=\"center\">2000</td>\n<td align=\"center\">MM</td>\n<td align=\"center\">2500</td>\n<td align=\"center\">MMD</td>\n</tr>\n</tbody></table>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p>\n<blockquote>\n<p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>给定一个小于3999的整数，将其转换为罗马数</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">romanToInt</span>(<span class=\"params\">s</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># your code</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;III&#x27;</span>) == <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;IV&#x27;</span>) == <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;VI&#x27;</span>) == <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;XIX&#x27;</span>) == <span class=\"number\">19</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;XX&#x27;</span>) == <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romaToInt(<span class=\"string\">&#x27;XLV&#x27;</span>) == <span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> romanToInt(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>) == <span class=\"number\">1980</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"罗马数转阿拉伯数\"><a href=\"#罗马数转阿拉伯数\" class=\"headerlink\" title=\"罗马数转阿拉伯数\"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p>\n<blockquote>\n<p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p>\n</blockquote>\n<ol>\n<li>第一位是X，表示10，pre = 0，res = 0 + 10</li>\n<li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li>\n<li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li>\n<li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li>\n<li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li>\n<li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li>\n<li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li>\n</ol>\n<p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p>\n<h3 id=\"阿拉伯数-整数-转罗马数\"><a href=\"#阿拉伯数-整数-转罗马数\" class=\"headerlink\" title=\"阿拉伯数(整数)转罗马数\"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p>\n<blockquote>\n<p>如1980，(res表示结果):</p>\n</blockquote>\n<ol>\n<li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li>\n<li>980 // 900 = 1, res += CM, 980 % 900 = 80</li>\n<li>80 // 50 = 1, res += L, 80 % 50 = 30</li>\n<li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li>\n</ol>\n<p>经过上述步骤即可得整数1980 = MCMLXXX</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># 罗马数字转换</span></span><br><span class=\"line\"><span class=\"comment\"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></span><br><span class=\"line\"><span class=\"comment\"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># e.g.</span></span><br><span class=\"line\"><span class=\"comment\"># 3-&gt;III</span></span><br><span class=\"line\"><span class=\"comment\"># 4-&gt;IV</span></span><br><span class=\"line\"><span class=\"comment\"># 6-&gt;VI</span></span><br><span class=\"line\"><span class=\"comment\"># 19-&gt;XIX</span></span><br><span class=\"line\"><span class=\"comment\"># 45-&gt;XLV</span></span><br><span class=\"line\"><span class=\"comment\"># 999-&gt;CMXCIX</span></span><br><span class=\"line\"><span class=\"comment\"># 1980-&gt;MCMLXXX</span></span><br><span class=\"line\"><span class=\"comment\"># 3999-&gt;MMMCMXCIX</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 罗马转数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">roman_to_int</span>(<span class=\"params\">s</span>):</span></span><br><span class=\"line\">    roman_int_dic = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;I&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;V&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;X&#x27;</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;L&#x27;</span>: <span class=\"number\">50</span>, <span class=\"string\">&#x27;C&#x27;</span>: <span class=\"number\">100</span>, <span class=\"string\">&#x27;D&#x27;</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;M&#x27;</span>: <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    res, pre = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> roman_int_dic[x] &gt;= pre:</span><br><span class=\"line\">            res += roman_int_dic[x]</span><br><span class=\"line\">            pre = roman_int_dic[x]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res -= roman_int_dic[x]</span><br><span class=\"line\">            pre = roman_int_dic[x]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 数字转罗马</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int_to_roman</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">    dic = &#123;</span><br><span class=\"line\">        <span class=\"number\">1000</span>: <span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">900</span>: <span class=\"string\">&#x27;CM&#x27;</span>, <span class=\"number\">500</span>: <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">400</span>: <span class=\"string\">&#x27;CD&#x27;</span>,</span><br><span class=\"line\">        <span class=\"number\">100</span>: <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">90</span>: <span class=\"string\">&#x27;XC&#x27;</span>, <span class=\"number\">50</span>: <span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">40</span>: <span class=\"string\">&#x27;XL&#x27;</span>,</span><br><span class=\"line\">        <span class=\"number\">10</span>: <span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">9</span>: <span class=\"string\">&#x27;IX&#x27;</span>, <span class=\"number\">5</span>: <span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">4</span>: <span class=\"string\">&#x27;IV&#x27;</span>, <span class=\"number\">1</span>: <span class=\"string\">&#x27;I&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">            res += i // k * dic[k]</span><br><span class=\"line\">            i %= k</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = roman_to_int(<span class=\"string\">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    int_res = int_to_roman(<span class=\"number\">3999</span>)</span><br><span class=\"line\">    print(int_res)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = roman_to_int(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    int_res = int_to_roman(<span class=\"number\">1980</span>)</span><br><span class=\"line\">    print(int_res)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;III&#x27;</span>) == <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;IV&#x27;</span>) == <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;VI&#x27;</span>) == <span class=\"number\">6</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;XIX&#x27;</span>) == <span class=\"number\">19</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;XLV&#x27;</span>) == <span class=\"number\">45</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;MCMLXXX&#x27;</span>) == <span class=\"number\">1980</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> roman_to_int(<span class=\"string\">&#x27;CMXCIX&#x27;</span>) == <span class=\"number\">999</span></span><br><span class=\"line\">    print(<span class=\"string\">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(<span class=\"string\">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class=\"line\"><span class=\"number\">3999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">3999</span>)</span><br><span class=\"line\">MMMCMXCIX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</span><br><span class=\"line\"><span class=\"number\">1980</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int_to_roman(<span class=\"number\">1980</span>)</span><br><span class=\"line\">MCMLXXX</span><br></pre></td></tr></table></figure>\n\n<p>结果与要求一致</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】螺旋矩阵","date":"2017-06-23T11:44:50.000Z","updated":"2017-06-23T12:01:46.000Z","comments":1,"_content":"\n**螺旋矩阵**是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。\n![matrix](/images/imagesource/17-06-23.jpg )\n<!--more-->\n\n## 问题\n\n> 输出如图的螺旋矩阵\n>\n```\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n```\n\n**附加题**\n> 输入一个正整数N，输出以N为边长的螺旋矩阵。\n\n## 思路\n\n需要找到数字在二维数组中赋值的规律：\n\n1. 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；\n2. 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；\n3. 从第一行，当y < N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；\n4. 然后开始递增x(x<N)，y不变,为matrix[x][y]赋新值(从上至下)；\n5. 接下来开始递减y(y>=0)，x不变，为matrix[x][y]赋新值(从右至左)；\n6. 最后递减x(x>=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；\n7. 重复**3-6**步，直到最后赋的值等于N的平方\n\n\n## Python实现\n\n```python\n#  -*- coding: utf-8 -*-\n# 打印输出螺旋矩阵\n\n\ndef gen_matrix(n):\n    # 用二维数组来代表矩阵\n    matrix = [[0 for col in range(n)] for row in range(n)]\n    return matrix\n\n\ndef get_rota_matrix(n):\n    mat = gen_matrix(n)  # 初始矩阵，所有元素都为0\n    x = y = 0\n    total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1\n    while total != n * n:\n        while y + 1 < n and not mat[x][y + 1]: # 从左至右\n            y += 1\n            total += 1\n            mat[x][y] = total\n        while x + 1 < n and not mat[x + 1][y]: # 从上之下\n            x += 1\n            total += 1\n            mat[x][y] = total\n        while y - 1 >= 0 and not mat[x][y - 1]: # 从右至左\n            y -= 1\n            total += 1\n            mat[x][y] = total\n        while x - 1 >= 0 and not mat[x - 1][y]: # 从下至上\n            x -= 1\n            total += 1\n            mat[x][y] = total\n    return mat\n\n\nif __name__ == '__main__':\n    n = int(input(\"请输入矩形数组的大小:\"))\n    matrix = get_rota_matrix(n)\n    # print(matrix)\n    for i in range(n):\n        for j in range(n):\n            print('%4d' % matrix[i][j], end=\" \")\n        print()\n\n```\n\n## 测试\n\n输出结果\n当N = 4 时：\n```\n>>> 请输入矩形数组的大小： 4\n\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n\n```\n\n当N = 5 时：\n```\n>>> 请输入矩形数组的大小： 5\n\n    1     2     3     4    5 \n  16   17   18   19    6 \n  15   24   25   20    7 \n  14   23   22   21    8 \n  13   12   11   10    9 \n```\n\n结果与要求一致，可以输出任意N的螺旋矩阵。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】螺旋矩阵.md","raw":"---\ntitle: 【每周一坑】螺旋矩阵\ndate: 2017-06-23 19:44:50\nupdated: 2017-06-23 20:01:46\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n**螺旋矩阵**是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。\n![matrix](/images/imagesource/17-06-23.jpg )\n<!--more-->\n\n## 问题\n\n> 输出如图的螺旋矩阵\n>\n```\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n```\n\n**附加题**\n> 输入一个正整数N，输出以N为边长的螺旋矩阵。\n\n## 思路\n\n需要找到数字在二维数组中赋值的规律：\n\n1. 设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；\n2. 为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；\n3. 从第一行，当y < N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；\n4. 然后开始递增x(x<N)，y不变,为matrix[x][y]赋新值(从上至下)；\n5. 接下来开始递减y(y>=0)，x不变，为matrix[x][y]赋新值(从右至左)；\n6. 最后递减x(x>=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；\n7. 重复**3-6**步，直到最后赋的值等于N的平方\n\n\n## Python实现\n\n```python\n#  -*- coding: utf-8 -*-\n# 打印输出螺旋矩阵\n\n\ndef gen_matrix(n):\n    # 用二维数组来代表矩阵\n    matrix = [[0 for col in range(n)] for row in range(n)]\n    return matrix\n\n\ndef get_rota_matrix(n):\n    mat = gen_matrix(n)  # 初始矩阵，所有元素都为0\n    x = y = 0\n    total = mat[x][y] = 1 # 将数组第一个元素设为1，即mat[0][0] = 1\n    while total != n * n:\n        while y + 1 < n and not mat[x][y + 1]: # 从左至右\n            y += 1\n            total += 1\n            mat[x][y] = total\n        while x + 1 < n and not mat[x + 1][y]: # 从上之下\n            x += 1\n            total += 1\n            mat[x][y] = total\n        while y - 1 >= 0 and not mat[x][y - 1]: # 从右至左\n            y -= 1\n            total += 1\n            mat[x][y] = total\n        while x - 1 >= 0 and not mat[x - 1][y]: # 从下至上\n            x -= 1\n            total += 1\n            mat[x][y] = total\n    return mat\n\n\nif __name__ == '__main__':\n    n = int(input(\"请输入矩形数组的大小:\"))\n    matrix = get_rota_matrix(n)\n    # print(matrix)\n    for i in range(n):\n        for j in range(n):\n            print('%4d' % matrix[i][j], end=\" \")\n        print()\n\n```\n\n## 测试\n\n输出结果\n当N = 4 时：\n```\n>>> 请输入矩形数组的大小： 4\n\n      1    2    3    4\n    12  13   14   5\n    11  16   15   6\n    10    9     8   7\n\n```\n\n当N = 5 时：\n```\n>>> 请输入矩形数组的大小： 5\n\n    1     2     3     4    5 \n  16   17   18   19    6 \n  15   24   25   20    7 \n  14   23   22   21    8 \n  13   12   11   10    9 \n```\n\n结果与要求一致，可以输出任意N的螺旋矩阵。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】螺旋矩阵","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsj00027w8vo19xt3u35","content":"<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img data-src=\"/images/imagesource/17-06-23.jpg\" alt=\"matrix\"></p>\n<a id=\"more\"></a>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出如图的螺旋矩阵</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1    2    3    4</span><br><span class=\"line\">12  13   14   5</span><br><span class=\"line\">11  16   15   6</span><br><span class=\"line\">10    9     8   7</span><br></pre></td></tr></table></figure>\n\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p>\n<ol>\n<li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li>\n<li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li>\n<li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li>\n<li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li>\n<li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li>\n<li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li>\n<li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li>\n</ol>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># 打印输出螺旋矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_matrix</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 用二维数组来代表矩阵</span></span><br><span class=\"line\">    matrix = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_rota_matrix</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    mat = gen_matrix(n)  <span class=\"comment\"># 初始矩阵，所有元素都为0</span></span><br><span class=\"line\">    x = y = <span class=\"number\">0</span></span><br><span class=\"line\">    total = mat[x][y] = <span class=\"number\">1</span> <span class=\"comment\"># 将数组第一个元素设为1，即mat[0][0] = 1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> total != n * n:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> y + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y + <span class=\"number\">1</span>]: <span class=\"comment\"># 从左至右</span></span><br><span class=\"line\">            y += <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> x + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x + <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从上之下</span></span><br><span class=\"line\">            x += <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> y - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y - <span class=\"number\">1</span>]: <span class=\"comment\"># 从右至左</span></span><br><span class=\"line\">            y -= <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> x - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x - <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从下至上</span></span><br><span class=\"line\">            x -= <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mat</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&quot;请输入矩形数组的大小:&quot;</span>))</span><br><span class=\"line\">    matrix = get_rota_matrix(n)</span><br><span class=\"line\">    <span class=\"comment\"># print(matrix)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;%4d&#x27;</span> % matrix[i][j], end=<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">        print()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果<br>当N = 4 时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 4</span><br><span class=\"line\"></span><br><span class=\"line\">      1    2    3    4</span><br><span class=\"line\">    12  13   14   5</span><br><span class=\"line\">    11  16   15   6</span><br><span class=\"line\">    10    9     8   7</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当N = 5 时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 5</span><br><span class=\"line\"></span><br><span class=\"line\">    1     2     3     4    5 </span><br><span class=\"line\">  16   17   18   19    6 </span><br><span class=\"line\">  15   24   25   20    7 </span><br><span class=\"line\">  14   23   22   21    8 </span><br><span class=\"line\">  13   12   11   10    9 </span><br></pre></td></tr></table></figure>\n\n<p>结果与要求一致，可以输出任意N的螺旋矩阵。</p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1389,"excerpt":"<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img data-src=\"/images/imagesource/17-06-23.jpg\" alt=\"matrix\"></p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出如图的螺旋矩阵</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1    2    3    4</span><br><span class=\"line\">12  13   14   5</span><br><span class=\"line\">11  16   15   6</span><br><span class=\"line\">10    9     8   7</span><br></pre></td></tr></table></figure>\n\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p>\n<ol>\n<li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li>\n<li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li>\n<li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li>\n<li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li>\n<li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li>\n<li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li>\n<li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li>\n</ol>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># 打印输出螺旋矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_matrix</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 用二维数组来代表矩阵</span></span><br><span class=\"line\">    matrix = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_rota_matrix</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    mat = gen_matrix(n)  <span class=\"comment\"># 初始矩阵，所有元素都为0</span></span><br><span class=\"line\">    x = y = <span class=\"number\">0</span></span><br><span class=\"line\">    total = mat[x][y] = <span class=\"number\">1</span> <span class=\"comment\"># 将数组第一个元素设为1，即mat[0][0] = 1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> total != n * n:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> y + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y + <span class=\"number\">1</span>]: <span class=\"comment\"># 从左至右</span></span><br><span class=\"line\">            y += <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> x + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x + <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从上之下</span></span><br><span class=\"line\">            x += <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> y - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x][y - <span class=\"number\">1</span>]: <span class=\"comment\"># 从右至左</span></span><br><span class=\"line\">            y -= <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">        <span class=\"keyword\">while</span> x - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> mat[x - <span class=\"number\">1</span>][y]: <span class=\"comment\"># 从下至上</span></span><br><span class=\"line\">            x -= <span class=\"number\">1</span></span><br><span class=\"line\">            total += <span class=\"number\">1</span></span><br><span class=\"line\">            mat[x][y] = total</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mat</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&quot;请输入矩形数组的大小:&quot;</span>))</span><br><span class=\"line\">    matrix = get_rota_matrix(n)</span><br><span class=\"line\">    <span class=\"comment\"># print(matrix)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;%4d&#x27;</span> % matrix[i][j], end=<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">        print()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果<br>当N = 4 时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 4</span><br><span class=\"line\"></span><br><span class=\"line\">      1    2    3    4</span><br><span class=\"line\">    12  13   14   5</span><br><span class=\"line\">    11  16   15   6</span><br><span class=\"line\">    10    9     8   7</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当N = 5 时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 请输入矩形数组的大小： 5</span><br><span class=\"line\"></span><br><span class=\"line\">    1     2     3     4    5 </span><br><span class=\"line\">  16   17   18   19    6 </span><br><span class=\"line\">  15   24   25   20    7 </span><br><span class=\"line\">  14   23   22   21    8 </span><br><span class=\"line\">  13   12   11   10    9 </span><br></pre></td></tr></table></figure>\n\n<p>结果与要求一致，可以输出任意N的螺旋矩阵。</p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】阿姆斯特朗数","date":"2017-08-04T10:37:51.000Z","updated":"2017-08-04T11:18:32.000Z","comments":1,"_content":"\n![armstrong](/images/imagesource/17-08-04.jpg )\n快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog...)，今天诈尸更新一下~~\n\n\n\n一个经典的编程练习题：\n> 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。\n如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数\n\n## 问题\n> 输出1000以内的所有阿姆斯特朗数。\n\n**附加题**\n> 输入一个整数，输出距离它最近的阿姆斯特朗数。\n\n<!--more-->\n\n## 思路\n\n一眼看到阿姆斯特朗就想到了[《银魂》](http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0)**阿姆斯特朗回旋加速喷气式阿姆斯特朗炮**了，果然银魂毁节操QAQ。\n\n回到主题，其实阿姆斯特朗数和[水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)差不多。\n满足阿姆斯特朗数的公式如下，设 $ n = d\\_kd\\_{k-1}\\cdots d\\_1 $，则有\n\n$$\nn = d\\_k^k + d\\_{k-1}^k+\\cdots+d\\_2^k+d\\_1^k\n$$\n\n编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。\n\n```python\ntemp = num\nwhile temp:\n    # 求出每位数的k次幂的和\n    res += (temp % 10)**n\n    num //= 10\nif res == num:\n    # 如果满足阿姆斯特朗数的条件，就返回这个数\n    return num\n```\n\n## Python实现\n```python\n# -*- coding: utf-8 -*-\n\n\n# 得到bound以内的阿姆斯特朗数，bound默认为1000\ndef get_number(bound=1000):\n    armstrong_number = []\n    for i in range(bound):\n        temp = i\n        n = len(str(i))\n        res = 0\n        while temp:\n            res += (temp % 10) ** n\n            temp //= 10\n        if res == i:\n            armstrong_number.append(i)\n    return armstrong_number\n\n\n# 得到离number最近的阿姆斯特朗数\ndef get_nearest_number(num):\n    if is_arm_num(num):\n        return num\n    temp = num\n    res = get_number(temp)[-1]\n    while not is_arm_num(temp):\n        temp += 1\n    res_new = temp\n    if abs(res_new - num) < abs(res - num):\n        return res_new\n    else:\n        return res\n\n\n# 判断num是否是阿姆斯特朗数\ndef is_arm_num(num):\n    temp = num\n    res = 0\n    n = len(str(num))\n    while temp:\n        res += (temp % 10) ** n\n        temp //= 10\n    return res == num\n\n\nif __name__ == '__main__':\n    print(get_number())\n    print(get_nearest_number(390))\n    print(get_nearest_number(389))\n\n```\n\n## 测试\n\n输出结果\n\n```ptyhon\n>>> get_number(1000)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]\n\n>>> get_nearest_number(390)\n407\n\n>>> get_nearest_number(389)\n371\n```\n\n满足问题要求\n\n## 参考资料\n[1]: [Wiki 水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)\n\nEnd~\n\n---\n\n\n\n","source":"_posts/【每周一坑】阿姆斯特朗数.md","raw":"---\ntitle: 【每周一坑】阿姆斯特朗数\ndate: 2017-08-04 18:37:51\nupdated: 2017-08-04 19:18:32\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![armstrong](/images/imagesource/17-08-04.jpg )\n快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog...)，今天诈尸更新一下~~\n\n\n\n一个经典的编程练习题：\n> 如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。\n如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数\n\n## 问题\n> 输出1000以内的所有阿姆斯特朗数。\n\n**附加题**\n> 输入一个整数，输出距离它最近的阿姆斯特朗数。\n\n<!--more-->\n\n## 思路\n\n一眼看到阿姆斯特朗就想到了[《银魂》](http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0)**阿姆斯特朗回旋加速喷气式阿姆斯特朗炮**了，果然银魂毁节操QAQ。\n\n回到主题，其实阿姆斯特朗数和[水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)差不多。\n满足阿姆斯特朗数的公式如下，设 $ n = d\\_kd\\_{k-1}\\cdots d\\_1 $，则有\n\n$$\nn = d\\_k^k + d\\_{k-1}^k+\\cdots+d\\_2^k+d\\_1^k\n$$\n\n编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。\n\n```python\ntemp = num\nwhile temp:\n    # 求出每位数的k次幂的和\n    res += (temp % 10)**n\n    num //= 10\nif res == num:\n    # 如果满足阿姆斯特朗数的条件，就返回这个数\n    return num\n```\n\n## Python实现\n```python\n# -*- coding: utf-8 -*-\n\n\n# 得到bound以内的阿姆斯特朗数，bound默认为1000\ndef get_number(bound=1000):\n    armstrong_number = []\n    for i in range(bound):\n        temp = i\n        n = len(str(i))\n        res = 0\n        while temp:\n            res += (temp % 10) ** n\n            temp //= 10\n        if res == i:\n            armstrong_number.append(i)\n    return armstrong_number\n\n\n# 得到离number最近的阿姆斯特朗数\ndef get_nearest_number(num):\n    if is_arm_num(num):\n        return num\n    temp = num\n    res = get_number(temp)[-1]\n    while not is_arm_num(temp):\n        temp += 1\n    res_new = temp\n    if abs(res_new - num) < abs(res - num):\n        return res_new\n    else:\n        return res\n\n\n# 判断num是否是阿姆斯特朗数\ndef is_arm_num(num):\n    temp = num\n    res = 0\n    n = len(str(num))\n    while temp:\n        res += (temp % 10) ** n\n        temp //= 10\n    return res == num\n\n\nif __name__ == '__main__':\n    print(get_number())\n    print(get_nearest_number(390))\n    print(get_nearest_number(389))\n\n```\n\n## 测试\n\n输出结果\n\n```ptyhon\n>>> get_number(1000)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]\n\n>>> get_nearest_number(390)\n407\n\n>>> get_nearest_number(389)\n371\n```\n\n满足问题要求\n\n## 参考资料\n[1]: [Wiki 水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)\n\nEnd~\n\n---\n\n\n\n","slug":"【每周一坑】阿姆斯特朗数","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsj0002aw8vo0n18awe3","content":"<p><img data-src=\"/images/imagesource/17-08-04.jpg\" alt=\"armstrong\"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p>\n<p>一个经典的编程练习题：</p>\n<blockquote>\n<p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出1000以内的所有阿姆斯特朗数。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href=\"http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0\">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p>\n<p>回到主题，其实阿姆斯特朗数和<a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\\cdots d_1 $，则有</p>\n<p>$$<br>n = d_k^k + d_{k-1}^k+\\cdots+d_2^k+d_1^k<br>$$</p>\n<p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">temp = num</span><br><span class=\"line\"><span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">    <span class=\"comment\"># 求出每位数的k次幂的和</span></span><br><span class=\"line\">    res += (temp % <span class=\"number\">10</span>)**n</span><br><span class=\"line\">    num //= <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> res == num:</span><br><span class=\"line\">    <span class=\"comment\"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_number</span>(<span class=\"params\">bound=<span class=\"number\">1000</span></span>):</span></span><br><span class=\"line\">    armstrong_number = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(bound):</span><br><span class=\"line\">        temp = i</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">            res += (temp % <span class=\"number\">10</span>) ** n</span><br><span class=\"line\">            temp //= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == i:</span><br><span class=\"line\">            armstrong_number.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> armstrong_number</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 得到离number最近的阿姆斯特朗数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_nearest_number</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_arm_num(num):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num</span><br><span class=\"line\">    temp = num</span><br><span class=\"line\">    res = get_number(temp)[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> is_arm_num(temp):</span><br><span class=\"line\">        temp += <span class=\"number\">1</span></span><br><span class=\"line\">    res_new = temp</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(res_new - num) &lt; <span class=\"built_in\">abs</span>(res - num):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res_new</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 判断num是否是阿姆斯特朗数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_arm_num</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    temp = num</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(num))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">        res += (temp % <span class=\"number\">10</span>) ** n</span><br><span class=\"line\">        temp //= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == num</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    print(get_number())</span><br><span class=\"line\">    print(get_nearest_number(<span class=\"number\">390</span>))</span><br><span class=\"line\">    print(get_nearest_number(<span class=\"number\">389</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; get_number(1000)</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; get_nearest_number(390)</span><br><span class=\"line\">407</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; get_nearest_number(389)</span><br><span class=\"line\">371</span><br></pre></td></tr></table></figure>\n\n<p>满足问题要求</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">Wiki 水仙花数</a></p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":1423,"excerpt":"<p><img data-src=\"/images/imagesource/17-08-04.jpg\" alt=\"armstrong\"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p>\n<p>一个经典的编程练习题：</p>\n<blockquote>\n<p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>输出1000以内的所有阿姆斯特朗数。</p>\n</blockquote>\n<p><strong>附加题</strong></p>\n<blockquote>\n<p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p>\n</blockquote>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href=\"http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0\">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p>\n<p>回到主题，其实阿姆斯特朗数和<a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\\cdots d_1 $，则有</p>\n<p>$$<br>n = d_k^k + d_{k-1}^k+\\cdots+d_2^k+d_1^k<br>$$</p>\n<p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">temp = num</span><br><span class=\"line\"><span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">    <span class=\"comment\"># 求出每位数的k次幂的和</span></span><br><span class=\"line\">    res += (temp % <span class=\"number\">10</span>)**n</span><br><span class=\"line\">    num //= <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> res == num:</span><br><span class=\"line\">    <span class=\"comment\"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_number</span>(<span class=\"params\">bound=<span class=\"number\">1000</span></span>):</span></span><br><span class=\"line\">    armstrong_number = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(bound):</span><br><span class=\"line\">        temp = i</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">            res += (temp % <span class=\"number\">10</span>) ** n</span><br><span class=\"line\">            temp //= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == i:</span><br><span class=\"line\">            armstrong_number.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> armstrong_number</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 得到离number最近的阿姆斯特朗数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_nearest_number</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_arm_num(num):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num</span><br><span class=\"line\">    temp = num</span><br><span class=\"line\">    res = get_number(temp)[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> is_arm_num(temp):</span><br><span class=\"line\">        temp += <span class=\"number\">1</span></span><br><span class=\"line\">    res_new = temp</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(res_new - num) &lt; <span class=\"built_in\">abs</span>(res - num):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res_new</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 判断num是否是阿姆斯特朗数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_arm_num</span>(<span class=\"params\">num</span>):</span></span><br><span class=\"line\">    temp = num</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(num))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> temp:</span><br><span class=\"line\">        res += (temp % <span class=\"number\">10</span>) ** n</span><br><span class=\"line\">        temp //= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == num</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    print(get_number())</span><br><span class=\"line\">    print(get_nearest_number(<span class=\"number\">390</span>))</span><br><span class=\"line\">    print(get_nearest_number(<span class=\"number\">389</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; get_number(1000)</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; get_nearest_number(390)</span><br><span class=\"line\">407</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; get_nearest_number(389)</span><br><span class=\"line\">371</span><br></pre></td></tr></table></figure>\n\n<p>满足问题要求</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1]: <a href=\"https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\">Wiki 水仙花数</a></p>\n<p>End~</p>\n<hr>"},{"title":"【每周一坑】验证哥德巴赫猜想","date":"2017-05-28T01:53:38.000Z","updated":"2017-05-28T02:12:08.000Z","comments":1,"_content":"\n![Goldbach's conjecture](/images/imagesource/17-05-28.jpg )\n\n> 哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。\n\n<!--more-->\n\n## 问题描述\n\n**本周题目**\n\n> 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。\n\n示例：\n\n```python\n>>> Goldbach(123456)\n7 123449\n>>> Goldbach(12345678)\n31 12345647\n```\n\n## 思路\n\n这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。\n\n## Python实现\n\n```python\nimport math\n\n# 求得小于等于n的所有质数\ndef get_prime(n):\n    prime = []\n    prime_dic = {}\n    for i in range(2, n+1):\n        prime_dic[i] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        for j in range(i * i, n + 1, i):\n            if prime_dic[i] == 1:\n                prime_dic[j] = 0\n    for k, v in prime.items():\n        if v == 1:\n            prime.append(k)\n    return prime\n\n# 求满足猜想的质数和\ndef gold_bach(n):\n    cnt = 0\n    prime = get_prime(n)\n    for prime1 in prime:\n        prime2 = n - prime1\n        if prime2 in prime and cnt != 1:    # 只输出一种结果\n            cnt += 1\n            return prime1. prime2\n\nif __name__ == '__main__'：\n    print(gold_bach(123456))\n    print(gold_bach(12345678))\n```\n\n## 输出结果\n\nprint(gold_bach(123456))\n\n> (7, 123449)\n\nprint(gold_bach(12345678))\n\n> (31, 12345647)\n\n与示例一致。\n\nEnd~\n\n---\n\n","source":"_posts/【每周一坑】验证哥德巴赫猜想.md","raw":"---\ntitle: 【每周一坑】验证哥德巴赫猜想\ndate: 2017-05-28 09:53:38\nupdated: 2017-05-28 10:12:08\ncategory: Python\ntags: 每周一坑\ncomments: true\n---\n\n![Goldbach's conjecture](/images/imagesource/17-05-28.jpg )\n\n> 哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。\n\n<!--more-->\n\n## 问题描述\n\n**本周题目**\n\n> 实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。\n\n示例：\n\n```python\n>>> Goldbach(123456)\n7 123449\n>>> Goldbach(12345678)\n31 12345647\n```\n\n## 思路\n\n这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。\n\n## Python实现\n\n```python\nimport math\n\n# 求得小于等于n的所有质数\ndef get_prime(n):\n    prime = []\n    prime_dic = {}\n    for i in range(2, n+1):\n        prime_dic[i] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        for j in range(i * i, n + 1, i):\n            if prime_dic[i] == 1:\n                prime_dic[j] = 0\n    for k, v in prime.items():\n        if v == 1:\n            prime.append(k)\n    return prime\n\n# 求满足猜想的质数和\ndef gold_bach(n):\n    cnt = 0\n    prime = get_prime(n)\n    for prime1 in prime:\n        prime2 = n - prime1\n        if prime2 in prime and cnt != 1:    # 只输出一种结果\n            cnt += 1\n            return prime1. prime2\n\nif __name__ == '__main__'：\n    print(gold_bach(123456))\n    print(gold_bach(12345678))\n```\n\n## 输出结果\n\nprint(gold_bach(123456))\n\n> (7, 123449)\n\nprint(gold_bach(12345678))\n\n> (31, 12345647)\n\n与示例一致。\n\nEnd~\n\n---\n\n","slug":"【每周一坑】验证哥德巴赫猜想","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsj1002ew8vo8y2e54uq","content":"<p><img data-src=\"/images/imagesource/17-05-28.jpg\" alt=\"Goldbach&#39;s conjecture\"></p>\n<blockquote>\n<p>哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">123456</span>)</span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">123449</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">12345678</span>)</span><br><span class=\"line\"><span class=\"number\">31</span> <span class=\"number\">12345647</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求得小于等于n的所有质数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_prime</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    prime = []</span><br><span class=\"line\">    prime_dic = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        prime_dic[i] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"built_in\">int</span>(math.sqrt(n)) + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i * i, n + <span class=\"number\">1</span>, i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prime_dic[i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                prime_dic[j] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> prime.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">1</span>:</span><br><span class=\"line\">            prime.append(k)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求满足猜想的质数和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold_bach</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    prime = get_prime(n)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> prime1 <span class=\"keyword\">in</span> prime:</span><br><span class=\"line\">        prime2 = n - prime1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> prime2 <span class=\"keyword\">in</span> prime <span class=\"keyword\">and</span> cnt != <span class=\"number\">1</span>:    <span class=\"comment\"># 只输出一种结果</span></span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> prime1. prime2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>：</span><br><span class=\"line\">    print(gold_bach(<span class=\"number\">123456</span>))</span><br><span class=\"line\">    print(gold_bach(<span class=\"number\">12345678</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>print(gold_bach(123456))</p>\n<blockquote>\n<p>(7, 123449)</p>\n</blockquote>\n<p>print(gold_bach(12345678))</p>\n<blockquote>\n<p>(31, 12345647)</p>\n</blockquote>\n<p>与示例一致。</p>\n<p>End~</p>\n<hr>\n","site":{"data":{}},"length":959,"excerpt":"<p><img data-src=\"/images/imagesource/17-05-28.jpg\" alt=\"Goldbach&#39;s conjecture\"></p>\n<blockquote>\n<p>哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。</p>\n</blockquote>","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>本周题目</strong></p>\n<blockquote>\n<p>实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">123456</span>)</span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">123449</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Goldbach(<span class=\"number\">12345678</span>)</span><br><span class=\"line\"><span class=\"number\">31</span> <span class=\"number\">12345647</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求得小于等于n的所有质数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_prime</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    prime = []</span><br><span class=\"line\">    prime_dic = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        prime_dic[i] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"built_in\">int</span>(math.sqrt(n)) + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i * i, n + <span class=\"number\">1</span>, i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prime_dic[i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                prime_dic[j] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> prime.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">1</span>:</span><br><span class=\"line\">            prime.append(k)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求满足猜想的质数和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold_bach</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    prime = get_prime(n)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> prime1 <span class=\"keyword\">in</span> prime:</span><br><span class=\"line\">        prime2 = n - prime1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> prime2 <span class=\"keyword\">in</span> prime <span class=\"keyword\">and</span> cnt != <span class=\"number\">1</span>:    <span class=\"comment\"># 只输出一种结果</span></span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> prime1. prime2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>：</span><br><span class=\"line\">    print(gold_bach(<span class=\"number\">123456</span>))</span><br><span class=\"line\">    print(gold_bach(<span class=\"number\">12345678</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h2><p>print(gold_bach(123456))</p>\n<blockquote>\n<p>(7, 123449)</p>\n</blockquote>\n<p>print(gold_bach(12345678))</p>\n<blockquote>\n<p>(31, 12345647)</p>\n</blockquote>\n<p>与示例一致。</p>\n<p>End~</p>\n<hr>"},{"title":"函数返回数组指针或数组引用","date":"2017-04-15T11:05:14.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n下面就介绍几种方法：\n\n<!--more-->\n\n## 方法一： 使用类型别名\n```C++\ntypedef int arrT[10];       // arrT是一个类型别名，表示的类型\n                            // 是含有10个整型的数组\nusing arrT = int[10];       // arrT的等价声明\narrT* func(int i);          // func返回一个指向含有10个整数的数组的指针\n```\n其中`arrT`是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此`func`函数接受一个`int`实参，返回一个指向包含10个整数的数组的指针。\n\n## 方法二： 声明一个返回数组指针的函数\n要想在声明`func`时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：\n```C++\nint arr[10];            // arr是一个含有10个整数的数组\nint *p1[10];            // p1是一个含有10个指针的数组\nint (*p2)[10] = &arr;   // p2是一个指针，他只想含有10个整数的数组\n```\n和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：\n\n> Type (*function(parameter_list)) [dimension]\n\n类似于其他数组的声明，`Type`表示元素的类型，`dimension`表示数组的大小。`(*function(parameter_list))`两段的括号必须存在，就像定义`p2`时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n```C++\nint (*func(int i)) [10];\n```\n可以按照以下的顺序来逐层理解该声明的含义：\n\n - `func(int i)`表示调用`func`函数时需要一个`int`类型的实参\n - `(*func(int i))`意味这我们可以对函数调用的结果执行解引用操作\n - `(*func(int i)) [10]`表示解引用`func`的调用将得到一个大小是10的数组\n - `int(*func(int i)) [10]`表示数组中元素是`int`类型\n\n## 方法三： 使用尾置返回类型\n在C++11新标准中海油可以简化上述`func`声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：\n\n```C++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*) [10];\n```\n因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。\n\n## 方法四： 使用decltype\n还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个：\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *addPtr(int i)\n{\n    return (i % 2) ? &odd : &even;      // 返回一个指向数组的指针\n}\n```\n`arrPtr`使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与`odd`类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个`*`符号。\n\n## 练习\n### 1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\n```C++\n    string (&func(string (&arr)[10])) [10];\n```\n### 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\n```C++\n// 使用类型别名\nusing arrT = string[10];\narrT& func1(arrT& arr);\n\n// 使用尾置返回类型\nauto func2(arrT& arr)->string(&) [10];\n\n// 使用decltype关键字\nstring arrS[10];\ndecltype(arrS) &func3(arrT& arr);\n```\n### 3. 修改arrPtr函数，使其返回数组的引用\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\ndecltype(odd) &arrPtr(int i)\n{\n    return (i % 2) ? odd : even;\n}\n```\n\n\n","source":"_posts/函数返回数组指针或数组引用.md","raw":"---\ntitle: 函数返回数组指针或数组引用\ndate: 2017-04-15 19:05:14\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags: C++\ncomments: true\n---\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n下面就介绍几种方法：\n\n<!--more-->\n\n## 方法一： 使用类型别名\n```C++\ntypedef int arrT[10];       // arrT是一个类型别名，表示的类型\n                            // 是含有10个整型的数组\nusing arrT = int[10];       // arrT的等价声明\narrT* func(int i);          // func返回一个指向含有10个整数的数组的指针\n```\n其中`arrT`是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此`func`函数接受一个`int`实参，返回一个指向包含10个整数的数组的指针。\n\n## 方法二： 声明一个返回数组指针的函数\n要想在声明`func`时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：\n```C++\nint arr[10];            // arr是一个含有10个整数的数组\nint *p1[10];            // p1是一个含有10个指针的数组\nint (*p2)[10] = &arr;   // p2是一个指针，他只想含有10个整数的数组\n```\n和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：\n\n> Type (*function(parameter_list)) [dimension]\n\n类似于其他数组的声明，`Type`表示元素的类型，`dimension`表示数组的大小。`(*function(parameter_list))`两段的括号必须存在，就像定义`p2`时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n```C++\nint (*func(int i)) [10];\n```\n可以按照以下的顺序来逐层理解该声明的含义：\n\n - `func(int i)`表示调用`func`函数时需要一个`int`类型的实参\n - `(*func(int i))`意味这我们可以对函数调用的结果执行解引用操作\n - `(*func(int i)) [10]`表示解引用`func`的调用将得到一个大小是10的数组\n - `int(*func(int i)) [10]`表示数组中元素是`int`类型\n\n## 方法三： 使用尾置返回类型\n在C++11新标准中海油可以简化上述`func`声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：\n\n```C++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*) [10];\n```\n因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。\n\n## 方法四： 使用decltype\n还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个：\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *addPtr(int i)\n{\n    return (i % 2) ? &odd : &even;      // 返回一个指向数组的指针\n}\n```\n`arrPtr`使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与`odd`类型一致。因为`odd`是数组，所以`arrPtr`返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个`*`符号。\n\n## 练习\n### 1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\n```C++\n    string (&func(string (&arr)[10])) [10];\n```\n### 2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\n```C++\n// 使用类型别名\nusing arrT = string[10];\narrT& func1(arrT& arr);\n\n// 使用尾置返回类型\nauto func2(arrT& arr)->string(&) [10];\n\n// 使用decltype关键字\nstring arrS[10];\ndecltype(arrS) &func3(arrT& arr);\n```\n### 3. 修改arrPtr函数，使其返回数组的引用\n```C++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\ndecltype(odd) &arrPtr(int i)\n{\n    return (i % 2) ? odd : even;\n}\n```\n\n\n","slug":"函数返回数组指针或数组引用","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsjb0046w8vogeupenj4","content":"<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。<br>下面就介绍几种方法：</p>\n<a id=\"more\"></a>\n\n<h2 id=\"方法一：-使用类型别名\"><a href=\"#方法一：-使用类型别名\" class=\"headerlink\" title=\"方法一： 使用类型别名\"></a>方法一： 使用类型别名</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> arrT[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT是一个类型别名，表示的类型</span></span><br><span class=\"line\">                            <span class=\"comment\">// 是含有10个整型的数组</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT的等价声明</span></span><br><span class=\"line\"><span class=\"function\">arrT* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;          <span class=\"comment\">// func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>arrT</code>是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>\n<h2 id=\"方法二：-声明一个返回数组指针的函数\"><a href=\"#方法二：-声明一个返回数组指针的函数\" class=\"headerlink\" title=\"方法二： 声明一个返回数组指针的函数\"></a>方法二： 声明一个返回数组指针的函数</h2><p>要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];            <span class=\"comment\">// arr是一个含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1[<span class=\"number\">10</span>];            <span class=\"comment\">// p1是一个含有10个指针的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p2)[<span class=\"number\">10</span>] = &amp;arr;   <span class=\"comment\">// p2是一个指针，他只想含有10个整数的数组</span></span><br></pre></td></tr></table></figure>\n<p>和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：</p>\n<blockquote>\n<p>Type (*function(parameter_list)) [dimension]</p>\n</blockquote>\n<p>类似于其他数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两段的括号必须存在，就像定义<code>p2</code>时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。</p>\n<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*func(<span class=\"keyword\">int</span> i)) [<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>可以按照以下的顺序来逐层理解该声明的含义：</p>\n<ul>\n<li><code>func(int i)</code>表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参</li>\n<li><code>(*func(int i))</code>意味这我们可以对函数调用的结果执行解引用操作</li>\n<li><code>(*func(int i)) [10]</code>表示解引用<code>func</code>的调用将得到一个大小是10的数组</li>\n<li><code>int(*func(int i)) [10]</code>表示数组中元素是<code>int</code>类型</li>\n</ul>\n<h2 id=\"方法三：-使用尾置返回类型\"><a href=\"#方法三：-使用尾置返回类型\" class=\"headerlink\" title=\"方法三： 使用尾置返回类型\"></a>方法三： 使用尾置返回类型</h2><p>在C++11新标准中海油可以简化上述<code>func</code>声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class=\"line\">auto func(int i) -&gt; int(*) [10];</span><br></pre></td></tr></table></figure>\n<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</p>\n<h2 id=\"方法四：-使用decltype\"><a href=\"#方法四：-使用decltype\" class=\"headerlink\" title=\"方法四： 使用decltype\"></a>方法四： 使用decltype</h2><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数<code>i</code>的不同指向两个已知数组中的某一个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(odd) *addPtr(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;      <span class=\"comment\">// 返回一个指向数组的指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>arrPtr</code>使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个<code>*</code>符号。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"><a href=\"#1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\" class=\"headerlink\" title=\"1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"></a>1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (&amp;func(<span class=\"built_in\">string</span> (&amp;arr)[<span class=\"number\">10</span>])) [<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"><a href=\"#2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\" class=\"headerlink\" title=\"2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"></a>2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"built_in\">string</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\">arrT&amp; <span class=\"title\">func1</span><span class=\"params\">(arrT&amp; arr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用尾置返回类型</span></span><br><span class=\"line\">auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用decltype关键字</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> arrS[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(arrS) &amp;func3(arrT&amp; arr);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-修改arrPtr函数，使其返回数组的引用\"><a href=\"#3-修改arrPtr函数，使其返回数组的引用\" class=\"headerlink\" title=\"3. 修改arrPtr函数，使其返回数组的引用\"></a>3. 修改arrPtr函数，使其返回数组的引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(odd) &amp;arrPtr(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? odd : even;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"length":2209,"excerpt":"<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。<br>下面就介绍几种方法：</p>","more":"<h2 id=\"方法一：-使用类型别名\"><a href=\"#方法一：-使用类型别名\" class=\"headerlink\" title=\"方法一： 使用类型别名\"></a>方法一： 使用类型别名</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> arrT[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT是一个类型别名，表示的类型</span></span><br><span class=\"line\">                            <span class=\"comment\">// 是含有10个整型的数组</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];       <span class=\"comment\">// arrT的等价声明</span></span><br><span class=\"line\"><span class=\"function\">arrT* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;          <span class=\"comment\">// func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>arrT</code>是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>\n<h2 id=\"方法二：-声明一个返回数组指针的函数\"><a href=\"#方法二：-声明一个返回数组指针的函数\" class=\"headerlink\" title=\"方法二： 声明一个返回数组指针的函数\"></a>方法二： 声明一个返回数组指针的函数</h2><p>要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];            <span class=\"comment\">// arr是一个含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1[<span class=\"number\">10</span>];            <span class=\"comment\">// p1是一个含有10个指针的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p2)[<span class=\"number\">10</span>] = &amp;arr;   <span class=\"comment\">// p2是一个指针，他只想含有10个整数的数组</span></span><br></pre></td></tr></table></figure>\n<p>和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：</p>\n<blockquote>\n<p>Type (*function(parameter_list)) [dimension]</p>\n</blockquote>\n<p>类似于其他数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两段的括号必须存在，就像定义<code>p2</code>时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。</p>\n<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*func(<span class=\"keyword\">int</span> i)) [<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>可以按照以下的顺序来逐层理解该声明的含义：</p>\n<ul>\n<li><code>func(int i)</code>表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参</li>\n<li><code>(*func(int i))</code>意味这我们可以对函数调用的结果执行解引用操作</li>\n<li><code>(*func(int i)) [10]</code>表示解引用<code>func</code>的调用将得到一个大小是10的数组</li>\n<li><code>int(*func(int i)) [10]</code>表示数组中元素是<code>int</code>类型</li>\n</ul>\n<h2 id=\"方法三：-使用尾置返回类型\"><a href=\"#方法三：-使用尾置返回类型\" class=\"headerlink\" title=\"方法三： 使用尾置返回类型\"></a>方法三： 使用尾置返回类型</h2><p>在C++11新标准中海油可以简化上述<code>func</code>声明的方法，就是使用**尾置返回类型(trailing return type)**。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class=\"line\">auto func(int i) -&gt; int(*) [10];</span><br></pre></td></tr></table></figure>\n<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</p>\n<h2 id=\"方法四：-使用decltype\"><a href=\"#方法四：-使用decltype\" class=\"headerlink\" title=\"方法四： 使用decltype\"></a>方法四： 使用decltype</h2><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数<code>i</code>的不同指向两个已知数组中的某一个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(odd) *addPtr(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;      <span class=\"comment\">// 返回一个指向数组的指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>arrPtr</code>使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个<code>*</code>符号。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"><a href=\"#1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\" class=\"headerlink\" title=\"1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。\"></a>1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (&amp;func(<span class=\"built_in\">string</span> (&amp;arr)[<span class=\"number\">10</span>])) [<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"><a href=\"#2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\" class=\"headerlink\" title=\"2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。\"></a>2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> arrT = <span class=\"built_in\">string</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\">arrT&amp; <span class=\"title\">func1</span><span class=\"params\">(arrT&amp; arr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用尾置返回类型</span></span><br><span class=\"line\">auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用decltype关键字</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> arrS[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(arrS) &amp;func3(arrT&amp; arr);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-修改arrPtr函数，使其返回数组的引用\"><a href=\"#3-修改arrPtr函数，使其返回数组的引用\" class=\"headerlink\" title=\"3. 修改arrPtr函数，使其返回数组的引用\"></a>3. 修改arrPtr函数，使其返回数组的引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(odd) &amp;arrPtr(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? odd : even;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"给出一个表达式，按照顺序求出表达式的值","date":"2017-03-25T14:54:21.000Z","updated":"2019-01-07T13:44:48.000Z","comments":1,"_content":"## 按顺序求出表达式的值\n今天碰到一个题目：\n**题目描述：**\n> 常规的表达式求值，我们都会根据计算的优先级来计算， 比如`*`、`/`的优先级就高于`+`、`-`。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有`/`，只有(`+`,`-`和`*`)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。\n\n**输入描述：**\n> 输入为一行字符串，即一个表达式。其中运算符只有`+`,`-`和`*`。参与计算的数字只有0-9。\n保证表达式是合法的，排列规则如样例所示。\n\n**输出描述**\n> 输出一个数，即表达式的值\n\n<!--more-->\n\n**输入例子**\n> 3+5*7\n\n**输出例子**\n> 56\n\n刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的...\n\n## C++实现\n``` C++\n/*\n * 输入字符串表达式，按照输入顺序求出表达式的结果\n */\n\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<cmath>\n\nusing namespace std;\n\n// 字符串转数字\nint get_number(string num_str)\n{\n\tstringstream stream;\t// 声明stringstram变量\n\tint result = 0;\n\tint str_len = num_str.length();\n\tstream << num_str;\n\tstream >> result;\n\treturn result;\n}\n\nint main()\n{\n\tstring s;\t\t// 保存输入的字符串\n\tcout << \"请输入要计算的表达式(不包含除):\" << endl;\n\tcin >> s;\n\tint number[100] = { 0 };\t\t// 保存数字的数组\n\tstring operator_str;\t\t// 保存操作符的字符串\n\tint length = s.length();\n\tstring number_str;\t\t// 保存每个操作符之前的字符串\n\tint index = 0;\t// 标记保存数字的数组的指针\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (s[i] >= '0' && s[i] <= '9')\t\t// 如果是数字，则存入 number_str\n\t\t{\n\t\t\tnumber_str += s[i];\n\t\t}\n\t\telse\t\t// 如果是操作符，存入operator_str\n\t\t{\n\t\t\toperator_str += s[i];\n\t\t\tnumber[index] = get_number(number_str);\t\t// 得到两个操作符之间的操作数，并存入数组\n\t\t\tindex++;\n\t\t\tnumber_str = \"\";\t\t\t// 将字符串置为空，重新存入下一个操作数的字符串\n\t\t}\n\t\tif (i == length -1)\t\t// 得到表达式的最后一个操作数\n\t\t{\n\t\t\tnumber[index] = get_number(number_str);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tint result = 0;\t\t// 计算结果\n\tfor (int i = 0; i < index; i++)\n\t{\n\t\t//todo 计算结果\n\t\tif (i<1)\n\t\t{\n\t\t\tresult += number[i];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tswitch (operator_str[i-1])\n\t\t\t{\n\t\t\tcase '+':\n\t\t\t\tresult = result + number[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult = result - number[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result * number[i];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << number[i] << endl;\n\t}\n\t//for (int i = 0; i < operator_str.length(); i++)\n\t//{\n\t//\tcout << operator_str[i] << endl;\n\t//}\n\t//cout << \"输入的字符串为:\" << s << \" 得到的数字为: \" << number << endl;\n\n\tcout << \"Result = \" << result << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n挺简单的题目，居然写了这么多！ _ _(:3」∠)_ _\n太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง\n\nEnd~\n","source":"_posts/给出一个表达式，按照顺序求出表达式的值.md","raw":"---\ntitle: 给出一个表达式，按照顺序求出表达式的值\ndate: 2017-03-25 22:54:21\nupdated: 2019-01-07 21:44:48\ncategory: CPP\ntags:\n- C++\n- String\ncomments: true\n---\n## 按顺序求出表达式的值\n今天碰到一个题目：\n**题目描述：**\n> 常规的表达式求值，我们都会根据计算的优先级来计算， 比如`*`、`/`的优先级就高于`+`、`-`。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有`/`，只有(`+`,`-`和`*`)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。\n\n**输入描述：**\n> 输入为一行字符串，即一个表达式。其中运算符只有`+`,`-`和`*`。参与计算的数字只有0-9。\n保证表达式是合法的，排列规则如样例所示。\n\n**输出描述**\n> 输出一个数，即表达式的值\n\n<!--more-->\n\n**输入例子**\n> 3+5*7\n\n**输出例子**\n> 56\n\n刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的...\n\n## C++实现\n``` C++\n/*\n * 输入字符串表达式，按照输入顺序求出表达式的结果\n */\n\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<cmath>\n\nusing namespace std;\n\n// 字符串转数字\nint get_number(string num_str)\n{\n\tstringstream stream;\t// 声明stringstram变量\n\tint result = 0;\n\tint str_len = num_str.length();\n\tstream << num_str;\n\tstream >> result;\n\treturn result;\n}\n\nint main()\n{\n\tstring s;\t\t// 保存输入的字符串\n\tcout << \"请输入要计算的表达式(不包含除):\" << endl;\n\tcin >> s;\n\tint number[100] = { 0 };\t\t// 保存数字的数组\n\tstring operator_str;\t\t// 保存操作符的字符串\n\tint length = s.length();\n\tstring number_str;\t\t// 保存每个操作符之前的字符串\n\tint index = 0;\t// 标记保存数字的数组的指针\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (s[i] >= '0' && s[i] <= '9')\t\t// 如果是数字，则存入 number_str\n\t\t{\n\t\t\tnumber_str += s[i];\n\t\t}\n\t\telse\t\t// 如果是操作符，存入operator_str\n\t\t{\n\t\t\toperator_str += s[i];\n\t\t\tnumber[index] = get_number(number_str);\t\t// 得到两个操作符之间的操作数，并存入数组\n\t\t\tindex++;\n\t\t\tnumber_str = \"\";\t\t\t// 将字符串置为空，重新存入下一个操作数的字符串\n\t\t}\n\t\tif (i == length -1)\t\t// 得到表达式的最后一个操作数\n\t\t{\n\t\t\tnumber[index] = get_number(number_str);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tint result = 0;\t\t// 计算结果\n\tfor (int i = 0; i < index; i++)\n\t{\n\t\t//todo 计算结果\n\t\tif (i<1)\n\t\t{\n\t\t\tresult += number[i];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tswitch (operator_str[i-1])\n\t\t\t{\n\t\t\tcase '+':\n\t\t\t\tresult = result + number[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult = result - number[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result * number[i];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << number[i] << endl;\n\t}\n\t//for (int i = 0; i < operator_str.length(); i++)\n\t//{\n\t//\tcout << operator_str[i] << endl;\n\t//}\n\t//cout << \"输入的字符串为:\" << s << \" 得到的数字为: \" << number << endl;\n\n\tcout << \"Result = \" << result << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n挺简单的题目，居然写了这么多！ _ _(:3」∠)_ _\n太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง\n\nEnd~\n","slug":"给出一个表达式，按照顺序求出表达式的值","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsjb0047w8vo9y46gh1u","content":"<h2 id=\"按顺序求出表达式的值\"><a href=\"#按顺序求出表达式的值\" class=\"headerlink\" title=\"按顺序求出表达式的值\"></a>按顺序求出表达式的值</h2><p>今天碰到一个题目：<br><strong>题目描述：</strong></p>\n<blockquote>\n<p>常规的表达式求值，我们都会根据计算的优先级来计算， 比如<code>*</code>、<code>/</code>的优先级就高于<code>+</code>、<code>-</code>。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有<code>/</code>，只有(<code>+</code>,<code>-</code>和<code>*</code>)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。</p>\n</blockquote>\n<p><strong>输入描述：</strong></p>\n<blockquote>\n<p>输入为一行字符串，即一个表达式。其中运算符只有<code>+</code>,<code>-</code>和<code>*</code>。参与计算的数字只有0-9。<br>保证表达式是合法的，排列规则如样例所示。</p>\n</blockquote>\n<p><strong>输出描述</strong></p>\n<blockquote>\n<p>输出一个数，即表达式的值</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p><strong>输入例子</strong></p>\n<blockquote>\n<p>3+5*7</p>\n</blockquote>\n<p><strong>输出例子</strong></p>\n<blockquote>\n<p>56</p>\n</blockquote>\n<p>刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的…</p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 输入字符串表达式，按照输入顺序求出表达式的结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_number</span><span class=\"params\">(<span class=\"built_in\">string</span> num_str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stringstream</span> stream;\t<span class=\"comment\">// 声明stringstram变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> str_len = num_str.length();</span><br><span class=\"line\">\tstream &lt;&lt; num_str;</span><br><span class=\"line\">\tstream &gt;&gt; result;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> s;\t\t<span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入要计算的表达式(不包含除):&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> number[<span class=\"number\">100</span>] = &#123; <span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 保存数字的数组</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> operator_str;\t\t<span class=\"comment\">// 保存操作符的字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length = s.length();</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> number_str;\t\t<span class=\"comment\">// 保存每个操作符之前的字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;\t<span class=\"comment\">// 标记保存数字的数组的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>)\t\t<span class=\"comment\">// 如果是数字，则存入 number_str</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnumber_str += s[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>\t\t<span class=\"comment\">// 如果是操作符，存入operator_str</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toperator_str += s[i];</span><br><span class=\"line\">\t\t\tnumber[index] = get_number(number_str);\t\t<span class=\"comment\">// 得到两个操作符之间的操作数，并存入数组</span></span><br><span class=\"line\">\t\t\tindex++;</span><br><span class=\"line\">\t\t\tnumber_str = <span class=\"string\">&quot;&quot;</span>;\t\t\t<span class=\"comment\">// 将字符串置为空，重新存入下一个操作数的字符串</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == length <span class=\"number\">-1</span>)\t\t<span class=\"comment\">// 得到表达式的最后一个操作数</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnumber[index] = get_number(number_str);</span><br><span class=\"line\">\t\t\tindex++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 计算结果</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//todo 计算结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tresult += number[i];</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (operator_str[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result + number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result - number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result * number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; number[i] &lt;&lt; endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//for (int i = 0; i &lt; operator_str.length(); i++)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tcout &lt;&lt; operator_str[i] &lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; &quot;输入的字符串为:&quot; &lt;&lt; s &lt;&lt; &quot; 得到的数字为: &quot; &lt;&lt; number &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Result = &quot;</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>挺简单的题目，居然写了这么多！ _ <em>(:3」∠)</em> _<br>太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง</p>\n<p>End~</p>\n","site":{"data":{}},"length":2184,"excerpt":"<h2 id=\"按顺序求出表达式的值\"><a href=\"#按顺序求出表达式的值\" class=\"headerlink\" title=\"按顺序求出表达式的值\"></a>按顺序求出表达式的值</h2><p>今天碰到一个题目：<br><strong>题目描述：</strong></p>\n<blockquote>\n<p>常规的表达式求值，我们都会根据计算的优先级来计算， 比如<code>*</code>、<code>/</code>的优先级就高于<code>+</code>、<code>-</code>。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有<code>/</code>，只有(<code>+</code>,<code>-</code>和<code>*</code>)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。</p>\n</blockquote>\n<p><strong>输入描述：</strong></p>\n<blockquote>\n<p>输入为一行字符串，即一个表达式。其中运算符只有<code>+</code>,<code>-</code>和<code>*</code>。参与计算的数字只有0-9。<br>保证表达式是合法的，排列规则如样例所示。</p>\n</blockquote>\n<p><strong>输出描述</strong></p>\n<blockquote>\n<p>输出一个数，即表达式的值</p>\n</blockquote>","more":"<p><strong>输入例子</strong></p>\n<blockquote>\n<p>3+5*7</p>\n</blockquote>\n<p><strong>输出例子</strong></p>\n<blockquote>\n<p>56</p>\n</blockquote>\n<p>刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的…</p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 输入字符串表达式，按照输入顺序求出表达式的结果</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_number</span><span class=\"params\">(<span class=\"built_in\">string</span> num_str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stringstream</span> stream;\t<span class=\"comment\">// 声明stringstram变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> str_len = num_str.length();</span><br><span class=\"line\">\tstream &lt;&lt; num_str;</span><br><span class=\"line\">\tstream &gt;&gt; result;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> s;\t\t<span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入要计算的表达式(不包含除):&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> number[<span class=\"number\">100</span>] = &#123; <span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 保存数字的数组</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> operator_str;\t\t<span class=\"comment\">// 保存操作符的字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length = s.length();</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> number_str;\t\t<span class=\"comment\">// 保存每个操作符之前的字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;\t<span class=\"comment\">// 标记保存数字的数组的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>)\t\t<span class=\"comment\">// 如果是数字，则存入 number_str</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnumber_str += s[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>\t\t<span class=\"comment\">// 如果是操作符，存入operator_str</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toperator_str += s[i];</span><br><span class=\"line\">\t\t\tnumber[index] = get_number(number_str);\t\t<span class=\"comment\">// 得到两个操作符之间的操作数，并存入数组</span></span><br><span class=\"line\">\t\t\tindex++;</span><br><span class=\"line\">\t\t\tnumber_str = <span class=\"string\">&quot;&quot;</span>;\t\t\t<span class=\"comment\">// 将字符串置为空，重新存入下一个操作数的字符串</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == length <span class=\"number\">-1</span>)\t\t<span class=\"comment\">// 得到表达式的最后一个操作数</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnumber[index] = get_number(number_str);</span><br><span class=\"line\">\t\t\tindex++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 计算结果</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//todo 计算结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tresult += number[i];</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (operator_str[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result + number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result - number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tresult = result * number[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; number[i] &lt;&lt; endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//for (int i = 0; i &lt; operator_str.length(); i++)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tcout &lt;&lt; operator_str[i] &lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; &quot;输入的字符串为:&quot; &lt;&lt; s &lt;&lt; &quot; 得到的数字为: &quot; &lt;&lt; number &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Result = &quot;</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>挺简单的题目，居然写了这么多！ _ <em>(:3」∠)</em> _<br>太久没写了，写的有点丑¬_¬，看来还是要多练习 (ง •̀_•́)ง</p>\n<p>End~</p>"},{"title":"OpenStack Neutron -- Linux 虚拟网络基础","date":"2019-05-14T03:59:26.000Z","updated":"2019-05-14T04:28:54.000Z","comments":1,"header_image":"/images/bing/BingWallPaper-2019-05-14.jpg","_content":"\nNeutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。\n<!--more-->\n\n## TAP/TUN\n\nTAP/TUN 是 Linux 内核实现的一对虚拟网络设备。TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过 TAP/TUN 设备发送数据。\n\nLinux 中设备的含义并不是指实际的物理硬件，而是一个类似于数据结构、内核模块或设备驱动。像 TAP/TUN 这样的设备，其数据结构如下：\n\n```c\nstruct tun_struct {\n    char name[8];\t\t\t\t// 设备名\n    unsigned long flags;\t\t\t// 区分 TAP 和 TUN 设备\n    struct fasync_struct *fasync;\t\t// 文件异步通知结构\n    wait_queue_head_t read_wait;\t\t// 文件等待队列\n    struct net_device dev;\t\t\t// Linux 抽象网络设备结构\n    struct sk_buff_head txq;\t\t\t// 网络缓冲区队列\n    struct net_device_status stats;\t\t// 网卡状态信息结构\n};\n```\n\nTAP 与 TUN 的定义相同，通过 `flags` 来进行区分。但是从其背后所承载的功能而言，两者有着较大的区别：TAP 位于网络 OSI 模型的第二层（数据链路层），TUN 位于第三层（网络层）。\n\nTAP 从功能定位上来讲，位于数据链路层，数据链路层的主要协议有：\n\n1. 点对点协议（Point-to-Point Protocol）\n2. 以太网（Ethernet）\n3. 高级数据链路协议（High-Level Data Link Protocol）\n4. 帧中继（Frame Relay）\n5. 异步传输模式（Asynchronous Transfer Mode）\n\n但是 TAP 只与以太网（Ethernet）协议对于。所以，TAP 有时也称为“虚拟以太设备”。\n\n想要使用 Linux 命令行（基于 CentOS7 x86_64）操作一个 TAP，首先需要 Linux tun 模块：\n\n```bash\n# 如果输入 Linux 命令 modinfo tun，有如下输出，则说明有 tun 模块\nmodinfo tun\nfilename:\t/lib/modules/3.10.0-862.14.4.el7.x86_64/kernel/drivers/net/tun.ko.xz\nalias:\t\tdevname:net/tun\nalias:\t\tchar-major-10-200\n......\n```\n\n当 Linux 版本具有 tun 模块时，还需要查看其是否已经加载：\n\n```bash\nlsmod | grep tun\ntun 31665 1\n```\n\n如果已经加载，则会出现上述的”tun ***“那一行。如果没有加载，则可使用如下命令进行加载：\n\n```bash\nmodprob tun\n```\n\n当确认 Linux 加载 tun 模块之后，还需要确认 Linux 是否操作 TAP/TUN 的命令行工具 tunctl：\n\n```bash\ntunctl help\n```\n\n如果 Linux 有输出，则说明已有命令行工具，否则表示当前 Linux 系统并没有安装 tunctl，可以通过如下命令进行安装：\n\n```bash\nyum install tunctl\n```\n\n{% blockquote %}若安装时出现 no package tunctl avaliable 时，需要手动添加安装源：\n1. 添加安装源配置文件 /etc/yun.repos.d/nux-misc.repo：\n\n{% codeblock lang:ini %}\n[nux-misc]\nname=Nux Misc\nbaseurl=http://li.nux.ro/download/nux/misc/el7/x86_64\nenabled=0\ngpgcheck=1\ngpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro\n{% endcodeblock %}\n\n2. 重新执行安装命令：\n\n{% codeblock lang:bash %}\nyum --enablerepo=nux-misc install tunctl\n{% endcodeblock %}\n\nref: [CentOS 7 安装tunctl](<https://blog.csdn.net/lopng/article/details/72821438>)  \n{% endblockquote %}\n具备了 tun 和 tunctl 后，就可以创建一个 TAP 设备了：\n\n```bash\ntunctl -t tap_test\nSet 'tap_test' persistent and owned by uid 0\n```\n\n可以通过如下命令来查看所创建的 TAP（名字为 `tap_test`）：\n\n```bash\nip link list\n```\n\n也可以通过如下命令查看：\n\n```bash\nifconfig -a\n```\n\n通过 tunctl 创建的 `tap_test` 还未绑定 IP 地址，可以通过如下命令进行绑定：\n\n```bash\n# 使用 ip addr 命令绑定 IP 地址\nip addr add local 192.168.100.1/24 dev tap_test\n# 或者使用 ifconfig 命令绑定 IP 地址\nifconfig tap_test 192.168.100.1/24\n```\n\n使用 `ifconfig -a` 命令再次查看，可以发现 `tap_test` 已绑定了所设置的 IP 地址。\n\n## namespace\n\nnamespace 是 Linux 虚拟网络的一个重要概念。传统 Linux 的许多资源是全局的，比如进程 ID 资源。而 namespace 的目的就是将这些资源进行隔离。Linux 可以在一个 Host 内创建许多 namespace，于是那些原本是 Linux 全局的资源，就变成了 namespace 范围内的”全局“资源，而且不同的 namespace 的资源互不可见、彼此透明（感觉类似于 C/C++ 的 namespace）。\n\nLinux 内核对哪些资源进行了隔离可以从 include/linux/nsproxy.h 中看出：\n\n```c\n// nsproxy.h\nstruct nsproxy {\n    atomic_t count;\n    struct uts_namepsace *uts_ns;\n    struct ipc_namespace *ipc_ns;\n    struct mnt_namespace *mnt_ns;\n    struct pid_namespace *pid_ns;\n    struct user_namepsace *user_ns;\n    struct net *net_ns;\n};\n```\n\n以上 6 个资源就是 Linux namespace 所隔离的资源，其含义如下表：\n\n|  资源   | 含义                                                         |\n| :-----: | :----------------------------------------------------------- |\n| uts_ns  | UTS 为 Unix Timesharing System 的简称，包含内存名称、版本、底层体系结构等信息 |\n| ipc_ns  | 所有与进程间通信（IPC）有关的信息                            |\n| mnt_ns  | 当前装载的文件系统                                           |\n| pid_ns  | 有关进程 ID 的信息                                           |\n| user_ns | 资源配额的信息                                               |\n| net_ns  | 网络信息                                                     |\n\n单纯从网络角度来看，一个 namespace 提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP 路由、防火墙规则、sockets 等）。一个设备（Linux Device）只能位于一个 namespace 中，不同 namespace 中的设备可以利用 veth pair 进行桥接。\n\nLinux 操作 namespace 的命令为 `ip netns`，可以通过如下命令查看其功能：\n\n```bash\nip netns help\nUsage:\tip netns list\n\tip netns add NAME\n\tip netns set NAME NETNSID\n\tip [-all] netns delete [NAME]\n\tip netns identify [PID]\n\tip netns pids NAME\n\tip [-all] netns exec [name] cmd ...\n\tip netns monitor\n\tip netns list-id\n```\n\n首先可以创建一个 namespace ：\n\n```bash\n# 首先查看当前的 namespace 列表\nip netns list\n# 由于当前没有 namespace，所以命令行没有任何返回\n# 创建一个 namespace，命名为 ns_test\nip netns add ns_test\n#在此查看当前 namespace 列表，可以发现刚刚创建的 namespace: ns_test\nip netns list\nns_test # 这个是 ip netns list 的返回值\n```\n\n当我们创建一个 namespace 后，可以将原来创建的虚拟设备 tap_test 迁移到这个 namespace 中去，命令如下：\n\n```bash\nip link set tap_test netns ns_test\n```\n\n这个时候，在原来的 host/vm 里再执行 `ip link list` 命令，就会发现设备 `tap_test` 消失了，因为我们已经将其迁移到 `ns_test` 中去了。\n\n通过一下命令可以查看或者操作 namespace 里的设备：\n\n```bash\nip [-all] netns exec [NAME] cmd ...\t\t# cmd 为想要操作的命令\n```\n\n比如要管理 `ns_test` 里面的设备，执行命令如下：\n\n1. 在 `ns_test` 里执行 `ip link list`\n\n```bash\nip netns exec ns_test ip link list\n```\n\n2. 在 ` ns_test` 里执行 `ifconfig -a`\n\n```bash\nip netns exec ns_test ifconfig -a\n```\n\n3. 绑定 IP 地址\n\n```bash\nip netns exec ns_test ifconfig tap_test 192.168.50.1/24 up\n```\n\n4. 查看 IP 地址\n\n```bash\nip netns exec ns_test ifconfig -a\n```\n\n## veth pair\n\nveth pair 不是一个设备，而是一对设备，用以连接两个虚拟以太端口。操作 veth pair，需要结合 namespace，不然就没有意义。下面举一个例子，两个 namespace ns1/ns2 中各有一组 tap 组成 veth pair，两者的 IP 地址分别为 192.168.50.1 和 192.168.50.2，两个 IP 进行互 ping 测试，ping 通表示测试通过。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap2\n# 2. 创建 namespace: ns1、ns2\nip netns add ns1\nip netns add ns2\n# 3. 把两个 tap 分别迁移到对应的 namespace 中\nip link set tap1 netns ns1\nip link set tap2 netns ns2\n# 4. 分别给两个 tap 绑定 IP 地址\nip netns exec ns1 ip addr add local 192.168.50.1/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.50.2/24 dev tap2\n# 5. 将两个 tap 设置为 up\nip netns exec ns1 ifconfig tap1 up\nip netns exec ns2 ifconfig tap2 up\n# 6. ping\nip netns exec ns2 ping 192.168.50.1\t\t# ping ns1 中的 tap\n...\t\t# 输出结果\nip netns exec ns1 ping 192.168.50.2\t\t# ping ns2 中的 tap\n...\t\t# 输出结果\n```\n\n上述用例给出了 veth pair 连接两个namespace 的方法，veth pair 只有一对 tap，如果需要实现两个 以上的namespace 互通，则 veth pair 无法满足需求。\n\n## Bridge\n\nBridge/Switch 可以实现两个以上 namespace 之间的互通。在 Linux 的语境里，Bridge（网桥）与 Switch（交换机）是一个概念，这里也不对两者进行区分。Linux 中实现 Bridge 功能的是 brctl 模块。在命令行中输入 `brctl` 可以查看是否正确安装模块：\n\n```bash\nbrctl\nUsage: brctl [Commands]\ncommands:\n\taddbr\t\t\t<bridge>\t\t\tadd bridge\n\tdelbr\t\t\t<bridge>\t\t\tdelete bridge\n\taddif\t\t\t<bridge> <device>\t\tadd interface to bridge\n\tdelif\t\t\t<bridge> <device>\t\tdelete interface from bridge\n\thairpin\t\t\t<bridge> <port> {on|off}\tturn hairpin on/off\n\tsetageing\t\t<bridge> <time>\t\t\tset ageing time\n\tsetbridgeprio\t        <bridge> <prio>\t\t\tset bridge priority\n\tsetfd\t\t\t<bridge> <time>\t\t\tset bridge forward delay\n\tsethello\t\t<bridge> <time>\t\t\tset hello time\n\tsetmaxage\t\t<bridge> <time>\t\t\tset max message age\n\tsetpathcost\t\t<bridge> <prot> <cost>\t\tset path cost\n\tsetportprio\t\t<bridge> <prot> <prio>\t\tset port priority\n\tshow\t\t\t[ <bridge> ]\t\t\tshow a list of bridges\n\tshowmacs\t\t<bridge>\t\t\tshow a list of mac addrs\n\tshowstp\t\t\t<bridge>\t\t\tshow bridge stp info\n\tstp\t\t\t<bridge> {on|off}\t\tturn stp on/off\n```\n\n若未安装，可通过如下命令进行安装：\n\n```bash\nyum install bridge-utils\n```\n\n接下来也通过一个例子来说明 Bridge 的基本用法，同时也涵盖了之前所述的几个概念：tap、namespace、veth pair。样例中有 4 个 namespace，每个 namespace 都有一个 tap 与交换机上一个 tap 口组成 veth pair。这样 4 个 namespace 就通过 veth pair 及 Bridge 互联起来。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap1_peer\nip link add tap2 type veth peer name tap2_peer\nip link add tap3 type veth peer name tap3_peer\nip link add tap4 type veth peer name tap4_peer\n# 2. 创建 namespace\nip netns add ns1\nip netns add ns2\nip netns add ns3\nip netns add ns4\n# 3. 把 tap 迁移到相应的 namespace 中\nip link set tap1 netns ns1\nip link set tap2 netns ns2\nip link set tap3 netns ns3\nip link set tap4 netns ns4\n# 4. 创建 Bridge\nbrctl addbr br1\n# 5. 把相应的 tap 添加到 Bridge 中\nbrctl addif br1 tap1_peer\nbrctl addif br1 tap2_peer\nbrctl addif br1 tap3_peer\nbrctl addif br1 tap4_peer\n# 6. 配置相应 tap 的 IP 地址\nip netns exec ns1 ip addr add local 192.168.50.1/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.50.2/24 dev tap2\nip netns exec ns3 ip addr add local 192.168.50.3/24 dev tap3\nip netns exec ns4 ip addr add local 192.168.50.4/24 dev tap4\n# 7. 将 Bridge 及所有 tap 状态设置为 up\nip link set br1 up\nip link set tap1_peer up\nip link set tap2_peer up\nip link set tap3_peer up\nip link set tap4_peer up\nip netns exec ns1 ip link set tap1 up\nip netns exec ns2 ip link set tap2 up\nip netns exec ns3 ip link set tap3 up\nip netns exec ns4 ip link set tap4 up\n# 8. 互 ping 测试\nip netns exec ns1 ping 192.168.50.2\nip netns exec ns1 ping 192.168.50.3\nip netns exec ns1 ping 192.168.50.4\n...\nip netns exec ns4 ping 192.168.50.1\nip netns exec ns4 ping 192.168.50.2\nip netns exec ns4 ping 192.168.50.3\n```\n\n若能够互相 ping 通，则表示测试通过。\n\n## Router\n\nLinux 中 Router 能够用于不同网段之间的互通。通过如下命令可以查看系统是否开启路由转发功能：\n\n```bash\nless /proc/sys/net/ipv4/if_forward\n```\n\n如果返回的结果是 `0`，则表示未开启，若为 `1`，则表示已开启路由转发功能。可以修改配置文件 “/etc/systcl.conf”，将 `net.ipv4.ip_forward` 的值修改为 `1` 来开启该功能。\n\n下面举个例子，用于说明 Router 的作用。分别设计 ns1/tap1 和 ns2/tap2，且它们不在同一个网段中，中间需要经过一个路由转发才能互通。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap1_peer\nip link add tap2 type veth peer name tap2_peer\n# 2. 创建 namespace\nip netns add ns1\nip netns add ns2\n# 3. 将 tap 迁移到 namespace\nip link set tap1 netns ns1\nip link set tap2 netns ns2\n# 4. 配置 tap IP 地址\nip addr add local 192.168.100.1/24 dev tap1_peer\nip addr add local 192.168.200.1/24 dev tap2_peer\nip netns exec ns1 ip addr add local 192.168.100.2/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.200.2/24 dev tap2\n# 5. 将 tap 设置为 up\nip link set tap1_peer up\nip link set tap2_peer up\nip netns exec ns1 ip link set tap1 up\nip netns exec ns2 ip link set tap2 up\n# 6. 为 ns1、ns2 添加静态路由，分别到达对方的网段\nip netns exec ns1 route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.100.1\nip netns exec ns2 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.200.1\n# 7. 互 ping 测试\nip netns exec ns1 ping 192.168.200.2\n...\nip netns exec ns2 ping 192.168.100.2\n...\n```\n\n能够互相 ping 通表示测试通过。\n\n添加了静态路由信息后，可以使用如下命令查看 namespace 的路由表：\n\n```bash\nip netns exec ns1 route -nee\n...\nip netns exec ns1 route -nee\n...\n```\n\n上述命令可以分别查看 ns1 和 ns2 的路由表信息。\n\n## tun\n\ntun 是一个网络层（IP）的点对点设备，它启用了 IP 层隧道功能。Linux 原生支持的三层隧道，可以通过 `ip tunnle help` 查看。\n\nLinux 一共原生支持 5 种三层隧道（tunnel），如表所示：\n\n|  隧道  | 简述                                                         |\n| :----: | :----------------------------------------------------------- |\n|  ipip  | IP in IP，在 IPv4 报文的基础上再封装一个 IPv4 报文头，属于 IPv4 in IPv4 |\n|  gre   | 通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于 IPv4/IPv6 over IPv4 |\n|  sit   | 与 ipip 类似，用一个IPv4 的报文头封装 IPv6 的报文，属于 IPv6 over IPv4 |\n| isatap | 站内自动隧道寻址协议，一般用于 IPv4 网络中的 IPv6/IPv4 节点间的通信 |\n|  vti   | 全称是 Virtual Tunnel Interface，为 IPsec 隧道提供了一个可路由的接口类型 |\n\n下面给出 tun 的具体用例来进行说明，以 ipip tunnel为例进行配置。在上一节 Router 的基础上，分别在 ns1 和 ns2 中添加 tun1 和 tun2，tun1 和 tun2 不互通，且与 tap1、tap2也没有关系。\n\n```bash\n# 1. 加载 ipip 模块，可通过 lsmod | grep ip 命令查看是否加载\nmodprobe ipip\n# 2. 在 ns1 上创建 tun1 和 ipip tunnel\nip netns exec ns1 ip tunnel add tun1 mode ipip remote 192.168.200.2 local 192.168.100.2 ttl 255\t\t# 创建 tun1，模式为 ipip，分别配置远端地址和近端（本地）地址以及 ttl\nip netns exec ns1 ip link set tun1 up\t\t# 启动 tun1\nip netns exec ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1\t\t# 为 tun1 添加 ipip 隧道的内层 IP 地址，并设置对端的 ipip 隧道内层 IP 地址\n# 3. 在 ns2 上创建 tun2 和 ipip tunnel\nip netns exec ns2 ip tunnel add tun2 mode ipip remote 192.168.100.2 local 192.168.200.2 ttl 255\nip netns exec ns2 ip link set tun2 up\nip netns exec ns2 ip addr add 192.168.60.10 peer 192.168.50.10 dev tun2\n# 4. 互 ping 测试 （测试时遇到了问题，在 CentOS 7 系统下，按照上述命令无法实现两个 tun ping 通，但是前面的 Router 是可以的，原因未知。）\nip netns exec ns1 ping 192.168.60.10\n...\nip netns exec ns2 ping 192.168.50.10\n...\n```\n\n> 将上述命令中的 `ipip` 改为 `gre`，其余保持不变，即可创建一个 gre 隧道的 tun 设备对。\n\n查看 ns1 的路由表，发现已添加了一个直连路由条目，从 tun1 可以直接到达 192.168.60.10，ns2 亦然。\n","source":"_posts/OpenStack-Neutron-Linux-Virtual-Network.md","raw":"---\ntitle: OpenStack Neutron -- Linux 虚拟网络基础\ndate: 2019-05-14 11:59:26\nupdated: 2019-05-14 12:28:54\ncategory: OpenStack\ntags: [Neutron]\ncomments: true\nheader_image: /images/bing/BingWallPaper-2019-05-14.jpg\n---\n\nNeutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。\n<!--more-->\n\n## TAP/TUN\n\nTAP/TUN 是 Linux 内核实现的一对虚拟网络设备。TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过 TAP/TUN 设备发送数据。\n\nLinux 中设备的含义并不是指实际的物理硬件，而是一个类似于数据结构、内核模块或设备驱动。像 TAP/TUN 这样的设备，其数据结构如下：\n\n```c\nstruct tun_struct {\n    char name[8];\t\t\t\t// 设备名\n    unsigned long flags;\t\t\t// 区分 TAP 和 TUN 设备\n    struct fasync_struct *fasync;\t\t// 文件异步通知结构\n    wait_queue_head_t read_wait;\t\t// 文件等待队列\n    struct net_device dev;\t\t\t// Linux 抽象网络设备结构\n    struct sk_buff_head txq;\t\t\t// 网络缓冲区队列\n    struct net_device_status stats;\t\t// 网卡状态信息结构\n};\n```\n\nTAP 与 TUN 的定义相同，通过 `flags` 来进行区分。但是从其背后所承载的功能而言，两者有着较大的区别：TAP 位于网络 OSI 模型的第二层（数据链路层），TUN 位于第三层（网络层）。\n\nTAP 从功能定位上来讲，位于数据链路层，数据链路层的主要协议有：\n\n1. 点对点协议（Point-to-Point Protocol）\n2. 以太网（Ethernet）\n3. 高级数据链路协议（High-Level Data Link Protocol）\n4. 帧中继（Frame Relay）\n5. 异步传输模式（Asynchronous Transfer Mode）\n\n但是 TAP 只与以太网（Ethernet）协议对于。所以，TAP 有时也称为“虚拟以太设备”。\n\n想要使用 Linux 命令行（基于 CentOS7 x86_64）操作一个 TAP，首先需要 Linux tun 模块：\n\n```bash\n# 如果输入 Linux 命令 modinfo tun，有如下输出，则说明有 tun 模块\nmodinfo tun\nfilename:\t/lib/modules/3.10.0-862.14.4.el7.x86_64/kernel/drivers/net/tun.ko.xz\nalias:\t\tdevname:net/tun\nalias:\t\tchar-major-10-200\n......\n```\n\n当 Linux 版本具有 tun 模块时，还需要查看其是否已经加载：\n\n```bash\nlsmod | grep tun\ntun 31665 1\n```\n\n如果已经加载，则会出现上述的”tun ***“那一行。如果没有加载，则可使用如下命令进行加载：\n\n```bash\nmodprob tun\n```\n\n当确认 Linux 加载 tun 模块之后，还需要确认 Linux 是否操作 TAP/TUN 的命令行工具 tunctl：\n\n```bash\ntunctl help\n```\n\n如果 Linux 有输出，则说明已有命令行工具，否则表示当前 Linux 系统并没有安装 tunctl，可以通过如下命令进行安装：\n\n```bash\nyum install tunctl\n```\n\n{% blockquote %}若安装时出现 no package tunctl avaliable 时，需要手动添加安装源：\n1. 添加安装源配置文件 /etc/yun.repos.d/nux-misc.repo：\n\n{% codeblock lang:ini %}\n[nux-misc]\nname=Nux Misc\nbaseurl=http://li.nux.ro/download/nux/misc/el7/x86_64\nenabled=0\ngpgcheck=1\ngpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro\n{% endcodeblock %}\n\n2. 重新执行安装命令：\n\n{% codeblock lang:bash %}\nyum --enablerepo=nux-misc install tunctl\n{% endcodeblock %}\n\nref: [CentOS 7 安装tunctl](<https://blog.csdn.net/lopng/article/details/72821438>)  \n{% endblockquote %}\n具备了 tun 和 tunctl 后，就可以创建一个 TAP 设备了：\n\n```bash\ntunctl -t tap_test\nSet 'tap_test' persistent and owned by uid 0\n```\n\n可以通过如下命令来查看所创建的 TAP（名字为 `tap_test`）：\n\n```bash\nip link list\n```\n\n也可以通过如下命令查看：\n\n```bash\nifconfig -a\n```\n\n通过 tunctl 创建的 `tap_test` 还未绑定 IP 地址，可以通过如下命令进行绑定：\n\n```bash\n# 使用 ip addr 命令绑定 IP 地址\nip addr add local 192.168.100.1/24 dev tap_test\n# 或者使用 ifconfig 命令绑定 IP 地址\nifconfig tap_test 192.168.100.1/24\n```\n\n使用 `ifconfig -a` 命令再次查看，可以发现 `tap_test` 已绑定了所设置的 IP 地址。\n\n## namespace\n\nnamespace 是 Linux 虚拟网络的一个重要概念。传统 Linux 的许多资源是全局的，比如进程 ID 资源。而 namespace 的目的就是将这些资源进行隔离。Linux 可以在一个 Host 内创建许多 namespace，于是那些原本是 Linux 全局的资源，就变成了 namespace 范围内的”全局“资源，而且不同的 namespace 的资源互不可见、彼此透明（感觉类似于 C/C++ 的 namespace）。\n\nLinux 内核对哪些资源进行了隔离可以从 include/linux/nsproxy.h 中看出：\n\n```c\n// nsproxy.h\nstruct nsproxy {\n    atomic_t count;\n    struct uts_namepsace *uts_ns;\n    struct ipc_namespace *ipc_ns;\n    struct mnt_namespace *mnt_ns;\n    struct pid_namespace *pid_ns;\n    struct user_namepsace *user_ns;\n    struct net *net_ns;\n};\n```\n\n以上 6 个资源就是 Linux namespace 所隔离的资源，其含义如下表：\n\n|  资源   | 含义                                                         |\n| :-----: | :----------------------------------------------------------- |\n| uts_ns  | UTS 为 Unix Timesharing System 的简称，包含内存名称、版本、底层体系结构等信息 |\n| ipc_ns  | 所有与进程间通信（IPC）有关的信息                            |\n| mnt_ns  | 当前装载的文件系统                                           |\n| pid_ns  | 有关进程 ID 的信息                                           |\n| user_ns | 资源配额的信息                                               |\n| net_ns  | 网络信息                                                     |\n\n单纯从网络角度来看，一个 namespace 提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP 路由、防火墙规则、sockets 等）。一个设备（Linux Device）只能位于一个 namespace 中，不同 namespace 中的设备可以利用 veth pair 进行桥接。\n\nLinux 操作 namespace 的命令为 `ip netns`，可以通过如下命令查看其功能：\n\n```bash\nip netns help\nUsage:\tip netns list\n\tip netns add NAME\n\tip netns set NAME NETNSID\n\tip [-all] netns delete [NAME]\n\tip netns identify [PID]\n\tip netns pids NAME\n\tip [-all] netns exec [name] cmd ...\n\tip netns monitor\n\tip netns list-id\n```\n\n首先可以创建一个 namespace ：\n\n```bash\n# 首先查看当前的 namespace 列表\nip netns list\n# 由于当前没有 namespace，所以命令行没有任何返回\n# 创建一个 namespace，命名为 ns_test\nip netns add ns_test\n#在此查看当前 namespace 列表，可以发现刚刚创建的 namespace: ns_test\nip netns list\nns_test # 这个是 ip netns list 的返回值\n```\n\n当我们创建一个 namespace 后，可以将原来创建的虚拟设备 tap_test 迁移到这个 namespace 中去，命令如下：\n\n```bash\nip link set tap_test netns ns_test\n```\n\n这个时候，在原来的 host/vm 里再执行 `ip link list` 命令，就会发现设备 `tap_test` 消失了，因为我们已经将其迁移到 `ns_test` 中去了。\n\n通过一下命令可以查看或者操作 namespace 里的设备：\n\n```bash\nip [-all] netns exec [NAME] cmd ...\t\t# cmd 为想要操作的命令\n```\n\n比如要管理 `ns_test` 里面的设备，执行命令如下：\n\n1. 在 `ns_test` 里执行 `ip link list`\n\n```bash\nip netns exec ns_test ip link list\n```\n\n2. 在 ` ns_test` 里执行 `ifconfig -a`\n\n```bash\nip netns exec ns_test ifconfig -a\n```\n\n3. 绑定 IP 地址\n\n```bash\nip netns exec ns_test ifconfig tap_test 192.168.50.1/24 up\n```\n\n4. 查看 IP 地址\n\n```bash\nip netns exec ns_test ifconfig -a\n```\n\n## veth pair\n\nveth pair 不是一个设备，而是一对设备，用以连接两个虚拟以太端口。操作 veth pair，需要结合 namespace，不然就没有意义。下面举一个例子，两个 namespace ns1/ns2 中各有一组 tap 组成 veth pair，两者的 IP 地址分别为 192.168.50.1 和 192.168.50.2，两个 IP 进行互 ping 测试，ping 通表示测试通过。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap2\n# 2. 创建 namespace: ns1、ns2\nip netns add ns1\nip netns add ns2\n# 3. 把两个 tap 分别迁移到对应的 namespace 中\nip link set tap1 netns ns1\nip link set tap2 netns ns2\n# 4. 分别给两个 tap 绑定 IP 地址\nip netns exec ns1 ip addr add local 192.168.50.1/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.50.2/24 dev tap2\n# 5. 将两个 tap 设置为 up\nip netns exec ns1 ifconfig tap1 up\nip netns exec ns2 ifconfig tap2 up\n# 6. ping\nip netns exec ns2 ping 192.168.50.1\t\t# ping ns1 中的 tap\n...\t\t# 输出结果\nip netns exec ns1 ping 192.168.50.2\t\t# ping ns2 中的 tap\n...\t\t# 输出结果\n```\n\n上述用例给出了 veth pair 连接两个namespace 的方法，veth pair 只有一对 tap，如果需要实现两个 以上的namespace 互通，则 veth pair 无法满足需求。\n\n## Bridge\n\nBridge/Switch 可以实现两个以上 namespace 之间的互通。在 Linux 的语境里，Bridge（网桥）与 Switch（交换机）是一个概念，这里也不对两者进行区分。Linux 中实现 Bridge 功能的是 brctl 模块。在命令行中输入 `brctl` 可以查看是否正确安装模块：\n\n```bash\nbrctl\nUsage: brctl [Commands]\ncommands:\n\taddbr\t\t\t<bridge>\t\t\tadd bridge\n\tdelbr\t\t\t<bridge>\t\t\tdelete bridge\n\taddif\t\t\t<bridge> <device>\t\tadd interface to bridge\n\tdelif\t\t\t<bridge> <device>\t\tdelete interface from bridge\n\thairpin\t\t\t<bridge> <port> {on|off}\tturn hairpin on/off\n\tsetageing\t\t<bridge> <time>\t\t\tset ageing time\n\tsetbridgeprio\t        <bridge> <prio>\t\t\tset bridge priority\n\tsetfd\t\t\t<bridge> <time>\t\t\tset bridge forward delay\n\tsethello\t\t<bridge> <time>\t\t\tset hello time\n\tsetmaxage\t\t<bridge> <time>\t\t\tset max message age\n\tsetpathcost\t\t<bridge> <prot> <cost>\t\tset path cost\n\tsetportprio\t\t<bridge> <prot> <prio>\t\tset port priority\n\tshow\t\t\t[ <bridge> ]\t\t\tshow a list of bridges\n\tshowmacs\t\t<bridge>\t\t\tshow a list of mac addrs\n\tshowstp\t\t\t<bridge>\t\t\tshow bridge stp info\n\tstp\t\t\t<bridge> {on|off}\t\tturn stp on/off\n```\n\n若未安装，可通过如下命令进行安装：\n\n```bash\nyum install bridge-utils\n```\n\n接下来也通过一个例子来说明 Bridge 的基本用法，同时也涵盖了之前所述的几个概念：tap、namespace、veth pair。样例中有 4 个 namespace，每个 namespace 都有一个 tap 与交换机上一个 tap 口组成 veth pair。这样 4 个 namespace 就通过 veth pair 及 Bridge 互联起来。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap1_peer\nip link add tap2 type veth peer name tap2_peer\nip link add tap3 type veth peer name tap3_peer\nip link add tap4 type veth peer name tap4_peer\n# 2. 创建 namespace\nip netns add ns1\nip netns add ns2\nip netns add ns3\nip netns add ns4\n# 3. 把 tap 迁移到相应的 namespace 中\nip link set tap1 netns ns1\nip link set tap2 netns ns2\nip link set tap3 netns ns3\nip link set tap4 netns ns4\n# 4. 创建 Bridge\nbrctl addbr br1\n# 5. 把相应的 tap 添加到 Bridge 中\nbrctl addif br1 tap1_peer\nbrctl addif br1 tap2_peer\nbrctl addif br1 tap3_peer\nbrctl addif br1 tap4_peer\n# 6. 配置相应 tap 的 IP 地址\nip netns exec ns1 ip addr add local 192.168.50.1/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.50.2/24 dev tap2\nip netns exec ns3 ip addr add local 192.168.50.3/24 dev tap3\nip netns exec ns4 ip addr add local 192.168.50.4/24 dev tap4\n# 7. 将 Bridge 及所有 tap 状态设置为 up\nip link set br1 up\nip link set tap1_peer up\nip link set tap2_peer up\nip link set tap3_peer up\nip link set tap4_peer up\nip netns exec ns1 ip link set tap1 up\nip netns exec ns2 ip link set tap2 up\nip netns exec ns3 ip link set tap3 up\nip netns exec ns4 ip link set tap4 up\n# 8. 互 ping 测试\nip netns exec ns1 ping 192.168.50.2\nip netns exec ns1 ping 192.168.50.3\nip netns exec ns1 ping 192.168.50.4\n...\nip netns exec ns4 ping 192.168.50.1\nip netns exec ns4 ping 192.168.50.2\nip netns exec ns4 ping 192.168.50.3\n```\n\n若能够互相 ping 通，则表示测试通过。\n\n## Router\n\nLinux 中 Router 能够用于不同网段之间的互通。通过如下命令可以查看系统是否开启路由转发功能：\n\n```bash\nless /proc/sys/net/ipv4/if_forward\n```\n\n如果返回的结果是 `0`，则表示未开启，若为 `1`，则表示已开启路由转发功能。可以修改配置文件 “/etc/systcl.conf”，将 `net.ipv4.ip_forward` 的值修改为 `1` 来开启该功能。\n\n下面举个例子，用于说明 Router 的作用。分别设计 ns1/tap1 和 ns2/tap2，且它们不在同一个网段中，中间需要经过一个路由转发才能互通。\n\n```bash\n# 1. 创建 veth pair\nip link add tap1 type veth peer name tap1_peer\nip link add tap2 type veth peer name tap2_peer\n# 2. 创建 namespace\nip netns add ns1\nip netns add ns2\n# 3. 将 tap 迁移到 namespace\nip link set tap1 netns ns1\nip link set tap2 netns ns2\n# 4. 配置 tap IP 地址\nip addr add local 192.168.100.1/24 dev tap1_peer\nip addr add local 192.168.200.1/24 dev tap2_peer\nip netns exec ns1 ip addr add local 192.168.100.2/24 dev tap1\nip netns exec ns2 ip addr add local 192.168.200.2/24 dev tap2\n# 5. 将 tap 设置为 up\nip link set tap1_peer up\nip link set tap2_peer up\nip netns exec ns1 ip link set tap1 up\nip netns exec ns2 ip link set tap2 up\n# 6. 为 ns1、ns2 添加静态路由，分别到达对方的网段\nip netns exec ns1 route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.100.1\nip netns exec ns2 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.200.1\n# 7. 互 ping 测试\nip netns exec ns1 ping 192.168.200.2\n...\nip netns exec ns2 ping 192.168.100.2\n...\n```\n\n能够互相 ping 通表示测试通过。\n\n添加了静态路由信息后，可以使用如下命令查看 namespace 的路由表：\n\n```bash\nip netns exec ns1 route -nee\n...\nip netns exec ns1 route -nee\n...\n```\n\n上述命令可以分别查看 ns1 和 ns2 的路由表信息。\n\n## tun\n\ntun 是一个网络层（IP）的点对点设备，它启用了 IP 层隧道功能。Linux 原生支持的三层隧道，可以通过 `ip tunnle help` 查看。\n\nLinux 一共原生支持 5 种三层隧道（tunnel），如表所示：\n\n|  隧道  | 简述                                                         |\n| :----: | :----------------------------------------------------------- |\n|  ipip  | IP in IP，在 IPv4 报文的基础上再封装一个 IPv4 报文头，属于 IPv4 in IPv4 |\n|  gre   | 通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于 IPv4/IPv6 over IPv4 |\n|  sit   | 与 ipip 类似，用一个IPv4 的报文头封装 IPv6 的报文，属于 IPv6 over IPv4 |\n| isatap | 站内自动隧道寻址协议，一般用于 IPv4 网络中的 IPv6/IPv4 节点间的通信 |\n|  vti   | 全称是 Virtual Tunnel Interface，为 IPsec 隧道提供了一个可路由的接口类型 |\n\n下面给出 tun 的具体用例来进行说明，以 ipip tunnel为例进行配置。在上一节 Router 的基础上，分别在 ns1 和 ns2 中添加 tun1 和 tun2，tun1 和 tun2 不互通，且与 tap1、tap2也没有关系。\n\n```bash\n# 1. 加载 ipip 模块，可通过 lsmod | grep ip 命令查看是否加载\nmodprobe ipip\n# 2. 在 ns1 上创建 tun1 和 ipip tunnel\nip netns exec ns1 ip tunnel add tun1 mode ipip remote 192.168.200.2 local 192.168.100.2 ttl 255\t\t# 创建 tun1，模式为 ipip，分别配置远端地址和近端（本地）地址以及 ttl\nip netns exec ns1 ip link set tun1 up\t\t# 启动 tun1\nip netns exec ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1\t\t# 为 tun1 添加 ipip 隧道的内层 IP 地址，并设置对端的 ipip 隧道内层 IP 地址\n# 3. 在 ns2 上创建 tun2 和 ipip tunnel\nip netns exec ns2 ip tunnel add tun2 mode ipip remote 192.168.100.2 local 192.168.200.2 ttl 255\nip netns exec ns2 ip link set tun2 up\nip netns exec ns2 ip addr add 192.168.60.10 peer 192.168.50.10 dev tun2\n# 4. 互 ping 测试 （测试时遇到了问题，在 CentOS 7 系统下，按照上述命令无法实现两个 tun ping 通，但是前面的 Router 是可以的，原因未知。）\nip netns exec ns1 ping 192.168.60.10\n...\nip netns exec ns2 ping 192.168.50.10\n...\n```\n\n> 将上述命令中的 `ipip` 改为 `gre`，其余保持不变，即可创建一个 gre 隧道的 tun 设备对。\n\n查看 ns1 的路由表，发现已添加了一个直连路由条目，从 tun1 可以直接到达 192.168.60.10，ns2 亦然。\n","slug":"OpenStack-Neutron-Linux-Virtual-Network","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsjc0049w8vo7oekgba7","content":"<p>Neutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"TAP-TUN\"><a href=\"#TAP-TUN\" class=\"headerlink\" title=\"TAP/TUN\"></a>TAP/TUN</h2><p>TAP/TUN 是 Linux 内核实现的一对虚拟网络设备。TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过 TAP/TUN 设备发送数据。</p>\n<p>Linux 中设备的含义并不是指实际的物理硬件，而是一个类似于数据结构、内核模块或设备驱动。像 TAP/TUN 这样的设备，其数据结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tun_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">8</span>];\t\t\t\t<span class=\"comment\">// 设备名</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;\t\t\t<span class=\"comment\">// 区分 TAP 和 TUN 设备</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fasync_struct</span> *<span class=\"title\">fasync</span>;</span>\t\t<span class=\"comment\">// 文件异步通知结构</span></span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> read_wait;\t\t<span class=\"comment\">// 文件等待队列</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device</span> <span class=\"title\">dev</span>;</span>\t\t\t<span class=\"comment\">// Linux 抽象网络设备结构</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sk_buff_head</span> <span class=\"title\">txq</span>;</span>\t\t\t<span class=\"comment\">// 网络缓冲区队列</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_status</span> <span class=\"title\">stats</span>;</span>\t\t<span class=\"comment\">// 网卡状态信息结构</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TAP 与 TUN 的定义相同，通过 <code>flags</code> 来进行区分。但是从其背后所承载的功能而言，两者有着较大的区别：TAP 位于网络 OSI 模型的第二层（数据链路层），TUN 位于第三层（网络层）。</p>\n<p>TAP 从功能定位上来讲，位于数据链路层，数据链路层的主要协议有：</p>\n<ol>\n<li>点对点协议（Point-to-Point Protocol）</li>\n<li>以太网（Ethernet）</li>\n<li>高级数据链路协议（High-Level Data Link Protocol）</li>\n<li>帧中继（Frame Relay）</li>\n<li>异步传输模式（Asynchronous Transfer Mode）</li>\n</ol>\n<p>但是 TAP 只与以太网（Ethernet）协议对于。所以，TAP 有时也称为“虚拟以太设备”。</p>\n<p>想要使用 Linux 命令行（基于 CentOS7 x86_64）操作一个 TAP，首先需要 Linux tun 模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果输入 Linux 命令 modinfo tun，有如下输出，则说明有 tun 模块</span></span><br><span class=\"line\">modinfo tun</span><br><span class=\"line\">filename:\t/lib/modules/3.10.0-862.14.4.el7.x86_64/kernel/drivers/net/tun.ko.xz</span><br><span class=\"line\"><span class=\"built_in\">alias</span>:\t\tdevname:net/tun</span><br><span class=\"line\"><span class=\"built_in\">alias</span>:\t\tchar-major-10-200</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>当 Linux 版本具有 tun 模块时，还需要查看其是否已经加载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod | grep tun</span><br><span class=\"line\">tun 31665 1</span><br></pre></td></tr></table></figure>\n\n<p>如果已经加载，则会出现上述的”tun ***“那一行。如果没有加载，则可使用如下命令进行加载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprob tun</span><br></pre></td></tr></table></figure>\n\n<p>当确认 Linux 加载 tun 模块之后，还需要确认 Linux 是否操作 TAP/TUN 的命令行工具 tunctl：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tunctl <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 Linux 有输出，则说明已有命令行工具，否则表示当前 Linux 系统并没有安装 tunctl，可以通过如下命令进行安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install tunctl</span><br></pre></td></tr></table></figure>\n\n<blockquote><p>若安装时出现 no package tunctl avaliable 时，需要手动添加安装源：</p>\n<ol>\n<li>添加安装源配置文件 /etc/yun.repos.d/nux-misc.repo：</li>\n</ol>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[nux-misc]</span></span><br><span class=\"line\"><span class=\"attr\">name</span>=Nux Misc</span><br><span class=\"line\"><span class=\"attr\">baseurl</span>=http://li.nux.ro/download/nux/misc/el7/x<span class=\"number\">86_64</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">gpgcheck</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">gpgkey</span>=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>重新执行安装命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum --enablerepo=nux-misc install tunctl</span><br></pre></td></tr></table></figure>\n\n<p>ref: <a href=\"https://blog.csdn.net/lopng/article/details/72821438\">CentOS 7 安装tunctl</a>  </p>\n</blockquote>\n<p>具备了 tun 和 tunctl 后，就可以创建一个 TAP 设备了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tunctl -t tap_test</span><br><span class=\"line\">Set <span class=\"string\">&#x27;tap_test&#x27;</span> persistent and owned by uid 0</span><br></pre></td></tr></table></figure>\n\n<p>可以通过如下命令来查看所创建的 TAP（名字为 <code>tap_test</code>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip link list</span><br></pre></td></tr></table></figure>\n\n<p>也可以通过如下命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<p>通过 tunctl 创建的 <code>tap_test</code> 还未绑定 IP 地址，可以通过如下命令进行绑定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 ip addr 命令绑定 IP 地址</span></span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.100.1/24 dev tap_test</span><br><span class=\"line\"><span class=\"comment\"># 或者使用 ifconfig 命令绑定 IP 地址</span></span><br><span class=\"line\">ifconfig tap_test 192.168.100.1/24</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>ifconfig -a</code> 命令再次查看，可以发现 <code>tap_test</code> 已绑定了所设置的 IP 地址。</p>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><p>namespace 是 Linux 虚拟网络的一个重要概念。传统 Linux 的许多资源是全局的，比如进程 ID 资源。而 namespace 的目的就是将这些资源进行隔离。Linux 可以在一个 Host 内创建许多 namespace，于是那些原本是 Linux 全局的资源，就变成了 namespace 范围内的”全局“资源，而且不同的 namespace 的资源互不可见、彼此透明（感觉类似于 C/C++ 的 namespace）。</p>\n<p>Linux 内核对哪些资源进行了隔离可以从 include/linux/nsproxy.h 中看出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nsproxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nsproxy</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">atomic_t</span> count;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uts_namepsace</span> *<span class=\"title\">uts_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_namespace</span> *<span class=\"title\">ipc_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mnt_namespace</span> *<span class=\"title\">mnt_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid_namespace</span> *<span class=\"title\">pid_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_namepsace</span> *<span class=\"title\">user_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net</span> *<span class=\"title\">net_ns</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>以上 6 个资源就是 Linux namespace 所隔离的资源，其含义如下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">资源</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">uts_ns</td>\n<td align=\"left\">UTS 为 Unix Timesharing System 的简称，包含内存名称、版本、底层体系结构等信息</td>\n</tr>\n<tr>\n<td align=\"center\">ipc_ns</td>\n<td align=\"left\">所有与进程间通信（IPC）有关的信息</td>\n</tr>\n<tr>\n<td align=\"center\">mnt_ns</td>\n<td align=\"left\">当前装载的文件系统</td>\n</tr>\n<tr>\n<td align=\"center\">pid_ns</td>\n<td align=\"left\">有关进程 ID 的信息</td>\n</tr>\n<tr>\n<td align=\"center\">user_ns</td>\n<td align=\"left\">资源配额的信息</td>\n</tr>\n<tr>\n<td align=\"center\">net_ns</td>\n<td align=\"left\">网络信息</td>\n</tr>\n</tbody></table>\n<p>单纯从网络角度来看，一个 namespace 提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP 路由、防火墙规则、sockets 等）。一个设备（Linux Device）只能位于一个 namespace 中，不同 namespace 中的设备可以利用 veth pair 进行桥接。</p>\n<p>Linux 操作 namespace 的命令为 <code>ip netns</code>，可以通过如下命令查看其功能：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">help</span></span><br><span class=\"line\">Usage:\tip netns list</span><br><span class=\"line\">\tip netns add NAME</span><br><span class=\"line\">\tip netns <span class=\"built_in\">set</span> NAME NETNSID</span><br><span class=\"line\">\tip [-all] netns delete [NAME]</span><br><span class=\"line\">\tip netns identify [PID]</span><br><span class=\"line\">\tip netns pids NAME</span><br><span class=\"line\">\tip [-all] netns <span class=\"built_in\">exec</span> [name] cmd ...</span><br><span class=\"line\">\tip netns monitor</span><br><span class=\"line\">\tip netns list-id</span><br></pre></td></tr></table></figure>\n\n<p>首先可以创建一个 namespace ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先查看当前的 namespace 列表</span></span><br><span class=\"line\">ip netns list</span><br><span class=\"line\"><span class=\"comment\"># 由于当前没有 namespace，所以命令行没有任何返回</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个 namespace，命名为 ns_test</span></span><br><span class=\"line\">ip netns add ns_test</span><br><span class=\"line\"><span class=\"comment\">#在此查看当前 namespace 列表，可以发现刚刚创建的 namespace: ns_test</span></span><br><span class=\"line\">ip netns list</span><br><span class=\"line\">ns_test <span class=\"comment\"># 这个是 ip netns list 的返回值</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们创建一个 namespace 后，可以将原来创建的虚拟设备 tap_test 迁移到这个 namespace 中去，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip link <span class=\"built_in\">set</span> tap_test netns ns_test</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，在原来的 host/vm 里再执行 <code>ip link list</code> 命令，就会发现设备 <code>tap_test</code> 消失了，因为我们已经将其迁移到 <code>ns_test</code> 中去了。</p>\n<p>通过一下命令可以查看或者操作 namespace 里的设备：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip [-all] netns <span class=\"built_in\">exec</span> [NAME] cmd ...\t\t<span class=\"comment\"># cmd 为想要操作的命令</span></span><br></pre></td></tr></table></figure>\n\n<p>比如要管理 <code>ns_test</code> 里面的设备，执行命令如下：</p>\n<ol>\n<li>在 <code>ns_test</code> 里执行 <code>ip link list</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ip link list</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在 <code> ns_test</code> 里执行 <code>ifconfig -a</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>绑定 IP 地址</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig tap_test 192.168.50.1/24 up</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>查看 IP 地址</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"veth-pair\"><a href=\"#veth-pair\" class=\"headerlink\" title=\"veth pair\"></a>veth pair</h2><p>veth pair 不是一个设备，而是一对设备，用以连接两个虚拟以太端口。操作 veth pair，需要结合 namespace，不然就没有意义。下面举一个例子，两个 namespace ns1/ns2 中各有一组 tap 组成 veth pair，两者的 IP 地址分别为 192.168.50.1 和 192.168.50.2，两个 IP 进行互 ping 测试，ping 通表示测试通过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap2</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace: ns1、ns2</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\"><span class=\"comment\"># 3. 把两个 tap 分别迁移到对应的 namespace 中</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\"><span class=\"comment\"># 4. 分别给两个 tap 绑定 IP 地址</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.50.1/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.50.2/24 dev tap2</span><br><span class=\"line\"><span class=\"comment\"># 5. 将两个 tap 设置为 up</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ifconfig tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ifconfig tap2 up</span><br><span class=\"line\"><span class=\"comment\"># 6. ping</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.50.1\t\t<span class=\"comment\"># ping ns1 中的 tap</span></span><br><span class=\"line\">...\t\t<span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.2\t\t<span class=\"comment\"># ping ns2 中的 tap</span></span><br><span class=\"line\">...\t\t<span class=\"comment\"># 输出结果</span></span><br></pre></td></tr></table></figure>\n\n<p>上述用例给出了 veth pair 连接两个namespace 的方法，veth pair 只有一对 tap，如果需要实现两个 以上的namespace 互通，则 veth pair 无法满足需求。</p>\n<h2 id=\"Bridge\"><a href=\"#Bridge\" class=\"headerlink\" title=\"Bridge\"></a>Bridge</h2><p>Bridge/Switch 可以实现两个以上 namespace 之间的互通。在 Linux 的语境里，Bridge（网桥）与 Switch（交换机）是一个概念，这里也不对两者进行区分。Linux 中实现 Bridge 功能的是 brctl 模块。在命令行中输入 <code>brctl</code> 可以查看是否正确安装模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brctl</span><br><span class=\"line\">Usage: brctl [Commands]</span><br><span class=\"line\">commands:</span><br><span class=\"line\">\taddbr\t\t\t&lt;bridge&gt;\t\t\tadd bridge</span><br><span class=\"line\">\tdelbr\t\t\t&lt;bridge&gt;\t\t\tdelete bridge</span><br><span class=\"line\">\taddif\t\t\t&lt;bridge&gt; &lt;device&gt;\t\tadd interface to bridge</span><br><span class=\"line\">\tdelif\t\t\t&lt;bridge&gt; &lt;device&gt;\t\tdelete interface from bridge</span><br><span class=\"line\">\thairpin\t\t\t&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;\tturn hairpin on/off</span><br><span class=\"line\">\tsetageing\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> ageing time</span><br><span class=\"line\">\tsetbridgeprio\t        &lt;bridge&gt; &lt;prio&gt;\t\t\t<span class=\"built_in\">set</span> bridge priority</span><br><span class=\"line\">\tsetfd\t\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> bridge forward delay</span><br><span class=\"line\">\tsethello\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> hello time</span><br><span class=\"line\">\tsetmaxage\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> max message age</span><br><span class=\"line\">\tsetpathcost\t\t&lt;bridge&gt; &lt;prot&gt; &lt;cost&gt;\t\t<span class=\"built_in\">set</span> path cost</span><br><span class=\"line\">\tsetportprio\t\t&lt;bridge&gt; &lt;prot&gt; &lt;prio&gt;\t\t<span class=\"built_in\">set</span> port priority</span><br><span class=\"line\">\tshow\t\t\t[ &lt;bridge&gt; ]\t\t\tshow a list of bridges</span><br><span class=\"line\">\tshowmacs\t\t&lt;bridge&gt;\t\t\tshow a list of mac addrs</span><br><span class=\"line\">\tshowstp\t\t\t&lt;bridge&gt;\t\t\tshow bridge stp info</span><br><span class=\"line\">\tstp\t\t\t&lt;bridge&gt; &#123;on|off&#125;\t\tturn stp on/off</span><br></pre></td></tr></table></figure>\n\n<p>若未安装，可通过如下命令进行安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install bridge-utils</span><br></pre></td></tr></table></figure>\n\n<p>接下来也通过一个例子来说明 Bridge 的基本用法，同时也涵盖了之前所述的几个概念：tap、namespace、veth pair。样例中有 4 个 namespace，每个 namespace 都有一个 tap 与交换机上一个 tap 口组成 veth pair。这样 4 个 namespace 就通过 veth pair 及 Bridge 互联起来。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap1_peer</span><br><span class=\"line\">ip link add tap2 <span class=\"built_in\">type</span> veth peer name tap2_peer</span><br><span class=\"line\">ip link add tap3 <span class=\"built_in\">type</span> veth peer name tap3_peer</span><br><span class=\"line\">ip link add tap4 <span class=\"built_in\">type</span> veth peer name tap4_peer</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\">ip netns add ns3</span><br><span class=\"line\">ip netns add ns4</span><br><span class=\"line\"><span class=\"comment\"># 3. 把 tap 迁移到相应的 namespace 中</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap3 netns ns3</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap4 netns ns4</span><br><span class=\"line\"><span class=\"comment\"># 4. 创建 Bridge</span></span><br><span class=\"line\">brctl addbr br1</span><br><span class=\"line\"><span class=\"comment\"># 5. 把相应的 tap 添加到 Bridge 中</span></span><br><span class=\"line\">brctl addif br1 tap1_peer</span><br><span class=\"line\">brctl addif br1 tap2_peer</span><br><span class=\"line\">brctl addif br1 tap3_peer</span><br><span class=\"line\">brctl addif br1 tap4_peer</span><br><span class=\"line\"><span class=\"comment\"># 6. 配置相应 tap 的 IP 地址</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.50.1/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.50.2/24 dev tap2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns3 ip addr add <span class=\"built_in\">local</span> 192.168.50.3/24 dev tap3</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ip addr add <span class=\"built_in\">local</span> 192.168.50.4/24 dev tap4</span><br><span class=\"line\"><span class=\"comment\"># 7. 将 Bridge 及所有 tap 状态设置为 up</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> br1 up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap3_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap4_peer up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tap2 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns3 ip link <span class=\"built_in\">set</span> tap3 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ip link <span class=\"built_in\">set</span> tap4 up</span><br><span class=\"line\"><span class=\"comment\"># 8. 互 ping 测试</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.3</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.4</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.3</span><br></pre></td></tr></table></figure>\n\n<p>若能够互相 ping 通，则表示测试通过。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>Linux 中 Router 能够用于不同网段之间的互通。通过如下命令可以查看系统是否开启路由转发功能：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less /proc/sys/net/ipv4/if_forward</span><br></pre></td></tr></table></figure>\n\n<p>如果返回的结果是 <code>0</code>，则表示未开启，若为 <code>1</code>，则表示已开启路由转发功能。可以修改配置文件 “/etc/systcl.conf”，将 <code>net.ipv4.ip_forward</code> 的值修改为 <code>1</code> 来开启该功能。</p>\n<p>下面举个例子，用于说明 Router 的作用。分别设计 ns1/tap1 和 ns2/tap2，且它们不在同一个网段中，中间需要经过一个路由转发才能互通。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap1_peer</span><br><span class=\"line\">ip link add tap2 <span class=\"built_in\">type</span> veth peer name tap2_peer</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\"><span class=\"comment\"># 3. 将 tap 迁移到 namespace</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\"><span class=\"comment\"># 4. 配置 tap IP 地址</span></span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.100.1/24 dev tap1_peer</span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.200.1/24 dev tap2_peer</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.100.2/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.200.2/24 dev tap2</span><br><span class=\"line\"><span class=\"comment\"># 5. 将 tap 设置为 up</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2_peer up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tap2 up</span><br><span class=\"line\"><span class=\"comment\"># 6. 为 ns1、ns2 添加静态路由，分别到达对方的网段</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.100.1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.200.1</span><br><span class=\"line\"><span class=\"comment\"># 7. 互 ping 测试</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.200.2</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.100.2</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>能够互相 ping 通表示测试通过。</p>\n<p>添加了静态路由信息后，可以使用如下命令查看 namespace 的路由表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route -nee</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route -nee</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>上述命令可以分别查看 ns1 和 ns2 的路由表信息。</p>\n<h2 id=\"tun\"><a href=\"#tun\" class=\"headerlink\" title=\"tun\"></a>tun</h2><p>tun 是一个网络层（IP）的点对点设备，它启用了 IP 层隧道功能。Linux 原生支持的三层隧道，可以通过 <code>ip tunnle help</code> 查看。</p>\n<p>Linux 一共原生支持 5 种三层隧道（tunnel），如表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隧道</th>\n<th align=\"left\">简述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ipip</td>\n<td align=\"left\">IP in IP，在 IPv4 报文的基础上再封装一个 IPv4 报文头，属于 IPv4 in IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">gre</td>\n<td align=\"left\">通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于 IPv4/IPv6 over IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">sit</td>\n<td align=\"left\">与 ipip 类似，用一个IPv4 的报文头封装 IPv6 的报文，属于 IPv6 over IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">isatap</td>\n<td align=\"left\">站内自动隧道寻址协议，一般用于 IPv4 网络中的 IPv6/IPv4 节点间的通信</td>\n</tr>\n<tr>\n<td align=\"center\">vti</td>\n<td align=\"left\">全称是 Virtual Tunnel Interface，为 IPsec 隧道提供了一个可路由的接口类型</td>\n</tr>\n</tbody></table>\n<p>下面给出 tun 的具体用例来进行说明，以 ipip tunnel为例进行配置。在上一节 Router 的基础上，分别在 ns1 和 ns2 中添加 tun1 和 tun2，tun1 和 tun2 不互通，且与 tap1、tap2也没有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 加载 ipip 模块，可通过 lsmod | grep ip 命令查看是否加载</span></span><br><span class=\"line\">modprobe ipip</span><br><span class=\"line\"><span class=\"comment\"># 2. 在 ns1 上创建 tun1 和 ipip tunnel</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip tunnel add tun1 mode ipip remote 192.168.200.2 <span class=\"built_in\">local</span> 192.168.100.2 ttl 255\t\t<span class=\"comment\"># 创建 tun1，模式为 ipip，分别配置远端地址和近端（本地）地址以及 ttl</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tun1 up\t\t<span class=\"comment\"># 启动 tun1</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1\t\t<span class=\"comment\"># 为 tun1 添加 ipip 隧道的内层 IP 地址，并设置对端的 ipip 隧道内层 IP 地址</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 在 ns2 上创建 tun2 和 ipip tunnel</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip tunnel add tun2 mode ipip remote 192.168.100.2 <span class=\"built_in\">local</span> 192.168.200.2 ttl 255</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tun2 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add 192.168.60.10 peer 192.168.50.10 dev tun2</span><br><span class=\"line\"><span class=\"comment\"># 4. 互 ping 测试 （测试时遇到了问题，在 CentOS 7 系统下，按照上述命令无法实现两个 tun ping 通，但是前面的 Router 是可以的，原因未知。）</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.60.10</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.50.10</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将上述命令中的 <code>ipip</code> 改为 <code>gre</code>，其余保持不变，即可创建一个 gre 隧道的 tun 设备对。</p>\n</blockquote>\n<p>查看 ns1 的路由表，发现已添加了一个直连路由条目，从 tun1 可以直接到达 192.168.60.10，ns2 亦然。</p>\n","site":{"data":{}},"length":9259,"excerpt":"<p>Neutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。</p>","more":"<h2 id=\"TAP-TUN\"><a href=\"#TAP-TUN\" class=\"headerlink\" title=\"TAP/TUN\"></a>TAP/TUN</h2><p>TAP/TUN 是 Linux 内核实现的一对虚拟网络设备。TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过 TAP/TUN 设备发送数据。</p>\n<p>Linux 中设备的含义并不是指实际的物理硬件，而是一个类似于数据结构、内核模块或设备驱动。像 TAP/TUN 这样的设备，其数据结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tun_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">8</span>];\t\t\t\t<span class=\"comment\">// 设备名</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags;\t\t\t<span class=\"comment\">// 区分 TAP 和 TUN 设备</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fasync_struct</span> *<span class=\"title\">fasync</span>;</span>\t\t<span class=\"comment\">// 文件异步通知结构</span></span><br><span class=\"line\">    <span class=\"keyword\">wait_queue_head_t</span> read_wait;\t\t<span class=\"comment\">// 文件等待队列</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device</span> <span class=\"title\">dev</span>;</span>\t\t\t<span class=\"comment\">// Linux 抽象网络设备结构</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sk_buff_head</span> <span class=\"title\">txq</span>;</span>\t\t\t<span class=\"comment\">// 网络缓冲区队列</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_status</span> <span class=\"title\">stats</span>;</span>\t\t<span class=\"comment\">// 网卡状态信息结构</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TAP 与 TUN 的定义相同，通过 <code>flags</code> 来进行区分。但是从其背后所承载的功能而言，两者有着较大的区别：TAP 位于网络 OSI 模型的第二层（数据链路层），TUN 位于第三层（网络层）。</p>\n<p>TAP 从功能定位上来讲，位于数据链路层，数据链路层的主要协议有：</p>\n<ol>\n<li>点对点协议（Point-to-Point Protocol）</li>\n<li>以太网（Ethernet）</li>\n<li>高级数据链路协议（High-Level Data Link Protocol）</li>\n<li>帧中继（Frame Relay）</li>\n<li>异步传输模式（Asynchronous Transfer Mode）</li>\n</ol>\n<p>但是 TAP 只与以太网（Ethernet）协议对于。所以，TAP 有时也称为“虚拟以太设备”。</p>\n<p>想要使用 Linux 命令行（基于 CentOS7 x86_64）操作一个 TAP，首先需要 Linux tun 模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果输入 Linux 命令 modinfo tun，有如下输出，则说明有 tun 模块</span></span><br><span class=\"line\">modinfo tun</span><br><span class=\"line\">filename:\t/lib/modules/3.10.0-862.14.4.el7.x86_64/kernel/drivers/net/tun.ko.xz</span><br><span class=\"line\"><span class=\"built_in\">alias</span>:\t\tdevname:net/tun</span><br><span class=\"line\"><span class=\"built_in\">alias</span>:\t\tchar-major-10-200</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>当 Linux 版本具有 tun 模块时，还需要查看其是否已经加载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod | grep tun</span><br><span class=\"line\">tun 31665 1</span><br></pre></td></tr></table></figure>\n\n<p>如果已经加载，则会出现上述的”tun ***“那一行。如果没有加载，则可使用如下命令进行加载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprob tun</span><br></pre></td></tr></table></figure>\n\n<p>当确认 Linux 加载 tun 模块之后，还需要确认 Linux 是否操作 TAP/TUN 的命令行工具 tunctl：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tunctl <span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 Linux 有输出，则说明已有命令行工具，否则表示当前 Linux 系统并没有安装 tunctl，可以通过如下命令进行安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install tunctl</span><br></pre></td></tr></table></figure>\n\n<blockquote><p>若安装时出现 no package tunctl avaliable 时，需要手动添加安装源：</p>\n<ol>\n<li>添加安装源配置文件 /etc/yun.repos.d/nux-misc.repo：</li>\n</ol>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[nux-misc]</span></span><br><span class=\"line\"><span class=\"attr\">name</span>=Nux Misc</span><br><span class=\"line\"><span class=\"attr\">baseurl</span>=http://li.nux.ro/download/nux/misc/el7/x<span class=\"number\">86_64</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">gpgcheck</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">gpgkey</span>=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>重新执行安装命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum --enablerepo=nux-misc install tunctl</span><br></pre></td></tr></table></figure>\n\n<p>ref: <a href=\"https://blog.csdn.net/lopng/article/details/72821438\">CentOS 7 安装tunctl</a>  </p>\n</blockquote>\n<p>具备了 tun 和 tunctl 后，就可以创建一个 TAP 设备了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tunctl -t tap_test</span><br><span class=\"line\">Set <span class=\"string\">&#x27;tap_test&#x27;</span> persistent and owned by uid 0</span><br></pre></td></tr></table></figure>\n\n<p>可以通过如下命令来查看所创建的 TAP（名字为 <code>tap_test</code>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip link list</span><br></pre></td></tr></table></figure>\n\n<p>也可以通过如下命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<p>通过 tunctl 创建的 <code>tap_test</code> 还未绑定 IP 地址，可以通过如下命令进行绑定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 ip addr 命令绑定 IP 地址</span></span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.100.1/24 dev tap_test</span><br><span class=\"line\"><span class=\"comment\"># 或者使用 ifconfig 命令绑定 IP 地址</span></span><br><span class=\"line\">ifconfig tap_test 192.168.100.1/24</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>ifconfig -a</code> 命令再次查看，可以发现 <code>tap_test</code> 已绑定了所设置的 IP 地址。</p>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><p>namespace 是 Linux 虚拟网络的一个重要概念。传统 Linux 的许多资源是全局的，比如进程 ID 资源。而 namespace 的目的就是将这些资源进行隔离。Linux 可以在一个 Host 内创建许多 namespace，于是那些原本是 Linux 全局的资源，就变成了 namespace 范围内的”全局“资源，而且不同的 namespace 的资源互不可见、彼此透明（感觉类似于 C/C++ 的 namespace）。</p>\n<p>Linux 内核对哪些资源进行了隔离可以从 include/linux/nsproxy.h 中看出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nsproxy.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nsproxy</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">atomic_t</span> count;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uts_namepsace</span> *<span class=\"title\">uts_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_namespace</span> *<span class=\"title\">ipc_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mnt_namespace</span> *<span class=\"title\">mnt_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid_namespace</span> *<span class=\"title\">pid_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_namepsace</span> *<span class=\"title\">user_ns</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net</span> *<span class=\"title\">net_ns</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>以上 6 个资源就是 Linux namespace 所隔离的资源，其含义如下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">资源</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">uts_ns</td>\n<td align=\"left\">UTS 为 Unix Timesharing System 的简称，包含内存名称、版本、底层体系结构等信息</td>\n</tr>\n<tr>\n<td align=\"center\">ipc_ns</td>\n<td align=\"left\">所有与进程间通信（IPC）有关的信息</td>\n</tr>\n<tr>\n<td align=\"center\">mnt_ns</td>\n<td align=\"left\">当前装载的文件系统</td>\n</tr>\n<tr>\n<td align=\"center\">pid_ns</td>\n<td align=\"left\">有关进程 ID 的信息</td>\n</tr>\n<tr>\n<td align=\"center\">user_ns</td>\n<td align=\"left\">资源配额的信息</td>\n</tr>\n<tr>\n<td align=\"center\">net_ns</td>\n<td align=\"left\">网络信息</td>\n</tr>\n</tbody></table>\n<p>单纯从网络角度来看，一个 namespace 提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP 路由、防火墙规则、sockets 等）。一个设备（Linux Device）只能位于一个 namespace 中，不同 namespace 中的设备可以利用 veth pair 进行桥接。</p>\n<p>Linux 操作 namespace 的命令为 <code>ip netns</code>，可以通过如下命令查看其功能：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">help</span></span><br><span class=\"line\">Usage:\tip netns list</span><br><span class=\"line\">\tip netns add NAME</span><br><span class=\"line\">\tip netns <span class=\"built_in\">set</span> NAME NETNSID</span><br><span class=\"line\">\tip [-all] netns delete [NAME]</span><br><span class=\"line\">\tip netns identify [PID]</span><br><span class=\"line\">\tip netns pids NAME</span><br><span class=\"line\">\tip [-all] netns <span class=\"built_in\">exec</span> [name] cmd ...</span><br><span class=\"line\">\tip netns monitor</span><br><span class=\"line\">\tip netns list-id</span><br></pre></td></tr></table></figure>\n\n<p>首先可以创建一个 namespace ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先查看当前的 namespace 列表</span></span><br><span class=\"line\">ip netns list</span><br><span class=\"line\"><span class=\"comment\"># 由于当前没有 namespace，所以命令行没有任何返回</span></span><br><span class=\"line\"><span class=\"comment\"># 创建一个 namespace，命名为 ns_test</span></span><br><span class=\"line\">ip netns add ns_test</span><br><span class=\"line\"><span class=\"comment\">#在此查看当前 namespace 列表，可以发现刚刚创建的 namespace: ns_test</span></span><br><span class=\"line\">ip netns list</span><br><span class=\"line\">ns_test <span class=\"comment\"># 这个是 ip netns list 的返回值</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们创建一个 namespace 后，可以将原来创建的虚拟设备 tap_test 迁移到这个 namespace 中去，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip link <span class=\"built_in\">set</span> tap_test netns ns_test</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，在原来的 host/vm 里再执行 <code>ip link list</code> 命令，就会发现设备 <code>tap_test</code> 消失了，因为我们已经将其迁移到 <code>ns_test</code> 中去了。</p>\n<p>通过一下命令可以查看或者操作 namespace 里的设备：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip [-all] netns <span class=\"built_in\">exec</span> [NAME] cmd ...\t\t<span class=\"comment\"># cmd 为想要操作的命令</span></span><br></pre></td></tr></table></figure>\n\n<p>比如要管理 <code>ns_test</code> 里面的设备，执行命令如下：</p>\n<ol>\n<li>在 <code>ns_test</code> 里执行 <code>ip link list</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ip link list</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在 <code> ns_test</code> 里执行 <code>ifconfig -a</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>绑定 IP 地址</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig tap_test 192.168.50.1/24 up</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>查看 IP 地址</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"veth-pair\"><a href=\"#veth-pair\" class=\"headerlink\" title=\"veth pair\"></a>veth pair</h2><p>veth pair 不是一个设备，而是一对设备，用以连接两个虚拟以太端口。操作 veth pair，需要结合 namespace，不然就没有意义。下面举一个例子，两个 namespace ns1/ns2 中各有一组 tap 组成 veth pair，两者的 IP 地址分别为 192.168.50.1 和 192.168.50.2，两个 IP 进行互 ping 测试，ping 通表示测试通过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap2</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace: ns1、ns2</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\"><span class=\"comment\"># 3. 把两个 tap 分别迁移到对应的 namespace 中</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\"><span class=\"comment\"># 4. 分别给两个 tap 绑定 IP 地址</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.50.1/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.50.2/24 dev tap2</span><br><span class=\"line\"><span class=\"comment\"># 5. 将两个 tap 设置为 up</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ifconfig tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ifconfig tap2 up</span><br><span class=\"line\"><span class=\"comment\"># 6. ping</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.50.1\t\t<span class=\"comment\"># ping ns1 中的 tap</span></span><br><span class=\"line\">...\t\t<span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.2\t\t<span class=\"comment\"># ping ns2 中的 tap</span></span><br><span class=\"line\">...\t\t<span class=\"comment\"># 输出结果</span></span><br></pre></td></tr></table></figure>\n\n<p>上述用例给出了 veth pair 连接两个namespace 的方法，veth pair 只有一对 tap，如果需要实现两个 以上的namespace 互通，则 veth pair 无法满足需求。</p>\n<h2 id=\"Bridge\"><a href=\"#Bridge\" class=\"headerlink\" title=\"Bridge\"></a>Bridge</h2><p>Bridge/Switch 可以实现两个以上 namespace 之间的互通。在 Linux 的语境里，Bridge（网桥）与 Switch（交换机）是一个概念，这里也不对两者进行区分。Linux 中实现 Bridge 功能的是 brctl 模块。在命令行中输入 <code>brctl</code> 可以查看是否正确安装模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brctl</span><br><span class=\"line\">Usage: brctl [Commands]</span><br><span class=\"line\">commands:</span><br><span class=\"line\">\taddbr\t\t\t&lt;bridge&gt;\t\t\tadd bridge</span><br><span class=\"line\">\tdelbr\t\t\t&lt;bridge&gt;\t\t\tdelete bridge</span><br><span class=\"line\">\taddif\t\t\t&lt;bridge&gt; &lt;device&gt;\t\tadd interface to bridge</span><br><span class=\"line\">\tdelif\t\t\t&lt;bridge&gt; &lt;device&gt;\t\tdelete interface from bridge</span><br><span class=\"line\">\thairpin\t\t\t&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;\tturn hairpin on/off</span><br><span class=\"line\">\tsetageing\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> ageing time</span><br><span class=\"line\">\tsetbridgeprio\t        &lt;bridge&gt; &lt;prio&gt;\t\t\t<span class=\"built_in\">set</span> bridge priority</span><br><span class=\"line\">\tsetfd\t\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> bridge forward delay</span><br><span class=\"line\">\tsethello\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> hello time</span><br><span class=\"line\">\tsetmaxage\t\t&lt;bridge&gt; &lt;time&gt;\t\t\t<span class=\"built_in\">set</span> max message age</span><br><span class=\"line\">\tsetpathcost\t\t&lt;bridge&gt; &lt;prot&gt; &lt;cost&gt;\t\t<span class=\"built_in\">set</span> path cost</span><br><span class=\"line\">\tsetportprio\t\t&lt;bridge&gt; &lt;prot&gt; &lt;prio&gt;\t\t<span class=\"built_in\">set</span> port priority</span><br><span class=\"line\">\tshow\t\t\t[ &lt;bridge&gt; ]\t\t\tshow a list of bridges</span><br><span class=\"line\">\tshowmacs\t\t&lt;bridge&gt;\t\t\tshow a list of mac addrs</span><br><span class=\"line\">\tshowstp\t\t\t&lt;bridge&gt;\t\t\tshow bridge stp info</span><br><span class=\"line\">\tstp\t\t\t&lt;bridge&gt; &#123;on|off&#125;\t\tturn stp on/off</span><br></pre></td></tr></table></figure>\n\n<p>若未安装，可通过如下命令进行安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install bridge-utils</span><br></pre></td></tr></table></figure>\n\n<p>接下来也通过一个例子来说明 Bridge 的基本用法，同时也涵盖了之前所述的几个概念：tap、namespace、veth pair。样例中有 4 个 namespace，每个 namespace 都有一个 tap 与交换机上一个 tap 口组成 veth pair。这样 4 个 namespace 就通过 veth pair 及 Bridge 互联起来。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap1_peer</span><br><span class=\"line\">ip link add tap2 <span class=\"built_in\">type</span> veth peer name tap2_peer</span><br><span class=\"line\">ip link add tap3 <span class=\"built_in\">type</span> veth peer name tap3_peer</span><br><span class=\"line\">ip link add tap4 <span class=\"built_in\">type</span> veth peer name tap4_peer</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\">ip netns add ns3</span><br><span class=\"line\">ip netns add ns4</span><br><span class=\"line\"><span class=\"comment\"># 3. 把 tap 迁移到相应的 namespace 中</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap3 netns ns3</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap4 netns ns4</span><br><span class=\"line\"><span class=\"comment\"># 4. 创建 Bridge</span></span><br><span class=\"line\">brctl addbr br1</span><br><span class=\"line\"><span class=\"comment\"># 5. 把相应的 tap 添加到 Bridge 中</span></span><br><span class=\"line\">brctl addif br1 tap1_peer</span><br><span class=\"line\">brctl addif br1 tap2_peer</span><br><span class=\"line\">brctl addif br1 tap3_peer</span><br><span class=\"line\">brctl addif br1 tap4_peer</span><br><span class=\"line\"><span class=\"comment\"># 6. 配置相应 tap 的 IP 地址</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.50.1/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.50.2/24 dev tap2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns3 ip addr add <span class=\"built_in\">local</span> 192.168.50.3/24 dev tap3</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ip addr add <span class=\"built_in\">local</span> 192.168.50.4/24 dev tap4</span><br><span class=\"line\"><span class=\"comment\"># 7. 将 Bridge 及所有 tap 状态设置为 up</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> br1 up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap3_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap4_peer up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tap2 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns3 ip link <span class=\"built_in\">set</span> tap3 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ip link <span class=\"built_in\">set</span> tap4 up</span><br><span class=\"line\"><span class=\"comment\"># 8. 互 ping 测试</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.3</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.50.4</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.2</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns4 ping 192.168.50.3</span><br></pre></td></tr></table></figure>\n\n<p>若能够互相 ping 通，则表示测试通过。</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>Linux 中 Router 能够用于不同网段之间的互通。通过如下命令可以查看系统是否开启路由转发功能：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less /proc/sys/net/ipv4/if_forward</span><br></pre></td></tr></table></figure>\n\n<p>如果返回的结果是 <code>0</code>，则表示未开启，若为 <code>1</code>，则表示已开启路由转发功能。可以修改配置文件 “/etc/systcl.conf”，将 <code>net.ipv4.ip_forward</code> 的值修改为 <code>1</code> 来开启该功能。</p>\n<p>下面举个例子，用于说明 Router 的作用。分别设计 ns1/tap1 和 ns2/tap2，且它们不在同一个网段中，中间需要经过一个路由转发才能互通。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 创建 veth pair</span></span><br><span class=\"line\">ip link add tap1 <span class=\"built_in\">type</span> veth peer name tap1_peer</span><br><span class=\"line\">ip link add tap2 <span class=\"built_in\">type</span> veth peer name tap2_peer</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建 namespace</span></span><br><span class=\"line\">ip netns add ns1</span><br><span class=\"line\">ip netns add ns2</span><br><span class=\"line\"><span class=\"comment\"># 3. 将 tap 迁移到 namespace</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1 netns ns1</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2 netns ns2</span><br><span class=\"line\"><span class=\"comment\"># 4. 配置 tap IP 地址</span></span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.100.1/24 dev tap1_peer</span><br><span class=\"line\">ip addr add <span class=\"built_in\">local</span> 192.168.200.1/24 dev tap2_peer</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add <span class=\"built_in\">local</span> 192.168.100.2/24 dev tap1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add <span class=\"built_in\">local</span> 192.168.200.2/24 dev tap2</span><br><span class=\"line\"><span class=\"comment\"># 5. 将 tap 设置为 up</span></span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap1_peer up</span><br><span class=\"line\">ip link <span class=\"built_in\">set</span> tap2_peer up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tap1 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tap2 up</span><br><span class=\"line\"><span class=\"comment\"># 6. 为 ns1、ns2 添加静态路由，分别到达对方的网段</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.100.1</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.200.1</span><br><span class=\"line\"><span class=\"comment\"># 7. 互 ping 测试</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.200.2</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.100.2</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>能够互相 ping 通表示测试通过。</p>\n<p>添加了静态路由信息后，可以使用如下命令查看 namespace 的路由表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route -nee</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 route -nee</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>上述命令可以分别查看 ns1 和 ns2 的路由表信息。</p>\n<h2 id=\"tun\"><a href=\"#tun\" class=\"headerlink\" title=\"tun\"></a>tun</h2><p>tun 是一个网络层（IP）的点对点设备，它启用了 IP 层隧道功能。Linux 原生支持的三层隧道，可以通过 <code>ip tunnle help</code> 查看。</p>\n<p>Linux 一共原生支持 5 种三层隧道（tunnel），如表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隧道</th>\n<th align=\"left\">简述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ipip</td>\n<td align=\"left\">IP in IP，在 IPv4 报文的基础上再封装一个 IPv4 报文头，属于 IPv4 in IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">gre</td>\n<td align=\"left\">通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于 IPv4/IPv6 over IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">sit</td>\n<td align=\"left\">与 ipip 类似，用一个IPv4 的报文头封装 IPv6 的报文，属于 IPv6 over IPv4</td>\n</tr>\n<tr>\n<td align=\"center\">isatap</td>\n<td align=\"left\">站内自动隧道寻址协议，一般用于 IPv4 网络中的 IPv6/IPv4 节点间的通信</td>\n</tr>\n<tr>\n<td align=\"center\">vti</td>\n<td align=\"left\">全称是 Virtual Tunnel Interface，为 IPsec 隧道提供了一个可路由的接口类型</td>\n</tr>\n</tbody></table>\n<p>下面给出 tun 的具体用例来进行说明，以 ipip tunnel为例进行配置。在上一节 Router 的基础上，分别在 ns1 和 ns2 中添加 tun1 和 tun2，tun1 和 tun2 不互通，且与 tap1、tap2也没有关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 加载 ipip 模块，可通过 lsmod | grep ip 命令查看是否加载</span></span><br><span class=\"line\">modprobe ipip</span><br><span class=\"line\"><span class=\"comment\"># 2. 在 ns1 上创建 tun1 和 ipip tunnel</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip tunnel add tun1 mode ipip remote 192.168.200.2 <span class=\"built_in\">local</span> 192.168.100.2 ttl 255\t\t<span class=\"comment\"># 创建 tun1，模式为 ipip，分别配置远端地址和近端（本地）地址以及 ttl</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip link <span class=\"built_in\">set</span> tun1 up\t\t<span class=\"comment\"># 启动 tun1</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1\t\t<span class=\"comment\"># 为 tun1 添加 ipip 隧道的内层 IP 地址，并设置对端的 ipip 隧道内层 IP 地址</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 在 ns2 上创建 tun2 和 ipip tunnel</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip tunnel add tun2 mode ipip remote 192.168.100.2 <span class=\"built_in\">local</span> 192.168.200.2 ttl 255</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip link <span class=\"built_in\">set</span> tun2 up</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ip addr add 192.168.60.10 peer 192.168.50.10 dev tun2</span><br><span class=\"line\"><span class=\"comment\"># 4. 互 ping 测试 （测试时遇到了问题，在 CentOS 7 系统下，按照上述命令无法实现两个 tun ping 通，但是前面的 Router 是可以的，原因未知。）</span></span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns1 ping 192.168.60.10</span><br><span class=\"line\">...</span><br><span class=\"line\">ip netns <span class=\"built_in\">exec</span> ns2 ping 192.168.50.10</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将上述命令中的 <code>ipip</code> 改为 <code>gre</code>，其余保持不变，即可创建一个 gre 隧道的 tun 设备对。</p>\n</blockquote>\n<p>查看 ns1 的路由表，发现已添加了一个直连路由条目，从 tun1 可以直接到达 192.168.60.10，ns2 亦然。</p>"},{"title":"二叉树相关问题(转载)","date":"2017-10-09T11:33:35.000Z","updated":"2019-01-07T13:25:14.000Z","comments":1,"_content":"\n文章转自 http://blog.csdn.net/walkinginthewind/article/details/7518888\n\n# 二叉树\n\n树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。\n\n<!--more-->\n\n# 二叉树节点定义\n\n```C++\n/* Definition for a binary tree node*/\nstruct TreeNode {\n    int val;\n    TreeNode* left;    // left tree node\n    TreeNode* right;   // right tree node\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}    // ctor\n};\n```\n\n# 问题列表\n\n二叉树的大部分题目都应用了递归，时刻往递归结构去思考。\n\n[1. 求二叉树中的节点个数](#nodeNum)  \n[2. 求二叉树的深度](#nodeDepth)  \n[3. 前序、中序、后序遍历](#nodeTraverse)  \n[4. 其他遍历二叉树方法（深度、广度优先）](#nodeDFSBFS)  \n[5. 将二叉查找树变为有序的双向链表](#nodeList)  \n[6. 求二叉树第K层的节点个数](#nodeKth)  \n[7. 求二叉树中叶子节点的个数](#nodeLeaf)  \n[8. 判断两棵二叉树结构是否相同](#nodeStructure)  \n[9. 判断二叉树是不是平衡二叉树](#nodeAVL)  \n[10. 求二叉树的镜像](#nodeMirror)  \n[11. 求二叉树中两个节点的最低公共祖先节点](#nodeAncestor)  \n[12. 求二叉树中节点的最大距离](#nodeDistance)  \n[13. 由前序遍历序列和中序遍历序列重建二叉树](#nodeRebuild)  \n[14. 判断二叉树是不是完全二叉树](#nodeComplete)\n\n# 详细解答\n\n## <span id=\"nodeNum\">**求二叉树中的节点个数**</span>\n\n递归解法：\n1. 如果二叉树为空，节点个数为\n2. 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1\n\n参考代码：\n```c++\nint getNodeNum(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    return getNodeNum(root->left) + getNodeNum(root->right) + 1;\n}\n```\n\n## <span id=\"nodeDepth\">**求二叉树的深度**</span>\n\n递归解法：\n1. 如果二叉树为空，二叉树的深度为0\n2. 如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1\n\n参考代码：\n```c++\nint getDepth(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    int depthLeft = getDepth(root->left);\n    int depthRight = getDepth(root->right);\n    return depthLeft > depthRight ? depthLeft + 1 : depthRight + 1;\n}\n```\n\n## <span id=\"nodeTraverse\">**前序、中序、后序遍历**</span>\n\n### 前序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树\n\n参考代码：\n```c++\nvoid preOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    visit(root);                     // 访问根结点\n    preOrderTraverse(root->left);    // 前序遍历左子树\n    preOrderTraverse(root->right);   // 前序遍历右子树\n}\n```\n\n### 中序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树\n\n参考代码：\n```c++\nvoid inOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    inOrderTraverse(root->left);    // 中序遍历左子树\n    visit(root)；                   // 访问根结点\n    inOrderTraverse(root->right);   // 中序遍历右子树\n}\n```\n\n### 后序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点\n\n参考代码：\n```c++\nvoid postOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    postOrderTraverse(root->left);    // 后序遍历左子树\n    postOrderTraverse(root->right);   // 后序遍历右子树\n    visit(root);                      // 访问根结点\n}\n```\n\n## <span id=\"nodeDFSBFS\">**其他遍历二叉树方法(深度、广度优先)**</span>\n\n### 深度优先遍历解法：\n1. 借助一个栈（后进先出）来实现深度遍历\n2. 先访问根结点\n3. 遍历左子树接着遍历右子树\n\n参考代码：\n```c++\nvoid DFS(TreeNode* root)\n{\n    if (!root) return;\n    stack<TreeNode*> nodeStack;\n    nodeStack.push(root);\n    while (!nodeStack.empty()) {\n        TreeNode *tmp = nodeStack.top();\n        visit(tmp);\n        nodeStack.pop();\n        if (tmp->right)\n            nodeStack.push(tmp->right);\n        if (tmp->left)\n            nodeStack.push(tmp->left);\n    }\n}\n```\n\n### 广度优先遍历解法：\n1. 借助队列（先进先出）来实现广度优先遍历\n2. 将根节点入队\n3. 当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队\n\n参考代码：\n```c++\nvoid BFS(TreeNode* root)\n{\n    if (!root) return;\n    queue<TreeNode*> nodeQueue;\n    q.push(root);\n    while (!nodeQueue.empty()) {\n        TreeNode *tmp = q.front();\n        q.pop();\n        visit(tmp);\n        if (tmp->left)\n            nodeQueue.push(tmp->left);\n        if (tmp->right)\n            nodeQueue.push(tmp->right);\n}\n```\n\n## <span id=\"nodeList\">**将二叉查找树变为有序的双向链表**</span>\n\n要求不创建新节点，只调整指针。\n递归解法：\n1. 如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL\n2. 如果二叉查找树不为空：\n    如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；\n    如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；\n    如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；\n    如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。\n\n参考代码：\n```c++\n/**\n  * root: 二叉查找树的根结点指针\n  * pFirstNode: 转换后双向有序链表的第一个节点指针\n  * pLastNode: 转换后双向有序链表的最后一个节点指针\n  **/\n void convert(TreeNode* root, \n              TreeNode* &pFirstNode, \n              TreeNode* &pLastNode) {\n    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;\n    if (!root) {\n        pFirstNode = NULL;\n        pLastNode = NULL;\n        return;\n    }\n\n    if (!root->left)\n        // 如果左子树为空，对应双向有序链表的第一个节点是根节点\n        pFirstNode = root;\n    else {\n        convert(root->left, pFirstLeft, pLastLeft);\n        // 二叉查找树对应双向有序链表的第一个节点就是\n        // 左子树转换后双向有序链表的第一个节点\n        pFristNode = pFirstLeft;\n        // 将根节点与左子树转换后的双向有序链表的最后一个节点连接\n        root->left = pLastLeft;\n        pLastLeft->right = root;\n    }\n\n    if (!root->right)\n        // 对应双向有序链表的最后一个节点是根节点\n        pLastNode = root;\n    else {\n        convert(root->right, pFirstRight, pLastRight);\n        // 对应双向有序链表的最后一个节点就是\n        // 右子树转换后双向有序链表的最后一个节点\n        pLastNode = pLastRight;\n        // 将根节点和右子树转换后的双向有序链表的第一个节点连接\n        root->right = pFirstRight;\n        pFirstRight->left = root;\n    }\n}\n```\n\n## <span id=\"nodeKth\">**求二叉树第K层的节点个数**</span>\n\n递归解法:\n1. 如果二叉树为空或者k < 1，返回0\n2. 如果二叉树不为空且k = 1，返回1\n3. 如果二叉树不为空且k > 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和\n\n参考代码：\n```c++\nint getKthLevelNodeNum(TreeNode* root)\n{\n    if (!roo || k < 1) return 0;\n    if (k == 1) return 1;\n    \n    int leftNum = getKthLevelNodeNum(root->left);    // 左子树中k-1层节点个数\n    int rightNum = getKthLevelNodeNum(root->right);  // 右子树中k-1层节点个数\n    return (leftNum + rightNum);\n}\n```\n\n## <span id=\"nodeLeaf\">**求二叉树中叶子节点的个数**</span>\n\n递归解法：\n1. 如果二叉树为空，返回0\n2. 如果二叉树不为空且左右子树为空，返回1\n3. 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数\n\n参考代码：\n```c++\nint getLeafNodeNum(TreeNode* root)\n{\n    if (!root) return 0;\n    if(!root->left && !root->right) return 1;\n    \n    int numLeft = getLeafNodeNum(root->left);    // 左子树中叶节点个数\n    int numRight = getLeafNodeNum(root->right);  // 右子树中叶节点个数\n    return (numLeft + numRight);\n}\n```\n\n## <span id=\"nodeStructure\">**判断两棵二叉树结构是否相同**</span>\n\n不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。\n递归解法:\n1. 如果两棵二叉树都为空，返回真\n2. 如果两颗二叉树一棵为空，另一个不为空，返回假\n3. 如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假\n\n参考代码：\n```c++\nbool structureCmp(TreeNode* lhs, TreeNode* rhs)\n{\n    if (!lhs && !rhs) return true;           // 都为空树，返回真\n    else if (!lhs || !rhs) return false;     // 一个为空而另一个不为空，返回假\nbool resultLeft = structureCmp(lhs->left, rhs->left);    // 比较对应左子树\nbool resultRight = structureCmp(lhs->right, rhs->right); // 比较对应右子树\nreturn (resultLeft && resultRight);\n}\n```\n\n## <span id=\"nodeAVL\">**判断二叉树是不是平衡二叉树**</span>\n\n递归解法：\n1. 如果二叉树为空，返回真\n2. 如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假\n\n参考代码：\n```c++\nboo isAVL(TreeNode* root, int &height)\n{\n    if (!root) {    // 空树，返回真\n        height = 0;\n        return true;\n    }\n    \n    int heightLeft;\n    bool resultLeft = isAVL(root->left, heightLeft);\n    int heightRight;\n    bool resultRight = isAVL(root->right, heightRight);\n    if (resultLeft && resultRight && abs(heightLeft - heightRight) <= 1){    \n        // 左右子树都是AVL树，并且高度差不大于1，返回真\n        height = max(heightLeft, heightRight) + 1;\n        return true;\n    }\n    else {\n        height = max(heightLeft, heightRight) + 1;\n        return false;\n    }\n}\n```\n\n## <span id=\"nodeMirror\">**求二叉树的镜像**</span>\n\n递归解法：\n1. 如果二叉树为空，返回空\n2. 如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树\n\n参考代码：\n```c++\nTreeNode* mirrorTree(TreeNode* root)\n{\n    if (!root) return NULL;\n    \n    TreeNode *leftTree = mirrorTree(root->left);    // 求左子树镜像\n    TreeNode *rightTree = mirrorTree(root->right);  // 求右子树镜像\n    // 交换左右子树\n    root->left = leftTree;\n    root->right = rightTree;\n    return root;\n}\n```\n\n## <span id=\"nodeAncestor\">**求二叉树中两个节点的最低公共祖先节点**</span>\n\n### 递归解法：\n\n1. 如果两个节点分别在根结点的左子树和右子树，则返回根结点\n2. 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树\n\n参考代码：\n```c++\nbool findNode(TreeNode* root, TreeNode *pNode)\n{\n    if (!root || !pNode) return false;\n    \n    if (root == pNode) return true;\n    bool found = findNode(root->left, pNode);\n    if (!found)\n        found = findNode(root->right, pNode);\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode* root,\n                                  TreeNode* pNode1,\n                                  TreeNode* pNode2)\n{\n    if (findNode(root->left, pNode1)) {\n        if (findNode(root->right, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->left, pNode1, pNode2);\n    }\n    else {\n        if (find(root->left, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->right, pNode1, pNode2);\n    }\n}\n```\n\n递归解法效率较低，有很多重复遍历，下面看一下非递归解法。\n\n### 非递归解法：\n\n先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点\n\n参考代码：\n```c++\nbool getNodePath(TreeNode* root, \n                 TreeNode* pNode, \n                 list<TreeNode*> &path)\n{\n    if (root == pNode) {\n        path.push_back(root);\n        return true;\n    }\n    if (!root) return false;\n    path.push_back(root);\n    bool found = false;\n    found = getNodePath(root->left, pNode, path);\n    if (!found)\n        found = getNodePath(root->right, pNode, path);\n    if (!found)\n        path.pop_back();\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode *root, \n                                  TreeNode* pNode1, \n                                  TreeNode* pNode2)\n{\n    if (!root || !pNode1 || !pNode2) return NULL;\n    \n    list<TreeNode*> path1;\n    bool result1 = getNodePath(root, pNode1, path1);\n    list<TreeNode*> path2;\n    bool result2 = getNodePath(root, pNode2, path2);\n    \n    if (!result1 || !result2) return NULL;\n    TreeNode* pLast = NULL;\n    list<TreeNode*>::iterator iter1 = path1.begin();\n    list<TreeNode*>::iterator iter2 = path2.begin();\n    while (iter != path1.end() && iter2 != path2.end()) {\n        if (*iter1 == *iter2)\n            pLast = *iter1;\n        else\n            break;\n        ++iter1;\n        ++iter2;\n    }\n    return pLast;\n}\n```\n\n在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。\n\n## <span id=\"nodeDistance\">**求二叉树中节点的最大距离**</span>\n\n即二叉树中相距最远的两个节点之间的距离。\n递归解法：\n1. 如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0\n2. 如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离\n\n参考代码：\n```c++\nint getMaxDistance(TreeNode* root, int &maxLeft, int &maxRight)\n{\n    // maxLeft: 左子树中的节点离根节点的最远距离\n    // maxRight: 右子树中的节点离根节点的最远距离\n    if (!root) {\n        maxLeft = 0;\n        maxRight = 0;\n        return 0;\n    }\n    \n    int maxLL, maxLR, maxRL, maxRR;\n    int maxDistLeft, maxDistRight;\n    if (root->left) {\n        maxDistLeft = getMaxDistance(root->left, maxLL, maxLR);\n        maxLeft = max(maxLL, maxLR) + 1;\n    }\n    else {\n        maxDistLeft = 0;\n        maxLeft = 0;\n    }\n    if (root->right) {\n        maxDistRight = getMaxDistance(root->right, maxRL, maxRR);\n        maxRight = max(maxRL, maxRR) + 1;\n    }\n    else {\n        maxDistRight = 0;\n        maxRight = 0;\n    }\n    return max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);\n}\n```\n\n## <span id=\"nodeRebuild\">**由前序遍历序列和中序遍历序列重建二叉树**</span>\n\n二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。\n递归解法：\n1. 如果前序遍历为空或者节点个数小于等于0，返回NULL。\n2. 创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树\n\n参考代码：\n```c++\n/**\n  * pPreOrder: 前序遍历序列\n  * pInOrder: 中序遍历序列\n  * nodeNum: 二叉树节点数\n  **/\nTreeNode* rebuildTree(int* pPreOrder, int* pInOrder, int nodeNum)\n{\n    if (!pPreOrder || !pInOrder || nodeNum <= 0) return NULL;\n    TreeNode* root = new TreeNode;\n    // 前序遍历的第一个节点就是根节点\n    root->val = pPreOrder[0];\n    root->left = NULL;\n    root->right = NULL;\n    // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树\n    int rootPoistionInOrder = -1;\n    for (int i = 0; i < nodeNum; ++i) {\n        if (pInOrder[i] == root->val) {\n            rootPositionInOrder = i;\n            break;\n        }\n    }\n    if (rootPositionInOrder == -1)\n        throw std::exception(\"Invalid Input.\");\n    \n    // 重建左子树\n    int nodeNumLeft = rootPositionInOrder;\n    int* pPreOrderLeft = pPreOrder + 1;\n    int* pInOrderLeft = pInOrder;\n    root->left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);\n    // 重建右子树\n    int nodeNumRight = nodeNum - nodeNumLeft -1;\n    int* pPreOrderRight = pPreOrder + 1 + nodeNumLeft;\n    int* pInOrderRight = pInOrder + nodeNumLeft + 1;\n    root->right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);\n    return root;\n}\n```\n\n同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树\n\n## <span id=\"nodeComplete\">**判断二叉树是不是完全二叉树**</span>\n\n若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。\n如何判断是否为完全二叉树：\n按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树\n\n参考代码：\n```c++\nbool isCompleteTree(TreeNode* root)\n{\n    if (!root) return false;\n    queue<TreeNode*> nodeQueue;\n    nodeQueue.push(root);\n    bool mustHaveNoChild = false;\n    bool result = true;\n    while (!nodeQueue.empty()) {\n        TreeNode* pNode = nodeQueue.front();\n        nodeQueue.pop();\n        if (mustHaveNoChild) {   // 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)\n            if (pNode->left || pNode->right) {\n                result = false;\n                break;\n            }\n        }\n        else {\n            if (pNode->left && pNode->right) {\n                nodeQueue.push(pNode->left);\n                nodeQueue.push(pNode->right);\n            }\n            else if (pNode->left && !pNode->right) {\n                mustHaveNoChild = true;\n                nodeQueue.push(pNode->left);\n            }\n            else if (!pNode->left && pNode->right) {\n                result = false;\n                break;\n            }\n            else\n                mastHaveNoChild = true;\n        }\n    }\n    return result;\n}\n```\n\n---\n","source":"_posts/二叉树相关问题-转载.md","raw":"---\ntitle: 二叉树相关问题(转载)\ndate: 2017-10-09 19:33:35\nupdated: 2019-01-07 21:25:14\ncategory: DataStructure\ntags: BinaryTree\ncomments: true\n---\n\n文章转自 http://blog.csdn.net/walkinginthewind/article/details/7518888\n\n# 二叉树\n\n树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。\n\n<!--more-->\n\n# 二叉树节点定义\n\n```C++\n/* Definition for a binary tree node*/\nstruct TreeNode {\n    int val;\n    TreeNode* left;    // left tree node\n    TreeNode* right;   // right tree node\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}    // ctor\n};\n```\n\n# 问题列表\n\n二叉树的大部分题目都应用了递归，时刻往递归结构去思考。\n\n[1. 求二叉树中的节点个数](#nodeNum)  \n[2. 求二叉树的深度](#nodeDepth)  \n[3. 前序、中序、后序遍历](#nodeTraverse)  \n[4. 其他遍历二叉树方法（深度、广度优先）](#nodeDFSBFS)  \n[5. 将二叉查找树变为有序的双向链表](#nodeList)  \n[6. 求二叉树第K层的节点个数](#nodeKth)  \n[7. 求二叉树中叶子节点的个数](#nodeLeaf)  \n[8. 判断两棵二叉树结构是否相同](#nodeStructure)  \n[9. 判断二叉树是不是平衡二叉树](#nodeAVL)  \n[10. 求二叉树的镜像](#nodeMirror)  \n[11. 求二叉树中两个节点的最低公共祖先节点](#nodeAncestor)  \n[12. 求二叉树中节点的最大距离](#nodeDistance)  \n[13. 由前序遍历序列和中序遍历序列重建二叉树](#nodeRebuild)  \n[14. 判断二叉树是不是完全二叉树](#nodeComplete)\n\n# 详细解答\n\n## <span id=\"nodeNum\">**求二叉树中的节点个数**</span>\n\n递归解法：\n1. 如果二叉树为空，节点个数为\n2. 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1\n\n参考代码：\n```c++\nint getNodeNum(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    return getNodeNum(root->left) + getNodeNum(root->right) + 1;\n}\n```\n\n## <span id=\"nodeDepth\">**求二叉树的深度**</span>\n\n递归解法：\n1. 如果二叉树为空，二叉树的深度为0\n2. 如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1\n\n参考代码：\n```c++\nint getDepth(TreeNode* root)\n{\n    if (!root) return 0;    // 递归出口\n    int depthLeft = getDepth(root->left);\n    int depthRight = getDepth(root->right);\n    return depthLeft > depthRight ? depthLeft + 1 : depthRight + 1;\n}\n```\n\n## <span id=\"nodeTraverse\">**前序、中序、后序遍历**</span>\n\n### 前序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树\n\n参考代码：\n```c++\nvoid preOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    visit(root);                     // 访问根结点\n    preOrderTraverse(root->left);    // 前序遍历左子树\n    preOrderTraverse(root->right);   // 前序遍历右子树\n}\n```\n\n### 中序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树\n\n参考代码：\n```c++\nvoid inOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    inOrderTraverse(root->left);    // 中序遍历左子树\n    visit(root)；                   // 访问根结点\n    inOrderTraverse(root->right);   // 中序遍历右子树\n}\n```\n\n### 后序遍历递归解法：\n\n1. 如果二叉树为空，空操作\n2. 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点\n\n参考代码：\n```c++\nvoid postOrderTraverse(TreeNode* root)\n{\n    if (!root) return;\n    postOrderTraverse(root->left);    // 后序遍历左子树\n    postOrderTraverse(root->right);   // 后序遍历右子树\n    visit(root);                      // 访问根结点\n}\n```\n\n## <span id=\"nodeDFSBFS\">**其他遍历二叉树方法(深度、广度优先)**</span>\n\n### 深度优先遍历解法：\n1. 借助一个栈（后进先出）来实现深度遍历\n2. 先访问根结点\n3. 遍历左子树接着遍历右子树\n\n参考代码：\n```c++\nvoid DFS(TreeNode* root)\n{\n    if (!root) return;\n    stack<TreeNode*> nodeStack;\n    nodeStack.push(root);\n    while (!nodeStack.empty()) {\n        TreeNode *tmp = nodeStack.top();\n        visit(tmp);\n        nodeStack.pop();\n        if (tmp->right)\n            nodeStack.push(tmp->right);\n        if (tmp->left)\n            nodeStack.push(tmp->left);\n    }\n}\n```\n\n### 广度优先遍历解法：\n1. 借助队列（先进先出）来实现广度优先遍历\n2. 将根节点入队\n3. 当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队\n\n参考代码：\n```c++\nvoid BFS(TreeNode* root)\n{\n    if (!root) return;\n    queue<TreeNode*> nodeQueue;\n    q.push(root);\n    while (!nodeQueue.empty()) {\n        TreeNode *tmp = q.front();\n        q.pop();\n        visit(tmp);\n        if (tmp->left)\n            nodeQueue.push(tmp->left);\n        if (tmp->right)\n            nodeQueue.push(tmp->right);\n}\n```\n\n## <span id=\"nodeList\">**将二叉查找树变为有序的双向链表**</span>\n\n要求不创建新节点，只调整指针。\n递归解法：\n1. 如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL\n2. 如果二叉查找树不为空：\n    如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；\n    如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；\n    如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；\n    如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。\n\n参考代码：\n```c++\n/**\n  * root: 二叉查找树的根结点指针\n  * pFirstNode: 转换后双向有序链表的第一个节点指针\n  * pLastNode: 转换后双向有序链表的最后一个节点指针\n  **/\n void convert(TreeNode* root, \n              TreeNode* &pFirstNode, \n              TreeNode* &pLastNode) {\n    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;\n    if (!root) {\n        pFirstNode = NULL;\n        pLastNode = NULL;\n        return;\n    }\n\n    if (!root->left)\n        // 如果左子树为空，对应双向有序链表的第一个节点是根节点\n        pFirstNode = root;\n    else {\n        convert(root->left, pFirstLeft, pLastLeft);\n        // 二叉查找树对应双向有序链表的第一个节点就是\n        // 左子树转换后双向有序链表的第一个节点\n        pFristNode = pFirstLeft;\n        // 将根节点与左子树转换后的双向有序链表的最后一个节点连接\n        root->left = pLastLeft;\n        pLastLeft->right = root;\n    }\n\n    if (!root->right)\n        // 对应双向有序链表的最后一个节点是根节点\n        pLastNode = root;\n    else {\n        convert(root->right, pFirstRight, pLastRight);\n        // 对应双向有序链表的最后一个节点就是\n        // 右子树转换后双向有序链表的最后一个节点\n        pLastNode = pLastRight;\n        // 将根节点和右子树转换后的双向有序链表的第一个节点连接\n        root->right = pFirstRight;\n        pFirstRight->left = root;\n    }\n}\n```\n\n## <span id=\"nodeKth\">**求二叉树第K层的节点个数**</span>\n\n递归解法:\n1. 如果二叉树为空或者k < 1，返回0\n2. 如果二叉树不为空且k = 1，返回1\n3. 如果二叉树不为空且k > 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和\n\n参考代码：\n```c++\nint getKthLevelNodeNum(TreeNode* root)\n{\n    if (!roo || k < 1) return 0;\n    if (k == 1) return 1;\n    \n    int leftNum = getKthLevelNodeNum(root->left);    // 左子树中k-1层节点个数\n    int rightNum = getKthLevelNodeNum(root->right);  // 右子树中k-1层节点个数\n    return (leftNum + rightNum);\n}\n```\n\n## <span id=\"nodeLeaf\">**求二叉树中叶子节点的个数**</span>\n\n递归解法：\n1. 如果二叉树为空，返回0\n2. 如果二叉树不为空且左右子树为空，返回1\n3. 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数\n\n参考代码：\n```c++\nint getLeafNodeNum(TreeNode* root)\n{\n    if (!root) return 0;\n    if(!root->left && !root->right) return 1;\n    \n    int numLeft = getLeafNodeNum(root->left);    // 左子树中叶节点个数\n    int numRight = getLeafNodeNum(root->right);  // 右子树中叶节点个数\n    return (numLeft + numRight);\n}\n```\n\n## <span id=\"nodeStructure\">**判断两棵二叉树结构是否相同**</span>\n\n不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。\n递归解法:\n1. 如果两棵二叉树都为空，返回真\n2. 如果两颗二叉树一棵为空，另一个不为空，返回假\n3. 如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假\n\n参考代码：\n```c++\nbool structureCmp(TreeNode* lhs, TreeNode* rhs)\n{\n    if (!lhs && !rhs) return true;           // 都为空树，返回真\n    else if (!lhs || !rhs) return false;     // 一个为空而另一个不为空，返回假\nbool resultLeft = structureCmp(lhs->left, rhs->left);    // 比较对应左子树\nbool resultRight = structureCmp(lhs->right, rhs->right); // 比较对应右子树\nreturn (resultLeft && resultRight);\n}\n```\n\n## <span id=\"nodeAVL\">**判断二叉树是不是平衡二叉树**</span>\n\n递归解法：\n1. 如果二叉树为空，返回真\n2. 如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假\n\n参考代码：\n```c++\nboo isAVL(TreeNode* root, int &height)\n{\n    if (!root) {    // 空树，返回真\n        height = 0;\n        return true;\n    }\n    \n    int heightLeft;\n    bool resultLeft = isAVL(root->left, heightLeft);\n    int heightRight;\n    bool resultRight = isAVL(root->right, heightRight);\n    if (resultLeft && resultRight && abs(heightLeft - heightRight) <= 1){    \n        // 左右子树都是AVL树，并且高度差不大于1，返回真\n        height = max(heightLeft, heightRight) + 1;\n        return true;\n    }\n    else {\n        height = max(heightLeft, heightRight) + 1;\n        return false;\n    }\n}\n```\n\n## <span id=\"nodeMirror\">**求二叉树的镜像**</span>\n\n递归解法：\n1. 如果二叉树为空，返回空\n2. 如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树\n\n参考代码：\n```c++\nTreeNode* mirrorTree(TreeNode* root)\n{\n    if (!root) return NULL;\n    \n    TreeNode *leftTree = mirrorTree(root->left);    // 求左子树镜像\n    TreeNode *rightTree = mirrorTree(root->right);  // 求右子树镜像\n    // 交换左右子树\n    root->left = leftTree;\n    root->right = rightTree;\n    return root;\n}\n```\n\n## <span id=\"nodeAncestor\">**求二叉树中两个节点的最低公共祖先节点**</span>\n\n### 递归解法：\n\n1. 如果两个节点分别在根结点的左子树和右子树，则返回根结点\n2. 如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树\n\n参考代码：\n```c++\nbool findNode(TreeNode* root, TreeNode *pNode)\n{\n    if (!root || !pNode) return false;\n    \n    if (root == pNode) return true;\n    bool found = findNode(root->left, pNode);\n    if (!found)\n        found = findNode(root->right, pNode);\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode* root,\n                                  TreeNode* pNode1,\n                                  TreeNode* pNode2)\n{\n    if (findNode(root->left, pNode1)) {\n        if (findNode(root->right, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->left, pNode1, pNode2);\n    }\n    else {\n        if (find(root->left, pNode2))\n            return root;\n        else\n            return getLowestCommonAncestor(root->right, pNode1, pNode2);\n    }\n}\n```\n\n递归解法效率较低，有很多重复遍历，下面看一下非递归解法。\n\n### 非递归解法：\n\n先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点\n\n参考代码：\n```c++\nbool getNodePath(TreeNode* root, \n                 TreeNode* pNode, \n                 list<TreeNode*> &path)\n{\n    if (root == pNode) {\n        path.push_back(root);\n        return true;\n    }\n    if (!root) return false;\n    path.push_back(root);\n    bool found = false;\n    found = getNodePath(root->left, pNode, path);\n    if (!found)\n        found = getNodePath(root->right, pNode, path);\n    if (!found)\n        path.pop_back();\n    return found;\n}\n\nTreeNode* getLowestCommonAncestor(TreeNode *root, \n                                  TreeNode* pNode1, \n                                  TreeNode* pNode2)\n{\n    if (!root || !pNode1 || !pNode2) return NULL;\n    \n    list<TreeNode*> path1;\n    bool result1 = getNodePath(root, pNode1, path1);\n    list<TreeNode*> path2;\n    bool result2 = getNodePath(root, pNode2, path2);\n    \n    if (!result1 || !result2) return NULL;\n    TreeNode* pLast = NULL;\n    list<TreeNode*>::iterator iter1 = path1.begin();\n    list<TreeNode*>::iterator iter2 = path2.begin();\n    while (iter != path1.end() && iter2 != path2.end()) {\n        if (*iter1 == *iter2)\n            pLast = *iter1;\n        else\n            break;\n        ++iter1;\n        ++iter2;\n    }\n    return pLast;\n}\n```\n\n在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。\n\n## <span id=\"nodeDistance\">**求二叉树中节点的最大距离**</span>\n\n即二叉树中相距最远的两个节点之间的距离。\n递归解法：\n1. 如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0\n2. 如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离\n\n参考代码：\n```c++\nint getMaxDistance(TreeNode* root, int &maxLeft, int &maxRight)\n{\n    // maxLeft: 左子树中的节点离根节点的最远距离\n    // maxRight: 右子树中的节点离根节点的最远距离\n    if (!root) {\n        maxLeft = 0;\n        maxRight = 0;\n        return 0;\n    }\n    \n    int maxLL, maxLR, maxRL, maxRR;\n    int maxDistLeft, maxDistRight;\n    if (root->left) {\n        maxDistLeft = getMaxDistance(root->left, maxLL, maxLR);\n        maxLeft = max(maxLL, maxLR) + 1;\n    }\n    else {\n        maxDistLeft = 0;\n        maxLeft = 0;\n    }\n    if (root->right) {\n        maxDistRight = getMaxDistance(root->right, maxRL, maxRR);\n        maxRight = max(maxRL, maxRR) + 1;\n    }\n    else {\n        maxDistRight = 0;\n        maxRight = 0;\n    }\n    return max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);\n}\n```\n\n## <span id=\"nodeRebuild\">**由前序遍历序列和中序遍历序列重建二叉树**</span>\n\n二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。\n递归解法：\n1. 如果前序遍历为空或者节点个数小于等于0，返回NULL。\n2. 创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树\n\n参考代码：\n```c++\n/**\n  * pPreOrder: 前序遍历序列\n  * pInOrder: 中序遍历序列\n  * nodeNum: 二叉树节点数\n  **/\nTreeNode* rebuildTree(int* pPreOrder, int* pInOrder, int nodeNum)\n{\n    if (!pPreOrder || !pInOrder || nodeNum <= 0) return NULL;\n    TreeNode* root = new TreeNode;\n    // 前序遍历的第一个节点就是根节点\n    root->val = pPreOrder[0];\n    root->left = NULL;\n    root->right = NULL;\n    // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树\n    int rootPoistionInOrder = -1;\n    for (int i = 0; i < nodeNum; ++i) {\n        if (pInOrder[i] == root->val) {\n            rootPositionInOrder = i;\n            break;\n        }\n    }\n    if (rootPositionInOrder == -1)\n        throw std::exception(\"Invalid Input.\");\n    \n    // 重建左子树\n    int nodeNumLeft = rootPositionInOrder;\n    int* pPreOrderLeft = pPreOrder + 1;\n    int* pInOrderLeft = pInOrder;\n    root->left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);\n    // 重建右子树\n    int nodeNumRight = nodeNum - nodeNumLeft -1;\n    int* pPreOrderRight = pPreOrder + 1 + nodeNumLeft;\n    int* pInOrderRight = pInOrder + nodeNumLeft + 1;\n    root->right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);\n    return root;\n}\n```\n\n同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树\n\n## <span id=\"nodeComplete\">**判断二叉树是不是完全二叉树**</span>\n\n若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。\n如何判断是否为完全二叉树：\n按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树\n\n参考代码：\n```c++\nbool isCompleteTree(TreeNode* root)\n{\n    if (!root) return false;\n    queue<TreeNode*> nodeQueue;\n    nodeQueue.push(root);\n    bool mustHaveNoChild = false;\n    bool result = true;\n    while (!nodeQueue.empty()) {\n        TreeNode* pNode = nodeQueue.front();\n        nodeQueue.pop();\n        if (mustHaveNoChild) {   // 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)\n            if (pNode->left || pNode->right) {\n                result = false;\n                break;\n            }\n        }\n        else {\n            if (pNode->left && pNode->right) {\n                nodeQueue.push(pNode->left);\n                nodeQueue.push(pNode->right);\n            }\n            else if (pNode->left && !pNode->right) {\n                mustHaveNoChild = true;\n                nodeQueue.push(pNode->left);\n            }\n            else if (!pNode->left && pNode->right) {\n                result = false;\n                break;\n            }\n            else\n                mastHaveNoChild = true;\n        }\n    }\n    return result;\n}\n```\n\n---\n","slug":"二叉树相关问题-转载","published":1,"layout":"post","photos":[],"link":"","_id":"ckhgfgsjd004gw8vofvshf5r2","content":"<p>文章转自 <a href=\"http://blog.csdn.net/walkinginthewind/article/details/7518888\">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"二叉树节点定义\"><a href=\"#二叉树节点定义\" class=\"headerlink\" title=\"二叉树节点定义\"></a>二叉树节点定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Definition for a binary tree node*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode* left;    <span class=\"comment\">// left tree node</span></span><br><span class=\"line\">    TreeNode* right;   <span class=\"comment\">// right tree node</span></span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) : val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;    <span class=\"comment\">// ctor</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"问题列表\"><a href=\"#问题列表\" class=\"headerlink\" title=\"问题列表\"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p>\n<p><a href=\"#nodeNum\">1. 求二叉树中的节点个数</a><br><a href=\"#nodeDepth\">2. 求二叉树的深度</a><br><a href=\"#nodeTraverse\">3. 前序、中序、后序遍历</a><br><a href=\"#nodeDFSBFS\">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href=\"#nodeList\">5. 将二叉查找树变为有序的双向链表</a><br><a href=\"#nodeKth\">6. 求二叉树第K层的节点个数</a><br><a href=\"#nodeLeaf\">7. 求二叉树中叶子节点的个数</a><br><a href=\"#nodeStructure\">8. 判断两棵二叉树结构是否相同</a><br><a href=\"#nodeAVL\">9. 判断二叉树是不是平衡二叉树</a><br><a href=\"#nodeMirror\">10. 求二叉树的镜像</a><br><a href=\"#nodeAncestor\">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href=\"#nodeDistance\">12. 求二叉树中节点的最大距离</a><br><a href=\"#nodeRebuild\">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href=\"#nodeComplete\">14. 判断二叉树是不是完全二叉树</a></p>\n<h1 id=\"详细解答\"><a href=\"#详细解答\" class=\"headerlink\" title=\"详细解答\"></a>详细解答</h1><h2 id=\"求二叉树中的节点个数\"><a href=\"#求二叉树中的节点个数\" class=\"headerlink\" title=\"求二叉树中的节点个数\"></a><span id=\"nodeNum\"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，节点个数为</li>\n<li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的深度\"><a href=\"#求二叉树的深度\" class=\"headerlink\" title=\"求二叉树的深度\"></a><span id=\"nodeDepth\"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，二叉树的深度为0</li>\n<li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> depthLeft = getDepth(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> depthRight = getDepth(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> depthLeft &gt; depthRight ? depthLeft + <span class=\"number\">1</span> : depthRight + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前序、中序、后序遍历\"><a href=\"#前序、中序、后序遍历\" class=\"headerlink\" title=\"前序、中序、后序遍历\"></a><span id=\"nodeTraverse\"><strong>前序、中序、后序遍历</strong></span></h2><h3 id=\"前序遍历递归解法：\"><a href=\"#前序遍历递归解法：\" class=\"headerlink\" title=\"前序遍历递归解法：\"></a>前序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    visit(root);                     <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">    preOrderTraverse(root-&gt;left);    <span class=\"comment\">// 前序遍历左子树</span></span><br><span class=\"line\">    preOrderTraverse(root-&gt;right);   <span class=\"comment\">// 前序遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"中序遍历递归解法：\"><a href=\"#中序遍历递归解法：\" class=\"headerlink\" title=\"中序遍历递归解法：\"></a>中序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    inOrderTraverse(root-&gt;left);    <span class=\"comment\">// 中序遍历左子树</span></span><br><span class=\"line\">    visit(root)；                   <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">    inOrderTraverse(root-&gt;right);   <span class=\"comment\">// 中序遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后序遍历递归解法：\"><a href=\"#后序遍历递归解法：\" class=\"headerlink\" title=\"后序遍历递归解法：\"></a>后序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    postOrderTraverse(root-&gt;left);    <span class=\"comment\">// 后序遍历左子树</span></span><br><span class=\"line\">    postOrderTraverse(root-&gt;right);   <span class=\"comment\">// 后序遍历右子树</span></span><br><span class=\"line\">    visit(root);                      <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他遍历二叉树方法-深度、广度优先\"><a href=\"#其他遍历二叉树方法-深度、广度优先\" class=\"headerlink\" title=\"其他遍历二叉树方法(深度、广度优先)\"></a><span id=\"nodeDFSBFS\"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id=\"深度优先遍历解法：\"><a href=\"#深度优先遍历解法：\" class=\"headerlink\" title=\"深度优先遍历解法：\"></a>深度优先遍历解法：</h3><ol>\n<li>借助一个栈（后进先出）来实现深度遍历</li>\n<li>先访问根结点</li>\n<li>遍历左子树接着遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class=\"line\">    nodeStack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">        TreeNode *tmp = nodeStack.top();</span><br><span class=\"line\">        visit(tmp);</span><br><span class=\"line\">        nodeStack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</span><br><span class=\"line\">            nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</span><br><span class=\"line\">            nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"广度优先遍历解法：\"><a href=\"#广度优先遍历解法：\" class=\"headerlink\" title=\"广度优先遍历解法：\"></a>广度优先遍历解法：</h3><ol>\n<li>借助队列（先进先出）来实现广度优先遍历</li>\n<li>将根节点入队</li>\n<li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">        TreeNode *tmp = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        visit(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</span><br><span class=\"line\">            nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</span><br><span class=\"line\">            nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将二叉查找树变为有序的双向链表\"><a href=\"#将二叉查找树变为有序的双向链表\" class=\"headerlink\" title=\"将二叉查找树变为有序的双向链表\"></a><span id=\"nodeList\"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p>\n<ol>\n<li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li>\n<li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * root: 二叉查找树的根结点指针</span></span><br><span class=\"line\"><span class=\"comment\">  * pFirstNode: 转换后双向有序链表的第一个节点指针</span></span><br><span class=\"line\"><span class=\"comment\">  * pLastNode: 转换后双向有序链表的最后一个节点指针</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(TreeNode* root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              TreeNode* &amp;pFirstNode, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              TreeNode* &amp;pLastNode)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        pFirstNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        pLastNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">        <span class=\"comment\">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></span><br><span class=\"line\">        pFirstNode = root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        convert(root-&gt;left, pFirstLeft, pLastLeft);</span><br><span class=\"line\">        <span class=\"comment\">// 二叉查找树对应双向有序链表的第一个节点就是</span></span><br><span class=\"line\">        <span class=\"comment\">// 左子树转换后双向有序链表的第一个节点</span></span><br><span class=\"line\">        pFristNode = pFirstLeft;</span><br><span class=\"line\">        <span class=\"comment\">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></span><br><span class=\"line\">        root-&gt;left = pLastLeft;</span><br><span class=\"line\">        pLastLeft-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点是根节点</span></span><br><span class=\"line\">        pLastNode = root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        convert(root-&gt;right, pFirstRight, pLastRight);</span><br><span class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点就是</span></span><br><span class=\"line\">        <span class=\"comment\">// 右子树转换后双向有序链表的最后一个节点</span></span><br><span class=\"line\">        pLastNode = pLastRight;</span><br><span class=\"line\">        <span class=\"comment\">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></span><br><span class=\"line\">        root-&gt;right = pFirstRight;</span><br><span class=\"line\">        pFirstRight-&gt;left = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树第K层的节点个数\"><a href=\"#求二叉树第K层的节点个数\" class=\"headerlink\" title=\"求二叉树第K层的节点个数\"></a><span id=\"nodeKth\"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p>\n<ol>\n<li>如果二叉树为空或者k &lt; 1，返回0</li>\n<li>如果二叉树不为空且k = 1，返回1</li>\n<li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthLevelNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!roo || k &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中k-1层节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中k-1层节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (leftNum + rightNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树中叶子节点的个数\"><a href=\"#求二叉树中叶子节点的个数\" class=\"headerlink\" title=\"求二叉树中叶子节点的个数\"></a><span id=\"nodeLeaf\"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回0</li>\n<li>如果二叉树不为空且左右子树为空，返回1</li>\n<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLeafNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中叶节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中叶节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (numLeft + numRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"判断两棵二叉树结构是否相同\"><a href=\"#判断两棵二叉树结构是否相同\" class=\"headerlink\" title=\"判断两棵二叉树结构是否相同\"></a><span id=\"nodeStructure\"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p>\n<ol>\n<li>如果两棵二叉树都为空，返回真</li>\n<li>如果两颗二叉树一棵为空，另一个不为空，返回假</li>\n<li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">structureCmp</span><span class=\"params\">(TreeNode* lhs, TreeNode* rhs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lhs &amp;&amp; !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;           <span class=\"comment\">// 都为空树，返回真</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lhs || !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;     <span class=\"comment\">// 一个为空而另一个不为空，返回假</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class=\"comment\">// 比较对应左子树</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class=\"comment\">// 比较对应右子树</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> (resultLeft &amp;&amp; resultRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"判断二叉树是不是平衡二叉树\"><a href=\"#判断二叉树是不是平衡二叉树\" class=\"headerlink\" title=\"判断二叉树是不是平衡二叉树\"></a><span id=\"nodeAVL\"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回真</li>\n<li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">boo <span class=\"title\">isAVL</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;height)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;    <span class=\"comment\">// 空树，返回真</span></span><br><span class=\"line\">        height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightLeft;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightRight;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class=\"built_in\">abs</span>(heightLeft - heightRight) &lt;= <span class=\"number\">1</span>)&#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></span><br><span class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的镜像\"><a href=\"#求二叉树的镜像\" class=\"headerlink\" title=\"求二叉树的镜像\"></a><span id=\"nodeMirror\"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回空</li>\n<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class=\"comment\">// 求左子树镜像</span></span><br><span class=\"line\">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class=\"comment\">// 求右子树镜像</span></span><br><span class=\"line\">    <span class=\"comment\">// 交换左右子树</span></span><br><span class=\"line\">    root-&gt;left = leftTree;</span><br><span class=\"line\">    root-&gt;right = rightTree;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树中两个节点的最低公共祖先节点\"><a href=\"#求二叉树中两个节点的最低公共祖先节点\" class=\"headerlink\" title=\"求二叉树中两个节点的最低公共祖先节点\"></a><span id=\"nodeAncestor\"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id=\"递归解法：\"><a href=\"#递归解法：\" class=\"headerlink\" title=\"递归解法：\"></a>递归解法：</h3><ol>\n<li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li>\n<li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findNode</span><span class=\"params\">(TreeNode* root, TreeNode *pNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> found = findNode(root-&gt;left, pNode);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        found = findNode(root-&gt;right, pNode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode* root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode1,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findNode(root-&gt;left, pNode1)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (findNode(root-&gt;right, pNode2))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(root-&gt;left, pNode2))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p>\n<h3 id=\"非递归解法：\"><a href=\"#非递归解法：\" class=\"headerlink\" title=\"非递归解法：\"></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getNodePath</span><span class=\"params\">(TreeNode* root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 TreeNode* pNode, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">list</span>&lt;TreeNode*&gt; &amp;path)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) &#123;</span><br><span class=\"line\">        path.push_back(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    path.push_back(root);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    found = getNodePath(root-&gt;left, pNode, path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        found = getNodePath(root-&gt;right, pNode, path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        path.pop_back();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode *root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode1, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode1 || !pNode2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path1;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result1 = getNodePath(root, pNode1, path1);</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path2;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result2 = getNodePath(root, pNode2, path2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result1 || !result2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    TreeNode* pLast = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*iter1 == *iter2)</span><br><span class=\"line\">            pLast = *iter1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ++iter1;</span><br><span class=\"line\">        ++iter2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pLast;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p>\n<h2 id=\"求二叉树中节点的最大距离\"><a href=\"#求二叉树中节点的最大距离\" class=\"headerlink\" title=\"求二叉树中节点的最大距离\"></a><span id=\"nodeDistance\"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p>\n<ol>\n<li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li>\n<li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMaxDistance</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;maxLeft, <span class=\"keyword\">int</span> &amp;maxRight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// maxLeft: 左子树中的节点离根节点的最远距离</span></span><br><span class=\"line\">    <span class=\"comment\">// maxRight: 右子树中的节点离根节点的最远距离</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        maxLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLL, maxLR, maxRL, maxRR;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxDistLeft, maxDistRight;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</span><br><span class=\"line\">        maxLeft = max(maxLL, maxLR) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        maxDistLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</span><br><span class=\"line\">        maxRight = max(maxRL, maxRR) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        maxDistRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"由前序遍历序列和中序遍历序列重建二叉树\"><a href=\"#由前序遍历序列和中序遍历序列重建二叉树\" class=\"headerlink\" title=\"由前序遍历序列和中序遍历序列重建二叉树\"></a><span id=\"nodeRebuild\"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p>\n<ol>\n<li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li>\n<li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * pPreOrder: 前序遍历序列</span></span><br><span class=\"line\"><span class=\"comment\">  * pInOrder: 中序遍历序列</span></span><br><span class=\"line\"><span class=\"comment\">  * nodeNum: 二叉树节点数</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">rebuildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>* pPreOrder, <span class=\"keyword\">int</span>* pInOrder, <span class=\"keyword\">int</span> nodeNum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> TreeNode;</span><br><span class=\"line\">    <span class=\"comment\">// 前序遍历的第一个节点就是根节点</span></span><br><span class=\"line\">    root-&gt;val = pPreOrder[<span class=\"number\">0</span>];</span><br><span class=\"line\">    root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    root-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rootPoistionInOrder = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nodeNum; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pInOrder[i] == root-&gt;val) &#123;</span><br><span class=\"line\">            rootPositionInOrder = i;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rootPositionInOrder == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception(<span class=\"string\">&quot;Invalid Input.&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重建左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nodeNumLeft = rootPositionInOrder;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderLeft = pPreOrder + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pInOrderLeft = pInOrder;</span><br><span class=\"line\">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</span><br><span class=\"line\">    <span class=\"comment\">// 重建右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderRight = pPreOrder + <span class=\"number\">1</span> + nodeNumLeft;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p>\n<h2 id=\"判断二叉树是不是完全二叉树\"><a href=\"#判断二叉树是不是完全二叉树\" class=\"headerlink\" title=\"判断二叉树是不是完全二叉树\"></a><span id=\"nodeComplete\"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class=\"line\">    nodeQueue.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> mustHaveNoChild = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">        TreeNode* pNode = nodeQueue.front();</span><br><span class=\"line\">        nodeQueue.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mustHaveNoChild) &#123;   <span class=\"comment\">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</span><br><span class=\"line\">                result = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;left);</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</span><br><span class=\"line\">                mustHaveNoChild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class=\"line\">                result = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                mastHaveNoChild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"length":10609,"excerpt":"<p>文章转自 <a href=\"http://blog.csdn.net/walkinginthewind/article/details/7518888\">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p>","more":"<h1 id=\"二叉树节点定义\"><a href=\"#二叉树节点定义\" class=\"headerlink\" title=\"二叉树节点定义\"></a>二叉树节点定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Definition for a binary tree node*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode* left;    <span class=\"comment\">// left tree node</span></span><br><span class=\"line\">    TreeNode* right;   <span class=\"comment\">// right tree node</span></span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) : val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;    <span class=\"comment\">// ctor</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"问题列表\"><a href=\"#问题列表\" class=\"headerlink\" title=\"问题列表\"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p>\n<p><a href=\"#nodeNum\">1. 求二叉树中的节点个数</a><br><a href=\"#nodeDepth\">2. 求二叉树的深度</a><br><a href=\"#nodeTraverse\">3. 前序、中序、后序遍历</a><br><a href=\"#nodeDFSBFS\">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href=\"#nodeList\">5. 将二叉查找树变为有序的双向链表</a><br><a href=\"#nodeKth\">6. 求二叉树第K层的节点个数</a><br><a href=\"#nodeLeaf\">7. 求二叉树中叶子节点的个数</a><br><a href=\"#nodeStructure\">8. 判断两棵二叉树结构是否相同</a><br><a href=\"#nodeAVL\">9. 判断二叉树是不是平衡二叉树</a><br><a href=\"#nodeMirror\">10. 求二叉树的镜像</a><br><a href=\"#nodeAncestor\">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href=\"#nodeDistance\">12. 求二叉树中节点的最大距离</a><br><a href=\"#nodeRebuild\">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href=\"#nodeComplete\">14. 判断二叉树是不是完全二叉树</a></p>\n<h1 id=\"详细解答\"><a href=\"#详细解答\" class=\"headerlink\" title=\"详细解答\"></a>详细解答</h1><h2 id=\"求二叉树中的节点个数\"><a href=\"#求二叉树中的节点个数\" class=\"headerlink\" title=\"求二叉树中的节点个数\"></a><span id=\"nodeNum\"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，节点个数为</li>\n<li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的深度\"><a href=\"#求二叉树的深度\" class=\"headerlink\" title=\"求二叉树的深度\"></a><span id=\"nodeDepth\"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，二叉树的深度为0</li>\n<li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 递归出口</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> depthLeft = getDepth(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> depthRight = getDepth(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> depthLeft &gt; depthRight ? depthLeft + <span class=\"number\">1</span> : depthRight + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前序、中序、后序遍历\"><a href=\"#前序、中序、后序遍历\" class=\"headerlink\" title=\"前序、中序、后序遍历\"></a><span id=\"nodeTraverse\"><strong>前序、中序、后序遍历</strong></span></h2><h3 id=\"前序遍历递归解法：\"><a href=\"#前序遍历递归解法：\" class=\"headerlink\" title=\"前序遍历递归解法：\"></a>前序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    visit(root);                     <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">    preOrderTraverse(root-&gt;left);    <span class=\"comment\">// 前序遍历左子树</span></span><br><span class=\"line\">    preOrderTraverse(root-&gt;right);   <span class=\"comment\">// 前序遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"中序遍历递归解法：\"><a href=\"#中序遍历递归解法：\" class=\"headerlink\" title=\"中序遍历递归解法：\"></a>中序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    inOrderTraverse(root-&gt;left);    <span class=\"comment\">// 中序遍历左子树</span></span><br><span class=\"line\">    visit(root)；                   <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">    inOrderTraverse(root-&gt;right);   <span class=\"comment\">// 中序遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后序遍历递归解法：\"><a href=\"#后序遍历递归解法：\" class=\"headerlink\" title=\"后序遍历递归解法：\"></a>后序遍历递归解法：</h3><ol>\n<li>如果二叉树为空，空操作</li>\n<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    postOrderTraverse(root-&gt;left);    <span class=\"comment\">// 后序遍历左子树</span></span><br><span class=\"line\">    postOrderTraverse(root-&gt;right);   <span class=\"comment\">// 后序遍历右子树</span></span><br><span class=\"line\">    visit(root);                      <span class=\"comment\">// 访问根结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他遍历二叉树方法-深度、广度优先\"><a href=\"#其他遍历二叉树方法-深度、广度优先\" class=\"headerlink\" title=\"其他遍历二叉树方法(深度、广度优先)\"></a><span id=\"nodeDFSBFS\"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id=\"深度优先遍历解法：\"><a href=\"#深度优先遍历解法：\" class=\"headerlink\" title=\"深度优先遍历解法：\"></a>深度优先遍历解法：</h3><ol>\n<li>借助一个栈（后进先出）来实现深度遍历</li>\n<li>先访问根结点</li>\n<li>遍历左子树接着遍历右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class=\"line\">    nodeStack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">        TreeNode *tmp = nodeStack.top();</span><br><span class=\"line\">        visit(tmp);</span><br><span class=\"line\">        nodeStack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</span><br><span class=\"line\">            nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</span><br><span class=\"line\">            nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"广度优先遍历解法：\"><a href=\"#广度优先遍历解法：\" class=\"headerlink\" title=\"广度优先遍历解法：\"></a>广度优先遍历解法：</h3><ol>\n<li>借助队列（先进先出）来实现广度优先遍历</li>\n<li>将根节点入队</li>\n<li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class=\"line\">    q.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">        TreeNode *tmp = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        visit(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;left)</span><br><span class=\"line\">            nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp-&gt;right)</span><br><span class=\"line\">            nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将二叉查找树变为有序的双向链表\"><a href=\"#将二叉查找树变为有序的双向链表\" class=\"headerlink\" title=\"将二叉查找树变为有序的双向链表\"></a><span id=\"nodeList\"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p>\n<ol>\n<li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li>\n<li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * root: 二叉查找树的根结点指针</span></span><br><span class=\"line\"><span class=\"comment\">  * pFirstNode: 转换后双向有序链表的第一个节点指针</span></span><br><span class=\"line\"><span class=\"comment\">  * pLastNode: 转换后双向有序链表的最后一个节点指针</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(TreeNode* root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              TreeNode* &amp;pFirstNode, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">              TreeNode* &amp;pLastNode)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        pFirstNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        pLastNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">        <span class=\"comment\">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></span><br><span class=\"line\">        pFirstNode = root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        convert(root-&gt;left, pFirstLeft, pLastLeft);</span><br><span class=\"line\">        <span class=\"comment\">// 二叉查找树对应双向有序链表的第一个节点就是</span></span><br><span class=\"line\">        <span class=\"comment\">// 左子树转换后双向有序链表的第一个节点</span></span><br><span class=\"line\">        pFristNode = pFirstLeft;</span><br><span class=\"line\">        <span class=\"comment\">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></span><br><span class=\"line\">        root-&gt;left = pLastLeft;</span><br><span class=\"line\">        pLastLeft-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点是根节点</span></span><br><span class=\"line\">        pLastNode = root;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        convert(root-&gt;right, pFirstRight, pLastRight);</span><br><span class=\"line\">        <span class=\"comment\">// 对应双向有序链表的最后一个节点就是</span></span><br><span class=\"line\">        <span class=\"comment\">// 右子树转换后双向有序链表的最后一个节点</span></span><br><span class=\"line\">        pLastNode = pLastRight;</span><br><span class=\"line\">        <span class=\"comment\">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></span><br><span class=\"line\">        root-&gt;right = pFirstRight;</span><br><span class=\"line\">        pFirstRight-&gt;left = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树第K层的节点个数\"><a href=\"#求二叉树第K层的节点个数\" class=\"headerlink\" title=\"求二叉树第K层的节点个数\"></a><span id=\"nodeKth\"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p>\n<ol>\n<li>如果二叉树为空或者k &lt; 1，返回0</li>\n<li>如果二叉树不为空且k = 1，返回1</li>\n<li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getKthLevelNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!roo || k &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中k-1层节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中k-1层节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (leftNum + rightNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树中叶子节点的个数\"><a href=\"#求二叉树中叶子节点的个数\" class=\"headerlink\" title=\"求二叉树中叶子节点的个数\"></a><span id=\"nodeLeaf\"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回0</li>\n<li>如果二叉树不为空且左右子树为空，返回1</li>\n<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLeafNodeNum</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class=\"comment\">// 左子树中叶节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class=\"comment\">// 右子树中叶节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (numLeft + numRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"判断两棵二叉树结构是否相同\"><a href=\"#判断两棵二叉树结构是否相同\" class=\"headerlink\" title=\"判断两棵二叉树结构是否相同\"></a><span id=\"nodeStructure\"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p>\n<ol>\n<li>如果两棵二叉树都为空，返回真</li>\n<li>如果两颗二叉树一棵为空，另一个不为空，返回假</li>\n<li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">structureCmp</span><span class=\"params\">(TreeNode* lhs, TreeNode* rhs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lhs &amp;&amp; !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;           <span class=\"comment\">// 都为空树，返回真</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lhs || !rhs) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;     <span class=\"comment\">// 一个为空而另一个不为空，返回假</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class=\"comment\">// 比较对应左子树</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class=\"comment\">// 比较对应右子树</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> (resultLeft &amp;&amp; resultRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"判断二叉树是不是平衡二叉树\"><a href=\"#判断二叉树是不是平衡二叉树\" class=\"headerlink\" title=\"判断二叉树是不是平衡二叉树\"></a><span id=\"nodeAVL\"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回真</li>\n<li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">boo <span class=\"title\">isAVL</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;height)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;    <span class=\"comment\">// 空树，返回真</span></span><br><span class=\"line\">        height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightLeft;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightRight;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class=\"built_in\">abs</span>(heightLeft - heightRight) &lt;= <span class=\"number\">1</span>)&#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></span><br><span class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        height = max(heightLeft, heightRight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的镜像\"><a href=\"#求二叉树的镜像\" class=\"headerlink\" title=\"求二叉树的镜像\"></a><span id=\"nodeMirror\"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p>\n<ol>\n<li>如果二叉树为空，返回空</li>\n<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class=\"comment\">// 求左子树镜像</span></span><br><span class=\"line\">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class=\"comment\">// 求右子树镜像</span></span><br><span class=\"line\">    <span class=\"comment\">// 交换左右子树</span></span><br><span class=\"line\">    root-&gt;left = leftTree;</span><br><span class=\"line\">    root-&gt;right = rightTree;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树中两个节点的最低公共祖先节点\"><a href=\"#求二叉树中两个节点的最低公共祖先节点\" class=\"headerlink\" title=\"求二叉树中两个节点的最低公共祖先节点\"></a><span id=\"nodeAncestor\"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id=\"递归解法：\"><a href=\"#递归解法：\" class=\"headerlink\" title=\"递归解法：\"></a>递归解法：</h3><ol>\n<li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li>\n<li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findNode</span><span class=\"params\">(TreeNode* root, TreeNode *pNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> found = findNode(root-&gt;left, pNode);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        found = findNode(root-&gt;right, pNode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode* root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode1,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findNode(root-&gt;left, pNode1)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (findNode(root-&gt;right, pNode2))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(root-&gt;left, pNode2))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p>\n<h3 id=\"非递归解法：\"><a href=\"#非递归解法：\" class=\"headerlink\" title=\"非递归解法：\"></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">getNodePath</span><span class=\"params\">(TreeNode* root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 TreeNode* pNode, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">list</span>&lt;TreeNode*&gt; &amp;path)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == pNode) &#123;</span><br><span class=\"line\">        path.push_back(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    path.push_back(root);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    found = getNodePath(root-&gt;left, pNode, path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        found = getNodePath(root-&gt;right, pNode, path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!found)</span><br><span class=\"line\">        path.pop_back();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> found;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">getLowestCommonAncestor</span><span class=\"params\">(TreeNode *root, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode1, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TreeNode* pNode2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root || !pNode1 || !pNode2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path1;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result1 = getNodePath(root, pNode1, path1);</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt; path2;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result2 = getNodePath(root, pNode2, path2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result1 || !result2) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    TreeNode* pLast = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*iter1 == *iter2)</span><br><span class=\"line\">            pLast = *iter1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ++iter1;</span><br><span class=\"line\">        ++iter2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pLast;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p>\n<h2 id=\"求二叉树中节点的最大距离\"><a href=\"#求二叉树中节点的最大距离\" class=\"headerlink\" title=\"求二叉树中节点的最大距离\"></a><span id=\"nodeDistance\"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p>\n<ol>\n<li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li>\n<li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMaxDistance</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> &amp;maxLeft, <span class=\"keyword\">int</span> &amp;maxRight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// maxLeft: 左子树中的节点离根节点的最远距离</span></span><br><span class=\"line\">    <span class=\"comment\">// maxRight: 右子树中的节点离根节点的最远距离</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        maxLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLL, maxLR, maxRL, maxRR;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxDistLeft, maxDistRight;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</span><br><span class=\"line\">        maxLeft = max(maxLL, maxLR) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        maxDistLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</span><br><span class=\"line\">        maxRight = max(maxRL, maxRR) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        maxDistRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"由前序遍历序列和中序遍历序列重建二叉树\"><a href=\"#由前序遍历序列和中序遍历序列重建二叉树\" class=\"headerlink\" title=\"由前序遍历序列和中序遍历序列重建二叉树\"></a><span id=\"nodeRebuild\"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p>\n<ol>\n<li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li>\n<li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * pPreOrder: 前序遍历序列</span></span><br><span class=\"line\"><span class=\"comment\">  * pInOrder: 中序遍历序列</span></span><br><span class=\"line\"><span class=\"comment\">  * nodeNum: 二叉树节点数</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">rebuildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>* pPreOrder, <span class=\"keyword\">int</span>* pInOrder, <span class=\"keyword\">int</span> nodeNum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> TreeNode;</span><br><span class=\"line\">    <span class=\"comment\">// 前序遍历的第一个节点就是根节点</span></span><br><span class=\"line\">    root-&gt;val = pPreOrder[<span class=\"number\">0</span>];</span><br><span class=\"line\">    root-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    root-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rootPoistionInOrder = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nodeNum; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pInOrder[i] == root-&gt;val) &#123;</span><br><span class=\"line\">            rootPositionInOrder = i;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rootPositionInOrder == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception(<span class=\"string\">&quot;Invalid Input.&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重建左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nodeNumLeft = rootPositionInOrder;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderLeft = pPreOrder + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pInOrderLeft = pInOrder;</span><br><span class=\"line\">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</span><br><span class=\"line\">    <span class=\"comment\">// 重建右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pPreOrderRight = pPreOrder + <span class=\"number\">1</span> + nodeNumLeft;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p>\n<h2 id=\"判断二叉树是不是完全二叉树\"><a href=\"#判断二叉树是不是完全二叉树\" class=\"headerlink\" title=\"判断二叉树是不是完全二叉树\"></a><span id=\"nodeComplete\"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p>\n<p>参考代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class=\"line\">    nodeQueue.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> mustHaveNoChild = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">        TreeNode* pNode = nodeQueue.front();</span><br><span class=\"line\">        nodeQueue.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mustHaveNoChild) &#123;   <span class=\"comment\">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</span><br><span class=\"line\">                result = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;left);</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</span><br><span class=\"line\">                mustHaveNoChild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                nodeQueue.push(pNode-&gt;left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class=\"line\">                result = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                mastHaveNoChild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckhgfgsie0009w8vo1iizcjlu","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsij000hw8vo9ls0h5ny"},{"post_id":"ckhgfgsi80001w8vo8x7jcy7b","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsik000mw8voc3yx3863"},{"post_id":"ckhgfgsif000bw8vofmyq8av1","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsil000ow8vofx0u5zzx"},{"post_id":"ckhgfgsib0003w8vo0c08gt69","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsim000sw8vohcis78mi"},{"post_id":"ckhgfgsid0007w8vo3p4vhlvh","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsim000uw8vo27s71pyc"},{"post_id":"ckhgfgsii000fw8vo77c971em","category_id":"ckhgfgsil000pw8vo7yd3f2r0","_id":"ckhgfgsip000zw8vo9o7l6u06"},{"post_id":"ckhgfgsij000gw8vobxu26svw","category_id":"ckhgfgsin000vw8vo0qwr52z9","_id":"ckhgfgsir0016w8vo2jfa4k7m"},{"post_id":"ckhgfgsiq0012w8vocx3tcx3p","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsis001cw8vo6vfebnqi"},{"post_id":"ckhgfgsik000lw8vo0ttggvys","category_id":"ckhgfgsin000vw8vo0qwr52z9","_id":"ckhgfgsit001hw8vo4r1edpvq"},{"post_id":"ckhgfgsil000nw8vo1fbvdc04","category_id":"ckhgfgsir0015w8vo77315i8e","_id":"ckhgfgsiu001lw8vo8imr249v"},{"post_id":"ckhgfgsis001bw8voase71v4i","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsiv001ow8voc88i6snr"},{"post_id":"ckhgfgsim000rw8vo7wgq6s7t","category_id":"ckhgfgsir0015w8vo77315i8e","_id":"ckhgfgsiw001rw8vo3we78lnu"},{"post_id":"ckhgfgsim000tw8voe32gau78","category_id":"ckhgfgsir0015w8vo77315i8e","_id":"ckhgfgsiy001ww8vo7kj98mig"},{"post_id":"ckhgfgsix001uw8vo6xbz7z8l","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsiz0024w8vo4tsuep9a"},{"post_id":"ckhgfgsin000xw8voa4ojg4rs","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj00028w8voeabse36e"},{"post_id":"ckhgfgsiy001xw8vodiowc1li","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj1002bw8vo72ao2ddb"},{"post_id":"ckhgfgsiz0021w8vodht62xqc","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj1002fw8vobfgm2nt0"},{"post_id":"ckhgfgsin000yw8voedel0ze6","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj2002hw8vo0acg9dis"},{"post_id":"ckhgfgsiz0023w8vo4tjk9nkq","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj2002kw8vo6add5hfm"},{"post_id":"ckhgfgsj00027w8vo19xt3u35","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj2002mw8vodyu93b2a"},{"post_id":"ckhgfgsiq0014w8vo51pvdpoj","category_id":"ckhgfgsj00025w8vobbhj7rsc","_id":"ckhgfgsj3002pw8vo08myh4bm"},{"post_id":"ckhgfgsj0002aw8vo0n18awe3","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj3002rw8vofbfsagin"},{"post_id":"ckhgfgsj1002ew8vo8y2e54uq","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj3002tw8vofn601aaj"},{"post_id":"ckhgfgsir0019w8vo5sen81ln","category_id":"ckhgfgsj1002cw8voeq5agn3y","_id":"ckhgfgsj3002ww8vo65py4b2t"},{"post_id":"ckhgfgsit001gw8voduk86dqc","category_id":"ckhgfgsj2002iw8vogj1ebwxn","_id":"ckhgfgsj4002yw8vofp1jht0b"},{"post_id":"ckhgfgsiu001jw8vobohkhi6a","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj40030w8vohoiod9qu"},{"post_id":"ckhgfgsiv001mw8vo240s4etn","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj40032w8vohos23pmp"},{"post_id":"ckhgfgsiv001pw8vobzp1gpy6","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj50035w8vob30e5amn"},{"post_id":"ckhgfgsiw001sw8vo1gtdgbgk","category_id":"ckhgfgsiw001qw8vo3q8z20rj","_id":"ckhgfgsj50039w8vo0u50f0o6"},{"post_id":"ckhgfgsjb0046w8vogeupenj4","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsjd004bw8vo48onfb49"},{"post_id":"ckhgfgsjb0047w8vo9y46gh1u","category_id":"ckhgfgsic0004w8vodki28f7k","_id":"ckhgfgsjd004dw8vo4hoqa2id"},{"post_id":"ckhgfgsjc0049w8vo7oekgba7","category_id":"ckhgfgsir0015w8vo77315i8e","_id":"ckhgfgsjd004fw8vo89ht3lka"},{"post_id":"ckhgfgsjd004gw8vofvshf5r2","category_id":"ckhgfgsje004hw8voc47e0byr","_id":"ckhgfgsje004kw8vo1b1r1rde"}],"PostTag":[{"post_id":"ckhgfgsi80001w8vo8x7jcy7b","tag_id":"ckhgfgsid0005w8vod72o5zvk","_id":"ckhgfgsii000ew8voc2v28hs2"},{"post_id":"ckhgfgsib0003w8vo0c08gt69","tag_id":"ckhgfgsid0005w8vod72o5zvk","_id":"ckhgfgsik000kw8vodg6u6d8t"},{"post_id":"ckhgfgsid0007w8vo3p4vhlvh","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsiq0013w8voeje2eldi"},{"post_id":"ckhgfgsid0007w8vo3p4vhlvh","tag_id":"ckhgfgsil000qw8vo7eq1921e","_id":"ckhgfgsir0017w8vogrjhd388"},{"post_id":"ckhgfgsid0007w8vo3p4vhlvh","tag_id":"ckhgfgsin000ww8vo88r7cqvb","_id":"ckhgfgsis001aw8vogxek7xrq"},{"post_id":"ckhgfgsie0009w8vo1iizcjlu","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsis001dw8vo15fl42gu"},{"post_id":"ckhgfgsif000bw8vofmyq8av1","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsiu001iw8vo2aci2spq"},{"post_id":"ckhgfgsii000fw8vo77c971em","tag_id":"ckhgfgsis001fw8vohyur87dg","_id":"ckhgfgsiy001vw8voglfg3egy"},{"post_id":"ckhgfgsii000fw8vo77c971em","tag_id":"ckhgfgsiv001nw8vo9s3y0ci1","_id":"ckhgfgsiy001zw8vo9hvi9q8w"},{"post_id":"ckhgfgsij000gw8vobxu26svw","tag_id":"ckhgfgsix001tw8voc2f0bpmn","_id":"ckhgfgsiz0022w8vo0wbe8acz"},{"post_id":"ckhgfgsik000lw8vo0ttggvys","tag_id":"ckhgfgsix001tw8voc2f0bpmn","_id":"ckhgfgsj00029w8vo7kvrad4w"},{"post_id":"ckhgfgsil000nw8vo1fbvdc04","tag_id":"ckhgfgsj00026w8voffyafw6w","_id":"ckhgfgsj2002gw8vo4e7s5rho"},{"post_id":"ckhgfgsim000rw8vo7wgq6s7t","tag_id":"ckhgfgsj00026w8voffyafw6w","_id":"ckhgfgsj2002lw8vo0i8h60js"},{"post_id":"ckhgfgsim000tw8voe32gau78","tag_id":"ckhgfgsj00026w8voffyafw6w","_id":"ckhgfgsj3002qw8vo1hmn6hyf"},{"post_id":"ckhgfgsin000xw8voa4ojg4rs","tag_id":"ckhgfgsj3002ow8vod4p33o10","_id":"ckhgfgsj3002vw8vo8fun0z08"},{"post_id":"ckhgfgsin000yw8voedel0ze6","tag_id":"ckhgfgsj3002ow8vod4p33o10","_id":"ckhgfgsj40034w8vo9eoy5osd"},{"post_id":"ckhgfgsin000yw8voedel0ze6","tag_id":"ckhgfgsj4002zw8voc7gzco89","_id":"ckhgfgsj50036w8vogbn98i8w"},{"post_id":"ckhgfgsiq0012w8vocx3tcx3p","tag_id":"ckhgfgsj40033w8voacpgbbho","_id":"ckhgfgsj50038w8vo6ze8ejqv"},{"post_id":"ckhgfgsiq0014w8vo51pvdpoj","tag_id":"ckhgfgsj50037w8vo65qc64r4","_id":"ckhgfgsj5003bw8vo6sr13sv5"},{"post_id":"ckhgfgsir0019w8vo5sen81ln","tag_id":"ckhgfgsj5003aw8vodnqc2et1","_id":"ckhgfgsj5003dw8vo1fcdb708"},{"post_id":"ckhgfgsis001bw8voase71v4i","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsj6003fw8vohvy463n3"},{"post_id":"ckhgfgsis001bw8voase71v4i","tag_id":"ckhgfgsj5003cw8vo07a3177c","_id":"ckhgfgsj6003gw8vo4hbib1fl"},{"post_id":"ckhgfgsit001gw8voduk86dqc","tag_id":"ckhgfgsj5003ew8vo3hvpdl9g","_id":"ckhgfgsj6003iw8vo7i4bgpfa"},{"post_id":"ckhgfgsiu001jw8vobohkhi6a","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj6003kw8vo0ryud0kb"},{"post_id":"ckhgfgsiv001mw8vo240s4etn","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj6003mw8vohpuy805l"},{"post_id":"ckhgfgsiv001pw8vobzp1gpy6","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj7003ow8voeus76nk1"},{"post_id":"ckhgfgsiw001sw8vo1gtdgbgk","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj7003rw8vo08vef62y"},{"post_id":"ckhgfgsiw001sw8vo1gtdgbgk","tag_id":"ckhgfgsj7003pw8vod027arfx","_id":"ckhgfgsj7003sw8vobpbo020c"},{"post_id":"ckhgfgsix001uw8vo6xbz7z8l","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj7003uw8vo6i2313sr"},{"post_id":"ckhgfgsiy001xw8vodiowc1li","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj8003ww8voghrz6bsn"},{"post_id":"ckhgfgsiz0021w8vodht62xqc","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj8003yw8vocc3qd10w"},{"post_id":"ckhgfgsiz0023w8vo4tjk9nkq","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj80040w8vo590y5w62"},{"post_id":"ckhgfgsj00027w8vo19xt3u35","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj90042w8vo6j9qfne6"},{"post_id":"ckhgfgsj0002aw8vo0n18awe3","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj90044w8vofvjnhuzi"},{"post_id":"ckhgfgsj1002ew8vo8y2e54uq","tag_id":"ckhgfgsj6003hw8vo94a4ddtc","_id":"ckhgfgsj90045w8vohspl5pqi"},{"post_id":"ckhgfgsjb0046w8vogeupenj4","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsjc0048w8vod1vm1byi"},{"post_id":"ckhgfgsjb0047w8vo9y46gh1u","tag_id":"ckhgfgsij000jw8vob2coccx2","_id":"ckhgfgsjd004aw8vobxcd5pvo"},{"post_id":"ckhgfgsjb0047w8vo9y46gh1u","tag_id":"ckhgfgsil000qw8vo7eq1921e","_id":"ckhgfgsjd004cw8vobj3k6v8f"},{"post_id":"ckhgfgsjc0049w8vo7oekgba7","tag_id":"ckhgfgsj00026w8voffyafw6w","_id":"ckhgfgsjd004ew8vo64go6949"},{"post_id":"ckhgfgsjd004gw8vofvshf5r2","tag_id":"ckhgfgsje004iw8vo2awnhcgf","_id":"ckhgfgsje004jw8vo74ad4prr"}],"Tag":[{"name":"C++ Primer","_id":"ckhgfgsid0005w8vod72o5zvk"},{"name":"C++","_id":"ckhgfgsij000jw8vob2coccx2"},{"name":"String","_id":"ckhgfgsil000qw8vo7eq1921e"},{"name":"vector","_id":"ckhgfgsin000ww8vo88r7cqvb"},{"name":"Travis-CI","_id":"ckhgfgsis001fw8vohyur87dg"},{"name":"Hexo","_id":"ckhgfgsiv001nw8vo9s3y0ci1"},{"name":"LeetCode","_id":"ckhgfgsix001tw8voc2f0bpmn"},{"name":"Neutron","_id":"ckhgfgsj00026w8voffyafw6w"},{"name":"Python","_id":"ckhgfgsj3002ow8vod4p33o10"},{"name":"词云","_id":"ckhgfgsj4002zw8voc7gzco89"},{"name":"UTF-8","_id":"ckhgfgsj40033w8voacpgbbho"},{"name":"VSCode","_id":"ckhgfgsj50037w8vo65qc64r4"},{"name":"Vim教程","_id":"ckhgfgsj5003aw8vodnqc2et1"},{"name":"IDE","_id":"ckhgfgsj5003cw8vo07a3177c"},{"name":"helloworld","_id":"ckhgfgsj5003ew8vo3hvpdl9g"},{"name":"每周一坑","_id":"ckhgfgsj6003hw8vo94a4ddtc"},{"name":"正则表达式","_id":"ckhgfgsj7003pw8vod027arfx"},{"name":"BinaryTree","_id":"ckhgfgsje004iw8vo2awnhcgf"}]}}