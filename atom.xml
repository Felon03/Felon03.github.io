<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreedomLy</title>
  
  <subtitle>Welcome to my blog. &lt;3</subtitle>
  <link href="https://www.freedomly.tk/atom.xml" rel="self"/>
  
  <link href="https://www.freedomly.tk/"/>
  <updated>2019-05-24T06:51:53.000Z</updated>
  <id>https://www.freedomly.tk/</id>
  
  <author>
    <name>Freedomly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenStack Neutron -- Neutron 架构分析</title>
    <link href="https://www.freedomly.tk/2019/05/24/OpenStack-Neutron-Architecture/"/>
    <id>https://www.freedomly.tk/2019/05/24/OpenStack-Neutron-Architecture/</id>
    <published>2019-05-24T06:51:53.000Z</published>
    <updated>2019-05-24T06:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Neutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：</p><ol><li>对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）</li><li>内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络</li></ol><p>Neutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：</p><ol><li>Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等</li><li>开源的网络功能，如 OVS 等</li><li>厂商提供的闭源产品</li></ol><p>在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。</p><a id="more"></a><h2 id="Neutron-中的-WSGI-Application"><a href="#Neutron-中的-WSGI-Application" class="headerlink" title="Neutron 中的 WSGI Application"></a>Neutron 中的 WSGI Application</h2><p>WSGI 是 Web Server Gateway Interface 的缩写。WSGI 本身只是一套标准接口，而非具体实现。这套接口位于 Web Service 和 Web Application（或者 Framework）之间，为的是提升 Web Applications 针对各种 Web Servers 的适配能力。</p><p>能够被 Web Server 按照 WSGI 接口调用的 Web Application 称为 WSGI Application，它有三个特征：</p><ol><li>是一个可调用的对象</li><li>有两个参数：environ、start_response</li><li>有一个可迭代的返回值</li></ol><p>对于 Neutron 来说，只需要按照 WSGI 规范写好 WSGI Application 即可，WSGI Application 才是真正的业务处理单元。</p><h2 id="Neutron-的消息通信机制"><a href="#Neutron-的消息通信机制" class="headerlink" title="Neutron 的消息通信机制"></a>Neutron 的消息通信机制</h2><p>Neutron 内部组件（进程）之间的通信（比如 Neutron Server 与 Neutron Agent），采用 AMQP （Advanced Message Queuing Protocol，高级消息队列协议）机制，进行 RPC 通信。Neutron 采用了三种 AMQP 标准的具体实现：RabbitMQ、Qpid 和 ZMQ，具体应用中根据配置文件选用某种实现。</p><h3 id="AMQP-基本概念"><a href="#AMQP-基本概念" class="headerlink" title="AMQP 基本概念"></a>AMQP 基本概念</h3><p>AMQP 把通信的双方（发送方和接收方）分别称为 Producer 和 Consumer。Producer 把消息发送到 Consumer 需要经过 Message Broker 的处理和传递。AMQP 中，承担 Message Broker 功能的是 AMQP Server，而 AMQP 的 Producer 和 Consumer 都是 AMQP Client。</p><p>在 AMQP Server 中，有两大部件：Exchange 和 Message Queues，其含义如下：</p><ol><li><p>Exchange 接收 Producers 发过来的消息，按照一定规则转发到相应的 Message Queues 中</p></li><li><p>Message Queues 再将消息转发到相应的 Consumers</p></li></ol><h3 id="AMQP-的消息转发"><a href="#AMQP-的消息转发" class="headerlink" title="AMQP 的消息转发"></a>AMQP 的消息转发</h3><h4 id="AMQP-消息转发模型"><a href="#AMQP-消息转发模型" class="headerlink" title="AMQP 消息转发模型"></a>AMQP 消息转发模型</h4><p>Producer 发送的消息，经过 AMQP Server 转发以后，到达对应的 Consumer，在这个消息转发中，起关键的“路由标识”作用的是一个字符串 Routing Key。具体的说，就是 Producer 首先发消息到 Exchange，Exchange 根据一定的转发规则转发到相应的 Message Queue，然后 Queue 通知绑定到它的 Consumer。Exchange 转发消息给 Message Queue 的规则根据 Routing Key 进行匹配。其匹配模式可分为三种：</p><ol><li><p>Direct Exchanges</p><ul><li><p>Routing Key 是一个字符串</p></li><li><p>匹配规则为全值匹配</p><p>Message Queue 绑定的 Routing Key 与 Producer 发送的 Routine Key 完全相同时，Exchange 才会将消息转发给该 Message Queue。</p></li></ul></li><li><p>Topic Exchanges</p><ul><li><p>Routing Key 是一个字符串，但是由“.” 分割为多个子字符串</p></li><li><p>匹配规则是模式匹配</p><p>所谓模式匹配，是有两个通配符，一个是“*”，代表任意一个字符串；另一个是“#”，代表任意多个子字符串。Producer 发送的 Routing Key 是一个完整的字符串，没有通配符，Message Queue 绑定的 Routing Key 可以有通配符。</p></li></ul></li><li><p>Fanout Exchanges</p><ul><li>没有 Routing Key</li><li>所有绑定到 Fanout Exchange Message Queue都能收到相应的 Producer 发送的消息</li></ul></li></ol><h4 id="AMQP-的几种通信模式"><a href="#AMQP-的几种通信模式" class="headerlink" title="AMQP 的几种通信模式"></a>AMQP 的几种通信模式</h4><p>基于 AMQP 的消息转发模型，有以下几种通信模式：</p><ol><li>远程过程调用（RPC）</li><li>发布—订阅（Publish-Subscribe）</li><li>广播（Broadcast）</li></ol><p>发布订阅只需采用 Topic Exchanges 消息转发模型即可，而广播只需采用 Fanout Exchanges 消息转发模型即可。RPC（Remote Procedure Call Protocol，远程过程调用协议），一般称为“远程过程调用”，是一种 Client/Server 通信模型。Client 和 Server 之间有一来（request）一往（response）两个消息。在 request 消息中，RPC Client 担任 Producer 的角色，RPC Server 担任 Consumer 的角色。在 response 消息中，两种角色进行了互换，RPC Server 担任 Producer 角色，RPC Client 担任 Consumer 角色。</p><h2 id="Neutron-的并发机制"><a href="#Neutron-的并发机制" class="headerlink" title="Neutron 的并发机制"></a>Neutron 的并发机制</h2><p>Neutron 北向提供 RESTful 接口，需要处理并发请求，南向对接多个“网元”，Neutron 不能算作“计算密集型”应用，而可以归类为“I/O阻塞型”应用，因此 Neutron 主要采用协程，并且在必要的时候，结合多进程方案来共同构建其并发机制。</p><h3 id="协程与进程、线程的比较"><a href="#协程与进程、线程的比较" class="headerlink" title="协程与进程、线程的比较"></a>协程与进程、线程的比较</h3><p>协程与进程和线程的比较如下：</p><ol><li>协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程与进程、线程的含义不在同一维度</li><li>一个进程可以包含多个线程，一个线程可以包含多个协程</li><li>一个线程内的多个协程虽然可以切换，但是这<strong>多个协程是串行执行的</strong>，只能在这一个线程内运行，没法利用 CPU 多核的能力</li><li>协程与进程一样，它们的切换都存在上下文切换问题</li></ol><p>表面上看，进程、线程和协程均存在上下文切换的问题，但是三者上下文切换又有显著的不同，如下表所示：</p><table><thead><tr><th align="left"></th><th align="left">进程</th><th align="left">线程</th><th align="left">协程</th></tr></thead><tbody><tr><td align="left">切换者</td><td align="left">操作系统</td><td align="left">操作系统</td><td align="left">用户（编程者/应用程序）</td></tr><tr><td align="left">切换时机</td><td align="left">根据操作系统自己的切换策略，用户不感知</td><td align="left">根据操作系统自己的切换策略，用户不感知</td><td align="left">用户自己（的程序）决定</td></tr><tr><td align="left">切换内容</td><td align="left">页全局目录、内核栈、硬件上下文</td><td align="left">内核栈、硬件上下文</td><td align="left">硬件上下文</td></tr><tr><td align="left">切换内容的保存</td><td align="left">保存于内核栈中</td><td align="left">保存于内核栈中</td><td align="left">保存于用户自己的变量（用户栈或堆）中</td></tr><tr><td align="left">切换过程</td><td align="left">用户态 - 内核态 - 用户态</td><td align="left">用户态 - 内核态- 用户态</td><td align="left">用户态（没有陷入内核态）</td></tr><tr><td align="left">切换效率</td><td align="left">低</td><td align="left">中</td><td align="left">高</td></tr></tbody></table><h2 id="通用库-Oslo"><a href="#通用库-Oslo" class="headerlink" title="通用库 Oslo"></a>通用库 Oslo</h2><p>为了降低代码的冗余度，OpenStack 社区创建了 Oslo 项目，从 OpenStack 代码中提取公共的部分，构建出一批 lib 库以供 OpenStack 其他项目使用。Neutron 使用了 Oslo 中的 lib。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Neutron 在 OpenStack 中的定位是 NaaS （Networking as a Service）。NaaS 有两层含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对外接口：Neutron 为 Network、Subnet、Port、Router 等网络资源建立了逻辑模型，并提供了 RESTful API、CLI（命令行）和 GUI（图形化用户接口）&lt;/li&gt;
&lt;li&gt;内部实现：利用 Linux 原生以及其他虚拟网络功能，再加上一些硬件网络功能，构建出真正的网络&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Neutron 管理的网元，主要以”软“网元为主（也称作虚拟网络功能）。这些”软“网元有三种来源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linux 原生（内核提供）的网络功能，如 Linux Router、Linux Bridge 等&lt;/li&gt;
&lt;li&gt;开源的网络功能，如 OVS 等&lt;/li&gt;
&lt;li&gt;厂商提供的闭源产品&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Neutron 的抽象架构中，Neutron 接到 RESTful API 的请求后，交由模块 WSGI Application 进行初步的处理，然后这个模块通过 Python API 调用 Neutron 的 Plugin 模块。Plugin 模块做了相应处理后，通过 RPC 调用 Neutron 的 Agent 模块，Agent 再通过某种协议（比如 CLI）对 VNF（虚拟网络功能）进行配置。Neutron 内部由不同的组件组成，这些组件之间需要通信，从而引出了 Neutron 消息总线的通信机制。同时，为了提高效率，Neutron 采用了协程来做并发处理。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenStack" scheme="https://www.freedomly.tk/categories/OpenStack/"/>
    
    
    <category term="Neutron" scheme="https://www.freedomly.tk/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Neutron -- Neutron 的资源模型</title>
    <link href="https://www.freedomly.tk/2019/05/22/OpenStack-Neutron-Resources-Model/"/>
    <id>https://www.freedomly.tk/2019/05/22/OpenStack-Neutron-Resources-Model/</id>
    <published>2019-05-22T07:06:13.000Z</published>
    <updated>2019-05-22T07:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Neutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。</p><a id="more"></a><h2 id="Neutron-资源的租户隔离"><a href="#Neutron-资源的租户隔离" class="headerlink" title="Neutron 资源的租户隔离"></a>Neutron 资源的租户隔离</h2><p>租户隔离指的是将不同的用户隔离开来，用户对其他用户无感知。租户隔离有三种含义：管理面的隔离、数据面的隔离和故障面的隔离。</p><h3 id="管理面的隔离"><a href="#管理面的隔离" class="headerlink" title="管理面的隔离"></a>管理面的隔离</h3><p>管里面的隔离，指的是”管理权限“的隔离，每个租户只知道他自己的网络，对其他网络毫无感觉。</p><h3 id="数据面的隔离"><a href="#数据面的隔离" class="headerlink" title="数据面的隔离"></a>数据面的隔离</h3><p>数据面的隔离，指的是数据转发的隔离。不同租户之间的网络，一般来说是不能互通的。从管理权限的角度，一个租户感知不到另外一个租户的网络。不仅无法感知，而且还可以”重复“。从这个角度来说，数据面的隔离是为了复用。</p><h3 id="故障面的隔离"><a href="#故障面的隔离" class="headerlink" title="故障面的隔离"></a>故障面的隔离</h3><p>故障隔离，主要是管里面的故障、数据面的故障要做到租户隔离，而物理资源层面，无法真正做到故障隔离。Neutron 在故障面的目标不是租户隔离，而是容错——尽量保证不受故障影响。</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Network 是 Neutron 的一个二层网络的资源模型，它支持的网络类型有：Local、Flat、VLAN、VXLAN、GRE、Geneve 等。其中，Local 仅仅是一个主机内的网络类型，只会用于测试，不会用于生产环境。VXLAN、GRE、Geneve 属于隧道型网络，Flat 和 VLAN 属于非隧道型网络。一般来说，这些网络内的虚拟机之间的二层通信并不需要用到路由器。</p><h3 id="运营商网络和租户网络"><a href="#运营商网络和租户网络" class="headerlink" title="运营商网络和租户网络"></a>运营商网络和租户网络</h3><p>由租户创建并管理的网络，Neutron 称之为租户网络。有时候，Neutron 还需要创建一个网络来映射外部网络，这个网络称为运营商网络（Provider Network）。</p><p>运营商网络与租户网络，从模型角度来讲，都是 Neutron 的资源模型 Network。两者的区别如下：</p><ol><li>管理的权限和角色不同。租户创建的网络，就是租户网络，而运营商管理员创建的网络，就是运营商网络</li><li>创建网络时，传入的参数不同。创建运营商网络时，需要传入 provider:network_type、provider:physical_network、provider:segmentation_id 三个参数，而创建租户网络时，没有办法传入这三个参数，它们是由 OpenStack 在管理员配置的范围内自动分配的</li></ol><p>Neutron 创建了一个网络，如果这个网络只是为了映射（匹配）另外一个网络，而且这个被映射的网络不在 Neutron 的管理范围内，这样的场景就是运营商网络的一般化使用场景。Neutron 创建的这个网络，也称为运营商网络。运营商网络可以认为是运营商的某个物理网络在 OpenStack （Neutron）上的延伸。</p><h3 id="物理网络"><a href="#物理网络" class="headerlink" title="物理网络"></a>物理网络</h3><p>一般来说，物理网络可以理解为运营商网络需要匹配的那个网络。物理网络的实际意义如下：</p><ol><li>非隧道型网络角度<ul><li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络的名称，这个含义是为了方便阅读和理解</li><li>无论是对于运营商网络还是租户网络，物理网络都意味着 br-ehtx 的选择（背后是主机网卡的选择），这个含义是 Neutron 所需要的，因此创建运营商网络时，需要直接传入这个参数，创建租户网络时，需要间接传入这个参数</li></ul></li><li>隧道型网络角度<ul><li>对于运营商网络，物理网络（provider:physical_network）就是这个运营商网络所要匹配的外部网络名称，之歌含义只为了方便阅读和理解，对 Neutron 无意义</li></ul></li></ol><h2 id="Trunk-Networking"><a href="#Trunk-Networking" class="headerlink" title="Trunk Networking"></a>Trunk Networking</h2><p>Trunk Networking 是 OpenStack Newton 版本所增加的特性，目的是为了支持 VLAN aware VM。一般情况下，VM 发送和接收的报文都是不带 VLAN Tag 的，不过有时候，VM 也期望能够发送和接收带有 VLAN Tag 的报文，这种情形即可称为 VLAN aware VM。</p><h3 id="Bridge-的-VLAN-接口模式"><a href="#Bridge-的-VLAN-接口模式" class="headerlink" title="Bridge 的 VLAN 接口模式"></a>Bridge 的 VLAN 接口模式</h3><p>一个 Bridge 可以抽象为两大部分：交换模块（基于 VLAN ID 做报文交换）和接口。</p><p>Bridge 接口关于 VLAN ID 的处理方式有三种模式：Access、Trunk 和 Hybrid。</p><h4 id="Access-接口模式"><a href="#Access-接口模式" class="headerlink" title="Access 接口模式"></a>Access 接口模式</h4><p>Access 模式，在报文入接口，对于 Tag 报文，直接丢弃，对于 Untag 报文，则打上 Default VID Tag 后送入交换模块（进行 VLAN 交换）。在报文出接口，先将报文去除 Tag，然后再从接口转发。</p><h4 id="Trunk-接口模式"><a href="#Trunk-接口模式" class="headerlink" title="Trunk 接口模式"></a>Trunk 接口模式</h4><p>Trunk 模式，首先要配置允许进入接口的 VLAN ID 列表（范围）。在列表范围内的 VLAN ID 可以进入端口，其他的则不允许进入。</p><h4 id="Hybrid-接口模式"><a href="#Hybrid-接口模式" class="headerlink" title="Hybrid 接口模式"></a>Hybrid 接口模式</h4><p>Hybrid 模式，在 Trunk 模式的基础上又多了一部分内容。Trunk 模式，在报文出接口时，如果 VLAN ID 等于 Default ID，那么 VLAN Tag 会去除。而 Hybrid 模式，允许配置哪些 VLAN ID 的报文，在出接口时，需要去除 VLAN Tag，比如配置 VLAN ID 在 40 ~ 50 这个范围内的报文，当其出接口时，需要去除 VLAN Tag。</p><blockquote><p>上述描述中的几个名词解释：</p><ul><li>Tag 报文：指的是报文中有 VLAN ID，简称 Tag</li><li>Untag 报文：指的是报文中没有 VLAN ID，简称 Untag</li><li>Default ID：端口默认 VLAN ID。Bridge 端口的默认 VLAN ID 为 “1”。这个默认值可以被修改</li></ul></blockquote><h3 id="VLAN-aware-VM-与-Trunk-Networking"><a href="#VLAN-aware-VM-与-Trunk-Networking" class="headerlink" title="VLAN aware VM 与 Trunk Networking"></a>VLAN aware VM 与 Trunk Networking</h3><p>VM 能够发送和接收带有 VLAN Tag 的报文，这种情形称作 VLAN aware VM。在没有引入 Trunk Networking 特性之前，Neutron 的模型设计中有这样的约束：一个 Port 只能属于一个 Network。假设一个 VM 只有一个 Port，如果想让 VM 具备 VLAN aware 特性，就意味着这个 Port 必须要属于多个 Network，这与 Neutron 的约束是矛盾的。这里所涉及的 Port，可以简单理解为 VM 的虚拟网口（virtual Network Interface Card，vNIC）。为了解决这个问题，Neutron 提出了 Trunk Networking 方案，主要解决实现 VLAN aware 的以下问题：</p><ol><li>VM aware 的 VLAN ID，在 Host 内部不能冲突</li><li>VM aware 的 VLAN ID，不需要在 Host 之间的物理网络透传（不能要求物理网络透传该 VLAN ID，因为物理网络很可能不在 Neutron 的管理范围内）</li><li>不要打破原来的 Network、Port 模型，否则会引发 Neutron 的源代码大量修改</li></ol><h4 id="Trunk-Networking-的实现模型"><a href="#Trunk-Networking-的实现模型" class="headerlink" title="Trunk Networking 的实现模型"></a>Trunk Networking 的实现模型</h4><p>为了解决 VM aware 的 VLAN ID 与 Host 内部的 VLAN ID 冲突的问题， Neutron 引入了一个 Trunk Bridge。Trunk Bridge 仍然是一个普通的 Bridge，只不过接口模式有所不同。Neutron 利用 br-trunk 做 VLAN ID 的转换，就可以解决上述的 VLAN ID 冲突的问题。</p><h4 id="Trunk-Networking-的资源模型"><a href="#Trunk-Networking-的资源模型" class="headerlink" title="Trunk Networking 的资源模型"></a>Trunk Networking 的资源模型</h4><p>Neutron 最终采取的模型不是“一个 Port 对应多个 Network”，而是增加了一个模型，名为 trunk，这个模型里最核心的就是两个字段：Parent Port 和 Sub Port List，如下表所示：</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">port_id</td><td align="center">stirng</td><td align="center">父端口 ID</td></tr><tr><td align="center">sub_ports</td><td align="center">array</td><td align="center">Trunk 关联的子端口列表</td></tr></tbody></table><p>这个模型在不同的视角有不同的解读，并解决了对应的问题。</p><p>从 VM 视角，它仍然相当于一个端口对接多个网络，因为它的端口可以发送带 VLAN ID 的报文，每个 VLAN ID 对应一个网络。这解决了 VM 的端口不能太多的问题。</p><p>从 Neutron 模型的角度，Trunk 模型利用一个 Parent Port （对应字段为 port_id）和多个 Sub Port（对应字段为 sub_ports）与不同的 Network 相对应。Parent Port 与 Sub Port 对应的都是 Port 模型，它们与 Network 的关系仍是一个 Port 对应一个 Network。</p><p>Trunk Networking 方案没有修改原来的实现模型和资源模型，而是在原来的实现模型中引入了 Trunk Bridge。在原来的资源模型中引入了 Trunk 资源模型，对原来的代码修改较少，就支持了 VLAN aware VM 特性。</p><h2 id="Subnet"><a href="#Subnet" class="headerlink" title="Subnet"></a>Subnet</h2><p>Subnet（子网）在一般概念中，有两个基本含义：</p><ol><li>这个子网的网段（CIDR）和 IP 版本</li><li>这个子网的路由信息（含默认路由）</li></ol><p>Neutron 中，Subnet 模型除了标识 CIDR、IP version 这样的纯逻辑资源外，为了解决 VM 的 IP 地址分配和 DNS 设置问题，还蕴含了管理功能，这些管理功能又称为 IP 的核心服务。</p><h3 id="IP-核心网络服务"><a href="#IP-核心网络服务" class="headerlink" title="IP 核心网络服务"></a>IP 核心网络服务</h3><p>IP 核心网络服务（IP Core Network Services），又称 DDI 服务，包括：DNS、DHCP 和 IPAM。这三个服务是所有 IP 网络及应用系统得以顺利运行的基础。</p><h2 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h2><p>如果说 Network 是 Neutron 模型中的“根”，那么 Port 则是 Neutron 模型中的“灵魂”，尤其是对于三层转发来说。因为无论 Neutron 的模型怎么设计，它的三层转发总归是绕不开 IP 地址，而承载 IP 地址的就是 Port。</p><p>Port 是一个逻辑模型，但是也可以理解为其代表一个虚拟网口。所以一个 VM 需要绑定 Port，一个 Router 也需要绑定 Port。作为一个虚拟网口，Port 具备两个基本属性：IP 地址和 MAC 地址。一个 Port 可以有多个 IP 地址，但在一般情况下，一个 Port 只有一个 MAC 地址。但是 Port 模型中有一个 allowed_address_pairs字段，允许多个绑定多个 MAC 地址，其典型的应用场景为 Antispoofing（一种识别和删除有错误源地址的数据包技术）。</p><p>Network、Subnet、Port 三者的关系如下：</p><p>一个 Network 可以有多个 Subnet，一个 Subnet 只能归属一个 Network。同时一个  Network 可以有多个 Port，而一个 Port 可以与其所在的 Network 中的所有 Subnet 相关联。当然，一个 Subnet 也可以有多个 Port。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>如果说 Port 是 Neutron 模型的“灵魂”，那么 Router 就是 Neutron 模型的 “发动机”，它承担着路由转发的功能。Router 可以简单地抽象为三部分：端口、路由表、路由协议处理单元。Router 最关键的两个概念就是端口和路由表。</p><p>Neutron 的 Router 模型中，蕴含三种路由：直连路由、默认静态路由和静态路由。前两种路由不需要显式地增加路由表项（routes 的 [destination (string), nexthop (string)]），也不会体现在路由表（routes）中。</p><p>路由表中的路由也是静态路由，它与默认静态路由一样，都是通往外部网络（Neutron 管理范围外的网络）。静态路由中的外部网络，一般指的是私网，而默认静态路由中的外部网络，一般指的是公网。</p><h3 id="Floating-IP"><a href="#Floating-IP" class="headerlink" title="Floating IP"></a>Floating IP</h3><p>Floating IP 首先是一个 SNAT/DNAT 转换规则：floating_ip_address（外网/公网 IP）与 fixed_ip_address （内网/私网 IP）互相转换。然后，从实现角度来讲，他才是绑定到一个 Router（router_id）的端口（port_id）上，以让报文在进出这个端口时，Router 能对其做 SNAT/DNAT 转换。</p><h2 id="BGP-VPN"><a href="#BGP-VPN" class="headerlink" title="BGP VPN"></a>BGP VPN</h2><p>Neutron 的 BGP VPN，指的是 MP-BGP MPLS L3VPN 或者是 E-VPN （E-VPN 的控制协议也是 MP-BGP）。</p><p>Neutron 中 BGP VPN 的实现模型主要是关于 PE/CE 的实现方法，有如下几种：</p><ol><li>PE/CE 都位于计算节点内，VM 扮演 CE 的角色，PE 则有 br-ehtx/br-tun（OVS）承担</li><li>PE/CE 都位于网络节点内， Router 承担 CE 角色，而由 L3 Agent 承担 PE 角色</li><li>CE 位于网络节点内，PE 位于外部路由器，Router 承担 CE 角色，而由外部路由器承担 PE 角色</li></ol><blockquote><p>名词解释：</p><p>PE：Provider Edge，运营商边缘路由器</p><p>CE：Customer Edge，用户边缘路由器</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Neutron 把它管理的对象统统称为资源，表面上看起来这些资源的名称与传统电信领域的命名（比如 Network、Subnet）等完全一致，但是由于管理的范围（Neutron 的管理范围主要还是 DC 内）和管理对象的特点（Neutron 主要管理 Host 内部的虚拟网元）等原因，Neutron 的资源模型在传统电信的理论基础上又有其特点。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenStack" scheme="https://www.freedomly.tk/categories/OpenStack/"/>
    
    
    <category term="Neutron" scheme="https://www.freedomly.tk/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>《Vim 教程》指令记录</title>
    <link href="https://www.freedomly.tk/2019/05/17/Vimtutor-commands/"/>
    <id>https://www.freedomly.tk/2019/05/17/Vimtutor-commands/</id>
    <published>2019-05-17T05:54:10.000Z</published>
    <updated>2019-05-17T05:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前跟着 <a href="https://www.vim.org/download.php">Vim</a> 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。</p><a id="more"></a><p>在命令行输入 <code>vimtutor</code> 进入 Vim 自带的教程。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>移动光标分别为 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 键，当然也可以通过键盘上的方向键进行移动。不过考虑方向键离主键盘较远，因此使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>会更加高效。如果不确定当前的指令，只需要按下 <code>ESC</code> 键即可回到正常模式，然后再次输入指令。</p><h3 id="Vim-的进入和退出"><a href="#Vim-的进入和退出" class="headerlink" title="Vim 的进入和退出"></a>Vim 的进入和退出</h3><p>在正常模式下，输入 <code>:q!</code> 然后再按下回车键即可退出当前打开的文档，该指令会丢弃之前对文件所作的所有改动。<br>如果是命令提示符中通过 <code>vimtutor</code> 进入教程的，这时会返回至命令行的界面，这时只需重新输入 <code>vimtutor</code>，即可重新进入教程，只不过之前对文档的修改都未得到保存（不管保存与否，通过 <code>vimtutor</code> 进入教程每次都会打开一个副本）。</p><blockquote><p>若未对文档进行修改，输入 <code>:q</code> 即可退出 Vim，<code>:q!</code> 用于对文档有修改，但是不保存的情况，表示强制退出。</p></blockquote><h3 id="文本编辑之删除"><a href="#文本编辑之删除" class="headerlink" title="文本编辑之删除"></a>文本编辑之删除</h3><p>在正常模式下（如果不知道是否处于正常模式，可以按下 <code>ESC</code> 来确保处于正常模式），可以按下 <code>x</code> 键来删除光标所在位置的字符。</p><h3 id="文编编辑之插入"><a href="#文编编辑之插入" class="headerlink" title="文编编辑之插入"></a>文编编辑之插入</h3><p>在正常模式下，按下 <code>i</code> 键来插入文本。这时会进入插入模式，当完成插入后，可按下 <code>ESC</code> 键返回正常模式。</p><h3 id="文本编辑之添加"><a href="#文本编辑之添加" class="headerlink" title="文本编辑之添加"></a>文本编辑之添加</h3><p>在正常模式下，按下 <code>A</code> 键来添加文本。与插入文本不同的是，添加文本操作会将光标移至当前行的行末。同样地，添加完成后，按下 <code>ESC</code> 键返回正常模式。</p><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><p>之前讲到如何退出 Vim，下面介绍如何保存修改后的文件。</p><p>在命令行输入 <code>vim &lt;filename&gt;</code> 并回车，会进入名为 <code>&lt;filename&gt;</code> 的文档，通过之前的命令对文档进行修改，修改完成后，输入 <code>:wq</code> 并按下回车键即可保存改动并退出 Vim。</p><h2 id="删除与撤销"><a href="#删除与撤销" class="headerlink" title="删除与撤销"></a>删除与撤销</h2><h3 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h3><p>确保处于正常模式，输入 <code>dw</code> 即可从光标处删除至一个单词的末尾。</p><blockquote><p>当我们输入时，字母 <code>d</code> 会同时出现在屏幕的最后一行。Vim 在等待输入字母 <code>w</code>。如果看到的是除 <code>d</code> 以外的其他字符，表明输入了错误的指令，这时可以按下 <code>ESC</code> 键，并重新输入。</p></blockquote><h3 id="更多删除类命令"><a href="#更多删除类命令" class="headerlink" title="更多删除类命令"></a>更多删除类命令</h3><p>在正常模式下，输入 <code>d$</code> 从当前光标删除到行末。</p><h3 id="关于命令和对象"><a href="#关于命令和对象" class="headerlink" title="关于命令和对象"></a>关于命令和对象</h3><p>许多改变文本的命令都由一个操作符和一个动作构成。</p><p>使用删除操作符 <code>d</code> 的删除命令的格式如下：</p><p><strong>d motion</strong></p><p>其中：</p><ul><li><code>d</code> 表示删除操作符</li><li><code>motion</code> 表示操作符的操作对象</li></ul><p>基本的动作列表如下所示：</p><table><thead><tr><th align="center">操作对象</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">w</td><td align="left">从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符</td></tr><tr><td align="center">e</td><td align="left">从当前光标当前位置直到单词末尾，包括最后一个字符</td></tr><tr><td align="center">$</td><td align="left">从当前光标当前位置直到当前行末</td></tr></tbody></table><p>因此输入 <code>de</code> 会从当前光标位置删除到单词末尾。</p><blockquote><p>若不输入操作符，只按下代表相应动作的键，则光标的移动将会按照上述动作进行。</p></blockquote><h3 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h3><p>在动作前输入数字会使它重复那么多次。例如：</p><ul><li>输入 <code>2w</code> 使光标向前移动两个单词。</li><li>输入 <code>3e</code> 使光标向前移动到第三个单词的末尾。</li><li>输入 <code>0</code> 移动光标到行首。</li></ul><p>通过输入不同的数值，可以执行相应的操作。</p><h3 id="使用计数以删除更多"><a href="#使用计数以删除更多" class="headerlink" title="使用计数以删除更多"></a>使用计数以删除更多</h3><p>使用操作符时输入数字可以使它重复那么多次。上面已经提到过删除操作和动作的组合，我们还可以在组合中动作之前插入一个数字以删除更多：</p><p><strong>d number motion</strong></p><p>例如：</p><ul><li>输入 <code>d2w</code> 可以删除两个单词</li></ul><h3 id="操作整行"><a href="#操作整行" class="headerlink" title="操作整行"></a>操作整行</h3><p>输入 <code>dd</code> 可以删除当前一整行。</p><p>鉴于整行删除操作的高频度，Vim 提供了简化的删除操作，我们只需在同一行上输入两次 <code>d</code> 即可删除光标所在的行了。同时可以在 <code>dd</code> 操作前加入数字，以删除多行，例如：</p><ul><li>输入 <code>2dd</code> 可以删除两行。</li></ul><h3 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h3><p>正常模式下，输入 <code>u</code> 来撤销最后执行的命令，输入 <code>U</code> 来撤销对整行的修改。例如按下了 <code>x</code> 删除了当前行的一个字符，那么可以通过 <code>u</code> 来撤销删除操作。若当前行执行了多个操作，需要全部撤销，则可通过 <code>U</code> 来撤销对当前行的所有修改。如果想要重做被撤销的命令，可以按下 <code>CTRL-R</code>，也即撤销掉撤销命令，回到原来修改后的状态。</p><h2 id="置入、更改和替换"><a href="#置入、更改和替换" class="headerlink" title="置入、更改和替换"></a>置入、更改和替换</h2><h3 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h3><p>正常模式下，输入 <code>p</code> 将最后一次删除的内容置入光标后。如：</p><ul><li>输入 <code>dd</code> 删除某一行</li><li>将光标移至准备置入的位置的<strong>上方</strong></li><li>在正常模式下输入 <code>p</code> 将删除的一行粘贴置入</li></ul><h3 id="替换类命令"><a href="#替换类命令" class="headerlink" title="替换类命令"></a>替换类命令</h3><p>正常模式下，输入 <code>r</code> 和一个字符替换光标所在位置的字符。</p><h3 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h3><p>正常模式下，要改变本文直到一个单词的末尾，可以使用 <code>ce</code>。同时也可以输入 <code>cw</code> 修改单词。具体操作为：</p><ul><li>将光标移动至单词中需要修改的开始位置</li><li>输入 <code>cw</code> 并输入正确的单词</li><li>按下 <code>ESC</code> 键退出修改</li></ul><blockquote><p>请注意，<code>ce</code> 和 <code>cw</code> 命令不仅仅是删除了一个单词，它同时会进入插入模式。</p></blockquote><h3 id="使用-c-更改更多"><a href="#使用-c-更改更多" class="headerlink" title="使用 c 更改更多"></a>使用 c 更改更多</h3><p>更改类操作符可以与删除中使用的同样的动作配合使用。</p><p>更改类操作符的工作方式跟删除类是一致的，其操作格式为：</p><p><strong>c [number] motion</strong></p><p>动作参数（motion）也是一样的，比如 <code>w</code> 代表单词，<code>$</code> 表示行末等。</p><h2 id="定位、查找和替换"><a href="#定位、查找和替换" class="headerlink" title="定位、查找和替换"></a>定位、查找和替换</h2><h3 id="定位及文件状态"><a href="#定位及文件状态" class="headerlink" title="定位及文件状态"></a>定位及文件状态</h3><p>正常模式下，输入 <code>CTRL-G</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</p><p>输入 <code>G</code> 可以使当前光标直接跳转到文件的最后一行。</p><p>输入 <code>gg</code> 可以使当前光标直接跳转到文件的第一行。</p><p>输入行号，然后再输入 <code>G</code> 即可使当前光标直接跳转到指定行。</p><h3 id="搜索类命令"><a href="#搜索类命令" class="headerlink" title="搜索类命令"></a>搜索类命令</h3><p>正常模式下，输入 <code>/</code> 加上一个字符串可以用以在当前文档中查找该字符串。</p><p>要查找同上一次的字符串，只需按下 <code>n</code> 键，如果要反向进行查找，则输入 <code>N</code>。</p><p>要反向查找字符串，可以用 <code>?</code> 代替 <code>/</code>。</p><p>要返回到之前的位置，可以按下 <code>CTRL-O</code>，重复按可以回退更多步。输入 <code>CTRL-I</code> 则会跳转到较新的位置，与 <code>CTRL-O</code> 执行的操作相反。</p><blockquote><p>如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 ‘wrapscan’ 选项被复位。</p></blockquote><h3 id="配对括号的查找"><a href="#配对括号的查找" class="headerlink" title="配对括号的查找"></a>配对括号的查找</h3><p>正常模式下，输入 <code>%</code> 可以查找配对的括号 <code>)</code>、<code>]</code>、<code>&#125;</code>。</p><p>若当前光标所在位置的字符为 <code>)</code>、<code>]</code> 或者是 <code>&#125;</code>，输入 <code>%</code> 即可使光标跳转至配对的括号处，再次输入 <code>%</code> 即可返回之前括号的位置。</p><h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><p>正常模式下，输入 <code>:s/old/new/g</code> 可以替换 old 为 new。</p><p>若要替换两行之间出现的每个字符串，可以通过以下命令：</p><ul><li>输入 <code>:#,#s/old/new/g</code>， <code>#,#</code> 表示替换操作的若干行的首尾行号</li><li>输入 <code>:%s/old/new/g</code>，表示替换整个文件中的每个匹配串</li><li>输入 <code>:%s/old/new/gc</code>，则会查找整个文件中的匹配串，并且对每个匹配串提示是否进行替换</li></ul><h2 id="文件相关操作"><a href="#文件相关操作" class="headerlink" title="文件相关操作"></a>文件相关操作</h2><h3 id="在-Vim-内执行外部命令的方法"><a href="#在-Vim-内执行外部命令的方法" class="headerlink" title="在 Vim 内执行外部命令的方法"></a>在 Vim 内执行外部命令的方法</h3><p>在正常模式下，输入 <code>:!</code> 然后紧接着输入一个外部命令即可执行该外部命令。</p><p>如输入 <code>:!ls</code> 并按下回车，会列出当前目录的内容。</p><h3 id="关于保存文件的更多信息"><a href="#关于保存文件的更多信息" class="headerlink" title="关于保存文件的更多信息"></a>关于保存文件的更多信息</h3><p>正常模式下，输入 <code>:w FILENAME</code> 可以将对文件的改动保存到 FILENAME 中。</p><p>若要删除保存的文件，可以通过执行外部命令的方法，输入 <code>:!rm TEST</code> 进行删除。</p><h3 id="一个具有选择性的保存命令"><a href="#一个具有选择性的保存命令" class="headerlink" title="一个具有选择性的保存命令"></a>一个具有选择性的保存命令</h3><p>在正常模式下，若要保存文件的部分内容，可以输入 <code>v motion :w FILENAME</code>。具体操作如下：</p><ul><li>将光标移动至要保存内容的开始位置</li><li>接着按下 <code>v</code> 键进入可视模式，并继续移动光标至要保存内容的结束位置，这些内容会高亮显示</li><li>然后按下 <code>:</code>，这时屏幕底部会出现 <code>:&#39;&lt;,&#39;&gt;</code></li><li>接着输入 <code>w FILENAME</code>，然后按下回车键</li><li>所选中的内容将会被写入 FILENAME 中。</li></ul><blockquote><p>按 <code>v</code> 键使 Vim 进入可视模式。我们可以移动光标使选取区域变大或变小。接着可以使用一个操作符对选中的文本进行操作。例如：按 <code>d</code> 键删除所选中的文本内容。</p></blockquote><h3 id="提取和合并文件"><a href="#提取和合并文件" class="headerlink" title="提取和合并文件"></a>提取和合并文件</h3><p>可以通过 <code>:r FILENAME</code> 命令向当前文件中插入另外文件的内容。</p><blockquote><p>除了合并文件外，还可以读取外部命令的输出。例如：<code>:r !ls</code> 可以读取 ls 命令的输出，并将其放置在光标打下面。</p></blockquote><h2 id="打开、附加、替换、复制和设置类命令"><a href="#打开、附加、替换、复制和设置类命令" class="headerlink" title="打开、附加、替换、复制和设置类命令"></a>打开、附加、替换、复制和设置类命令</h2><h3 id="打开类命令"><a href="#打开类命令" class="headerlink" title="打开类命令"></a>打开类命令</h3><p>正常模式下，输入 <code>o</code> 将在光标打下方打开新的一行并进入插入模式。</p><p>若要在光标的<strong>上方</strong>打开新的一行，则需要输入 <code>O</code>。</p><h3 id="附加类命令"><a href="#附加类命令" class="headerlink" title="附加类命令"></a>附加类命令</h3><p>正常模式下，输入 <code>a</code> 将在光标之后插入文本。</p><blockquote><p><code>a</code>、<code>i</code>、<code>A</code> 都会进入插入模式，唯一的区别在于字符插入的位置。<code>i</code> 将字符插入于光标之前，<code>a</code> 将字符插入于光标之后，而 <code>A</code> 则将字符插入于光标所在行的末尾。</p></blockquote><h3 id="另一个置换命令的版本"><a href="#另一个置换命令的版本" class="headerlink" title="另一个置换命令的版本"></a>另一个置换命令的版本</h3><p>正常模式下，输入 <code>R</code> 可以连续替换多个字符。具体操作如下：</p><ul><li>将光标移动至要替换内容的起始位置</li><li>输入 <code>R</code>，然后逐一输入要替换的字符</li><li>按下 <code>ESC</code> 键退出替换模式回到正常模式。</li></ul><blockquote><p>替换模式与插入模式类似，不过每个输入的字符都会删除一个已有的字符。</p></blockquote><h3 id="复制粘贴文本"><a href="#复制粘贴文本" class="headerlink" title="复制粘贴文本"></a>复制粘贴文本</h3><p>正常模式下，使用操作符 <code>y</code> 复制文本，使用 <code>p</code> 粘贴文本。例如：</p><ul><li>移动光标至所要复制内容的起始位置</li><li>按下 <code>v</code> 键进入可视模式</li><li>移动光标至所要复制内容的结束位置</li><li>输入 <code>y</code> 复制高亮文本</li><li>移动光标至要粘贴的位置，输入 <code>p</code> 以复制文本</li></ul><blockquote><p>可以把 <code>y</code> 当作操作符来使用。例如：<code>yw</code> 表示复制一个单词。</p></blockquote><h3 id="设置类命令选项"><a href="#设置类命令选项" class="headerlink" title="设置类命令选项"></a>设置类命令选项</h3><p>设置可使查找或者替换可忽略大小写的选项。例如：</p><ul><li>要查找单词 ignore 可以在正常模式下输入 <code>/ignore</code> 并回车</li><li>然后设置 ic 选项（Ignore Case，忽略大小写），输入：<code>:set ic</code></li><li>现在可以通过输入 <code>n</code> 键查找单词 ignore，且现在能够查找 Ignore 和 IGNORE</li><li>然后设置 hlsearch 和 insearch 这两个选项，输入：<code>set hls is</code></li><li>现在在此输入查找命令：<code>/ignore</code>，可以发现符合要求的字符串高亮显示了</li><li>若要禁用忽略大小写，则输入：<code>:set noic</code></li></ul><p>输入 <code>:set xxx</code> 可以设置 xxx 选项，一些常用的选项如下：</p><table><thead><tr><th align="center">缩写</th><th align="center">全称</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">ic</td><td align="center">ignorecase</td><td align="left">查找时忽略字母大小写</td></tr><tr><td align="center">is</td><td align="center">insearch</td><td align="left">查找短语时显示部分匹配</td></tr><tr><td align="center">hls</td><td align="center">hlsearch</td><td align="left">高亮显示所有的匹配短语</td></tr></tbody></table><blockquote><p>若要移除匹配项的高亮显示，可以输入：<code>:nohlsearch</code>。在选项前加上 <code>no</code> 可以关闭选项。<br>如果想要仅在一次查找时忽略字母大小写，可以使用 <code>\c:/ignore\c</code> 并回车</p></blockquote><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="在线帮助系统"><a href="#在线帮助系统" class="headerlink" title="在线帮助系统"></a>在线帮助系统</h3><p>Vim 拥有一个细致全面的在线帮助系统，可以通过下述命令启动该系统：</p><ul><li>按下 <HELP> 键</li><li>按下 <F1> 键</li><li>输入 <code>:help</code> 并回车</li></ul><p>输入 <code>CTRL-W</code> 可以在不同窗口间切换</p><p>在 <code>:help</code> 命令中添加关键字，可以找到改关键字的帮助，如：</p><ul><li><code>:help w</code></li><li><code>:help c_CTRL-D</code></li><li><code>:help insert-index</code></li><li><code>:helo user-manual</code></li></ul><h3 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h3><p>通过创建启动脚本，可以启用 Vim 的特性。Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，可以创建一个 vimrc 文件。</p><ul><li>开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：<ul><li><code>:edit ~/.vimrc</code>，这是 Unix 系统所使用的命令</li><li><code>:edit $VIM/_vimrc</code>，这是 MS-Windows 系统所使用的命令</li></ul></li><li>接着读取 vimrc 示例文件的内容：<ul><li><code>:r $VIMRUNTIME/vimrc_example.vim</code></li></ul></li><li>保存文件，命令为：<ul><li><code>:write</code></li></ul></li></ul><p>下次启动 Vim 时，编辑器就会有了语法高亮的功能。我们可以把喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 <code>:help imrc-intro</code>。</p><h3 id="补全功能"><a href="#补全功能" class="headerlink" title="补全功能"></a>补全功能</h3><p>使用 <code>CTRL-D</code> 和 <code>TAB</code> 可以进行命令补全。</p><blockquote><p>补全对于许多命令都有效。只需尝试按 CTRL-D 和 TAB。它对于 :help 命令非常有用。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前跟着 &lt;a href=&quot;https://www.vim.org/download.php&quot;&gt;Vim&lt;/a&gt; 自带的 《Vim 教程》过了一遍常用的快捷键和命令，下面作一下记录，方便后续查找和回忆。&lt;/p&gt;</summary>
    
    
    
    <category term="Vim" scheme="https://www.freedomly.tk/categories/Vim/"/>
    
    
    <category term="Vim教程" scheme="https://www.freedomly.tk/tags/Vim%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Neutron -- Neutron 的网络实现模型</title>
    <link href="https://www.freedomly.tk/2019/05/16/OpenStack-Neutron-Network-Model/"/>
    <id>https://www.freedomly.tk/2019/05/16/OpenStack-Neutron-Network-Model/</id>
    <published>2019-05-16T06:26:17.000Z</published>
    <updated>2019-05-16T06:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。</p><a id="more"></a><h2 id="计算节点"><a href="#计算节点" class="headerlink" title="计算节点"></a>计算节点</h2><p>一个基于 OpenStack 的云系统会有很多计算节点，一个计算节点就是一个 Host。一个计算节点里包含多个 VM。计算节点的网络模型主要服务于二层网络，用于构建各种类型的二层网络。而二层网络通信需要 Bridge/Switch（这里可以将 Bridge/Switch 理解为同一个概念）。只考虑网络层面，计算节点可分为 2 层：用户网络层、本地网络层。</p><h3 id="用户网络层"><a href="#用户网络层" class="headerlink" title="用户网络层"></a>用户网络层</h3><p>用户网络层（User Network），指的是 OpenStack 的用户创建的网络，也即外部网络，这个外部网络是相对于 Host 内部网络而言的。用户网络层对应的 Bridge 是 br-ethx （对应Flat、VLAN 等非隧道型二层网络）或者 br-tun （对应 VXLAN、GRE 等隧道型二层网络），其实现载体一般来说是 OVS （Open vSwitch）。用户网络层实现的是用户网络和本地网络之间的相互转换。<strong>用户网络层是对本地网络层的一个屏蔽，即不管用户网络采用什么技术（如 VXLAN、GRE 等），本地网络永远感知的仅仅是一个技术：VLAN</strong>。</p><h3 id="本地网络层"><a href="#本地网络层" class="headerlink" title="本地网络层"></a>本地网络层</h3><p>本地网络指的是 Host 内部的本地网络。本地网络只要感知一种技术：VLAN。本地网络还可以分为两层：安全层、Bridge 层。</p><h4 id="qbr"><a href="#qbr" class="headerlink" title="qbr"></a>qbr</h4><p>qbr 的实现载体是 Linux Bridge，它仅仅负责安全相关设置，所以称之为安全层。</p><h4 id="br-int"><a href="#br-int" class="headerlink" title="br-int"></a>br-int</h4><p>br-int 的实现载体一般是 OVS，她负责内部交换，所以称之为 Bridge 层。<strong>Bridge 层是对 VM 层的一个屏蔽。从 VM 发出的 Untag 报文，被 Bridge 层转换为 Tag 报文转发到 br-ethx/br-tun；从 br-ethx/br-tun 转发到 br-int 的 Tag 报文，被 br-int 剥去 Tag，变成 Untag 报文，然后再转发给 VM</strong>。</p><p>位于同一个 Host 的本地网络中的不同 VM 之间的通信，他们经过本地层网络（即经过 br-int）即可完成，无需通再往上通过用户网络层。</p><h2 id="网络节点"><a href="#网络节点" class="headerlink" title="网络节点"></a>网络节点</h2><p>在计算节点中，同属一个二层网络的 VM 可以自由进行二层通信。若要访问二层网络之外的网络，则需要网络节点。Neutron 除了在网络节点部署 Router （此路由器为虚拟路由器，利用了 Linux 内核功能）之外，还部署了 DHCP Server 等服务。从网络视角看，网络节点可分为 4 层：用户网络层、本地网络层、网络服务层和外部网络层。前两层与计算节点几乎相同。</p><h3 id="网络服务层"><a href="#网络服务层" class="headerlink" title="网络服务层"></a>网络服务层</h3><p>网络服务层为计算节点的 VM 提供网络服务，典型的服务有 DHCP Service 和 Router Service。关于 DHCP 有如下概念：</p><ol><li>Neutron 的 DHCP Service，采用的是 dnsmasq 进程（轻量级服务进程，可以提供 dns、dhcp、tftp等服务）</li><li>一个网络一个 DHCP Service</li><li>由于存在多个 DHCP Service （多个 dnsmasq 进程），Neutron 采用的是 namespace 方法做隔离，即一个 DHCP Service 运行在一个 namespace 中。</li></ol><p>网络服务层中的 Router 本质上是 Linux 内核模块。Router 做路由转发外，还提供 SNAT/DNAT 功能。为了达到隔离的目的，每个 Router 运行在一个 namespace 中。准确地说，Neutron 创建了 namespace，并且在 namespace 中开启了路由转发功能。</p><blockquote><ol><li>SNAT：Source Network Address Translation，源地址路由转换；DNAT：Destination Network Address Translation，目的地址路由转换</li><li>OpenStack Juno 版本引入了 DVR 特性，DVR 部署在计算节点上。计算节点访问 Internet，不必经过网络节点，直接从计算节点的 DVR 即可访问</li></ol></blockquote><h3 id="外部服务层"><a href="#外部服务层" class="headerlink" title="外部服务层"></a>外部服务层</h3><p>外部服务层包含 br-ex 和 Router。Router 是与外部网络联通的主体，而 br-ex 则是将 Router 对接到网络节点的物理网口。br-ex 相当于一个 Hub，而实际上 br-ex 是一个 Bridge，一般选用 OVS。</p><h2 id="控制节点"><a href="#控制节点" class="headerlink" title="控制节点"></a>控制节点</h2><p>计算机节点与网络节点承担 OpenStack 中网络构建的任务，实现网络功能的是两个节点中的各个 Bridge、DHCP Service 和 Router 等虚拟网元。控制节点并不实现具体网络功能，只是对各种虚拟网元进行管理和控制。控制节点部署着 OpenStack 的各种进程，对于 Neutron 来说，它的进程名为 neutron-server。</p><p>Neutron 中的控制功能不仅仅体现于一个控制节点，还包含计算节点和网络节点中的各种 Agent。控制节点中的 Neutron 进程只是 Neutron 控制系统的一部分。</p><p>控制节点的 Neutron 进程通过 RESTful 或者 CLI （Command Line Interface，命令行）接口接收外部请求，通过 RPC 与 Agent 进行交互。Neutron 进程与各个 Agent 进程共同完成管理控制任务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从部署角度来说，Neutron 分为三类节点：控制节点、网络节点和计算节点。<strong>网络节点和计算节点为 VM 构建了具体网络，控制节点则对这些网络进行管理。</strong></p><p>控制节点的 Neutron 进程与网络节点、计算节点的各个 Agent 进程互相配合，对内完成对网络节点、控制节点<strong>？</strong>（书上是控制节点，但是感觉应该是计算节点）中虚拟网元的配置管理，对外提供 RESTful 等服务接口。Neutron 进程与 Agent 进程之间的通信协议是 RPC（Remote Procedure Call，远程过程调用）。</p><p>计算节点中的各个 Bridge 构建了 Neutron 中的 Local、Flat、VLAN、GRE、VXLAN、Geneve 6 种二层网络。br-ethx 与 br-tun 对外构建用户网络，内对则为 br-int 屏蔽用户网络的各种差异，将不同类型的用户网络转换为 VLAN 网络。br-int 在 Host 内部为各个 VM 构建了一个本地网络。qbr 为 br-int （也是为各个 VM）提供辅助的安全功能。</p><p>网络节点为 Neutron 提供了其他网络服务，比如 DHCP Service 等。网络节点中的 Router，则提供了三层服务，除了提供普通的路由转发功能外，还提供了 SNAT/DNAT 等功能。</p><p>Neutron 的三类节点互相配合，共同完成了 Neutron 对外宣称的使命：NaaS（Network as a Service，网络即服务）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;承载 Neutron 抽象的网络资源模型的方案，称之为 Neutron 的网络实现模型。Neutron 仅为管理系统（或者说是控制系统），它本身并不能实现任何网络功能，实现网络功能的是各种网元。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenStack" scheme="https://www.freedomly.tk/categories/OpenStack/"/>
    
    
    <category term="Neutron" scheme="https://www.freedomly.tk/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Neutron -- Linux 虚拟网络基础</title>
    <link href="https://www.freedomly.tk/2019/05/14/OpenStack-Neutron-Linux-Virtual-Network/"/>
    <id>https://www.freedomly.tk/2019/05/14/OpenStack-Neutron-Linux-Virtual-Network/</id>
    <published>2019-05-14T03:59:26.000Z</published>
    <updated>2019-05-14T04:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Neutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。</p><a id="more"></a><h2 id="TAP-TUN"><a href="#TAP-TUN" class="headerlink" title="TAP/TUN"></a>TAP/TUN</h2><p>TAP/TUN 是 Linux 内核实现的一对虚拟网络设备。TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作硬件网络设备那样，通过 TAP/TUN 设备发送数据。</p><p>Linux 中设备的含义并不是指实际的物理硬件，而是一个类似于数据结构、内核模块或设备驱动。像 TAP/TUN 这样的设备，其数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tun_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];<span class="comment">// 设备名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">// 区分 TAP 和 TUN 设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span><span class="comment">// 文件异步通知结构</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;<span class="comment">// 文件等待队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> <span class="title">dev</span>;</span><span class="comment">// Linux 抽象网络设备结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">txq</span>;</span><span class="comment">// 网络缓冲区队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_status</span> <span class="title">stats</span>;</span><span class="comment">// 网卡状态信息结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TAP 与 TUN 的定义相同，通过 <code>flags</code> 来进行区分。但是从其背后所承载的功能而言，两者有着较大的区别：TAP 位于网络 OSI 模型的第二层（数据链路层），TUN 位于第三层（网络层）。</p><p>TAP 从功能定位上来讲，位于数据链路层，数据链路层的主要协议有：</p><ol><li>点对点协议（Point-to-Point Protocol）</li><li>以太网（Ethernet）</li><li>高级数据链路协议（High-Level Data Link Protocol）</li><li>帧中继（Frame Relay）</li><li>异步传输模式（Asynchronous Transfer Mode）</li></ol><p>但是 TAP 只与以太网（Ethernet）协议对于。所以，TAP 有时也称为“虚拟以太设备”。</p><p>想要使用 Linux 命令行（基于 CentOS7 x86_64）操作一个 TAP，首先需要 Linux tun 模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果输入 Linux 命令 modinfo tun，有如下输出，则说明有 tun 模块</span></span><br><span class="line">modinfo tun</span><br><span class="line">filename:/lib/modules/3.10.0-862.14.4.el7.x86_64/kernel/drivers/net/tun.ko.xz</span><br><span class="line"><span class="built_in">alias</span>:devname:net/tun</span><br><span class="line"><span class="built_in">alias</span>:char-major-10-200</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>当 Linux 版本具有 tun 模块时，还需要查看其是否已经加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep tun</span><br><span class="line">tun 31665 1</span><br></pre></td></tr></table></figure><p>如果已经加载，则会出现上述的”tun ***“那一行。如果没有加载，则可使用如下命令进行加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprob tun</span><br></pre></td></tr></table></figure><p>当确认 Linux 加载 tun 模块之后，还需要确认 Linux 是否操作 TAP/TUN 的命令行工具 tunctl：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tunctl <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如果 Linux 有输出，则说明已有命令行工具，否则表示当前 Linux 系统并没有安装 tunctl，可以通过如下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install tunctl</span><br></pre></td></tr></table></figure><blockquote><p>若安装时出现 no package tunctl avaliable 时，需要手动添加安装源：</p><ol><li>添加安装源配置文件 /etc/yun.repos.d/nux-misc.repo：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nux-misc]</span></span><br><span class="line"><span class="attr">name</span>=Nux Misc</span><br><span class="line"><span class="attr">baseurl</span>=http://li.nux.ro/download/nux/misc/el7/x<span class="number">86_64</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br></pre></td></tr></table></figure><ol start="2"><li>重新执行安装命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=nux-misc install tunctl</span><br></pre></td></tr></table></figure><p>ref: <a href="https://blog.csdn.net/lopng/article/details/72821438">CentOS 7 安装tunctl</a>  </p></blockquote><p>具备了 tun 和 tunctl 后，就可以创建一个 TAP 设备了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tunctl -t tap_test</span><br><span class="line">Set <span class="string">&#x27;tap_test&#x27;</span> persistent and owned by uid 0</span><br></pre></td></tr></table></figure><p>可以通过如下命令来查看所创建的 TAP（名字为 <code>tap_test</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link list</span><br></pre></td></tr></table></figure><p>也可以通过如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p>通过 tunctl 创建的 <code>tap_test</code> 还未绑定 IP 地址，可以通过如下命令进行绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ip addr 命令绑定 IP 地址</span></span><br><span class="line">ip addr add <span class="built_in">local</span> 192.168.100.1/24 dev tap_test</span><br><span class="line"><span class="comment"># 或者使用 ifconfig 命令绑定 IP 地址</span></span><br><span class="line">ifconfig tap_test 192.168.100.1/24</span><br></pre></td></tr></table></figure><p>使用 <code>ifconfig -a</code> 命令再次查看，可以发现 <code>tap_test</code> 已绑定了所设置的 IP 地址。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>namespace 是 Linux 虚拟网络的一个重要概念。传统 Linux 的许多资源是全局的，比如进程 ID 资源。而 namespace 的目的就是将这些资源进行隔离。Linux 可以在一个 Host 内创建许多 namespace，于是那些原本是 Linux 全局的资源，就变成了 namespace 范围内的”全局“资源，而且不同的 namespace 的资源互不可见、彼此透明（感觉类似于 C/C++ 的 namespace）。</p><p>Linux 内核对哪些资源进行了隔离可以从 include/linux/nsproxy.h 中看出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nsproxy.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namepsace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namepsace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上 6 个资源就是 Linux namespace 所隔离的资源，其含义如下表：</p><table><thead><tr><th align="center">资源</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">uts_ns</td><td align="left">UTS 为 Unix Timesharing System 的简称，包含内存名称、版本、底层体系结构等信息</td></tr><tr><td align="center">ipc_ns</td><td align="left">所有与进程间通信（IPC）有关的信息</td></tr><tr><td align="center">mnt_ns</td><td align="left">当前装载的文件系统</td></tr><tr><td align="center">pid_ns</td><td align="left">有关进程 ID 的信息</td></tr><tr><td align="center">user_ns</td><td align="left">资源配额的信息</td></tr><tr><td align="center">net_ns</td><td align="left">网络信息</td></tr></tbody></table><p>单纯从网络角度来看，一个 namespace 提供了一份独立的网络协议栈（网络设备接口、IPv4、IPv6、IP 路由、防火墙规则、sockets 等）。一个设备（Linux Device）只能位于一个 namespace 中，不同 namespace 中的设备可以利用 veth pair 进行桥接。</p><p>Linux 操作 namespace 的命令为 <code>ip netns</code>，可以通过如下命令查看其功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">help</span></span><br><span class="line">Usage:ip netns list</span><br><span class="line">ip netns add NAME</span><br><span class="line">ip netns <span class="built_in">set</span> NAME NETNSID</span><br><span class="line">ip [-all] netns delete [NAME]</span><br><span class="line">ip netns identify [PID]</span><br><span class="line">ip netns pids NAME</span><br><span class="line">ip [-all] netns <span class="built_in">exec</span> [name] cmd ...</span><br><span class="line">ip netns monitor</span><br><span class="line">ip netns list-id</span><br></pre></td></tr></table></figure><p>首先可以创建一个 namespace ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先查看当前的 namespace 列表</span></span><br><span class="line">ip netns list</span><br><span class="line"><span class="comment"># 由于当前没有 namespace，所以命令行没有任何返回</span></span><br><span class="line"><span class="comment"># 创建一个 namespace，命名为 ns_test</span></span><br><span class="line">ip netns add ns_test</span><br><span class="line"><span class="comment">#在此查看当前 namespace 列表，可以发现刚刚创建的 namespace: ns_test</span></span><br><span class="line">ip netns list</span><br><span class="line">ns_test <span class="comment"># 这个是 ip netns list 的返回值</span></span><br></pre></td></tr></table></figure><p>当我们创建一个 namespace 后，可以将原来创建的虚拟设备 tap_test 迁移到这个 namespace 中去，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> tap_test netns ns_test</span><br></pre></td></tr></table></figure><p>这个时候，在原来的 host/vm 里再执行 <code>ip link list</code> 命令，就会发现设备 <code>tap_test</code> 消失了，因为我们已经将其迁移到 <code>ns_test</code> 中去了。</p><p>通过一下命令可以查看或者操作 namespace 里的设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip [-all] netns <span class="built_in">exec</span> [NAME] cmd ...<span class="comment"># cmd 为想要操作的命令</span></span><br></pre></td></tr></table></figure><p>比如要管理 <code>ns_test</code> 里面的设备，执行命令如下：</p><ol><li>在 <code>ns_test</code> 里执行 <code>ip link list</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns_test ip link list</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code> ns_test</code> 里执行 <code>ifconfig -a</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定 IP 地址</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns_test ifconfig tap_test 192.168.50.1/24 up</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 IP 地址</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns_test ifconfig -a</span><br></pre></td></tr></table></figure><h2 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth pair"></a>veth pair</h2><p>veth pair 不是一个设备，而是一对设备，用以连接两个虚拟以太端口。操作 veth pair，需要结合 namespace，不然就没有意义。下面举一个例子，两个 namespace ns1/ns2 中各有一组 tap 组成 veth pair，两者的 IP 地址分别为 192.168.50.1 和 192.168.50.2，两个 IP 进行互 ping 测试，ping 通表示测试通过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 veth pair</span></span><br><span class="line">ip link add tap1 <span class="built_in">type</span> veth peer name tap2</span><br><span class="line"><span class="comment"># 2. 创建 namespace: ns1、ns2</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"><span class="comment"># 3. 把两个 tap 分别迁移到对应的 namespace 中</span></span><br><span class="line">ip link <span class="built_in">set</span> tap1 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> tap2 netns ns2</span><br><span class="line"><span class="comment"># 4. 分别给两个 tap 绑定 IP 地址</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add <span class="built_in">local</span> 192.168.50.1/24 dev tap1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip addr add <span class="built_in">local</span> 192.168.50.2/24 dev tap2</span><br><span class="line"><span class="comment"># 5. 将两个 tap 设置为 up</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig tap1 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ifconfig tap2 up</span><br><span class="line"><span class="comment"># 6. ping</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ping 192.168.50.1<span class="comment"># ping ns1 中的 tap</span></span><br><span class="line">...<span class="comment"># 输出结果</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.50.2<span class="comment"># ping ns2 中的 tap</span></span><br><span class="line">...<span class="comment"># 输出结果</span></span><br></pre></td></tr></table></figure><p>上述用例给出了 veth pair 连接两个namespace 的方法，veth pair 只有一对 tap，如果需要实现两个 以上的namespace 互通，则 veth pair 无法满足需求。</p><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>Bridge/Switch 可以实现两个以上 namespace 之间的互通。在 Linux 的语境里，Bridge（网桥）与 Switch（交换机）是一个概念，这里也不对两者进行区分。Linux 中实现 Bridge 功能的是 brctl 模块。在命令行中输入 <code>brctl</code> 可以查看是否正确安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">brctl</span><br><span class="line">Usage: brctl [Commands]</span><br><span class="line">commands:</span><br><span class="line">addbr&lt;bridge&gt;add bridge</span><br><span class="line">delbr&lt;bridge&gt;delete bridge</span><br><span class="line">addif&lt;bridge&gt; &lt;device&gt;add interface to bridge</span><br><span class="line">delif&lt;bridge&gt; &lt;device&gt;delete interface from bridge</span><br><span class="line">hairpin&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;turn hairpin on/off</span><br><span class="line">setageing&lt;bridge&gt; &lt;time&gt;<span class="built_in">set</span> ageing time</span><br><span class="line">setbridgeprio        &lt;bridge&gt; &lt;prio&gt;<span class="built_in">set</span> bridge priority</span><br><span class="line">setfd&lt;bridge&gt; &lt;time&gt;<span class="built_in">set</span> bridge forward delay</span><br><span class="line">sethello&lt;bridge&gt; &lt;time&gt;<span class="built_in">set</span> hello time</span><br><span class="line">setmaxage&lt;bridge&gt; &lt;time&gt;<span class="built_in">set</span> max message age</span><br><span class="line">setpathcost&lt;bridge&gt; &lt;prot&gt; &lt;cost&gt;<span class="built_in">set</span> path cost</span><br><span class="line">setportprio&lt;bridge&gt; &lt;prot&gt; &lt;prio&gt;<span class="built_in">set</span> port priority</span><br><span class="line">show[ &lt;bridge&gt; ]show a list of bridges</span><br><span class="line">showmacs&lt;bridge&gt;show a list of mac addrs</span><br><span class="line">showstp&lt;bridge&gt;show bridge stp info</span><br><span class="line">stp&lt;bridge&gt; &#123;on|off&#125;turn stp on/off</span><br></pre></td></tr></table></figure><p>若未安装，可通过如下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bridge-utils</span><br></pre></td></tr></table></figure><p>接下来也通过一个例子来说明 Bridge 的基本用法，同时也涵盖了之前所述的几个概念：tap、namespace、veth pair。样例中有 4 个 namespace，每个 namespace 都有一个 tap 与交换机上一个 tap 口组成 veth pair。这样 4 个 namespace 就通过 veth pair 及 Bridge 互联起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 veth pair</span></span><br><span class="line">ip link add tap1 <span class="built_in">type</span> veth peer name tap1_peer</span><br><span class="line">ip link add tap2 <span class="built_in">type</span> veth peer name tap2_peer</span><br><span class="line">ip link add tap3 <span class="built_in">type</span> veth peer name tap3_peer</span><br><span class="line">ip link add tap4 <span class="built_in">type</span> veth peer name tap4_peer</span><br><span class="line"><span class="comment"># 2. 创建 namespace</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line">ip netns add ns3</span><br><span class="line">ip netns add ns4</span><br><span class="line"><span class="comment"># 3. 把 tap 迁移到相应的 namespace 中</span></span><br><span class="line">ip link <span class="built_in">set</span> tap1 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> tap2 netns ns2</span><br><span class="line">ip link <span class="built_in">set</span> tap3 netns ns3</span><br><span class="line">ip link <span class="built_in">set</span> tap4 netns ns4</span><br><span class="line"><span class="comment"># 4. 创建 Bridge</span></span><br><span class="line">brctl addbr br1</span><br><span class="line"><span class="comment"># 5. 把相应的 tap 添加到 Bridge 中</span></span><br><span class="line">brctl addif br1 tap1_peer</span><br><span class="line">brctl addif br1 tap2_peer</span><br><span class="line">brctl addif br1 tap3_peer</span><br><span class="line">brctl addif br1 tap4_peer</span><br><span class="line"><span class="comment"># 6. 配置相应 tap 的 IP 地址</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add <span class="built_in">local</span> 192.168.50.1/24 dev tap1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip addr add <span class="built_in">local</span> 192.168.50.2/24 dev tap2</span><br><span class="line">ip netns <span class="built_in">exec</span> ns3 ip addr add <span class="built_in">local</span> 192.168.50.3/24 dev tap3</span><br><span class="line">ip netns <span class="built_in">exec</span> ns4 ip addr add <span class="built_in">local</span> 192.168.50.4/24 dev tap4</span><br><span class="line"><span class="comment"># 7. 将 Bridge 及所有 tap 状态设置为 up</span></span><br><span class="line">ip link <span class="built_in">set</span> br1 up</span><br><span class="line">ip link <span class="built_in">set</span> tap1_peer up</span><br><span class="line">ip link <span class="built_in">set</span> tap2_peer up</span><br><span class="line">ip link <span class="built_in">set</span> tap3_peer up</span><br><span class="line">ip link <span class="built_in">set</span> tap4_peer up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> tap1 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> tap2 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns3 ip link <span class="built_in">set</span> tap3 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns4 ip link <span class="built_in">set</span> tap4 up</span><br><span class="line"><span class="comment"># 8. 互 ping 测试</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.50.2</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.50.3</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.50.4</span><br><span class="line">...</span><br><span class="line">ip netns <span class="built_in">exec</span> ns4 ping 192.168.50.1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns4 ping 192.168.50.2</span><br><span class="line">ip netns <span class="built_in">exec</span> ns4 ping 192.168.50.3</span><br></pre></td></tr></table></figure><p>若能够互相 ping 通，则表示测试通过。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Linux 中 Router 能够用于不同网段之间的互通。通过如下命令可以查看系统是否开启路由转发功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /proc/sys/net/ipv4/if_forward</span><br></pre></td></tr></table></figure><p>如果返回的结果是 <code>0</code>，则表示未开启，若为 <code>1</code>，则表示已开启路由转发功能。可以修改配置文件 “/etc/systcl.conf”，将 <code>net.ipv4.ip_forward</code> 的值修改为 <code>1</code> 来开启该功能。</p><p>下面举个例子，用于说明 Router 的作用。分别设计 ns1/tap1 和 ns2/tap2，且它们不在同一个网段中，中间需要经过一个路由转发才能互通。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 veth pair</span></span><br><span class="line">ip link add tap1 <span class="built_in">type</span> veth peer name tap1_peer</span><br><span class="line">ip link add tap2 <span class="built_in">type</span> veth peer name tap2_peer</span><br><span class="line"><span class="comment"># 2. 创建 namespace</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"><span class="comment"># 3. 将 tap 迁移到 namespace</span></span><br><span class="line">ip link <span class="built_in">set</span> tap1 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> tap2 netns ns2</span><br><span class="line"><span class="comment"># 4. 配置 tap IP 地址</span></span><br><span class="line">ip addr add <span class="built_in">local</span> 192.168.100.1/24 dev tap1_peer</span><br><span class="line">ip addr add <span class="built_in">local</span> 192.168.200.1/24 dev tap2_peer</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add <span class="built_in">local</span> 192.168.100.2/24 dev tap1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip addr add <span class="built_in">local</span> 192.168.200.2/24 dev tap2</span><br><span class="line"><span class="comment"># 5. 将 tap 设置为 up</span></span><br><span class="line">ip link <span class="built_in">set</span> tap1_peer up</span><br><span class="line">ip link <span class="built_in">set</span> tap2_peer up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> tap1 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> tap2 up</span><br><span class="line"><span class="comment"># 6. 为 ns1、ns2 添加静态路由，分别到达对方的网段</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.100.1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.200.1</span><br><span class="line"><span class="comment"># 7. 互 ping 测试</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.200.2</span><br><span class="line">...</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ping 192.168.100.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>能够互相 ping 通表示测试通过。</p><p>添加了静态路由信息后，可以使用如下命令查看 namespace 的路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 route -nee</span><br><span class="line">...</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 route -nee</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述命令可以分别查看 ns1 和 ns2 的路由表信息。</p><h2 id="tun"><a href="#tun" class="headerlink" title="tun"></a>tun</h2><p>tun 是一个网络层（IP）的点对点设备，它启用了 IP 层隧道功能。Linux 原生支持的三层隧道，可以通过 <code>ip tunnle help</code> 查看。</p><p>Linux 一共原生支持 5 种三层隧道（tunnel），如表所示：</p><table><thead><tr><th align="center">隧道</th><th align="left">简述</th></tr></thead><tbody><tr><td align="center">ipip</td><td align="left">IP in IP，在 IPv4 报文的基础上再封装一个 IPv4 报文头，属于 IPv4 in IPv4</td></tr><tr><td align="center">gre</td><td align="left">通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议，属于 IPv4/IPv6 over IPv4</td></tr><tr><td align="center">sit</td><td align="left">与 ipip 类似，用一个IPv4 的报文头封装 IPv6 的报文，属于 IPv6 over IPv4</td></tr><tr><td align="center">isatap</td><td align="left">站内自动隧道寻址协议，一般用于 IPv4 网络中的 IPv6/IPv4 节点间的通信</td></tr><tr><td align="center">vti</td><td align="left">全称是 Virtual Tunnel Interface，为 IPsec 隧道提供了一个可路由的接口类型</td></tr></tbody></table><p>下面给出 tun 的具体用例来进行说明，以 ipip tunnel为例进行配置。在上一节 Router 的基础上，分别在 ns1 和 ns2 中添加 tun1 和 tun2，tun1 和 tun2 不互通，且与 tap1、tap2也没有关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 加载 ipip 模块，可通过 lsmod | grep ip 命令查看是否加载</span></span><br><span class="line">modprobe ipip</span><br><span class="line"><span class="comment"># 2. 在 ns1 上创建 tun1 和 ipip tunnel</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip tunnel add tun1 mode ipip remote 192.168.200.2 <span class="built_in">local</span> 192.168.100.2 ttl 255<span class="comment"># 创建 tun1，模式为 ipip，分别配置远端地址和近端（本地）地址以及 ttl</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> tun1 up<span class="comment"># 启动 tun1</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add 192.168.50.10 peer 192.168.60.10 dev tun1<span class="comment"># 为 tun1 添加 ipip 隧道的内层 IP 地址，并设置对端的 ipip 隧道内层 IP 地址</span></span><br><span class="line"><span class="comment"># 3. 在 ns2 上创建 tun2 和 ipip tunnel</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip tunnel add tun2 mode ipip remote 192.168.100.2 <span class="built_in">local</span> 192.168.200.2 ttl 255</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> tun2 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip addr add 192.168.60.10 peer 192.168.50.10 dev tun2</span><br><span class="line"><span class="comment"># 4. 互 ping 测试 （测试时遇到了问题，在 CentOS 7 系统下，按照上述命令无法实现两个 tun ping 通，但是前面的 Router 是可以的，原因未知。）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.60.10</span><br><span class="line">...</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ping 192.168.50.10</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>将上述命令中的 <code>ipip</code> 改为 <code>gre</code>，其余保持不变，即可创建一个 gre 隧道的 tun 设备对。</p></blockquote><p>查看 ns1 的路由表，发现已添加了一个直连路由条目，从 tun1 可以直接到达 192.168.60.10，ns2 亦然。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Neutron 在构建网络服务时，利用了许多 Linux 虚拟网络的功能（Linux 内核中的虚拟网络设备以及其他网络功能）。下面介绍一些与 Neutron 相关的 Linux 虚拟网络功能。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenStack" scheme="https://www.freedomly.tk/categories/OpenStack/"/>
    
    
    <category term="Neutron" scheme="https://www.freedomly.tk/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 实现 Hexo 博客自动构建和部署</title>
    <link href="https://www.freedomly.tk/2019/01/16/Hexo-Travis-CI-auto-deploy/"/>
    <id>https://www.freedomly.tk/2019/01/16/Hexo-Travis-CI-auto-deploy/</id>
    <published>2019-01-16T05:54:52.000Z</published>
    <updated>2019-01-17T14:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/imagesource/19-01-16/TravisCI-Full-Color.png" alt="Travis CI"></p><p>昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：</p><ol><li>每次博客更新都要自己手动 <code>hexo d -g</code>，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。</li><li>考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。</li></ol><p>因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。</p><a id="more"></a><h2 id="Hexo-博客源代码-GitHub-托管"><a href="#Hexo-博客源代码-GitHub-托管" class="headerlink" title="Hexo 博客源代码 GitHub 托管"></a>Hexo 博客源代码 GitHub 托管</h2><p>Hexo 是将 deploy 后生成的静态文件放在 GitHub Pages 上的，因此博客的源文件保存在本地。我们可以将博客源文件存放在同意仓库的另一个分支，比如我为个人博客仓库添加了 <code>source</code> 分支，用于存放源文件。</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-1.png" alt="github branches"></p><p>具体操作如下：</p><h3 id="添加分支"><a href="#添加分支" class="headerlink" title="添加分支"></a>添加分支</h3><p>在 GitHub 仓库里选择添加一个新的分支，并设定分支名，我这里命名为 source。这是 source 分支和 master 分支的内容是一样的。</p><h3 id="将仓库克隆至本地"><a href="#将仓库克隆至本地" class="headerlink" title="将仓库克隆至本地"></a>将仓库克隆至本地</h3><p>在本地使用 <code>git clone 你的仓库地址</code> 将仓库克隆至本地，然后使用 <code>git checkout source</code> 命令，切换到新创建的分支。</p><h3 id="在新分支中添加博客源文件"><a href="#在新分支中添加博客源文件" class="headerlink" title="在新分支中添加博客源文件"></a>在新分支中添加博客源文件</h3><p>删除该分支下除了 <code>.git</code> 文件以外的所有内容，并将本地 Hexo 博客的相关文件夹复制进来。最后 source 分支下的内容应该是这样的：</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-2.png" alt="source file"></p><p>然后 commit 更改，并 push 到远程仓库，这样我们就把本地的博客源文件存放到远程仓库的 source 分支里了。为下一步使用 Travis CI 自动化部署做准备。</p><h2 id="使用-Travis-CI-自动部署"><a href="#使用-Travis-CI-自动部署" class="headerlink" title="使用 Travis CI 自动部署"></a>使用 Travis CI 自动部署</h2><h3 id="Travis-CI-简介"><a href="#Travis-CI-简介" class="headerlink" title="Travis CI 简介"></a>Travis CI 简介</h3><p>Travis CI 提供持续集成服务(Continuous Integration, CI)。它可以绑定 GitHub 上的项目，只要有代码更新，就会自动抓取，并提供运行环境，执行测试，完成构建，还能部署到服务器。这里我们利用这个特性来为我们的 Hexo 博客实现远程构建并部署到 GitHub Pages。</p><h3 id="配置-Travis-CI"><a href="#配置-Travis-CI" class="headerlink" title="配置 Travis CI"></a>配置 Travis CI</h3><h4 id="网页端配置"><a href="#网页端配置" class="headerlink" title="网页端配置"></a>网页端配置</h4><p>首先进入 <a href="https://travis-ci.org/">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href="https://travis-ci.com/">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是 <code>feilongjiang.github.io</code>，把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-3.png" alt="Travis enable"></p><p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-4.png" alt="Travis settings"></p><p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href="https://github.com/settings/tokens">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-5.png" alt="generate token"></p><p>接着在原来 Travis 的设置界面添加 token。如图所示：</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-6.png" alt="Travis token"></p><p>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p><h4 id="Travis-配置文件"><a href="#Travis-配置文件" class="headerlink" title="Travis 配置文件"></a>Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">7.9</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定缓存模块，可加快编译速度</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定博客源码分支，这里填入博客源码的分支名</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span> <span class="comment"># 更改时区</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"> <span class="comment"># - npm install -g gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 git push 别名，邮箱。替换真实 token 到 _config.yml 文件中，然后 deploy 部署</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;FreedomLy&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;Freedom.JFL@gmail.com&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/feilongjiang/feilongjiang.github.io.git</span> <span class="string">.deploy_git</span> <span class="comment"># 解决 commit 清空问题</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">  <span class="comment"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot;</span> <span class="string">./_config.yml</span> <span class="comment"># 这里的 GH_TOKEN 名字要和网页中定义的别名一致</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line"><span class="comment"># E: Build LifeCycle</span></span><br></pre></td></tr></table></figure><p>同时修改 Hexo 的 <code>_confi.yml</code> 文件中的 deploy 模块，将原来的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:feilongjiang/feilongjiang.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gh_token@github.com/feilongjiang/feilongjiang.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这里的具体仓库地址需要替换成自己博客的仓库。下面解释一下两个配置文件中的 branch。在 <code>.travis.yml</code> 中的 branches 中填入的是存放博客源码的分支，而 <code>_config.yml</code> 中的 branch 则填入的是存放博客部署后产生的静态文件的分支。</p><p>然后将本地的更新 push 到源码所在的分支，就可以在 Travis 中看到 build 的条目了。</p><p><img data-src="/images/imagesource/19-01-16/2019-01-16-7.png" alt="Travis token"></p><p>自此，使用 Travis CI 进行自动化构建并部署就完成了。以后只需编写 <code>.md</code> 的博客文件，然后 push 到远程仓库即可，无需本地生成和部署。这些操作交由 Travis CI 代为操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://blog.csdn.net/Xiong_IT/article/details/78675874">Hexo遇上Travis-CI: 可能是最通俗易懂的自动发布博客图文教程</a><br>[2]: <a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">使用Travis CI自动部署Hexo博客</a><br>[3]: <a href="https://blog.xingoxu.com/2016/12/use-travis-ci-your-blog/">使用Travis Ci使hexo自动生成并部署</a><br>[4]: <a href="https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/">解决 Travis CI 总是更新旧博客的问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/imagesource/19-01-16/TravisCI-Full-Color.png&quot; alt=&quot;Travis CI&quot;&gt;&lt;/p&gt;
&lt;p&gt;昨天实现了用 Travis CI 对托管在 GitHub 上的 Hexo 博客进行自动部署。这么做的原因有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次博客更新都要自己手动 &lt;code&gt;hexo d -g&lt;/code&gt;，次数多了感觉有点麻烦，因此希望能用过自动化的方式部署，这样就只要专注博客内容更新，而非部署等操作。&lt;/li&gt;
&lt;li&gt;考虑到以后可能会更新设备(或者是多设备更新博客)，到时候又要重新安装一遍环境。设备之间的切换估计也比较麻烦。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此考虑实现博客源代码放在 GitHub 仓库里，并实现博客更新自动部署。&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://www.freedomly.tk/categories/Tech/"/>
    
    
    <category term="Travis-CI" scheme="https://www.freedomly.tk/tags/Travis-CI/"/>
    
    <category term="Hexo" scheme="https://www.freedomly.tk/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 常用插件记录</title>
    <link href="https://www.freedomly.tk/2019/01/08/VSCode-Extensions/"/>
    <id>https://www.freedomly.tk/2019/01/08/VSCode-Extensions/</id>
    <published>2019-01-08T13:50:16.000Z</published>
    <updated>2019-01-14T02:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/imagesource/19-01-08.png" alt="vscode"><br>诈尸更新~~🤣🤣🤣<br>这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。</p><a id="more"></a><p>VSCode 下载地址：<a href="https://code.visualstudio.com/">Visual Studio Code</a></p><h2 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><p>推荐微软官方推出的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++</a>插件，支持智能提示和debug，很方便。</p><p>如何在 VSCode 上配置 C/C++ 环境可以参考知乎<a href="https://www.zhihu.com/question/30315894/answer/154979413">Visual Studio Code如何编写运行C、C++？</a> 这个问题下的高赞回答。</p><p>通过 <a href="https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader">vscode-fileheader</a> 插件可以一键为新建的 C/C++ 文件添加头部注释，如作者信息、文档新建日期、最后修改日期等。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>同样推荐微软官方的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python</a> 插件。本来是民间大神写的，后来被微软收编了。只要安装好 <a href="https://www.python.org/downloads/">Python</a> 环境，然后再装这个插件，写起 Python 代码来美滋滋！</p><p>同时再推荐 <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode">Visual Studio IntelliCode</a> 插件，可以用于 Python 的代码智能提示插件。利用 AI 让代码提示更加智能，可以根据语境来推荐调用函数等。支持都多种语言，包括 TypeScript/JavaScript，Java，Python 等语言。</p><h2 id="文章书写"><a href="#文章书写" class="headerlink" title="文章书写"></a>文章书写</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>VSCode 对 Markdown 也有很好的支持。推荐如下几个插件：</p><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>，为 Markdown 提供一站式支持，加快文章编写，提高行文效率。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a>，增强 Markdown 的预览，同时支持输出 PDF (需要安装额外的工具) 以及 HTML 等格式。</li></ol><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><p>VSCode 还能用于书写 LaTeX，对于一些英文论文，使用 LaTeX 可以省去在排版上的精力。这里推荐 <a href="https://www.tug.org/texlive/">TeX Live</a> 作为 TeX 环境。有了 TeX 环境后，再安装 <a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop">LaTeX Workshop</a> 插件，即可愉快地写 LaTeX 文档了。LaTeX Workshop 支持 TeX 智能提示、Tex 文件编译以及预览 PDF 文件等。同时还能自定义编译工具链。是一款十分强大的插件。</p><p>同时推荐 <a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">Code Spell Checker</a>，可以用于单词拼写检查，这样就不怕单词经常拼错了。支持多种文件类型，除了 LaTex 以外，还支持众多编程语言。也可以单独为某种语言设置是否开启单词拼写检查。当有自定义的单词时，还能够添加到词典中，添加到词典中的单词不会提示错误，如果误添加，可以在 setting 中删除。</p><h2 id="美化相关"><a href="#美化相关" class="headerlink" title="美化相关"></a>美化相关</h2><p>VSCode 默认有亮色和暗色主题，但用久了会出现审美疲劳。这里推荐几款 VSCode 主题和图标。</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme">One Dark Pro</a>，一款仿照 Atom 的 One Dark 主题</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme">Material Theme</a>，Google Material Design 风格的主题，有多种颜色可以选择</li></ol><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>这里只推荐一个，个人最喜欢的一套图标 <a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a>，也是 Material Design 风格的。个人搭配 One Dark Pro 主题使用，非常耐看。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>VSCode 同时支持自定义字体，个人的字体设置为 <code>&#39;Consolas&#39;, &#39;思源黑体 Regular&#39;, monospace</code>，Consolas 比较适合编程，思源黑体用于中文字体显示。看起来比较舒服。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HTML-文件预览"><a href="#HTML-文件预览" class="headerlink" title="HTML 文件预览"></a>HTML 文件预览</h3><p>写 HTML 文档时需要经常预览其样式和内容的改变，推荐使用 <a href="https://marketplace.visualstudio.com/items?itemName=qinjia.view-in-browser">View In Browser</a>，通过快捷键 <code>Ctrl+F1</code> 即可在默认的浏览器中预览 HTML 文档了。</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-github">GitHub</a> 插件支持 GitHub pull/push 等源代码相关操作。</p><h3 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a> 插件支持海量编程语言的一键运行。只要编写完代码，点击 run code 即可运行(前提是安装已经安装好对应的语言环境)。可以说是真神器。</p><h3 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h3><p>新版 VSCode 默认界面为英文，如果需要其他语言，需要安装对应的语言包，如<a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">简体中文</a>，安装完成后重新加载即可使用中文界面。其他语言同理。</p><h3 id="同步设置"><a href="#同步设置" class="headerlink" title="同步设置"></a>同步设置</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync">Settings Sync</a> 插件可以同步设置，只需创建一个 gist token，即可将 vscode 的配置信息上传至 <a href="https://gist.github.com/">GitHub Gist</a> 中，当使用其他机器上的 vscode 时，可以通过这个插件来导入自己的配置信息。这个插件不仅同步设置，还可以同步按键设置、语言运行配置文件、代码段、插件以及插件配置、工作区文件。</p><p>以上就是个人常用的 VSCode 插件。涵盖了多个方面。如果以后有更好用的插件，再继续更新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/imagesource/19-01-08.png&quot; alt=&quot;vscode&quot;&gt;&lt;br&gt;诈尸更新~~🤣🤣🤣&lt;br&gt;这篇文章用于记录我常用的 VSCode 插件，用以换新设备或者重装系统后重新安装插件使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://www.freedomly.tk/categories/Development/"/>
    
    
    <category term="VSCode" scheme="https://www.freedomly.tk/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 19. Remove Nth Node From End of List</title>
    <link href="https://www.freedomly.tk/2018/01/09/LeetCode-19-Remove-Nth-Node-From-End-of-List/"/>
    <id>https://www.freedomly.tk/2018/01/09/LeetCode-19-Remove-Nth-Node-From-End-of-List/</id>
    <published>2018-01-09T10:46:44.000Z</published>
    <updated>2018-01-09T10:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Give a linked list, remove the $n^{th}$ node from the end of list and return its head.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><blockquote><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong>n = 2</strong><br>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Given <em>n</em> will always be valid.<br>Try do this in one pass.</p><h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><h3 id="单链表结构定义"><a href="#单链表结构定义" class="headerlink" title="单链表结构定义"></a>单链表结构定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="普通方法-遍历两次链表"><a href="#普通方法-遍历两次链表" class="headerlink" title="普通方法(遍历两次链表)"></a>普通方法(遍历两次链表)</h3><p>先遍历一次链表，获取链表的长度，然后第二次遍历链表删除导数第n个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode *p1 = head, *p2 = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; cnt - n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> tmp = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="New-Meta-使用二级指针，遍历一次链表"><a href="#New-Meta-使用二级指针，遍历一次链表" class="headerlink" title="New Meta(使用二级指针，遍历一次链表)"></a>New Meta(使用二级指针，遍历一次链表)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 利用二级指针删除元素</span></span><br><span class="line">        ListNode **t1 = &amp;head, *t2 = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将t2向后移动n位，此时t2的位置在len(head) - n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">        <span class="comment">// 当t2的下一个节点不为空时，开始移动t1</span></span><br><span class="line">        <span class="keyword">while</span> (t2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// t1指向下一个元素指针的地址</span></span><br><span class="line">            t1 = &amp;((*t1)-&gt;next);</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当t2为nullptr时，表示t1所指的元素指针的地址即为倒数第n个元素指针的地址</span></span><br><span class="line">        <span class="comment">// 因此我们需要删除该元素,并使t1指向下一个元素指针的地址</span></span><br><span class="line">        <span class="keyword">auto</span> tmp = *t1;</span><br><span class="line">        *t1 = (*t1)-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用二级指针后可以不用考虑n的位置是否为链表的头或者尾。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;Give a linked list, remove the $n^{th}$ node from the end of list and return its head.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.freedomly.tk/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.freedomly.tk/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 751. IP to CIDR</title>
    <link href="https://www.freedomly.tk/2017/12/29/LeetCode-751-IP-to-CIDR/"/>
    <id>https://www.freedomly.tk/2017/12/29/LeetCode-751-IP-to-CIDR/</id>
    <published>2017-12-29T07:09:13.000Z</published>
    <updated>2017-12-29T07:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p><p>A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.</p><a id="more"></a><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><blockquote><p><strong>Input:</strong> ip = “255.0.0.7”, n = 10<br><strong>Output:</strong> [“255.0.0.7/32”, “255,0.0.8/29”, “255.0.0.16/32”]<br><strong>Explanation:</strong><br>The initial ip address, when convered to binary, look like this (spaces added for clarity):<br>255.0.0.7 -&gt; 1111111 00000000 00000000 00000111<br>The address “255.0.0.7/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just this one address.</p></blockquote><blockquote><p>The address “255.0.0.8/29” specifies all address with a common prefix of 29 bits to the given address:<br>255.0.0.8 -&gt; 11111111 00000000 0000000 00001000<br>Address with common prefix of 29 bits are:<br>11111111 00000000 00000000 00001000<br>11111111 00000000 00000000 00001001<br>11111111 00000000 00000000 00001010<br>11111111 00000000 00000000 00001011<br>11111111 00000000 00000000 00001100<br>11111111 00000000 00000000 00001101<br>11111111 00000000 00000000 00001110<br>11111111 00000000 00000000 00001111</p></blockquote><blockquote><p>The address “255.0.0.16/32” specifies all address with a common prefix of 32 bits to the given address,<br>ie. just 11111111 00000000 00000000 00010000</p></blockquote><blockquote><p>In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</p></blockquote><blockquote><p>There were other representations, such as:<br>[“255.0.0.7/32”, “”255.0.0.8/30”, “255.0.0.12/30”, “255.0.0.16/32”],<br>but our answer was the shortest possible.</p></blockquote><blockquote><p>Also note that a representation beginning with say, “255.0.0.7/30” would be incorrect,<br>because it includes address like 255.0.0.4 = 11111111 00000000 00000000 00000100<br>that are outside the specified range.</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ol><li><code>ip</code> will be a valid IPv4 address.</li><li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li><li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li></ol><h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>这个问题是在给定的起始IP地址，求最少的<a href="https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin&fromid=3695195&fromtitle=CIDR">CIDR</a>正好覆盖n个IP地址。所求的地址要求是连续的，并且要在起始IP的后面。</p><p>先说明一下<code>255.255.0.8/29</code>中29的含义：<br>一个IPv4的地址总共有32位，可以表示29表示的是IP的前29为是固定的，后三位可以改变，因此可以覆盖$2^3$(8)个IP。那么要使CIDR尽量的少，就让固定的IP的位数尽量少，同时要保证IP是连续的。</p><p>比如我们以<code>255.0.0.7</code>开始，覆盖30个地址，那么就有：</p><blockquote><p>255.0.0.7/32<br>只有一个IP地址 剩余30 - 1 = 29</p></blockquote><blockquote><p>接下来的IP地址是 255.0.0.8，最后8位是: 00001000，还有3位可以更改<br>则有255.0.0.8/29 可以覆盖8个IP，剩余29 - 8 = 21</p></blockquote><blockquote><p>8个地址后的IP是255.0.0.16，最后8位是: 00010000，还有4位可以更改<br>则有255.0.0.16/28 可以覆盖16个IP，剩余21 - 16 = 5</p></blockquote><blockquote><p>接下来的IP地址是255.0.0.32，最后8位是： 00100000，还有5位可以更改，而剩余的要覆盖的IP只有5个，因此要小于5，否则覆盖的IP范围就会超过给定的个数，因此是4个，即对最后两位进行更改<br>则有255.0.0.32/30 可以覆盖4个IP，剩余5 - 4 = 1</p></blockquote><blockquote><p>那么最后一个要覆盖的就是255.0.0.36/32，剩余0个要覆盖<br>至此可以得到最少的CIDR。</p></blockquote><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>将IP转为数字:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str, <span class="keyword">char</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">while</span> (getline(ss, word, delim))</span><br><span class="line">    &#123;</span><br><span class="line">        ret.emplace_back(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip2Num</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec = split(ip, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stoi(vec[<span class="number">0</span>));</span><br><span class="line">    num = num &lt;&lt; <span class="number">8</span> | <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stoi(vec[<span class="number">1</span>]));</span><br><span class="line">    num = num &lt;&lt; <span class="number">8</span> | <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stoi(vec[<span class="number">2</span>]));</span><br><span class="line">    num = num &lt;&lt; <span class="number">8</span> | <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stoi(vec[<span class="number">3</span>]));</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字转换为IP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">num2Ip</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.emplace_back(to_string(num &amp; <span class="number">0xff</span>));</span><br><span class="line">        num &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    ret.append(vec[<span class="number">3</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    ret.append(vec[<span class="number">2</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    ret.append(vec[<span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    ret.append(vec[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ipToCIDR</span><span class="params">(<span class="built_in">string</span> ip, <span class="keyword">int</span> range)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">unsigned</span> num = ip2Num(ip);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (range)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            weight &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i &amp; num) || (weight &gt; range))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        weight &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        range -= weight;</span><br><span class="line">        ret.emplace_back(num2Ip(num) + <span class="string">&quot;/&quot;</span> + to_string(<span class="number">32</span> - i));</span><br><span class="line">        num += weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;Given a start IP address &lt;code&gt;ip&lt;/code&gt; and a number of ips we need to cover &lt;code&gt;n&lt;/code&gt;, return a representation of the range as a list (of smallest possible length) of CIDR blocks.&lt;/p&gt;
&lt;p&gt;A CIDR block is a string consisting of an IP, followed by a slash, and then prefix length. For example: “123.45.67.89/20”. That prefix length “20” represents the number of common prefix bits in the specified range.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.freedomly.tk/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.freedomly.tk/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio项目中集成Google Test测试框架</title>
    <link href="https://www.freedomly.tk/2017/11/17/Visual-Studio%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Google-Test%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.freedomly.tk/2017/11/17/Visual-Studio%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Google-Test%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</id>
    <published>2017-11-17T07:22:38.000Z</published>
    <updated>2019-01-07T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。</p><a id="more"></a><h2 id="VS2015下配置Google-Test"><a href="#VS2015下配置Google-Test" class="headerlink" title="VS2015下配置Google Test"></a>VS2015下配置Google Test</h2><h3 id="下载Google-Test"><a href="#下载Google-Test" class="headerlink" title="下载Google Test"></a>下载Google Test</h3><p><a href="https://github.com/google/googletest" title="Google Test">Google Test</a>是Google旗下的一个单元测试框架。下载地址在<a href="https://github.com/google/googletest/releases" title="Google Test Release">Release</a>中，在release页面下，有它的历史版本，我们下载最新的即可。</p><p>解压下载的文件，可以看到两个文件夹，这里我们要用的是<strong>googletest</strong>文件夹下的内容，其他的可以不用管。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-1.png" alt="googletest"></p><p>解压出来的文件夹存放位置没有要求。我们主要用到的是googletest文件夹下的<strong>include</strong>和<strong>src</strong>。其中<strong>include</strong>用于配置项目时添加到包含目录中；<strong>src</strong>是Google Test框架的源码。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-2.png" alt="src&amp;include"></p><h3 id="配置Google-Test-2018-04-04更新"><a href="#配置Google-Test-2018-04-04更新" class="headerlink" title="配置Google Test(2018-04-04更新)"></a>配置Google Test(2018-04-04更新)</h3><p>感谢@LazyWolf Lin的指出，Google Test本身自带了msvc的项目文件，我们只需打开gtest提供的项目，编译生成得到静态库文件，然后在项目中设置运行库即可，不需要自己新建Google Test项目来生成静态库。具体的操作可以参考这一篇<a href="https://blog.csdn.net/lywzgzl/article/details/52203558" title="GTEST基础学习">博客</a>。</p><p>下载好文件后，我们开始配置Google Test。我们新建一个简单的项目作为测试。</p><h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p>打开VS2105，<strong>新建项目-&gt;Win32控制台应用程序</strong>，我们将项目名称设置为SimpleTest。然后选择<strong>空项目</strong>，完成即可。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-3.png" alt="newproject"><br><img data-src="/images/imagesource/17-11-17/17-11-17-4.png" alt="newproject1"></p><p>我们为项目添加两个文件：一个头文件，一个运行的文件。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple_math.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(num, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// simple_math.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;simple_math.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ans = square(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>simple_math.h</code>中定义了一个<code>square</code>函数，返回传入的参数的平方值。并在<code>simple_math.cpp</code>中调用了该函数。可以按<strong>Ctrl+F5</strong>来测试一下是否运行正确。准备工作完毕，接下来就是配置Google Test了。</p><h4 id="配置Google-Test"><a href="#配置Google-Test" class="headerlink" title="配置Google Test"></a>配置Google Test</h4><p>接下来我们右键最上面的<strong>解决方案</strong>，选择<strong>添加-&gt;新建项目-&gt;Win32项目</strong>，我们把新的项目名叫作GoogleTest，在应用程序类型那里选择<strong>静态库</strong>，取消预编译头，然后点击完成。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-6.png" alt="googletestproject"></p><p>现在解决方案下面有两个项目，一个是我们之前创建的项目<strong>SimpleTest</strong>，一个是刚刚创建的<strong>GoogleTest</strong>。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-7.png" alt="project2"></p><p>下面我们给GoogleTest添加包含目录，就是之前下载的googletest文件夹下的目录。<strong>右键GoogleTest-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</strong>，我们在包含目录中添加Google Test相关文件。我们<strong>googletest文件夹</strong>和googletest目录下的<strong>include</strong>文件夹都添加进去，然后点击确定。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-8.png" alt="includefile"></p><p>接着再给GoogleTest项目添加源文件。<strong>右键GoogleTest的源文件-&gt;添加-&gt;现有项</strong>，把之前提到的<strong>src</strong>目录下的<strong>gtest_main.cc</strong>和<strong>gtest-all.cc</strong>添加进去。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-9.png" alt="addfile"></p><p>现在GoogleTest项目下有两个源文件。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-10.png" alt="sourcefiles"></p><h4 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h4><p>上述配置完成后，我们<strong>右键GoogleTest-&gt;生成</strong>，就可以生成GoogleTest的静态库了。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-11.png" alt="build"></p><h4 id="添加单元测试"><a href="#添加单元测试" class="headerlink" title="添加单元测试"></a>添加单元测试</h4><p>下面我们测试一下GoogleTest是否配置正确，新建一个单元测试项目<strong>UnittestSimpleTest</strong>，<strong>右键解决方案-&gt;添加-&gt;新建项目-&gt;Win32控制台应用程序</strong>，选择空项目，然后完成即可。</p><p>现在我们的解决方案中共有三个项目：<strong>GoogleTest，SimpleTest，UnittestSimpleTest</strong>。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-12.png" alt="project3"></p><p>同样，我们需要将googletest文件夹下的路径添加到UniitestSimpleTest的包含目录中。此外，我们还要添加SimpleTest的路径。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-13.png" alt="includepath"></p><p>添加完包含目录后，再为其添加引用：<strong>右键UnittestSimpleTest-&gt;添加-&gt;引用</strong>，将<strong>GoogleTest</strong>和<strong>SimpleTest</strong>全勾上</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-14.png" alt="references"></p><p>单击确定即可。可以看到之前两个项目都作为引用添加到SimpleTest中了。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-15.png" alt="references1"></p><h4 id="新建测试"><a href="#新建测试" class="headerlink" title="新建测试"></a>新建测试</h4><p>我们现在可以添加源文件，编写单元测试了。新建一个源文件<strong>test.cpp</strong>，编写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;simple_math.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TEST(testSquare, mySquareTest)</span><br><span class="line">&#123;</span><br><span class="line">EXPECT_EQ(<span class="number">100</span>, square(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将UnittestSimpleTest作为启动项目（<strong>右键项目-&gt;设为启动项目</strong>），然后运行即可。运行结果如图所示。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-16.png" alt="result"></p><h2 id="将现有的项目作为引用添加到其他项目中"><a href="#将现有的项目作为引用添加到其他项目中" class="headerlink" title="将现有的项目作为引用添加到其他项目中"></a>将现有的项目作为引用添加到其他项目中</h2><p>在配置Google Test时，我新建一个项目按照上面的步骤可以使用单元测试，但是在给现有项目同样的配置时，却在添加完GoogleTest和单元测试后报错，一大片的LNK 2019的错误。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-17.png" alt="errorlnk2019"></p><p>百度了半天没找到解决结果。后来看到了一篇文章，教我们怎么添加自己写的程序库，看了文章后我找到了链接错误的原因了：之前的项目没有作为<strong>静态库</strong>给新的项目引用，解决方法如下：<strong>右键项目-&gt;属性-&gt;配置属性-&gt;常规</strong>，将目标文件扩展名改为**.lib<strong>，然后在下面的项目默认值中的</strong>配置类型<strong>改为</strong>静态库**。</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-18.png" alt="buildall"></p><p>然后重新生成解决方案，没有报错，生成成功！然后就可以进行单元测试了。测试结果如图所示：</p><p><img data-src="/images/imagesource/17-11-17/17-11-17-19.png" alt="result1"></p><p>在这边我只用到了静态库的生成和引用，以上所有操作都是debug模式下进行。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.bogotobogo.com/cplusplus/google_unit_test_gtest.php" title="GTEST">C++ TUTORIAL - GOOGLE TEST (GTEST)</a></li><li><a href="http://blog.csdn.net/luoweifu/article/details/48895765" title="发布自己的程序库">带你玩转Visual Studio——带你发布自己的工程库</a></li><li><a href="http://blog.csdn.net/luoweifu/article/details/48915347" title="多工程开发">带你玩转Visual Studio——带你多工程开发</a></li><li><a href="https://blog.csdn.net/lywzgzl/article/details/52203558" title="GTEST基础学习">GTEST基础学习</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要分成两个部分，第一部分介绍VS2015下Google Test的基本配置，第二部分讲一下我配置时遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://www.freedomly.tk/categories/CPP/"/>
    
    
    <category term="C++" scheme="https://www.freedomly.tk/tags/C/"/>
    
    <category term="IDE" scheme="https://www.freedomly.tk/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】注册表单验证</title>
    <link href="https://www.freedomly.tk/2017/10/13/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    <id>https://www.freedomly.tk/2017/10/13/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</id>
    <published>2017-10-13T07:01:08.000Z</published>
    <updated>2017-10-13T07:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>用Python实现类似于网页表单信息验证的功能。</p><p>基本要求：</p><ol><li>需要输入邮箱地址、密码两项</li><li>邮箱地址需要满足形如<a href="mailto:&#x78;&#x78;&#x78;&#x40;&#120;&#x78;&#x78;&#x2e;&#120;&#120;">&#x78;&#x78;&#x78;&#x40;&#120;&#x78;&#x78;&#x2e;&#120;&#120;</a>的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格</li><li>密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）</li><li>重名验证</li></ol><a id="more"></a><p>思路：<br>通过正则表达式来实现</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式库"><a href="#正则表达式库" class="headerlink" title="正则表达式库"></a>正则表达式库</h3><p>Python中有正则表达式标准库，引入正则表达式库Re即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>由于Python的字符串本身也用\转义，因此建议使用Python的r前缀，就可以避免Python字符串转义的问题了。</p><h3 id="正则表达式特殊字符"><a href="#正则表达式特殊字符" class="headerlink" title="正则表达式特殊字符"></a>正则表达式特殊字符</h3><p>在这里介绍一下正在表达式的特殊字符，具体的匹配可以参考<a href="http://www.runoob.com/regexp/regexp-tutorial.html">正则表达式-菜鸟教程</a>。</p><p>特殊字符就是指有特殊含义的字符，在正则表达式中，它们负责了除本身字符含义之外的工作，如<code>*</code>表示匹配某字符串零次或多次，如果想要匹配<code>*</code>，则需要转义，即匹配<code>\*</code>，这样就是匹配<code>*</code>这个字符。正则表达式的特殊字符如下表所示：</p><table><thead><tr><th align="left">特殊字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置</td></tr><tr><td align="left">()</td><td align="left">标记一个子表达式的开始和结束位置</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符\n之外的任何单字符</td></tr><tr><td align="left">[]</td><td align="left">标记一个中括号表达式的开始和结束位置</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为特殊字符或原义字符或向后引用或八进制转义符</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置，在方括号表达式中使用时，表示非字符集</td></tr><tr><td align="left">{}</td><td align="left">标记限定符表达式的开始</td></tr><tr><td align="left">&#124;</td><td align="left">指明两项之间的一个选择</td></tr></tbody></table><h2 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkEmail = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\w+_?-?\.?\w*)@([\w+\.]+[a-zA-Z]+$)&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="验证密码"><a href="#验证密码" class="headerlink" title="验证密码"></a>验证密码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkPwd = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(?=.*[0-9].*)(?=.*[A-Z].*)(?=.*[a-z].*).&#123;8,&#125;$&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="重名验证"><a href="#重名验证" class="headerlink" title="重名验证"></a>重名验证</h2><p>没有用数据库，采用了文本文档存储已注册邮箱的方式，每次注册都要查询文本中的邮箱，是否有重复的，如果有重复的，提示邮箱重复，输入其他邮箱；否则注册通过，将新的邮箱地址存入文本中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开存储邮箱地址的文档，如果不存在则新建</span></span><br><span class="line"><span class="keyword">if</span> no os.path.exists(<span class="string">&#x27;./users.txt&#x27;</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;./users.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.close()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取文本中的邮箱地址，存入一个list，后面验证重名时使用</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./users.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    userName = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证重名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_email</span>(<span class="params">email_address</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> checkEmail.match(email_address):</span><br><span class="line">        email_address = <span class="built_in">input</span>(<span class="string">&#x27;邮箱地址格式不正确，请重新输入: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> email_address + <span class="string">&#x27;\n&#x27;</span> <span class="keyword">in</span> userName:</span><br><span class="line">        email_address = <span class="built_in">input</span>(<span class="string">&#x27;邮箱地址已注册，请输入其他邮箱: &#x27;</span>)</span><br><span class="line">        check_email(email_address)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;邮箱地址可用!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> email_address</span><br></pre></td></tr></table></figure><h2 id="验证密码是否符合要求"><a href="#验证密码是否符合要求" class="headerlink" title="验证密码是否符合要求"></a>验证密码是否符合要求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_pwd</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> checkPwd.match(password):</span><br><span class="line">        print(<span class="string">&#x27;密码需要8位以上，包含大小写和数字。请重新输入。&#x27;</span>)</span><br><span class="line">        password = <span class="built_in">input</span>(<span class="string">&#x27;密码: &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> password</span><br></pre></td></tr></table></figure><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check email address</span></span><br><span class="line">emailAdd = <span class="built_in">input</span>(<span class="string">&#x27;请输入邮箱地址: &#x27;</span>)</span><br><span class="line">emailAdd = check_email(emailAdd)</span><br><span class="line">print(<span class="string">&#x27;邮箱地址: &#x27;</span>, emailAdd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check password</span></span><br><span class="line">pwd = <span class="built_in">input</span>(<span class="string">&#x27;密码: &#x27;</span>)</span><br><span class="line">pwd = check_pwd(pwd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存新注册的邮箱</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./users.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(emailAdd + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;注册成功!&#x27;</span>)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;用Python实现类似于网页表单信息验证的功能。&lt;/p&gt;
&lt;p&gt;基本要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要输入邮箱地址、密码两项&lt;/li&gt;
&lt;li&gt;邮箱地址需要满足形如&lt;a href=&quot;mailto:&amp;#x78;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x2e;&amp;#120;&amp;#120;&quot;&gt;&amp;#x78;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x2e;&amp;#120;&amp;#120;&lt;/a&gt;的正常邮箱格式，（中间有一个@，后半段至少有一个.），并且不包含空格&lt;/li&gt;
&lt;li&gt;密码需要8位以上，必须包含大写字母、小写字母和数字三种字符（三种都要有）&lt;/li&gt;
&lt;li&gt;重名验证&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
    <category term="正则表达式" scheme="https://www.freedomly.tk/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树相关问题(转载)</title>
    <link href="https://www.freedomly.tk/2017/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/"/>
    <id>https://www.freedomly.tk/2017/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/</id>
    <published>2017-10-09T11:33:35.000Z</published>
    <updated>2019-01-07T13:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章转自 <a href="http://blog.csdn.net/walkinginthewind/article/details/7518888">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p><a id="more"></a><h1 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definition for a binary tree node*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;    <span class="comment">// left tree node</span></span><br><span class="line">    TreeNode* right;   <span class="comment">// right tree node</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;    <span class="comment">// ctor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p><p><a href="#nodeNum">1. 求二叉树中的节点个数</a><br><a href="#nodeDepth">2. 求二叉树的深度</a><br><a href="#nodeTraverse">3. 前序、中序、后序遍历</a><br><a href="#nodeDFSBFS">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href="#nodeList">5. 将二叉查找树变为有序的双向链表</a><br><a href="#nodeKth">6. 求二叉树第K层的节点个数</a><br><a href="#nodeLeaf">7. 求二叉树中叶子节点的个数</a><br><a href="#nodeStructure">8. 判断两棵二叉树结构是否相同</a><br><a href="#nodeAVL">9. 判断二叉树是不是平衡二叉树</a><br><a href="#nodeMirror">10. 求二叉树的镜像</a><br><a href="#nodeAncestor">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href="#nodeDistance">12. 求二叉树中节点的最大距离</a><br><a href="#nodeRebuild">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href="#nodeComplete">14. 判断二叉树是不是完全二叉树</a></p><h1 id="详细解答"><a href="#详细解答" class="headerlink" title="详细解答"></a>详细解答</h1><h2 id="求二叉树中的节点个数"><a href="#求二叉树中的节点个数" class="headerlink" title="求二叉树中的节点个数"></a><span id="nodeNum"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p><ol><li>如果二叉树为空，节点个数为</li><li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a><span id="nodeDepth"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p><ol><li>如果二叉树为空，二叉树的深度为0</li><li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">int</span> depthLeft = getDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> depthRight = getDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> depthLeft &gt; depthRight ? depthLeft + <span class="number">1</span> : depthRight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序、中序、后序遍历"><a href="#前序、中序、后序遍历" class="headerlink" title="前序、中序、后序遍历"></a><span id="nodeTraverse"><strong>前序、中序、后序遍历</strong></span></h2><h3 id="前序遍历递归解法："><a href="#前序遍历递归解法：" class="headerlink" title="前序遍历递归解法："></a>前序遍历递归解法：</h3><ol><li>如果二叉树为空，空操作</li><li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    visit(root);                     <span class="comment">// 访问根结点</span></span><br><span class="line">    preOrderTraverse(root-&gt;left);    <span class="comment">// 前序遍历左子树</span></span><br><span class="line">    preOrderTraverse(root-&gt;right);   <span class="comment">// 前序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历递归解法："><a href="#中序遍历递归解法：" class="headerlink" title="中序遍历递归解法："></a>中序遍历递归解法：</h3><ol><li>如果二叉树为空，空操作</li><li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    inOrderTraverse(root-&gt;left);    <span class="comment">// 中序遍历左子树</span></span><br><span class="line">    visit(root)；                   <span class="comment">// 访问根结点</span></span><br><span class="line">    inOrderTraverse(root-&gt;right);   <span class="comment">// 中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历递归解法："><a href="#后序遍历递归解法：" class="headerlink" title="后序遍历递归解法："></a>后序遍历递归解法：</h3><ol><li>如果二叉树为空，空操作</li><li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    postOrderTraverse(root-&gt;left);    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postOrderTraverse(root-&gt;right);   <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    visit(root);                      <span class="comment">// 访问根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他遍历二叉树方法-深度、广度优先"><a href="#其他遍历二叉树方法-深度、广度优先" class="headerlink" title="其他遍历二叉树方法(深度、广度优先)"></a><span id="nodeDFSBFS"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id="深度优先遍历解法："><a href="#深度优先遍历解法：" class="headerlink" title="深度优先遍历解法："></a>深度优先遍历解法：</h3><ol><li>借助一个栈（后进先出）来实现深度遍历</li><li>先访问根结点</li><li>遍历左子树接着遍历右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">    nodeStack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!nodeStack.empty()) &#123;</span><br><span class="line">        TreeNode *tmp = nodeStack.top();</span><br><span class="line">        visit(tmp);</span><br><span class="line">        nodeStack.pop();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">            nodeStack.push(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">            nodeStack.push(tmp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历解法："><a href="#广度优先遍历解法：" class="headerlink" title="广度优先遍历解法："></a>广度优先遍历解法：</h3><ol><li>借助队列（先进先出）来实现广度优先遍历</li><li>将根节点入队</li><li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">        TreeNode *tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        visit(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">            nodeQueue.push(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">            nodeQueue.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将二叉查找树变为有序的双向链表"><a href="#将二叉查找树变为有序的双向链表" class="headerlink" title="将二叉查找树变为有序的双向链表"></a><span id="nodeList"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p><ol><li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li><li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * root: 二叉查找树的根结点指针</span></span><br><span class="line"><span class="comment">  * pFirstNode: 转换后双向有序链表的第一个节点指针</span></span><br><span class="line"><span class="comment">  * pLastNode: 转换后双向有序链表的最后一个节点指针</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">              TreeNode* &amp;pFirstNode, </span></span></span><br><span class="line"><span class="function"><span class="params">              TreeNode* &amp;pLastNode)</span> </span>&#123;</span><br><span class="line">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        pFirstNode = <span class="literal">NULL</span>;</span><br><span class="line">        pLastNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">        <span class="comment">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></span><br><span class="line">        pFirstNode = root;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        convert(root-&gt;left, pFirstLeft, pLastLeft);</span><br><span class="line">        <span class="comment">// 二叉查找树对应双向有序链表的第一个节点就是</span></span><br><span class="line">        <span class="comment">// 左子树转换后双向有序链表的第一个节点</span></span><br><span class="line">        pFristNode = pFirstLeft;</span><br><span class="line">        <span class="comment">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></span><br><span class="line">        root-&gt;left = pLastLeft;</span><br><span class="line">        pLastLeft-&gt;right = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">        <span class="comment">// 对应双向有序链表的最后一个节点是根节点</span></span><br><span class="line">        pLastNode = root;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        convert(root-&gt;right, pFirstRight, pLastRight);</span><br><span class="line">        <span class="comment">// 对应双向有序链表的最后一个节点就是</span></span><br><span class="line">        <span class="comment">// 右子树转换后双向有序链表的最后一个节点</span></span><br><span class="line">        pLastNode = pLastRight;</span><br><span class="line">        <span class="comment">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></span><br><span class="line">        root-&gt;right = pFirstRight;</span><br><span class="line">        pFirstRight-&gt;left = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a><span id="nodeKth"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p><ol><li>如果二叉树为空或者k &lt; 1，返回0</li><li>如果二叉树不为空且k = 1，返回1</li><li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthLevelNodeNum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!roo || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class="comment">// 左子树中k-1层节点个数</span></span><br><span class="line">    <span class="keyword">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class="comment">// 右子树中k-1层节点个数</span></span><br><span class="line">    <span class="keyword">return</span> (leftNum + rightNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a><span id="nodeLeaf"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p><ol><li>如果二叉树为空，返回0</li><li>如果二叉树不为空且左右子树为空，返回1</li><li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeafNodeNum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class="comment">// 左子树中叶节点个数</span></span><br><span class="line">    <span class="keyword">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class="comment">// 右子树中叶节点个数</span></span><br><span class="line">    <span class="keyword">return</span> (numLeft + numRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两棵二叉树结构是否相同"><a href="#判断两棵二叉树结构是否相同" class="headerlink" title="判断两棵二叉树结构是否相同"></a><span id="nodeStructure"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p><ol><li>如果两棵二叉树都为空，返回真</li><li>如果两颗二叉树一棵为空，另一个不为空，返回假</li><li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">structureCmp</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs &amp;&amp; !rhs) <span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">// 都为空树，返回真</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!lhs || !rhs) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 一个为空而另一个不为空，返回假</span></span><br><span class="line"><span class="keyword">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class="comment">// 比较对应左子树</span></span><br><span class="line"><span class="keyword">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class="comment">// 比较对应右子树</span></span><br><span class="line"><span class="keyword">return</span> (resultLeft &amp;&amp; resultRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断二叉树是不是平衡二叉树"><a href="#判断二叉树是不是平衡二叉树" class="headerlink" title="判断二叉树是不是平衡二叉树"></a><span id="nodeAVL"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p><ol><li>如果二叉树为空，返回真</li><li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boo <span class="title">isAVL</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;    <span class="comment">// 空树，返回真</span></span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> heightLeft;</span><br><span class="line">    <span class="keyword">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</span><br><span class="line">    <span class="keyword">int</span> heightRight;</span><br><span class="line">    <span class="keyword">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</span><br><span class="line">    <span class="keyword">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class="built_in">abs</span>(heightLeft - heightRight) &lt;= <span class="number">1</span>)&#123;    </span><br><span class="line">        <span class="comment">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></span><br><span class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树的镜像"><a href="#求二叉树的镜像" class="headerlink" title="求二叉树的镜像"></a><span id="nodeMirror"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p><ol><li>如果二叉树为空，返回空</li><li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class="comment">// 求左子树镜像</span></span><br><span class="line">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class="comment">// 求右子树镜像</span></span><br><span class="line">    <span class="comment">// 交换左右子树</span></span><br><span class="line">    root-&gt;left = leftTree;</span><br><span class="line">    root-&gt;right = rightTree;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树中两个节点的最低公共祖先节点"><a href="#求二叉树中两个节点的最低公共祖先节点" class="headerlink" title="求二叉树中两个节点的最低公共祖先节点"></a><span id="nodeAncestor"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id="递归解法："><a href="#递归解法：" class="headerlink" title="递归解法："></a>递归解法：</h3><ol><li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li><li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNode</span><span class="params">(TreeNode* root, TreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || !pNode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == pNode) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = findNode(root-&gt;left, pNode);</span><br><span class="line">    <span class="keyword">if</span> (!found)</span><br><span class="line">        found = findNode(root-&gt;right, pNode);</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">getLowestCommonAncestor</span><span class="params">(TreeNode* root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  TreeNode* pNode1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findNode(root-&gt;left, pNode1)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (findNode(root-&gt;right, pNode2))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(root-&gt;left, pNode2))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p><h3 id="非递归解法："><a href="#非递归解法：" class="headerlink" title="非递归解法："></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getNodePath</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">                 TreeNode* pNode, </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="built_in">list</span>&lt;TreeNode*&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == pNode) &#123;</span><br><span class="line">        path.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    path.push_back(root);</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    found = getNodePath(root-&gt;left, pNode, path);</span><br><span class="line">    <span class="keyword">if</span> (!found)</span><br><span class="line">        found = getNodePath(root-&gt;right, pNode, path);</span><br><span class="line">    <span class="keyword">if</span> (!found)</span><br><span class="line">        path.pop_back();</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">getLowestCommonAncestor</span><span class="params">(TreeNode *root, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  TreeNode* pNode1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || !pNode1 || !pNode2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path1;</span><br><span class="line">    <span class="keyword">bool</span> result1 = getNodePath(root, pNode1, path1);</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path2;</span><br><span class="line">    <span class="keyword">bool</span> result2 = getNodePath(root, pNode2, path2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!result1 || !result2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* pLast = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</span><br><span class="line">    <span class="keyword">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*iter1 == *iter2)</span><br><span class="line">            pLast = *iter1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++iter1;</span><br><span class="line">        ++iter2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p><h2 id="求二叉树中节点的最大距离"><a href="#求二叉树中节点的最大距离" class="headerlink" title="求二叉树中节点的最大距离"></a><span id="nodeDistance"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p><ol><li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li><li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;maxLeft, <span class="keyword">int</span> &amp;maxRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// maxLeft: 左子树中的节点离根节点的最远距离</span></span><br><span class="line">    <span class="comment">// maxRight: 右子树中的节点离根节点的最远距离</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        maxLeft = <span class="number">0</span>;</span><br><span class="line">        maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxLL, maxLR, maxRL, maxRR;</span><br><span class="line">    <span class="keyword">int</span> maxDistLeft, maxDistRight;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</span><br><span class="line">        maxLeft = max(maxLL, maxLR) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        maxDistLeft = <span class="number">0</span>;</span><br><span class="line">        maxLeft = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</span><br><span class="line">        maxRight = max(maxRL, maxRR) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        maxDistRight = <span class="number">0</span>;</span><br><span class="line">        maxRight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由前序遍历序列和中序遍历序列重建二叉树"><a href="#由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="由前序遍历序列和中序遍历序列重建二叉树"></a><span id="nodeRebuild"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p><ol><li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li><li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li></ol><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * pPreOrder: 前序遍历序列</span></span><br><span class="line"><span class="comment">  * pInOrder: 中序遍历序列</span></span><br><span class="line"><span class="comment">  * nodeNum: 二叉树节点数</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rebuildTree</span><span class="params">(<span class="keyword">int</span>* pPreOrder, <span class="keyword">int</span>* pInOrder, <span class="keyword">int</span> nodeNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    <span class="comment">// 前序遍历的第一个节点就是根节点</span></span><br><span class="line">    root-&gt;val = pPreOrder[<span class="number">0</span>];</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></span><br><span class="line">    <span class="keyword">int</span> rootPoistionInOrder = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pInOrder[i] == root-&gt;val) &#123;</span><br><span class="line">            rootPositionInOrder = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootPositionInOrder == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">&quot;Invalid Input.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重建左子树</span></span><br><span class="line">    <span class="keyword">int</span> nodeNumLeft = rootPositionInOrder;</span><br><span class="line">    <span class="keyword">int</span>* pPreOrderLeft = pPreOrder + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* pInOrderLeft = pInOrder;</span><br><span class="line">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</span><br><span class="line">    <span class="comment">// 重建右子树</span></span><br><span class="line">    <span class="keyword">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span>* pPreOrderRight = pPreOrder + <span class="number">1</span> + nodeNumLeft;</span><br><span class="line">    <span class="keyword">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class="number">1</span>;</span><br><span class="line">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p><h2 id="判断二叉树是不是完全二叉树"><a href="#判断二叉树是不是完全二叉树" class="headerlink" title="判断二叉树是不是完全二叉树"></a><span id="nodeComplete"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    <span class="keyword">bool</span> mustHaveNoChild = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">        TreeNode* pNode = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line">        <span class="keyword">if</span> (mustHaveNoChild) &#123;   <span class="comment">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class="line">                nodeQueue.push(pNode-&gt;left);</span><br><span class="line">                nodeQueue.push(pNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</span><br><span class="line">                mustHaveNoChild = <span class="literal">true</span>;</span><br><span class="line">                nodeQueue.push(pNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mastHaveNoChild = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章转自 &lt;a href=&quot;http://blog.csdn.net/walkinginthewind/article/details/7518888&quot;&gt;http://blog.csdn.net/walkinginthewind/article/details/7518888&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;p&gt;树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。&lt;/p&gt;</summary>
    
    
    
    <category term="DataStructure" scheme="https://www.freedomly.tk/categories/DataStructure/"/>
    
    
    <category term="BinaryTree" scheme="https://www.freedomly.tk/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>UTF-8 码点</title>
    <link href="https://www.freedomly.tk/2017/10/09/UTF-8-%E7%A0%81%E7%82%B9/"/>
    <id>https://www.freedomly.tk/2017/10/09/UTF-8-%E7%A0%81%E7%82%B9/</id>
    <published>2017-10-09T02:34:48.000Z</published>
    <updated>2019-01-07T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：</p><a id="more"></a><table><thead><tr><th align="center">码点范围</th><th align="center">码点位数</th><th align="center">字节1</th><th align="center">字节2</th><th align="center">字节3</th><th align="center">字节4</th></tr></thead><tbody><tr><td align="center">U+0000~U+007F</td><td align="center">7</td><td align="center">0xxxxxxx</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">U+0080~U+07FF</td><td align="center">11</td><td align="center">110xxxxx</td><td align="center">10xxxxxx</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">U+0800~U+FFFF</td><td align="center">16</td><td align="center">1110xxxx</td><td align="center">10xxxxxx</td><td align="center">10xxxxxx</td><td align="center"></td></tr><tr><td align="center">U+10000~U+10FFFF</td><td align="center">21</td><td align="center">11110xxx</td><td align="center">10xxxxxx</td><td align="center">10xxxxxx</td><td align="center">10xxxxxx</td></tr></tbody></table><p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p><p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p><p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p><p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p><p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p><p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p><p> 代码表示(C):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u &lt;= 0x007F</span></span><br><span class="line">PUTC(c, u &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// u &lt;= 0x07FF</span></span><br><span class="line">PUTC(c, <span class="number">0xC0</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// u &lt;= 0xFFFF</span></span><br><span class="line">PUTC(c, <span class="number">0xE0</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// u &lt;= 0x10FFFF</span></span><br><span class="line">PUTC(c, <span class="number">0xF0</span> | ((u &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>));</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：&lt;/p&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://www.freedomly.tk/categories/CPP/"/>
    
    
    <category term="UTF-8" scheme="https://www.freedomly.tk/tags/UTF-8/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】矩阵旋转</title>
    <link href="https://www.freedomly.tk/2017/09/06/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC/"/>
    <id>https://www.freedomly.tk/2017/09/06/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC/</id>
    <published>2017-09-06T11:46:37.000Z</published>
    <updated>2017-09-06T11:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次的题目是关于矩阵旋转的</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p></blockquote><h2 id="附加要求"><a href="#附加要求" class="headerlink" title="附加要求"></a>附加要求</h2><blockquote><p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-使用额外的空间"><a href="#1-使用额外的空间" class="headerlink" title="1. 使用额外的空间"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p><blockquote><p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p></blockquote><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param matrix: List(List(int))</span></span><br><span class="line"><span class="string">    :return: List(List(int))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> subList <span class="keyword">in</span> matrix:</span><br><span class="line">            l.append(subList[i])</span><br><span class="line">        l.reverse()</span><br><span class="line">        res.append(l)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-在原矩阵上进行操作"><a href="#2-在原矩阵上进行操作" class="headerlink" title="2. 在原矩阵上进行操作"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href="http://blog.csdn.net/lion19930924/article/details/51661248">原博客</a>)</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</span></span><br><span class="line"><span class="string">对角线对称交换以后再进行反转后得到的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate1</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param matrix: List(List(int))</span></span><br><span class="line"><span class="string">    :return: matrix</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">        j = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">        <span class="comment"># print(matrix[i])</span></span><br><span class="line">        matrix[i].reverse()</span><br><span class="line">        <span class="comment"># print(matrix[i])</span></span><br><span class="line">    <span class="comment"># matrix.reverse()</span></span><br><span class="line">    <span class="comment"># print(matrix)</span></span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/lion19930924/article/details/51661248">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次的题目是关于矩阵旋转的&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】阿姆斯特朗数</title>
    <link href="https://www.freedomly.tk/2017/08/04/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0/"/>
    <id>https://www.freedomly.tk/2017/08/04/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0/</id>
    <published>2017-08-04T10:37:51.000Z</published>
    <updated>2017-08-04T11:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/imagesource/17-08-04.jpg" alt="armstrong"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p><p>一个经典的编程练习题：</p><blockquote><p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>输出1000以内的所有阿姆斯特朗数。</p></blockquote><p><strong>附加题</strong></p><blockquote><p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p></blockquote><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href="http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p><p>回到主题，其实阿姆斯特朗数和<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\cdots d_1 $，则有</p><p>$$<br>n = d_k^k + d_{k-1}^k+\cdots+d_2^k+d_1^k<br>$$</p><p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = num</span><br><span class="line"><span class="keyword">while</span> temp:</span><br><span class="line">    <span class="comment"># 求出每位数的k次幂的和</span></span><br><span class="line">    res += (temp % <span class="number">10</span>)**n</span><br><span class="line">    num //= <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> res == num:</span><br><span class="line">    <span class="comment"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span>(<span class="params">bound=<span class="number">1000</span></span>):</span></span><br><span class="line">    armstrong_number = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bound):</span><br><span class="line">        temp = i</span><br><span class="line">        n = <span class="built_in">len</span>(<span class="built_in">str</span>(i))</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp:</span><br><span class="line">            res += (temp % <span class="number">10</span>) ** n</span><br><span class="line">            temp //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> res == i:</span><br><span class="line">            armstrong_number.append(i)</span><br><span class="line">    <span class="keyword">return</span> armstrong_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到离number最近的阿姆斯特朗数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nearest_number</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_arm_num(num):</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    temp = num</span><br><span class="line">    res = get_number(temp)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> is_arm_num(temp):</span><br><span class="line">        temp += <span class="number">1</span></span><br><span class="line">    res_new = temp</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(res_new - num) &lt; <span class="built_in">abs</span>(res - num):</span><br><span class="line">        <span class="keyword">return</span> res_new</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断num是否是阿姆斯特朗数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_arm_num</span>(<span class="params">num</span>):</span></span><br><span class="line">    temp = num</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(<span class="built_in">str</span>(num))</span><br><span class="line">    <span class="keyword">while</span> temp:</span><br><span class="line">        res += (temp % <span class="number">10</span>) ** n</span><br><span class="line">        temp //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> res == num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(get_number())</span><br><span class="line">    print(get_nearest_number(<span class="number">390</span>))</span><br><span class="line">    print(get_nearest_number(<span class="number">389</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; get_number(1000)</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; get_nearest_number(390)</span><br><span class="line">407</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; get_nearest_number(389)</span><br><span class="line">371</span><br></pre></td></tr></table></figure><p>满足问题要求</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0">Wiki 水仙花数</a></p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/imagesource/17-08-04.jpg&quot; alt=&quot;armstrong&quot;&gt;&lt;br&gt;快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~&lt;/p&gt;
&lt;p&gt;一个经典的编程练习题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。&lt;br&gt;如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输出1000以内的所有阿姆斯特朗数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;附加题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数，输出距离它最近的阿姆斯特朗数。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】罗马数字转换</title>
    <link href="https://www.freedomly.tk/2017/07/08/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.freedomly.tk/2017/07/08/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</id>
    <published>2017-07-08T06:38:47.000Z</published>
    <updated>2017-07-08T06:53:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/imagesource/17-07-08.jpg" alt="roman"></p><p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p><p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p><ol><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li><li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li><li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li><li>在一个数的上面画一条横线，表示这个数曾1000倍</li></ol><a id="more"></a><p><strong>常见罗马字符表</strong></p><table><thead><tr><th align="center">数字</th><th align="center">罗马字符</th><th align="center">数字</th><th align="center">罗马字符</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Ⅰ</td><td align="center">2</td><td align="center">Ⅱ</td></tr><tr><td align="center">3</td><td align="center">Ⅲ</td><td align="center">4</td><td align="center">Ⅳ</td></tr><tr><td align="center">5</td><td align="center">Ⅴ</td><td align="center">6</td><td align="center">Ⅵ</td></tr><tr><td align="center">7</td><td align="center">Ⅶ</td><td align="center">8</td><td align="center">Ⅷ</td></tr><tr><td align="center">9</td><td align="center">Ⅸ</td><td align="center">10</td><td align="center">Ⅹ</td></tr><tr><td align="center">40</td><td align="center">XL</td><td align="center">50</td><td align="center">L</td></tr><tr><td align="center">90</td><td align="center">XC</td><td align="center">100</td><td align="center">C</td></tr><tr><td align="center">400</td><td align="center">CD</td><td align="center">500</td><td align="center">D</td></tr><tr><td align="center">900</td><td align="center">CM</td><td align="center">1000</td><td align="center">M</td></tr><tr><td align="center">2000</td><td align="center">MM</td><td align="center">2500</td><td align="center">MMD</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p><blockquote><p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p></blockquote><p><strong>附加题</strong></p><blockquote><p>给定一个小于3999的整数，将其转换为罗马数</p></blockquote><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># your code</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;III&#x27;</span>) == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;IV&#x27;</span>) == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;VI&#x27;</span>) == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;XIX&#x27;</span>) == <span class="number">19</span></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;XX&#x27;</span>) == <span class="number">20</span></span><br><span class="line"><span class="keyword">assert</span> romaToInt(<span class="string">&#x27;XLV&#x27;</span>) == <span class="number">45</span></span><br><span class="line"><span class="keyword">assert</span> romanToInt(<span class="string">&#x27;MCMLXXX&#x27;</span>) == <span class="number">1980</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="罗马数转阿拉伯数"><a href="#罗马数转阿拉伯数" class="headerlink" title="罗马数转阿拉伯数"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p><blockquote><p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p></blockquote><ol><li>第一位是X，表示10，pre = 0，res = 0 + 10</li><li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li><li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li><li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li><li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li><li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li><li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li></ol><p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p><h3 id="阿拉伯数-整数-转罗马数"><a href="#阿拉伯数-整数-转罗马数" class="headerlink" title="阿拉伯数(整数)转罗马数"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p><blockquote><p>如1980，(res表示结果):</p></blockquote><ol><li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li><li>980 // 900 = 1, res += CM, 980 % 900 = 80</li><li>80 // 50 = 1, res += L, 80 % 50 = 30</li><li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li></ol><p>经过上述步骤即可得整数1980 = MCMLXXX</p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 罗马数字转换</span></span><br><span class="line"><span class="comment"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></span><br><span class="line"><span class="comment"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># e.g.</span></span><br><span class="line"><span class="comment"># 3-&gt;III</span></span><br><span class="line"><span class="comment"># 4-&gt;IV</span></span><br><span class="line"><span class="comment"># 6-&gt;VI</span></span><br><span class="line"><span class="comment"># 19-&gt;XIX</span></span><br><span class="line"><span class="comment"># 45-&gt;XLV</span></span><br><span class="line"><span class="comment"># 999-&gt;CMXCIX</span></span><br><span class="line"><span class="comment"># 1980-&gt;MCMLXXX</span></span><br><span class="line"><span class="comment"># 3999-&gt;MMMCMXCIX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 罗马转数字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roman_to_int</span>(<span class="params">s</span>):</span></span><br><span class="line">    roman_int_dic = &#123;</span><br><span class="line">        <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    s = s[::<span class="number">-1</span>]</span><br><span class="line">    res, pre = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> roman_int_dic[x] &gt;= pre:</span><br><span class="line">            res += roman_int_dic[x]</span><br><span class="line">            pre = roman_int_dic[x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res -= roman_int_dic[x]</span><br><span class="line">            pre = roman_int_dic[x]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字转罗马</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_to_roman</span>(<span class="params">i</span>):</span></span><br><span class="line">    dic = &#123;</span><br><span class="line">        <span class="number">1000</span>: <span class="string">&#x27;M&#x27;</span>, <span class="number">900</span>: <span class="string">&#x27;CM&#x27;</span>, <span class="number">500</span>: <span class="string">&#x27;D&#x27;</span>, <span class="number">400</span>: <span class="string">&#x27;CD&#x27;</span>,</span><br><span class="line">        <span class="number">100</span>: <span class="string">&#x27;C&#x27;</span>, <span class="number">90</span>: <span class="string">&#x27;XC&#x27;</span>, <span class="number">50</span>: <span class="string">&#x27;L&#x27;</span>, <span class="number">40</span>: <span class="string">&#x27;XL&#x27;</span>,</span><br><span class="line">        <span class="number">10</span>: <span class="string">&#x27;X&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;IX&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;V&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;IV&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;I&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">            res += i // k * dic[k]</span><br><span class="line">            i %= k</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = roman_to_int(<span class="string">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    int_res = int_to_roman(<span class="number">3999</span>)</span><br><span class="line">    print(int_res)</span><br><span class="line"></span><br><span class="line">    result = roman_to_int(<span class="string">&#x27;MCMLXXX&#x27;</span>)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    int_res = int_to_roman(<span class="number">1980</span>)</span><br><span class="line">    print(int_res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;III&#x27;</span>) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;IV&#x27;</span>) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;VI&#x27;</span>) == <span class="number">6</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;XIX&#x27;</span>) == <span class="number">19</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;XLV&#x27;</span>) == <span class="number">45</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;MCMLXXX&#x27;</span>) == <span class="number">1980</span></span><br><span class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">&#x27;CMXCIX&#x27;</span>) == <span class="number">999</span></span><br><span class="line">    print(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>roman_to_int(<span class="string">&#x27;MMMCMXCIX&#x27;</span>)</span><br><span class="line"><span class="number">3999</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int_to_roman(<span class="number">3999</span>)</span><br><span class="line">MMMCMXCIX</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</span><br><span class="line"><span class="number">1980</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int_to_roman(<span class="number">1980</span>)</span><br><span class="line">MCMLXXX</span><br></pre></td></tr></table></figure><p>结果与要求一致</p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/imagesource/17-07-08.jpg&quot; alt=&quot;roman&quot;&gt;&lt;/p&gt;
&lt;p&gt;罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。&lt;/p&gt;
&lt;p&gt;罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3&lt;/li&gt;
&lt;li&gt;小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12&lt;/li&gt;
&lt;li&gt;小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9&lt;/li&gt;
&lt;li&gt;在一个数的上面画一条横线，表示这个数曾1000倍&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】螺旋矩阵</title>
    <link href="https://www.freedomly.tk/2017/06/23/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.freedomly.tk/2017/06/23/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2017-06-23T11:44:50.000Z</published>
    <updated>2017-06-23T12:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img data-src="/images/imagesource/17-06-23.jpg" alt="matrix"></p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>输出如图的螺旋矩阵</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1    2    3    4</span><br><span class="line">12  13   14   5</span><br><span class="line">11  16   15   6</span><br><span class="line">10    9     8   7</span><br></pre></td></tr></table></figure><p><strong>附加题</strong></p><blockquote><p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p><ol><li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li><li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li><li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li><li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li><li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li><li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li><li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li></ol><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 打印输出螺旋矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_matrix</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 用二维数组来代表矩阵</span></span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rota_matrix</span>(<span class="params">n</span>):</span></span><br><span class="line">    mat = gen_matrix(n)  <span class="comment"># 初始矩阵，所有元素都为0</span></span><br><span class="line">    x = y = <span class="number">0</span></span><br><span class="line">    total = mat[x][y] = <span class="number">1</span> <span class="comment"># 将数组第一个元素设为1，即mat[0][0] = 1</span></span><br><span class="line">    <span class="keyword">while</span> total != n * n:</span><br><span class="line">        <span class="keyword">while</span> y + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="keyword">not</span> mat[x][y + <span class="number">1</span>]: <span class="comment"># 从左至右</span></span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            mat[x][y] = total</span><br><span class="line">        <span class="keyword">while</span> x + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="keyword">not</span> mat[x + <span class="number">1</span>][y]: <span class="comment"># 从上之下</span></span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            mat[x][y] = total</span><br><span class="line">        <span class="keyword">while</span> y - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> mat[x][y - <span class="number">1</span>]: <span class="comment"># 从右至左</span></span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            mat[x][y] = total</span><br><span class="line">        <span class="keyword">while</span> x - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> mat[x - <span class="number">1</span>][y]: <span class="comment"># 从下至上</span></span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            mat[x][y] = total</span><br><span class="line">    <span class="keyword">return</span> mat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入矩形数组的大小:&quot;</span>))</span><br><span class="line">    matrix = get_rota_matrix(n)</span><br><span class="line">    <span class="comment"># print(matrix)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            print(<span class="string">&#x27;%4d&#x27;</span> % matrix[i][j], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        print()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果<br>当N = 4 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 请输入矩形数组的大小： 4</span><br><span class="line"></span><br><span class="line">      1    2    3    4</span><br><span class="line">    12  13   14   5</span><br><span class="line">    11  16   15   6</span><br><span class="line">    10    9     8   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当N = 5 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 请输入矩形数组的大小： 5</span><br><span class="line"></span><br><span class="line">    1     2     3     4    5 </span><br><span class="line">  16   17   18   19    6 </span><br><span class="line">  15   24   25   20    7 </span><br><span class="line">  14   23   22   21    8 </span><br><span class="line">  13   12   11   10    9 </span><br></pre></td></tr></table></figure><p>结果与要求一致，可以输出任意N的螺旋矩阵。</p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;螺旋矩阵&lt;/strong&gt;是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。&lt;br&gt;&lt;img data-src=&quot;/images/imagesource/17-06-23.jpg&quot; alt=&quot;matrix&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>C++中的explicit关键字</title>
    <link href="https://www.freedomly.tk/2017/06/15/C-%E4%B8%AD%E7%9A%84explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.freedomly.tk/2017/06/15/C-%E4%B8%AD%E7%9A%84explicit%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2017-06-15T08:19:33.000Z</published>
    <updated>2019-01-07T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p><blockquote><p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p></blockquote><a id="more"></a><p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p><h2 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 单形参构造函数，可以用作隐式转换</span></span><br><span class="line">Foo(<span class="keyword">int</span> foo) : m_foo(foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFoo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_foo; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，接受Foo类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">(Foo foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = foo.getFoo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Bar(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p><h2 id="使用explicit抑制构造函数定义的隐式转换"><a href="#使用explicit抑制构造函数定义的隐式转换" class="headerlink" title="使用explicit抑制构造函数定义的隐式转换"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> foo)</span> : <span class="title">m_foo</span><span class="params">(foo)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p><blockquote><p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p></blockquote><p>进行如下修改，对传入的<code>int</code>进行显式转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar(Foo(<span class="number">42</span>))</span><br></pre></td></tr></table></figure><p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p><blockquote><p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p><ul><li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li><li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li><li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li></ul><p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p><p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163">Stack OverFlow - What does the explicit keyword mean?</a></p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;隐式的类类型转换&quot;&gt;&lt;a href=&quot;#隐式的类类型转换&quot; class=&quot;headerlink&quot; title=&quot;隐式的类类型转换&quot;&gt;&lt;/a&gt;隐式的类类型转换&lt;/h2&gt;&lt;p&gt;在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作&lt;strong&gt;转换构造函数(converting constructor)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://www.freedomly.tk/categories/CPP/"/>
    
    
    <category term="C++" scheme="https://www.freedomly.tk/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】校验文件哈希</title>
    <link href="https://www.freedomly.tk/2017/06/09/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E5%93%88%E5%B8%8C/"/>
    <id>https://www.freedomly.tk/2017/06/09/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E5%93%88%E5%B8%8C/</id>
    <published>2017-06-09T11:18:25.000Z</published>
    <updated>2017-06-12T08:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/imagesource/17-06-09.png" alt="hash"></p><p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p></blockquote><p><strong>附加题</strong></p><blockquote><p>可以指定哈希加密算法，并让程序尽可能简单易用。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href="https://feilongjiang.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="计算哈希值的函数"><a href="#计算哈希值的函数" class="headerlink" title="计算哈希值的函数"></a>计算哈希值的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_hash</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">        md5 = hashlib.md5(s).hexdigest()  <span class="comment"># 生成MD5</span></span><br><span class="line">        sha1 = hashlib.sha1(s).hexdigest()  <span class="comment"># 生成SHA1</span></span><br><span class="line">        sha256 = hashlib.sha256(s).hexdigest()  <span class="comment"># 生成SHA256</span></span><br><span class="line">        sha512 = hashlib.sha512(s).hexdigest()  <span class="comment"># 生成SHA512</span></span><br><span class="line">    <span class="keyword">return</span> md5, sha1, sha256, sha512</span><br></pre></td></tr></table></figure><h3 id="可以指定哈希加密算法的函数"><a href="#可以指定哈希加密算法的函数" class="headerlink" title="可以指定哈希加密算法的函数"></a>可以指定哈希加密算法的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_hash_type</span>(<span class="params">file, hash_type</span>):</span></span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">        <span class="keyword">if</span> hash_type.lower() == <span class="string">&#x27;md5&#x27;</span>:</span><br><span class="line">            hash_res = hashlib.md5(s).hexdigest()</span><br><span class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">&#x27;sha1&#x27;</span>:</span><br><span class="line">            hash_res = hashlib.sha1(s).hexdigest()</span><br><span class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">&#x27;sha256&#x27;</span>:</span><br><span class="line">            hash_res = hashlib.sha256(s).hexdigest()</span><br><span class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">&#x27;sha512&#x27;</span>:</span><br><span class="line">            hash_res = hashlib.sha512(s).hexdigest()</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;Hash type error!&quot;</span>)</span><br><span class="line">            hash_res = <span class="string">&quot;Type Error&quot;</span></span><br><span class="line">    <span class="keyword">return</span> hash_type, hash_res</span><br></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_path, hash_t = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>(<span class="string">&#x27;Please enter the path of the file and hash type:&#x27;</span>).split())</span><br><span class="line">    md = generate_hash_type(file_path, hash_t)</span><br><span class="line">    print(md,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    md = generate_hash(file_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> md:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>最后别忘了引入<strong>hashlib</strong>库:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br></pre></td></tr></table></figure><p>还有设置编码格式以防万一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里我使用的是<a href="https://www.python.org/">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>please enter the path of the file:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>文件路径，我这里是 C:\Users\Freed\Downloads\python<span class="number">-3.6</span><span class="number">.1</span>-amd64.exe</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote></blockquote><p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p><p>然后是输入路径+指定加密算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>please enter the path of the file <span class="keyword">and</span> <span class="built_in">hash</span> <span class="built_in">type</span>:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C:\Users\Freed\Downloads\python<span class="number">-3.6</span><span class="number">.1</span>-amd64.exe md5</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p></blockquote><p>再来看看官网给出的md5：</p><blockquote><p>ad69fdacde90f2ce8286c279b11ca188</p></blockquote><p>和程序计算的结果一致。</p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;/images/imagesource/17-06-09.png&quot; alt=&quot;hash&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。&lt;br&gt;早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.freedomly.tk/categories/Python/"/>
    
    
    <category term="每周一坑" scheme="https://www.freedomly.tk/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版 练习 12.33</title>
    <link href="https://www.freedomly.tk/2017/06/07/C-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A0-12-33/"/>
    <id>https://www.freedomly.tk/2017/06/07/C-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A0-12-33/</id>
    <published>2017-06-07T14:39:56.000Z</published>
    <updated>2019-01-07T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。</p><a id="more"></a><h2 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h2><blockquote><p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p></blockquote><h2 id="文本查询程序设计"><a href="#文本查询程序设计" class="headerlink" title="文本查询程序设计"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p><h2 id="查询程序的实现"><a href="#查询程序的实现" class="headerlink" title="查询程序的实现"></a>查询程序的实现</h2><p>Query.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</span></span><br><span class="line"><span class="comment">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</span></span><br><span class="line"><span class="comment">   返回一个shared_ptr，指向QueryResult对象中的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;12.22.h&quot;</span></span></span><br><span class="line"><span class="comment">// 定义了StrBlob类的头文件</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了定义函数query的返回类型，这个定义是必须的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">TextQuery(<span class="built_in">std</span>::ifstream&amp;);</span><br><span class="line"><span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// 输入文件</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;StrBlob&gt; file;   </span><br><span class="line"><span class="comment">// 每个单词到它所在行号的映射</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, </span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line"><span class="keyword">using</span> qr_iter = <span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;::iterator;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">QueryResult(<span class="built_in">string</span> s, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class="built_in">shared_ptr</span>&lt;StrBlob&gt; f) :</span><br><span class="line">word(s), lines(l), file(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">qr_iter <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lines-&gt;begin(); &#125;</span><br><span class="line"><span class="function">qr_iter <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lines-&gt;end(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;StrBlob&gt; <span class="title">get_file</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> file; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 查询单词</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="comment">// 出现的行号</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</span><br><span class="line"> <span class="comment">// 输入文件</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;StrBlob&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Query.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取输入文件并建立单词到行号的映射</span></span><br><span class="line">TextQuery::TextQuery(<span class="built_in">std</span>::ifstream &amp;ifs) : file(<span class="keyword">new</span> StrBlob)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存行号</span></span><br><span class="line">StrBlob::size_type line_no&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 对文件中的每一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> line; <span class="built_in">std</span>::getline(ifs, line); ++line_no)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存此行文本</span></span><br><span class="line">file-&gt;push_back(line);</span><br><span class="line"> <span class="comment">// 将文本分解为单词</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="comment">// 对行中每个单词</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> text, word; stream &gt;&gt; text; word.clear())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 去除单词中的标点符号</span></span><br><span class="line"><span class="built_in">std</span>::remove_copy_if(text.begin(), text.end(),</span><br><span class="line"><span class="built_in">std</span>::back_inserter(word), <span class="built_in">ispunct</span>);</span><br><span class="line"><span class="comment">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></span><br><span class="line"><span class="keyword">auto</span> &amp;lines = wordmap[word];</span><br><span class="line"><span class="comment">// 第一次遇到这个单词时，lines的指针为空</span></span><br><span class="line"><span class="comment">// 分配一个新的set</span></span><br><span class="line"><span class="keyword">if</span> (!lines) lines.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;);</span><br><span class="line"><span class="comment">// 将此行号插入set中</span></span><br><span class="line">lines-&gt;insert(line_no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果未找到sought，将返回一个指向此set的指针</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt;</span><br><span class="line">nodata(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt; StrBlob::size_type&gt;);</span><br><span class="line"><span class="comment">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></span><br><span class="line"><span class="keyword">auto</span> found = wordmap.find(sought);</span><br><span class="line"><span class="keyword">if</span> (found != wordmap.end())</span><br><span class="line"><span class="comment">// 找到单词</span></span><br><span class="line"><span class="keyword">return</span> QueryResult(sought, found-&gt;second, file);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// 未找到</span></span><br><span class="line"><span class="keyword">return</span> QueryResult(sought, nodata, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line"><span class="comment">// 如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class="line">os &lt;&lt; query_result.word &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">&lt;&lt; (query_result.lines-&gt;size() &gt; <span class="number">1</span> ? <span class="string">&quot;times.&quot;</span> : <span class="string">&quot;time.&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单词出现的每一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ConstStrBlobPtr <span class="title">p</span><span class="params">(*query_result.file, *it)</span></span>;</span><br><span class="line">os &lt;&lt; <span class="string">&quot;\t(line &quot;</span> &lt;&lt; *it + <span class="number">1</span> &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Query_test.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;12.33.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(<span class="built_in">std</span>::ifstream &amp;ifs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">TextQuery <span class="title">text_query</span><span class="params">(ifs)</span></span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter word to look for or q to quit: &quot;</span>;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word) || word == <span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">print(<span class="built_in">std</span>::<span class="built_in">cout</span>, text_query.query(word)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;data/story.txt&quot;</span>)</span></span>;</span><br><span class="line">runQueries(ifs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href="https://github.com/pezy/CppPrimer">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p><p>End~</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——&lt;strong&gt;文本查询程序&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://www.freedomly.tk/categories/CPP/"/>
    
    
    <category term="C++ Primer" scheme="https://www.freedomly.tk/tags/C-Primer/"/>
    
  </entry>
  
</feed>
