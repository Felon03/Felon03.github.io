<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreedomLy</title>
  <subtitle>Welcome to my blog. &lt;3</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://felon03.github.io/"/>
  <updated>2017-10-09T11:53:21.279Z</updated>
  <id>https://felon03.github.io/</id>
  
  <author>
    <name>FreedomLy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树相关问题(转载)</title>
    <link href="https://felon03.github.io/2017/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/"/>
    <id>https://felon03.github.io/2017/10/09/二叉树相关问题-转载/</id>
    <published>2017-10-09T11:33:35.000Z</published>
    <updated>2017-10-09T11:53:21.279Z</updated>
    
    <content type="html"><![CDATA[<p>文章转自 <a href="http://blog.csdn.net/walkinginthewind/article/details/7518888" target="_blank" rel="external">http://blog.csdn.net/walkinginthewind/article/details/7518888</a></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。</p>
<a id="more"></a>
<h1 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Definition for a binary tree node*/</span></div><div class="line"><span class="keyword">struct</span> TreeNode &#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode* left;    <span class="comment">// left tree node</span></div><div class="line">    TreeNode* right;   <span class="comment">// right tree node</span></div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;    <span class="comment">// ctor</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>二叉树的大部分题目都应用了递归，时刻往递归结构去思考。</p>
<p><a href="#nodeNum">1. 求二叉树中的节点个数</a><br><a href="#nodeDepth">2. 求二叉树的深度</a><br><a href="#nodeTraverse">3. 前序、中序、后序遍历</a><br><a href="#nodeDFSBFS">4. 其他遍历二叉树方法（深度、广度优先）</a><br><a href="#nodeList">5. 将二叉查找树变为有序的双向链表</a><br><a href="#nodeKth">6. 求二叉树第K层的节点个数</a><br><a href="#nodeLeaf">7. 求二叉树中叶子节点的个数</a><br><a href="#nodeStructure">8. 判断两棵二叉树结构是否相同</a><br><a href="#nodeAVL">9. 判断二叉树是不是平衡二叉树</a><br><a href="#nodeMirror">10. 求二叉树的镜像</a><br><a href="#nodeAncestor">11. 求二叉树中两个节点的最低公共祖先节点</a><br><a href="#nodeDistance">12. 求二叉树中节点的最大距离</a><br><a href="#nodeRebuild">13. 由前序遍历序列和中序遍历序列重建二叉树</a><br><a href="#nodeComplete">14. 判断二叉树是不是完全二叉树</a></p>
<h1 id="详细解答"><a href="#详细解答" class="headerlink" title="详细解答"></a>详细解答</h1><h2 id="求二叉树中的节点个数"><a href="#求二叉树中的节点个数" class="headerlink" title="求二叉树中的节点个数"></a><span id="nodeNum"><strong>求二叉树中的节点个数</strong></span></h2><p>递归解法：</p>
<ol>
<li>如果二叉树为空，节点个数为</li>
<li>如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 递归出口</span></div><div class="line">    <span class="keyword">return</span> getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a><span id="nodeDepth"><strong>求二叉树的深度</strong></span></h2><p>递归解法：</p>
<ol>
<li>如果二叉树为空，二叉树的深度为0</li>
<li>如果二叉树不为空，二叉树的深度=max(左子树深度， 右子树深度)+1</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 递归出口</span></div><div class="line">    <span class="keyword">int</span> depthLeft = getDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> depthRight = getDepth(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> depthLeft &gt; depthRight ? depthLeft + <span class="number">1</span> : depthRight + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="前序、中序、后序遍历"><a href="#前序、中序、后序遍历" class="headerlink" title="前序、中序、后序遍历"></a><span id="nodeTraverse"><strong>前序、中序、后序遍历</strong></span></h2><h3 id="前序遍历递归解法："><a href="#前序遍历递归解法：" class="headerlink" title="前序遍历递归解法："></a>前序遍历递归解法：</h3><ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    visit(root);                     <span class="comment">// 访问根结点</span></div><div class="line">    preOrderTraverse(root-&gt;left);    <span class="comment">// 前序遍历左子树</span></div><div class="line">    preOrderTraverse(root-&gt;right);   <span class="comment">// 前序遍历右子树</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="中序遍历递归解法："><a href="#中序遍历递归解法：" class="headerlink" title="中序遍历递归解法："></a>中序遍历递归解法：</h3><ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，中序遍历左子树，访问根结点，中序遍历右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    inOrderTraverse(root-&gt;left);    <span class="comment">// 中序遍历左子树</span></div><div class="line">    visit(root)；                   <span class="comment">// 访问根结点</span></div><div class="line">    inOrderTraverse(root-&gt;right);   <span class="comment">// 中序遍历右子树</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="后序遍历递归解法："><a href="#后序遍历递归解法：" class="headerlink" title="后序遍历递归解法："></a>后序遍历递归解法：</h3><ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根结点</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    postOrderTraverse(root-&gt;left);    <span class="comment">// 后序遍历左子树</span></div><div class="line">    postOrderTraverse(root-&gt;right);   <span class="comment">// 后序遍历右子树</span></div><div class="line">    visit(root);                      <span class="comment">// 访问根结点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他遍历二叉树方法-深度、广度优先"><a href="#其他遍历二叉树方法-深度、广度优先" class="headerlink" title="其他遍历二叉树方法(深度、广度优先)"></a><span id="nodeDFSBFS"><strong>其他遍历二叉树方法(深度、广度优先)</strong></span></h2><h3 id="深度优先遍历解法："><a href="#深度优先遍历解法：" class="headerlink" title="深度优先遍历解法："></a>深度优先遍历解法：</h3><ol>
<li>借助一个栈（后进先出）来实现深度遍历</li>
<li>先访问根结点</li>
<li>遍历左子树接着遍历右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</div><div class="line">    nodeStack.push(root);</div><div class="line">    <span class="keyword">while</span> (!nodeStack.empty()) &#123;</div><div class="line">        TreeNode *tmp = nodeStack.top();</div><div class="line">        visit(tmp);</div><div class="line">        nodeStack.pop();</div><div class="line">        <span class="keyword">if</span> (tmp-&gt;right)</div><div class="line">            nodeStack.push(tmp-&gt;right);</div><div class="line">        <span class="keyword">if</span> (tmp-&gt;left)</div><div class="line">            nodeStack.push(tmp-&gt;left);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="广度优先遍历解法："><a href="#广度优先遍历解法：" class="headerlink" title="广度优先遍历解法："></a>广度优先遍历解法：</h3><ol>
<li>借助队列（先进先出）来实现广度优先遍历</li>
<li>将根节点入队</li>
<li>当队列不为空，弹出一个节点，访问，若左子节点或右子节点不为空，将其入队</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</div><div class="line">        TreeNode *tmp = q.front();</div><div class="line">        q.pop();</div><div class="line">        visit(tmp);</div><div class="line">        <span class="keyword">if</span> (tmp-&gt;left)</div><div class="line">            nodeQueue.push(tmp-&gt;left);</div><div class="line">        <span class="keyword">if</span> (tmp-&gt;right)</div><div class="line">            nodeQueue.push(tmp-&gt;right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="将二叉查找树变为有序的双向链表"><a href="#将二叉查找树变为有序的双向链表" class="headerlink" title="将二叉查找树变为有序的双向链表"></a><span id="nodeList"><strong>将二叉查找树变为有序的双向链表</strong></span></h2><p>要求不创建新节点，只调整指针。<br>递归解法：</p>
<ol>
<li>如果二叉查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点也是NULL</li>
<li>如果二叉查找树不为空：<br> 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；<br> 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点与左子树转换后的双向有序链表的最后一个节点连接；<br> 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；<br> 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点与右子树转换后的双向有序链表的第一个节点连接。</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * root: 二叉查找树的根结点指针</div><div class="line">  * pFirstNode: 转换后双向有序链表的第一个节点指针</div><div class="line">  * pLastNode: 转换后双向有序链表的最后一个节点指针</div><div class="line">  **/</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(TreeNode* root, </span></span></div><div class="line">              TreeNode* &amp;pFirstNode, </div><div class="line">              TreeNode* &amp;pLastNode) &#123;</div><div class="line">    TreeNode *pFirstLeft, *pLastLeft, *pFirstRight, *pLastRight;</div><div class="line">    <span class="keyword">if</span> (!root) &#123;</div><div class="line">        pFirstNode = <span class="literal">NULL</span>;</div><div class="line">        pLastNode = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!root-&gt;left)</div><div class="line">        <span class="comment">// 如果左子树为空，对应双向有序链表的第一个节点是根节点</span></div><div class="line">        pFirstNode = root;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        convert(root-&gt;left, pFirstLeft, pLastLeft);</div><div class="line">        <span class="comment">// 二叉查找树对应双向有序链表的第一个节点就是</span></div><div class="line">        <span class="comment">// 左子树转换后双向有序链表的第一个节点</span></div><div class="line">        pFristNode = pFirstLeft;</div><div class="line">        <span class="comment">// 将根节点与左子树转换后的双向有序链表的最后一个节点连接</span></div><div class="line">        root-&gt;left = pLastLeft;</div><div class="line">        pLastLeft-&gt;right = root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!root-&gt;right)</div><div class="line">        <span class="comment">// 对应双向有序链表的最后一个节点是根节点</span></div><div class="line">        pLastNode = root;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        convert(root-&gt;right, pFirstRight, pLastRight);</div><div class="line">        <span class="comment">// 对应双向有序链表的最后一个节点就是</span></div><div class="line">        <span class="comment">// 右子树转换后双向有序链表的最后一个节点</span></div><div class="line">        pLastNode = pLastRight;</div><div class="line">        <span class="comment">// 将根节点和右子树转换后的双向有序链表的第一个节点连接</span></div><div class="line">        root-&gt;right = pFirstRight;</div><div class="line">        pFirstRight-&gt;left = root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a><span id="nodeKth"><strong>求二叉树第K层的节点个数</strong></span></h2><p>递归解法:</p>
<ol>
<li>如果二叉树为空或者k &lt; 1，返回0</li>
<li>如果二叉树不为空且k = 1，返回1</li>
<li>如果二叉树不为空且k &gt; 1，返回左子树中k-1层节点个数与右子树k-1层节点个数之和</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthLevelNodeNum</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!roo || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> leftNum = getKthLevelNodeNum(root-&gt;left);    <span class="comment">// 左子树中k-1层节点个数</span></div><div class="line">    <span class="keyword">int</span> rightNum = getKthLevelNodeNum(root-&gt;right);  <span class="comment">// 右子树中k-1层节点个数</span></div><div class="line">    <span class="keyword">return</span> (leftNum + rightNum);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a><span id="nodeLeaf"><strong>求二叉树中叶子节点的个数</strong></span></h2><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回0</li>
<li>如果二叉树不为空且左右子树为空，返回1</li>
<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子结点个数</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeafNodeNum</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> numLeft = getLeafNodeNum(root-&gt;left);    <span class="comment">// 左子树中叶节点个数</span></div><div class="line">    <span class="keyword">int</span> numRight = getLeafNodeNum(root-&gt;right);  <span class="comment">// 右子树中叶节点个数</span></div><div class="line">    <span class="keyword">return</span> (numLeft + numRight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断两棵二叉树结构是否相同"><a href="#判断两棵二叉树结构是否相同" class="headerlink" title="判断两棵二叉树结构是否相同"></a><span id="nodeStructure"><strong>判断两棵二叉树结构是否相同</strong></span></h2><p>不考虑数据内容。结构相同意味着对应左子树和右子树结构都相同。<br>递归解法:</p>
<ol>
<li>如果两棵二叉树都为空，返回真</li>
<li>如果两颗二叉树一棵为空，另一个不为空，返回假</li>
<li>如果两棵二叉树都不为空，如果对应的左右子树都同构则返回真，其他返回假</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">structureCmp</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!lhs &amp;&amp; !rhs) <span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">// 都为空树，返回真</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!lhs || !rhs) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 一个为空而另一个不为空，返回假</span></div><div class="line"><span class="keyword">bool</span> resultLeft = structureCmp(lhs-&gt;left, rhs-&gt;left);    <span class="comment">// 比较对应左子树</span></div><div class="line"><span class="keyword">bool</span> resultRight = structureCmp(lhs-&gt;right, rhs-&gt;right); <span class="comment">// 比较对应右子树</span></div><div class="line"><span class="keyword">return</span> (resultLeft &amp;&amp; resultRight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断二叉树是不是平衡二叉树"><a href="#判断二叉树是不是平衡二叉树" class="headerlink" title="判断二叉树是不是平衡二叉树"></a><span id="nodeAVL"><strong>判断二叉树是不是平衡二叉树</strong></span></h2><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回真</li>
<li>如果二叉树不为空，如果左子树和右子树都是AVL树且左子树和右子树高度差不大于1，返回真，其他返回假</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">boo <span class="title">isAVL</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;height)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) &#123;    <span class="comment">// 空树，返回真</span></div><div class="line">        height = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> heightLeft;</div><div class="line">    <span class="keyword">bool</span> resultLeft = isAVL(root-&gt;left, heightLeft);</div><div class="line">    <span class="keyword">int</span> heightRight;</div><div class="line">    <span class="keyword">bool</span> resultRight = isAVL(root-&gt;right, heightRight);</div><div class="line">    <span class="keyword">if</span> (resultLeft &amp;&amp; resultRight &amp;&amp; <span class="built_in">abs</span>(heightLeft - heightRight) &lt;= <span class="number">1</span>)&#123;    </div><div class="line">        <span class="comment">// 左右子树都是AVL树，并且高度差不大于1，返回真</span></div><div class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        height = max(heightLeft, heightRight) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求二叉树的镜像"><a href="#求二叉树的镜像" class="headerlink" title="求二叉树的镜像"></a><span id="nodeMirror"><strong>求二叉树的镜像</strong></span></h2><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回空</li>
<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    TreeNode *leftTree = mirrorTree(root-&gt;left);    <span class="comment">// 求左子树镜像</span></div><div class="line">    TreeNode *rightTree = mirrorTree(root-&gt;right);  <span class="comment">// 求右子树镜像</span></div><div class="line">    <span class="comment">// 交换左右子树</span></div><div class="line">    root-&gt;left = leftTree;</div><div class="line">    root-&gt;right = rightTree;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求二叉树中两个节点的最低公共祖先节点"><a href="#求二叉树中两个节点的最低公共祖先节点" class="headerlink" title="求二叉树中两个节点的最低公共祖先节点"></a><span id="nodeAncestor"><strong>求二叉树中两个节点的最低公共祖先节点</strong></span></h2><h3 id="递归解法："><a href="#递归解法：" class="headerlink" title="递归解法："></a>递归解法：</h3><ol>
<li>如果两个节点分别在根结点的左子树和右子树，则返回根结点</li>
<li>如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNode</span><span class="params">(TreeNode* root, TreeNode *pNode)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root || !pNode) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (root == pNode) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">bool</span> found = findNode(root-&gt;left, pNode);</div><div class="line">    <span class="keyword">if</span> (!found)</div><div class="line">        found = findNode(root-&gt;right, pNode);</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">TreeNode* <span class="title">getLowestCommonAncestor</span><span class="params">(TreeNode* root,</span></span></div><div class="line">                                  TreeNode* pNode1,</div><div class="line">                                  TreeNode* pNode2)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (findNode(root-&gt;left, pNode1)) &#123;</div><div class="line">        <span class="keyword">if</span> (findNode(root-&gt;right, pNode2))</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> getLowestCommonAncestor(root-&gt;left, pNode1, pNode2);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (find(root-&gt;left, pNode2))</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> getLowestCommonAncestor(root-&gt;right, pNode1, pNode2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>递归解法效率较低，有很多重复遍历，下面看一下非递归解法。</p>
<h3 id="非递归解法："><a href="#非递归解法：" class="headerlink" title="非递归解法："></a>非递归解法：</h3><p>先从根结点到两个节点的路径，然后再比较对应路径的节点，最后一个相同的节点就是他们在二叉树中的最低公共祖先节点</p>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getNodePath</span><span class="params">(TreeNode* root, </span></span></div><div class="line">                 TreeNode* pNode, </div><div class="line">                 <span class="built_in">list</span>&lt;TreeNode*&gt; &amp;path)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (root == pNode) &#123;</div><div class="line">        path.push_back(root);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    path.push_back(root);</div><div class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">    found = getNodePath(root-&gt;left, pNode, path);</div><div class="line">    <span class="keyword">if</span> (!found)</div><div class="line">        found = getNodePath(root-&gt;right, pNode, path);</div><div class="line">    <span class="keyword">if</span> (!found)</div><div class="line">        path.pop_back();</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">TreeNode* <span class="title">getLowestCommonAncestor</span><span class="params">(TreeNode *root, </span></span></div><div class="line">                                  TreeNode* pNode1, </div><div class="line">                                  TreeNode* pNode2)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root || !pNode1 || !pNode2) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path1;</div><div class="line">    <span class="keyword">bool</span> result1 = getNodePath(root, pNode1, path1);</div><div class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path2;</div><div class="line">    <span class="keyword">bool</span> result2 = getNodePath(root, pNode2, path2);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!result1 || !result2) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    TreeNode* pLast = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::iterator iter1 = path1.begin();</div><div class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::iterator iter2 = path2.begin();</div><div class="line">    <span class="keyword">while</span> (iter != path1.end() &amp;&amp; iter2 != path2.end()) &#123;</div><div class="line">        <span class="keyword">if</span> (*iter1 == *iter2)</div><div class="line">            pLast = *iter1;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        ++iter1;</div><div class="line">        ++iter2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pLast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。</p>
<h2 id="求二叉树中节点的最大距离"><a href="#求二叉树中节点的最大距离" class="headerlink" title="求二叉树中节点的最大距离"></a><span id="nodeDistance"><strong>求二叉树中节点的最大距离</strong></span></h2><p>即二叉树中相距最远的两个节点之间的距离。<br>递归解法：</p>
<ol>
<li>如果二叉树为空，则返回0，同时记录左子树和右子树的深度都为0</li>
<li>如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点到根节点的最大距离，同时记录左子树和右子树节点到根节点的最大距离</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;maxLeft, <span class="keyword">int</span> &amp;maxRight)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// maxLeft: 左子树中的节点离根节点的最远距离</span></div><div class="line">    <span class="comment">// maxRight: 右子树中的节点离根节点的最远距离</span></div><div class="line">    <span class="keyword">if</span> (!root) &#123;</div><div class="line">        maxLeft = <span class="number">0</span>;</div><div class="line">        maxRight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> maxLL, maxLR, maxRL, maxRR;</div><div class="line">    <span class="keyword">int</span> maxDistLeft, maxDistRight;</div><div class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</div><div class="line">        maxDistLeft = getMaxDistance(root-&gt;left, maxLL, maxLR);</div><div class="line">        maxLeft = max(maxLL, maxLR) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        maxDistLeft = <span class="number">0</span>;</div><div class="line">        maxLeft = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</div><div class="line">        maxDistRight = getMaxDistance(root-&gt;right, maxRL, maxRR);</div><div class="line">        maxRight = max(maxRL, maxRR) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        maxDistRight = <span class="number">0</span>;</div><div class="line">        maxRight = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max(max(maxDistLeft, maxDistRight), maxLeft + maxRight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="由前序遍历序列和中序遍历序列重建二叉树"><a href="#由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="由前序遍历序列和中序遍历序列重建二叉树"></a><span id="nodeRebuild"><strong>由前序遍历序列和中序遍历序列重建二叉树</strong></span></h2><p>二叉树前序遍历序列中，第一个元素总是树的根结点。中序遍历序列中，左子树的节点位于根结点的左边，右子树的节点位于根结点的右边。<br>递归解法：</p>
<ol>
<li>如果前序遍历为空或者节点个数小于等于0，返回NULL。</li>
<li>创建根节点。前序遍历的第一个节点就是根节点，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * pPreOrder: 前序遍历序列</div><div class="line">  * pInOrder: 中序遍历序列</div><div class="line">  * nodeNum: 二叉树节点数</div><div class="line">  **/</div><div class="line"><span class="function">TreeNode* <span class="title">rebuildTree</span><span class="params">(<span class="keyword">int</span>* pPreOrder, <span class="keyword">int</span>* pInOrder, <span class="keyword">int</span> nodeNum)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!pPreOrder || !pInOrder || nodeNum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</div><div class="line">    <span class="comment">// 前序遍历的第一个节点就是根节点</span></div><div class="line">    root-&gt;val = pPreOrder[<span class="number">0</span>];</div><div class="line">    root-&gt;left = <span class="literal">NULL</span>;</div><div class="line">    root-&gt;right = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></div><div class="line">    <span class="keyword">int</span> rootPoistionInOrder = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeNum; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (pInOrder[i] == root-&gt;val) &#123;</div><div class="line">            rootPositionInOrder = i;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rootPositionInOrder == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid Input."</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 重建左子树</span></div><div class="line">    <span class="keyword">int</span> nodeNumLeft = rootPositionInOrder;</div><div class="line">    <span class="keyword">int</span>* pPreOrderLeft = pPreOrder + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span>* pInOrderLeft = pInOrder;</div><div class="line">    root-&gt;left = rebuildTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</div><div class="line">    <span class="comment">// 重建右子树</span></div><div class="line">    <span class="keyword">int</span> nodeNumRight = nodeNum - nodeNumLeft <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span>* pPreOrderRight = pPreOrder + <span class="number">1</span> + nodeNumLeft;</div><div class="line">    <span class="keyword">int</span>* pInOrderRight = pInOrder + nodeNumLeft + <span class="number">1</span>;</div><div class="line">    root-&gt;right = rebuildTree(pPreOrderRight, pInOrderRight, nodeNumRight);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树</p>
<h2 id="判断二叉树是不是完全二叉树"><a href="#判断二叉树是不是完全二叉树" class="headerlink" title="判断二叉树是不是完全二叉树"></a><span id="nodeComplete"><strong>判断二叉树是不是完全二叉树</strong></span></h2><p>若设二叉树的深度为h，除第h层外，其他各层(1~h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。<br>如何判断是否为完全二叉树：<br>按层次(从上之下，从左至右)遍历二叉树，当遇到一个节点的左子树为空时，则该节点的右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树</p>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</div><div class="line">    nodeQueue.push(root);</div><div class="line">    <span class="keyword">bool</span> mustHaveNoChild = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</div><div class="line">        TreeNode* pNode = nodeQueue.front();</div><div class="line">        nodeQueue.pop();</div><div class="line">        <span class="keyword">if</span> (mustHaveNoChild) &#123;   <span class="comment">// 已经出现了有空子树的节点了，后面的节点必须为叶子结点(没有孩子节点)</span></div><div class="line">            <span class="keyword">if</span> (pNode-&gt;left || pNode-&gt;right) &#123;</div><div class="line">                result = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class="line">                nodeQueue.push(pNode-&gt;left);</div><div class="line">                nodeQueue.push(pNode-&gt;right);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</div><div class="line">                mustHaveNoChild = <span class="literal">true</span>;</div><div class="line">                nodeQueue.push(pNode-&gt;left);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!pNode-&gt;left &amp;&amp; pNode-&gt;right) &#123;</div><div class="line">                result = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                mastHaveNoChild = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转自 &lt;a href=&quot;http://blog.csdn.net/walkinginthewind/article/details/7518888&quot;&gt;http://blog.csdn.net/walkinginthewind/article/details/7518888&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;p&gt;树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://felon03.github.io/categories/Data-Structure/"/>
    
    
      <category term="BinaryTree" scheme="https://felon03.github.io/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>UTF-8 码点</title>
    <link href="https://felon03.github.io/2017/10/09/UTF-8-%E7%A0%81%E7%82%B9/"/>
    <id>https://felon03.github.io/2017/10/09/UTF-8-码点/</id>
    <published>2017-10-09T02:34:48.000Z</published>
    <updated>2017-10-09T02:42:13.105Z</updated>
    
    <content type="html"><![CDATA[<p>UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">码点范围</th>
<th style="text-align:center">码点位数</th>
<th style="text-align:center">字节1</th>
<th style="text-align:center">字节2</th>
<th style="text-align:center">字节3</th>
<th style="text-align:center">字节4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">U+0000~U+007F</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0xxxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">U+0080~U+07FF</td>
<td style="text-align:center">11</td>
<td style="text-align:center">110xxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">U+0800~U+FFFF</td>
<td style="text-align:center">16</td>
<td style="text-align:center">1110xxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">U+10000~U+10FFFF</td>
<td style="text-align:center">21</td>
<td style="text-align:center">11110xxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
</tr>
</tbody>
</table>
<p> 1000 0000 -&gt; 80<br> 1100 0000 -&gt; C0<br> 1110 0000 -&gt; E0<br> 1111 0000 -&gt; F0</p>
<p> 1111 1111 -&gt; FF<br> 0011 1111 -&gt; 3F</p>
<p> e.g. U+20AC 0x0800 &lt; 0x20AC &lt; 0xFFFF<br> 所以0x20AC有16位码点,编成三字节<br> 0x20AC的二进制为 10 0000 1010 1100 需要16位，所以在前面补0，即<br> 0010 0000 1010 1100<br> 将其分成三组：<br> 0010， 000010， 101100<br> 加上前缀：<br> 1110 0010, 1000 0010, 1010 1100<br> 则得到 0xE2, 0x82, 0xAC</p>
<p> 10 0000 1010 1100 &gt;&gt; 12 -&gt; 10 -&gt; 0000 0010<br> 0000 0010 &amp; 1111 1111 -&gt; 0000 0010<br> 1110 0000 | 0000 0010 -&gt; 1110 0010 -&gt; 0xE2</p>
<p> 10 0000 1010 1100 &gt;&gt; 6 -&gt; 1000 0010<br> 1000 0010 &amp; 0011 1111 -&gt; 0000 0010<br> 1000 0000 | 0000 0010 -&gt; 1000 0010 -&gt; 0x82</p>
<p> 10 0000 1010 1100 &amp; 00 0000 1111 1111 -&gt; 00 0000 1010 1100<br> 00 0000 1000 0000 | 00 0000 1010 1100 -&gt; 1010 1100 -&gt; 0xAC</p>
<p> 代码表示(C):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// u &lt;= 0x007F</span></div><div class="line">PUTC(c, u &amp; <span class="number">0xFF</span>);</div><div class="line"></div><div class="line"><span class="comment">// u &lt;= 0x07FF</span></div><div class="line">PUTC(c, <span class="number">0xC0</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0xFF</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>);</div><div class="line"></div><div class="line"><span class="comment">// u &lt;= 0xFFFF</span></div><div class="line">PUTC(c, <span class="number">0xE0</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xFF</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>));</div><div class="line"></div><div class="line"><span class="comment">// u &lt;= 0x10FFFF</span></div><div class="line">PUTC(c, <span class="number">0xF0</span> | ((u &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xFF</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3F</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</div><div class="line">PUTC(c, <span class="number">0x80</span> | (u &amp; <span class="number">0x3F</span>));</div></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UTF-8的编码单元是8位字节，每个码点编成1至4个字节。它的编码方式很简单，按照码点的范围，把码点的二进制位拆分成1至最多4个字节：&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="UTF-8" scheme="https://felon03.github.io/tags/UTF-8/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】矩阵旋转</title>
    <link href="https://felon03.github.io/2017/09/06/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC/"/>
    <id>https://felon03.github.io/2017/09/06/【每周一坑】矩阵旋转/</id>
    <published>2017-09-06T11:46:37.000Z</published>
    <updated>2017-09-06T11:55:05.627Z</updated>
    
    <content type="html"><![CDATA[<p>本次的题目是关于矩阵旋转的<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>给定一个N*N的矩阵(N&gt;=0)，将其顺时针旋转90°。输出旋转后的矩阵。<br>举例：<br>1 2 3<br>4 5 6<br>7 8 9<br>旋转后输出的结果应该是：<br>7 4 1<br>8 5 2<br>9 6 3</p>
</blockquote>
<h2 id="附加要求"><a href="#附加要求" class="headerlink" title="附加要求"></a>附加要求</h2><blockquote>
<p>在不创建新矩阵的情况下做变换，即所有的修改都在原矩阵上直接进行。</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-使用额外的空间"><a href="#1-使用额外的空间" class="headerlink" title="1. 使用额外的空间"></a>1. 使用额外的空间</h3><p>顺时针旋转90°，可以把每一列元素取出来组成新的行，再将新的行反转一下就得到旋转后的矩阵了。</p>
<blockquote>
<p>如：<br>1 2 3<br>4 5 6<br>7 8 9<br>取出每一列作为新的行：<br>1 4 7<br>2 5 8<br>3 6 9<br>再将每一行反转就得到了：<br>7 4 1<br>8 5 2<br>9 6 3</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :param matrix: List(List(int))</div><div class="line">    :return: List(List(int))</div><div class="line">    """</div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> matrix</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</div><div class="line">        l = []</div><div class="line">        <span class="keyword">for</span> subList <span class="keyword">in</span> matrix:</div><div class="line">            l.append(subList[i])</div><div class="line">        l.reverse()</div><div class="line">        res.append(l)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h3 id="2-在原矩阵上进行操作"><a href="#2-在原矩阵上进行操作" class="headerlink" title="2. 在原矩阵上进行操作"></a>2. 在原矩阵上进行操作</h3><p>旋转90°可以看到变换前和变换后是按照对角线对称后再反转的 (<a href="http://blog.csdn.net/lion19930924/article/details/51661248" target="_blank" rel="external">原博客</a>)</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">将矩阵旋转90度，可以看出变换前和变换后的矩阵是按照</div><div class="line">对角线对称交换以后再进行反转后得到的</div><div class="line">'''</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate1</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :param matrix: List(List(int))</div><div class="line">    :return: matrix</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> matrix</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</div><div class="line">        j = i + <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> j &lt; len(matrix[<span class="number">0</span>]):</div><div class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</div><div class="line">            j += <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</div><div class="line">        <span class="comment"># print(matrix[i])</span></div><div class="line">        matrix[i].reverse()</div><div class="line">        <span class="comment"># print(matrix[i])</span></div><div class="line">    <span class="comment"># matrix.reverse()</span></div><div class="line">    <span class="comment"># print(matrix)</span></div><div class="line">    <span class="keyword">return</span> matrix</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/lion19930924/article/details/51661248" target="_blank" rel="external">CSDN Blog – 二维数组旋转90度(by @lynne233)</a></p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次的题目是关于矩阵旋转的&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】阿姆斯特朗数</title>
    <link href="https://felon03.github.io/2017/08/04/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0/"/>
    <id>https://felon03.github.io/2017/08/04/【每周一坑】阿姆斯特朗数/</id>
    <published>2017-08-04T10:37:51.000Z</published>
    <updated>2017-08-04T11:18:32.589Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-08-04.jpg" alt="armstrong"><br>快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~</p>
<p>一个经典的编程练习题：</p>
<blockquote>
<p>如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。<br>如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>输出1000以内的所有阿姆斯特朗数。</p>
</blockquote>
<p><strong>附加题</strong></p>
<blockquote>
<p>输入一个整数，输出距离它最近的阿姆斯特朗数。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一眼看到阿姆斯特朗就想到了<a href="http://v.youku.com/v_show/id_XMjY1ODQ2MzM1Ng==.html?spm=a2h1n.8261147.0.0" target="_blank" rel="external">《银魂》</a><strong>阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</strong>了，果然银魂毁节操QAQ。</p>
<p>回到主题，其实阿姆斯特朗数和<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0" target="_blank" rel="external">水仙花数</a>差不多。<br>满足阿姆斯特朗数的公式如下，设 $ n = d_kd_{k-1}\cdots d_1 $，则有</p>
<p>$$<br>n = d_k^k + d_{k-1}^k+\cdots+d_2^k+d_1^k<br>$$</p>
<p>编写代码是只要得到整数n的各个位上的数，然后进行k次幂求和即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">temp = num</div><div class="line"><span class="keyword">while</span> temp:</div><div class="line">    <span class="comment"># 求出每位数的k次幂的和</span></div><div class="line">    res += (temp % <span class="number">10</span>)**n</div><div class="line">    num //= <span class="number">10</span></div><div class="line"><span class="keyword">if</span> res == num:</div><div class="line">    <span class="comment"># 如果满足阿姆斯特朗数的条件，就返回这个数</span></div><div class="line">    <span class="keyword">return</span> num</div></pre></td></tr></table></figure>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 得到bound以内的阿姆斯特朗数，bound默认为1000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span><span class="params">(bound=<span class="number">1000</span>)</span>:</span></div><div class="line">    armstrong_number = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bound):</div><div class="line">        temp = i</div><div class="line">        n = len(str(i))</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> temp:</div><div class="line">            res += (temp % <span class="number">10</span>) ** n</div><div class="line">            temp //= <span class="number">10</span></div><div class="line">        <span class="keyword">if</span> res == i:</div><div class="line">            armstrong_number.append(i)</div><div class="line">    <span class="keyword">return</span> armstrong_number</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 得到离number最近的阿姆斯特朗数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nearest_number</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="keyword">if</span> is_arm_num(num):</div><div class="line">        <span class="keyword">return</span> num</div><div class="line">    temp = num</div><div class="line">    res = get_number(temp)[<span class="number">-1</span>]</div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> is_arm_num(temp):</div><div class="line">        temp += <span class="number">1</span></div><div class="line">    res_new = temp</div><div class="line">    <span class="keyword">if</span> abs(res_new - num) &lt; abs(res - num):</div><div class="line">        <span class="keyword">return</span> res_new</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 判断num是否是阿姆斯特朗数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_arm_num</span><span class="params">(num)</span>:</span></div><div class="line">    temp = num</div><div class="line">    res = <span class="number">0</span></div><div class="line">    n = len(str(num))</div><div class="line">    <span class="keyword">while</span> temp:</div><div class="line">        res += (temp % <span class="number">10</span>) ** n</div><div class="line">        temp //= <span class="number">10</span></div><div class="line">    <span class="keyword">return</span> res == num</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(get_number())</div><div class="line">    print(get_nearest_number(<span class="number">390</span>))</div><div class="line">    print(get_nearest_number(<span class="number">389</span>))</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; get_number(1000)</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407]</div><div class="line"></div><div class="line">&gt;&gt;&gt; get_nearest_number(390)</div><div class="line">407</div><div class="line"></div><div class="line">&gt;&gt;&gt; get_nearest_number(389)</div><div class="line">371</div></pre></td></tr></table></figure>
<p>满足问题要求</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0" target="_blank" rel="external">Wiki 水仙花数</a></p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-08-04.jpg&quot; alt=&quot;armstrong&quot;&gt;&lt;br&gt;快一个月没写博客了，整个七月确实比较忙，也没什么时间弄管理博客(虽然就我一个人会看这个Blog…)，今天诈尸更新一下~~&lt;/p&gt;
&lt;p&gt;一个经典的编程练习题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个n位正整数等于其各位数字的n次幂之和，则称该数为阿姆斯特朗数（亦称为自恋数、自幂数）。&lt;br&gt;如 $407 = 4^3 + 0^3 + 7^3$ 就是一个阿姆斯特朗数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输出1000以内的所有阿姆斯特朗数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;附加题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数，输出距离它最近的阿姆斯特朗数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】罗马数字转换</title>
    <link href="https://felon03.github.io/2017/07/08/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <id>https://felon03.github.io/2017/07/08/【每周一坑】罗马数字转换/</id>
    <published>2017-07-08T06:38:47.000Z</published>
    <updated>2017-07-08T06:53:31.323Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-07-08.jpg" alt="roman"></p>
<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。</p>
<p>罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：</p>
<ol>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3</li>
<li>小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12</li>
<li>小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9</li>
<li>在一个数的上面画一条横线，表示这个数曾1000倍</li>
</ol>
<a id="more"></a>
<p><strong>常见罗马字符表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">数字</th>
<th style="text-align:center">罗马字符</th>
<th style="text-align:center">数字</th>
<th style="text-align:center">罗马字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Ⅰ</td>
<td style="text-align:center">2</td>
<td style="text-align:center">Ⅱ</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Ⅲ</td>
<td style="text-align:center">4</td>
<td style="text-align:center">Ⅳ</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">Ⅴ</td>
<td style="text-align:center">6</td>
<td style="text-align:center">Ⅵ</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">Ⅶ</td>
<td style="text-align:center">8</td>
<td style="text-align:center">Ⅷ</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">Ⅸ</td>
<td style="text-align:center">10</td>
<td style="text-align:center">Ⅹ</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center">XL</td>
<td style="text-align:center">50</td>
<td style="text-align:center">L</td>
</tr>
<tr>
<td style="text-align:center">90</td>
<td style="text-align:center">XC</td>
<td style="text-align:center">100</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">CD</td>
<td style="text-align:center">500</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">900</td>
<td style="text-align:center">CM</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">2000</td>
<td style="text-align:center">MM</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">MMD</td>
</tr>
</tbody>
</table>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>编写一个罗马数字和阿拉伯数字的转换器：</p>
<blockquote>
<p>给定一个小于3999的罗马数，将其转换为整数，例如:Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980</p>
</blockquote>
<p><strong>附加题</strong></p>
<blockquote>
<p>给定一个小于3999的整数，将其转换为罗马数</p>
</blockquote>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="comment"># your code</span></div><div class="line">    <span class="keyword">return</span> i</div><div class="line"></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'III'</span>) == <span class="number">3</span></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'IV'</span>) == <span class="number">4</span></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'VI'</span>) == <span class="number">6</span></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'XIX'</span>) == <span class="number">19</span></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'XX'</span>) == <span class="number">20</span></div><div class="line"><span class="keyword">assert</span> romaToInt(<span class="string">'XLV'</span>) == <span class="number">45</span></div><div class="line"><span class="keyword">assert</span> romanToInt(<span class="string">'MCMLXXX'</span>) == <span class="number">1980</span></div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="罗马数转阿拉伯数"><a href="#罗马数转阿拉伯数" class="headerlink" title="罗马数转阿拉伯数"></a>罗马数转阿拉伯数</h3><p>根据罗马数的规则，要把罗马数转换为阿拉伯数只需把每位罗马数加起来即可，不过要<strong>注意IV、IX、XL、XC、CD、MC这些表示(5-1、10-1、50-10、100-10、500-100、1000-100)的情况</strong>。故在计算阿拉伯数时要判断是否是上述的数。观察可知以上数中，<strong>左边的罗马数均比右边的小</strong>，故可以以这个为判断条件，来确定是进行加操作还是减操作。可以<strong>将罗马数字符反转</strong>，然后从头遍历，如果<strong>当前罗马数小于上一位，则减去当前的罗马数所对应的数字；否则，加上当前罗马数所对应的数字</strong>。</p>
<blockquote>
<p>如 MCMLXXX，首先将其反转，得到XXXLMCM，再开始遍历(res表示结果，pre表示上一位罗马数)：</p>
<ol>
<li>第一位是X，表示10，pre = 0，res = 0 + 10</li>
<li>第二位是X，表示10，pre = 10，与Pre相等，则res = 10 + 10</li>
<li>第三位是X，表示10，pre = 10，与pre相等，则res = 20 + 10</li>
<li>第四位是L，表示50，pre = 10，大于pre，则res = 30 + 50</li>
<li>第五位是M，表示1000，pre = 50， 大于pre，则res = 80 + 1000</li>
<li>第六位是C，表示100， pre = 1000， 小于pre，则res = 1080 - 100</li>
<li>第七位是M，表示1000， pre = 100， 大于pre，则res = 980 + 1000</li>
</ol>
</blockquote>
<p>经过上述步骤，得到MCMLXXX对应的阿拉伯数为1980,结果正确</p>
<h3 id="阿拉伯数-整数-转罗马数"><a href="#阿拉伯数-整数-转罗马数" class="headerlink" title="阿拉伯数(整数)转罗马数"></a>阿拉伯数(整数)转罗马数</h3><p>将输入的整数不断除罗马数中的几个关键数(I、IV、V、IX、X、XL、CX、CD、D、CM、M)然后将由除法得到的数(即表示改罗马数的个数)加到结果中，再对整数取余，直到整数取余的结果为0</p>
<blockquote>
<p>如1980，(res表示结果):</p>
<ol>
<li>1980 // 1000 = 1, res += M, 1980 % 1000 = 980</li>
<li>980 // 900 = 1, res += CM, 980 % 900 = 80</li>
<li>80 // 50 = 1, res += L, 80 % 50 = 30</li>
<li>30 // 10 = 3, res += 3*X, 30 % 10 = 0</li>
</ol>
</blockquote>
<p>经过上述步骤即可得整数1980 = MCMLXXX</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># 罗马数字转换</span></div><div class="line"><span class="comment"># 1 I 4 IV 5V 9 IX 10X 40XL 50L 70 LXX 90XC 100C 200CC</span></div><div class="line"><span class="comment"># 400CCC;CD 500D 900CM 1000M 2500MMD</span></div><div class="line"></div><div class="line"><span class="comment"># e.g.</span></div><div class="line"><span class="comment"># 3-&gt;III</span></div><div class="line"><span class="comment"># 4-&gt;IV</span></div><div class="line"><span class="comment"># 6-&gt;VI</span></div><div class="line"><span class="comment"># 19-&gt;XIX</span></div><div class="line"><span class="comment"># 45-&gt;XLV</span></div><div class="line"><span class="comment"># 999-&gt;CMXCIX</span></div><div class="line"><span class="comment"># 1980-&gt;MCMLXXX</span></div><div class="line"><span class="comment"># 3999-&gt;MMMCMXCIX</span></div><div class="line"></div><div class="line"><span class="comment"># 罗马转数字</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">roman_to_int</span><span class="params">(s)</span>:</span></div><div class="line">    roman_int_dic = &#123;</div><div class="line">        <span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>,</div><div class="line">        <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>,</div><div class="line">        <span class="string">'M'</span>: <span class="number">1000</span></div><div class="line">    &#125;</div><div class="line">    s = s[::<span class="number">-1</span>]</div><div class="line">    res, pre = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> s:</div><div class="line">        <span class="keyword">if</span> roman_int_dic[x] &gt;= pre:</div><div class="line">            res += roman_int_dic[x]</div><div class="line">            pre = roman_int_dic[x]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            res -= roman_int_dic[x]</div><div class="line">            pre = roman_int_dic[x]</div><div class="line">    <span class="keyword">return</span> res</div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment"># 数字转罗马</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_to_roman</span><span class="params">(i)</span>:</span></div><div class="line">    dic = &#123;</div><div class="line">        <span class="number">1000</span>: <span class="string">'M'</span>, <span class="number">900</span>: <span class="string">'CM'</span>, <span class="number">500</span>: <span class="string">'D'</span>, <span class="number">400</span>: <span class="string">'CD'</span>,</div><div class="line">        <span class="number">100</span>: <span class="string">'C'</span>, <span class="number">90</span>: <span class="string">'XC'</span>, <span class="number">50</span>: <span class="string">'L'</span>, <span class="number">40</span>: <span class="string">'XL'</span>,</div><div class="line">        <span class="number">10</span>: <span class="string">'X'</span>, <span class="number">9</span>: <span class="string">'IX'</span>, <span class="number">5</span>: <span class="string">'V'</span>, <span class="number">4</span>: <span class="string">'IV'</span>, <span class="number">1</span>: <span class="string">'I'</span></div><div class="line">    &#125;</div><div class="line">    res = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> dic:</div><div class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</div><div class="line">            res += i // k * dic[k]</div><div class="line">            i %= k</div><div class="line">    <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    result = roman_to_int(<span class="string">'MMMCMXCIX'</span>)</div><div class="line">    print(result)</div><div class="line"></div><div class="line">    int_res = int_to_roman(<span class="number">3999</span>)</div><div class="line">    print(int_res)</div><div class="line"></div><div class="line">    result = roman_to_int(<span class="string">'MCMLXXX'</span>)</div><div class="line">    print(result)</div><div class="line"></div><div class="line">    int_res = int_to_roman(<span class="number">1980</span>)</div><div class="line">    print(int_res)</div><div class="line"></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'III'</span>) == <span class="number">3</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'IV'</span>) == <span class="number">4</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'VI'</span>) == <span class="number">6</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'XIX'</span>) == <span class="number">19</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'XLV'</span>) == <span class="number">45</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'MCMLXXX'</span>) == <span class="number">1980</span></div><div class="line">    <span class="keyword">assert</span> roman_to_int(<span class="string">'CMXCIX'</span>) == <span class="number">999</span></div><div class="line">    print(<span class="string">"OK"</span>)</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>roman_to_int(<span class="string">'MMMCMXCIX'</span>)</div><div class="line"><span class="number">3999</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int_to_roman(<span class="number">3999</span>)</div><div class="line">MMMCMXCIX</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>roman_to_int(MCMLXXX)</div><div class="line"><span class="number">1980</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int_to_roman(<span class="number">1980</span>)</div><div class="line">MCMLXXX</div></pre></td></tr></table></figure>
<p>结果与要求一致</p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-07-08.jpg&quot; alt=&quot;roman&quot;&gt;&lt;/p&gt;
&lt;p&gt;罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码，现在的使用已经非常少了，大概偶尔会在钟表、文章中的标号等地方还能见到。&lt;/p&gt;
&lt;p&gt;罗马数字采用七个罗马字母做数字，即I(1), V(5), X(10), L(50), C(100）, D(500), M(1000)。它有一套不同于阿拉伯数字的写法规则，简单来说可以总结为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ= 3&lt;/li&gt;
&lt;li&gt;小的数字在大的数字的右边，表示的数等于这些数字相加得到的数，如 Ⅷ=8， Ⅻ=12&lt;/li&gt;
&lt;li&gt;小的数字(限于Ⅰ、Ⅹ、Ｃ)在大的数字的左边，所表示的数等于大数减小数得到的数，如Ⅳ=4、Ⅸ=9&lt;/li&gt;
&lt;li&gt;在一个数的上面画一条横线，表示这个数曾1000倍&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】螺旋矩阵</title>
    <link href="https://felon03.github.io/2017/06/23/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://felon03.github.io/2017/06/23/【每周一坑】螺旋矩阵/</id>
    <published>2017-06-23T11:44:50.000Z</published>
    <updated>2017-06-23T12:01:46.982Z</updated>
    
    <content type="html"><![CDATA[<p><strong>螺旋矩阵</strong>是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。<br><img src="/images/imagesource/17-06-23.jpg" alt="matrix"><br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>输出如图的螺旋矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  1    2    3    4</div><div class="line">12  13   14   5</div><div class="line">11  16   15   6</div><div class="line">10    9     8   7</div></pre></td></tr></table></figure>
</blockquote>
<p><strong>附加题</strong></p>
<blockquote>
<p>输入一个正整数N，输出以N为边长的螺旋矩阵。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要找到数字在二维数组中赋值的规律：</p>
<ol>
<li>设x,y分别二维矩阵行和列的下标，则任意元素都可以用matrix[x][y]来表示，将矩阵matrix中所有元素初始值设置为0；</li>
<li>为数组中的各个元素赋值，要求matrix[x][y]除了初始化之外没有被赋过新值；</li>
<li>从第一行，当y &lt; N时，x不变，递增y，同时为matrix[x][y]赋新值，直到y = N(从右至左)；</li>
<li>然后开始递增x(x&lt;N)，y不变,为matrix[x][y]赋新值(从上至下)；</li>
<li>接下来开始递减y(y&gt;=0)，x不变，为matrix[x][y]赋新值(从右至左)；</li>
<li>最后递减x(x&gt;=0)，y保持不变，为matrix[x][y]赋新值(从下至上)；</li>
<li>重复<strong>3-6</strong>步，直到最后赋的值等于N的平方</li>
</ol>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># 打印输出螺旋矩阵</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_matrix</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="comment"># 用二维数组来代表矩阵</span></div><div class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]</div><div class="line">    <span class="keyword">return</span> matrix</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rota_matrix</span><span class="params">(n)</span>:</span></div><div class="line">    mat = gen_matrix(n)  <span class="comment"># 初始矩阵，所有元素都为0</span></div><div class="line">    x = y = <span class="number">0</span></div><div class="line">    total = mat[x][y] = <span class="number">1</span> <span class="comment"># 将数组第一个元素设为1，即mat[0][0] = 1</span></div><div class="line">    <span class="keyword">while</span> total != n * n:</div><div class="line">        <span class="keyword">while</span> y + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="keyword">not</span> mat[x][y + <span class="number">1</span>]: <span class="comment"># 从左至右</span></div><div class="line">            y += <span class="number">1</span></div><div class="line">            total += <span class="number">1</span></div><div class="line">            mat[x][y] = total</div><div class="line">        <span class="keyword">while</span> x + <span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="keyword">not</span> mat[x + <span class="number">1</span>][y]: <span class="comment"># 从上之下</span></div><div class="line">            x += <span class="number">1</span></div><div class="line">            total += <span class="number">1</span></div><div class="line">            mat[x][y] = total</div><div class="line">        <span class="keyword">while</span> y - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> mat[x][y - <span class="number">1</span>]: <span class="comment"># 从右至左</span></div><div class="line">            y -= <span class="number">1</span></div><div class="line">            total += <span class="number">1</span></div><div class="line">            mat[x][y] = total</div><div class="line">        <span class="keyword">while</span> x - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> mat[x - <span class="number">1</span>][y]: <span class="comment"># 从下至上</span></div><div class="line">            x -= <span class="number">1</span></div><div class="line">            total += <span class="number">1</span></div><div class="line">            mat[x][y] = total</div><div class="line">    <span class="keyword">return</span> mat</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    n = int(input(<span class="string">"请输入矩形数组的大小:"</span>))</div><div class="line">    matrix = get_rota_matrix(n)</div><div class="line">    <span class="comment"># print(matrix)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</div><div class="line">            print(<span class="string">'%4d'</span> % matrix[i][j], end=<span class="string">" "</span>)</div><div class="line">        print()</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输出结果<br>当N = 4 时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; 请输入矩形数组的大小： 4</div><div class="line"></div><div class="line">      1    2    3    4</div><div class="line">    12  13   14   5</div><div class="line">    11  16   15   6</div><div class="line">    10    9     8   7</div></pre></td></tr></table></figure></p>
<p>当N = 5 时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; 请输入矩形数组的大小： 5</div><div class="line"></div><div class="line">    1     2     3     4    5 </div><div class="line">  16   17   18   19    6 </div><div class="line">  15   24   25   20    7 </div><div class="line">  14   23   22   21    8 </div><div class="line">  13   12   11   10    9</div></pre></td></tr></table></figure></p>
<p>结果与要求一致，可以输出任意N的螺旋矩阵。</p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;螺旋矩阵&lt;/strong&gt;是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。&lt;br&gt;&lt;img src=&quot;/images/imagesource/17-06-23.jpg&quot; alt=&quot;matrix&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>C++中的explicit关键字</title>
    <link href="https://felon03.github.io/2017/06/15/C-%E4%B8%AD%E7%9A%84explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://felon03.github.io/2017/06/15/C-中的explicit关键字/</id>
    <published>2017-06-15T08:19:33.000Z</published>
    <updated>2017-06-15T08:27:44.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><p>在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：</p>
<blockquote>
<p>如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作<strong>转换构造函数(converting constructor)</strong></p>
</blockquote>
<a id="more"></a>
<p>也就是说编译器允许将构造函数参数类型通过隐式的转换，转化为一个类类型，以便为参数获取正确的类型。</p>
<h2 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h2><p>下面就给出一个例子，一个类的构造函数可以被用于隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="comment">// 单形参构造函数，可以用作隐式转换</span></div><div class="line">	Foo(<span class="keyword">int</span> foo) : m_foo(foo) &#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getFoo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_foo; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> m_foo;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个函数，接受Foo类型的形参</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">(Foo foo)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = foo.getFoo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 主函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Bar(<span class="number">42</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在<code>main</code>函数中，传入<code>Bar</code>的并不是一个<code>Foo</code>的对象，而是内置类型<code>int</code>，但类<code>Foo</code>的构造函数接受一个<code>int</code>，因此这个构造函数可以用来将参数转换成正确的类型。</p>
<h2 id="使用explicit抑制构造函数定义的隐式转换"><a href="#使用explicit抑制构造函数定义的隐式转换" class="headerlink" title="使用explicit抑制构造函数定义的隐式转换"></a>使用explicit抑制构造函数定义的隐式转换</h2><p>为了防止编译器使用单参数构造函数进行隐式转换，需要在构造函数前加一个<strong>explicit</strong>关键字：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">explicit Foo(int foo) : m_foo(foo) &#123;&#125;</div></pre></td></tr></table></figure>
<p>这样就可以有效防止隐式转换。之前在<code>main</code>函数中<code>Bar(42)</code>就会报错：</p>
<blockquote>
<p>void Bar(Foo): 无法将参数1从”int”转换为”Foo”</p>
</blockquote>
<p>进行如下修改，对传入的<code>int</code>进行显式转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bar(Foo(<span class="number">42</span>))</div></pre></td></tr></table></figure></p>
<p>这样就不会报错了。使用<strong>explicit</strong>关键字的原因是为了防止预想之外的情况发生。<br>下面举个例子（感觉不太合适）：</p>
<blockquote>
<p>假设有一个MyString(int size)类，它有一个构造函数，可以构造给定size的字符串。还有一个函数print(cons MyString&amp;)，然后调用print(3)。我们期望它能输出”3”，但是它实际上输出的是一个长度为3的空string。</p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于<strong>explicit</strong>的结论：</p>
<ul>
<li>关键字<strong>explicit</strong>只对一个实参的构造函数有效</li>
<li>需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为<strong>explicit</strong>的</li>
<li>只能在类内声明构造函数时使用<strong>explicit</strong>关键字，在类外部定义式不应重复</li>
</ul>
<p>当我们用<strong>explicit</strong>关键字声明构造函数时，它将只能以直接初始化的形式(例如<code>string s(&quot;Hello&quot;)</code>)使用。而且编译器将不会在自动转换过程中使用改构造函数。</p>
<p>如果我们不希望函数进行隐式转换，那么最好将单形参构造函数定义为<strong>explicit</strong>的。这样可以避免错误，并且当需要转换时，我们也可以显式地构造对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean/121163#121163" target="_blank" rel="external">Stack OverFlow - What does the explicit keyword mean?</a></p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;隐式的类类型转换&quot;&gt;&lt;a href=&quot;#隐式的类类型转换&quot; class=&quot;headerlink&quot; title=&quot;隐式的类类型转换&quot;&gt;&lt;/a&gt;隐式的类类型转换&lt;/h2&gt;&lt;p&gt;在介绍explicit关键字之前，先来了解一下什么是隐式的类类型转换，C++ Primer第五版中的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转化为次类类型的隐式转换规则，有时我们把这种构造函数称作&lt;strong&gt;转换构造函数(converting constructor)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://felon03.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】校验文件哈希</title>
    <link href="https://felon03.github.io/2017/06/09/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E5%93%88%E5%B8%8C/"/>
    <id>https://felon03.github.io/2017/06/09/【每周一坑】校验文件哈希/</id>
    <published>2017-06-09T11:18:25.000Z</published>
    <updated>2017-06-12T08:22:34.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-06-09.png" alt="hash"></p>
<p>我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。<br>早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>请使用Python写一个小程序，用来计算指定文件的哈希值。</p>
</blockquote>
<p><strong>附加题</strong></p>
<blockquote>
<p>可以指定哈希加密算法，并让程序尽可能简单易用。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>问题挺简单，可以使用hashlib这个库来生成哈希值。之前也用到过这个库<a href="https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/">【每周一坑】程序员的浪漫</a>,具体用法在之前的文章中也讲过了。</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="计算哈希值的函数"><a href="#计算哈希值的函数" class="headerlink" title="计算哈希值的函数"></a>计算哈希值的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算哈希值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_hash</span><span class="params">(file)</span>:</span></div><div class="line">    <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">        s = f.read()</div><div class="line">        md5 = hashlib.md5(s).hexdigest()  <span class="comment"># 生成MD5</span></div><div class="line">        sha1 = hashlib.sha1(s).hexdigest()  <span class="comment"># 生成SHA1</span></div><div class="line">        sha256 = hashlib.sha256(s).hexdigest()  <span class="comment"># 生成SHA256</span></div><div class="line">        sha512 = hashlib.sha512(s).hexdigest()  <span class="comment"># 生成SHA512</span></div><div class="line">    <span class="keyword">return</span> md5, sha1, sha256, sha512</div></pre></td></tr></table></figure>
<h3 id="可以指定哈希加密算法的函数"><a href="#可以指定哈希加密算法的函数" class="headerlink" title="可以指定哈希加密算法的函数"></a>可以指定哈希加密算法的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算哈希值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_hash_type</span><span class="params">(file, hash_type)</span>:</span></div><div class="line">     <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">        s = f.read()</div><div class="line">        <span class="keyword">if</span> hash_type.lower() == <span class="string">'md5'</span>:</div><div class="line">            hash_res = hashlib.md5(s).hexdigest()</div><div class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">'sha1'</span>:</div><div class="line">            hash_res = hashlib.sha1(s).hexdigest()</div><div class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">'sha256'</span>:</div><div class="line">            hash_res = hashlib.sha256(s).hexdigest()</div><div class="line">        <span class="keyword">elif</span> hash_type.lower() == <span class="string">'sha512'</span>:</div><div class="line">            hash_res = hashlib.sha512(s).hexdigest()</div><div class="line">         <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"Hash type error!"</span>)</div><div class="line">            hash_res = <span class="string">"Type Error"</span></div><div class="line">    <span class="keyword">return</span> hash_type, hash_res</div></pre></td></tr></table></figure>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    file_path, hash_t = map(str, input(<span class="string">'Please enter the path of the file and hash type:'</span>).split())</div><div class="line">    md = generate_hash_type(file_path, hash_t)</div><div class="line">    print(md,<span class="string">'\n'</span>)</div><div class="line">    md = generate_hash(file_path)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> md:</div><div class="line">        print(i)</div></pre></td></tr></table></figure>
<p>最后别忘了引入<strong>hashlib</strong>库:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div></pre></td></tr></table></figure>
<p>还有设置编码格式以防万一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里我使用的是<a href="https://www.python.org/" target="_blank" rel="external">Python官网</a>下载的<em>python-3.6.1-amd64.exe</em>做的测试，官网也给出了它的md5哈希值，方便校验。<br>首先是用<code>generate_hash()</code>函数，分别生成<strong>md5</strong>,<strong>sha1</strong>,<strong>sha256</strong>和<strong>sha512</strong>的校验码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>please enter the path of the file:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>文件路径，我这里是 C:\Users\Freed\Downloads\python<span class="number">-3.6</span><span class="number">.1</span>-amd64.exe</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p><strong>md5</strong><br>ad69fdacde90f2ce8286c279b11ca188<br><strong>sha1</strong><br>bf54252c4065b20f4a111cc39cf5215fb1edccff<br><strong>sha256</strong><br>591922fbf5c4234b766dd672e539cba3d9a158e028e3c85c76bfec6ede56ded8<br><strong>sha512</strong><br>f0abf85afaf53eb7b706c17c3d8087d81fa57c397099f403f9d51dbd60c4e7<br>b9ad9e79fc375dadcccf74d32eba8653b139e073d84c5eb0d03f35313a5c4c6873</p>
</blockquote>
<p>然后是输入路径+指定加密算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>please enter the path of the file <span class="keyword">and</span> hash type:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>C:\Users\Freed\Downloads\python<span class="number">-3.6</span><span class="number">.1</span>-amd64.exe md5</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>(‘md5’, ‘ad69fdacde90f2ce8286c279b11ca188’)</p>
</blockquote>
<p>再来看看官网给出的md5：</p>
<blockquote>
<p>ad69fdacde90f2ce8286c279b11ca188</p>
</blockquote>
<p>和程序计算的结果一致。</p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-06-09.png&quot; alt=&quot;hash&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们经常看到软件的下载页面会注明这个软件的哈希值。可能你从没注意，但这其实是个蛮重要的东西，它可以用来验证你下载的软件是否被人动过手脚。&lt;br&gt;早些时候Mac上爆出XCodeGhost木马事件，引发的一个重要环节就是因为部分开发人员既没有从官方渠道下载，也没有验证软件哈希值，以至于使用了被植入代码的开发工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版 练习 12.33</title>
    <link href="https://felon03.github.io/2017/06/07/C-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A0-12-33/"/>
    <id>https://felon03.github.io/2017/06/07/C-Primer-第五版-练习-12-33/</id>
    <published>2017-06-07T14:39:56.000Z</published>
    <updated>2017-06-08T01:09:00.188Z</updated>
    
    <content type="html"><![CDATA[<p>C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——<strong>文本查询程序</strong>。<br><a id="more"></a></p>
<h2 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h2><blockquote>
<p>实现一个简单的文本查询程序，作为标准库相关内容学习的总结。程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中多次出现，此行只列出一次。行会按照升序输出——即，第7行会在第9行之前显示，以此类推。</p>
</blockquote>
<h2 id="文本查询程序设计"><a href="#文本查询程序设计" class="headerlink" title="文本查询程序设计"></a>文本查询程序设计</h2><p>设计两个类：<code>TextQuery</code>和<code>QueryResult</code><br>其中<code>TextQuery</code>用来生成每个单词对应的行号以及进行相关的查询操作；<br><code>QuerResult</code>用来保存查询结果，通过其成员函数<code>print()</code>输出查询结果。</p>
<h2 id="查询程序的实现"><a href="#查询程序的实现" class="headerlink" title="查询程序的实现"></a>查询程序的实现</h2><p>Query.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"><span class="comment">/* 在QueryResult类中添加名为begin和end的成员，返回一个迭代器，</span></div><div class="line">   指向一个给定查询返回的行号set中的位置。再添加一个名为get_file的成员，</div><div class="line">   返回一个shared_ptr，指向QueryResult对象中的文件</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"12.22.h"</span></span></div><div class="line"><span class="comment">// 定义了StrBlob类的头文件</span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 为了定义函数query的返回类型，这个定义是必须的</span></div><div class="line"><span class="keyword">class</span> QueryResult;</div><div class="line"><span class="keyword">class</span> TextQuery &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	TextQuery(<span class="built_in">std</span>::ifstream&amp;);</div><div class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"> 	<span class="comment">// 输入文件</span></div><div class="line">	<span class="built_in">shared_ptr</span>&lt;StrBlob&gt; file;						   </div><div class="line">	<span class="comment">// 每个单词到它所在行号的映射</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, </div><div class="line">		<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt;&gt; wordmap;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> QueryResult &#123;</div><div class="line">	<span class="keyword">using</span> qr_iter = <span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;::iterator;</div><div class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, QueryResult&amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	QueryResult(<span class="built_in">string</span> s, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt; l, <span class="built_in">shared_ptr</span>&lt;StrBlob&gt; f) :</div><div class="line">		word(s), lines(l), file(f) &#123;&#125;</div><div class="line"></div><div class="line">	<span class="function">qr_iter <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lines-&gt;begin(); &#125;</div><div class="line">	<span class="function">qr_iter <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lines-&gt;end(); &#125;</div><div class="line"></div><div class="line">	<span class="built_in">shared_ptr</span>&lt;StrBlob&gt; get_file() <span class="keyword">const</span> &#123; <span class="keyword">return</span> file; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="comment">// 查询单词</span></div><div class="line">	<span class="built_in">string</span> word;</div><div class="line">	<span class="comment">// 出现的行号</span></div><div class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt; lines;</div><div class="line">	 <span class="comment">// 输入文件</span></div><div class="line">	<span class="built_in">shared_ptr</span>&lt;StrBlob&gt; file;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Query.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Query.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//读取输入文件并建立单词到行号的映射</span></div><div class="line">TextQuery::TextQuery(<span class="built_in">std</span>::ifstream &amp;ifs) : file(<span class="keyword">new</span> StrBlob)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// 保存行号</span></div><div class="line">	StrBlob::size_type line_no&#123; <span class="number">0</span> &#125;;</div><div class="line">	<span class="comment">// 对文件中的每一行</span></div><div class="line">	<span class="keyword">for</span> (<span class="built_in">string</span> line; <span class="built_in">std</span>::getline(ifs, line); ++line_no)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 保存此行文本</span></div><div class="line">		file-&gt;push_back(line);</div><div class="line">		 <span class="comment">// 将文本分解为单词</span></div><div class="line">		<span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(line)</span></span>;</div><div class="line">		<span class="comment">// 对行中每个单词</span></div><div class="line">		<span class="keyword">for</span> (<span class="built_in">string</span> text, word; stream &gt;&gt; text; word.clear())</div><div class="line">		&#123;</div><div class="line">			<span class="comment">// 去除单词中的标点符号</span></div><div class="line">			<span class="built_in">std</span>::remove_copy_if(text.begin(), text.end(),</div><div class="line">				<span class="built_in">std</span>::back_inserter(word), <span class="built_in">ispunct</span>);</div><div class="line">			<span class="comment">// 如果单词不在wordmap中，以之为下标在wordmap中添加一项</span></div><div class="line">			<span class="keyword">auto</span> &amp;lines = wordmap[word];</div><div class="line">			<span class="comment">// 第一次遇到这个单词时，lines的指针为空</span></div><div class="line">			<span class="comment">// 分配一个新的set</span></div><div class="line">			<span class="keyword">if</span> (!lines) lines.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;);</div><div class="line">			<span class="comment">// 将此行号插入set中</span></div><div class="line">			lines-&gt;insert(line_no);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">QueryResult TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 如果未找到sought，将返回一个指向此set的指针</span></div><div class="line">	<span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;StrBlob::size_type&gt;&gt;</div><div class="line">		nodata(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt; StrBlob::size_type&gt;);</div><div class="line">	<span class="comment">// 使用find而不是下标运算符来查找单词，避免将单词添加到wordmap中</span></div><div class="line">	<span class="keyword">auto</span> found = wordmap.find(sought);</div><div class="line">	<span class="keyword">if</span> (found != wordmap.end())</div><div class="line">		<span class="comment">// 找到单词</span></div><div class="line">		<span class="keyword">return</span> QueryResult(sought, found-&gt;second, file);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="comment">// 未找到</span></div><div class="line">		<span class="keyword">return</span> QueryResult(sought, nodata, file);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, QueryResult &amp;query_result)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></div><div class="line">	<span class="comment">// 如果找到了单词，打印出现次数和所有出现的位置</span></div><div class="line">	os &lt;&lt; query_result.word &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; query_result.lines-&gt;size() &lt;&lt; <span class="string">" "</span></div><div class="line">		&lt;&lt; (query_result.lines-&gt;size() &gt; <span class="number">1</span> ? <span class="string">"times."</span> : <span class="string">"time."</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 打印单词出现的每一行</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = query_result.begin(); it != query_result.end(); ++it)</div><div class="line">	&#123;</div><div class="line">		<span class="function">ConstStrBlobPtr <span class="title">p</span><span class="params">(*query_result.file, *it)</span></span>;</div><div class="line">		os &lt;&lt; <span class="string">"\t(line "</span> &lt;&lt; *it + <span class="number">1</span> &lt;&lt; <span class="string">") "</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Query_test.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"12.33.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(<span class="built_in">std</span>::ifstream &amp;ifs)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function">TextQuery <span class="title">text_query</span><span class="params">(ifs)</span></span>;</div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter word to look for or q to quit: "</span>;</div><div class="line">		<span class="built_in">string</span> word;</div><div class="line">		<span class="keyword">if</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word) || word == <span class="string">"q"</span>) <span class="keyword">break</span>;</div><div class="line">		print(<span class="built_in">std</span>::<span class="built_in">cout</span>, text_query.query(word)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">"data/story.txt"</span>)</span></span>;</div><div class="line">	runQueries(ifs);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里用到了之前几节定义的<code>StrBlob</code>来代替<code>vector&lt;string&gt;</code>来保存每一行的内容。<br>算是一个比较综合的练习了。刚开始做没什么思路，多亏了<a href="https://github.com/pezy/CppPrimer" target="_blank" rel="external">GayHub</a>（雾）上的大神，才完成了这个练习。革命尚未成功，同志还需努力!<br>(ง •̀_•́)ง </p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ Primer 第五版 第12章的动态内存终于（zou）看（ma）完（guan）了（hua）！！！记录一下本章的最后一个大练习——&lt;strong&gt;文本查询程序&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++ Primer" scheme="https://felon03.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】验证哥德巴赫猜想</title>
    <link href="https://felon03.github.io/2017/05/28/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E9%AA%8C%E8%AF%81%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/"/>
    <id>https://felon03.github.io/2017/05/28/【每周一坑】验证哥德巴赫猜想/</id>
    <published>2017-05-28T01:53:38.000Z</published>
    <updated>2017-05-28T02:12:08.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-05-28.jpg" alt="Goldbach&#39;s conjecture"></p>
<blockquote>
<p>哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。</p>
</blockquote>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>本周题目</strong></p>
<blockquote>
<p>实现一段代码，输入一个大于2的偶数k，输出两个质数m、n，满足 m + n == k。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Goldbach(<span class="number">123456</span>)</div><div class="line"><span class="number">7</span> <span class="number">123449</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Goldbach(<span class="number">12345678</span>)</div><div class="line"><span class="number">31</span> <span class="number">12345647</span></div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个问题其实就是在求k范围内的质数的基础上，在加一个判断，使得两个质数之和等于k即可。要注意的是，求得的解并不唯一。</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="comment"># 求得小于等于n的所有质数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime</span><span class="params">(n)</span>:</span></div><div class="line">    prime = []</div><div class="line">    prime_dic = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">        prime_dic[i] = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n)) + <span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i * i, n + <span class="number">1</span>, i):</div><div class="line">            <span class="keyword">if</span> prime_dic[i] == <span class="number">1</span>:</div><div class="line">                prime_dic[j] = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> prime.items():</div><div class="line">        <span class="keyword">if</span> v == <span class="number">1</span>:</div><div class="line">            prime.append(k)</div><div class="line">    <span class="keyword">return</span> prime</div><div class="line"></div><div class="line"><span class="comment"># 求满足猜想的质数和</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gold_bach</span><span class="params">(n)</span>:</span></div><div class="line">    cnt = <span class="number">0</span></div><div class="line">    prime = get_prime(n)</div><div class="line">    <span class="keyword">for</span> prime1 <span class="keyword">in</span> prime:</div><div class="line">        prime2 = n - prime1</div><div class="line">        <span class="keyword">if</span> prime2 <span class="keyword">in</span> prime <span class="keyword">and</span> cnt != <span class="number">1</span>:    <span class="comment"># 只输出一种结果</span></div><div class="line">            cnt += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> prime1. prime2</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>：</div><div class="line">    print(gold_bach(<span class="number">123456</span>))</div><div class="line">    print(gold_bach(<span class="number">12345678</span>))</div></pre></td></tr></table></figure>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p>print(gold_bach(123456))</p>
<blockquote>
<p>(7, 123449)</p>
</blockquote>
<p>print(gold_bach(12345678))</p>
<blockquote>
<p>(31, 12345647)</p>
</blockquote>
<p>与示例一致。</p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-05-28.jpg&quot; alt=&quot;Goldbach&amp;#39;s conjecture&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哥德巴赫在1742年给欧拉的信中提出了以下猜想：任一大于2的整数都可以写成三个质数之和。（因现今数学界已经不再使用“1也是质数”这个约定，原初猜想的现在陈述为：任一大于5的整数都可以写成三个质数之和。）欧拉在回信中也提出另一个等价的版本，即任一大于2的偶数都可以写成两个质数之和。今日常见的猜想陈述为欧拉的版本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版 练习12.3</title>
    <link href="https://felon03.github.io/2017/05/26/C-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%BB%83%E4%B9%A012-3/"/>
    <id>https://felon03.github.io/2017/05/26/C-Primer-第五版-练习12-3/</id>
    <published>2017-05-26T06:27:11.000Z</published>
    <updated>2017-05-28T02:29:06.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>StrBlob需要const版本的<code>push_back</code>和<code>pop_back</code>吗？如果需要，添加进去。否则，解释为什么不需要。</p>
<a id="more"></a>
<h2 id="定义StrBlob类"><a href="#定义StrBlob类" class="headerlink" title="定义StrBlob类"></a>定义StrBlob类</h2><p>首先，定义<strong>StrBlob</strong>类。类的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* StrBlob.h */</span></div><div class="line"><span class="comment">/* 编写你自己的StrBlob类，包含const版本的front和back */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> StrBlob &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> size_type = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</div><div class="line">    StrBlob() : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;()) &#123;&#125;</div><div class="line">    StrBlob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</div><div class="line">        : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;(il)) &#123;&#125;</div><div class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> cosnt </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</div><div class="line">    <span class="comment">// 添加和删除元素</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">       check(<span class="number">0</span>, <span class="string">"pop_back on empty StrBlob"</span>);</div><div class="line">       data-&gt;pop_back();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 元素访问</span></div><div class="line">    <span class="function"><span class="built_in">string</span> &amp;<span class="title">front</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 如果vector为空，check会抛出一个异常</span></div><div class="line">       check(<span class="number">0</span>, <span class="string">"front on empty StrBlob"</span>);</div><div class="line">       <span class="keyword">return</span> data-&gt;front();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        check(<span class="number">0</span>, <span class="string">"front on empty StrBlob"</span>);</div><div class="line">       <span class="keyword">return</span> data-&gt;front();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="built_in">string</span> &amp;<span class="title">back</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        check(<span class="number">0</span>, <span class="string">"back on empty StrBlob"</span>);</div><div class="line">        <span class="keyword">return</span> data-&gt;back();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        check(<span class="number">0</span>, <span class="string">"back on empty StrBlob"</span>);</div><div class="line">        <span class="keyword">return</span> data-&gt;back();</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;size())</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; data;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="非const-StrBlob对象"><a href="#非const-StrBlob对象" class="headerlink" title="非const StrBlob对象"></a>非const StrBlob对象</h3><p>根据<strong>StrBlob</strong>的定义，我们来测试一下：<br>首先声明一个<strong>StrBlob</strong>对象<strong>b1</strong>：</p>
<pre><code>StrBlob b1 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};        // 非const对象
</code></pre><p>然后分别对<strong>b1</strong>调用<code>push_back()</code>和<code>pop_back()</code>：</p>
<pre><code>b1.push_back(&quot;test&quot;);       // 向b1添加元素test
</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>, <strong>test</strong>;<br>接着就是</p>
<pre><code>b1.pop_back();         // 删除刚刚添加的元素
</code></pre><p>此时<strong>b1</strong>保存的内容是 <strong>a</strong>, <strong>an</strong>, <strong>the</strong>;<br>可以看到，我们定义的非const的<strong>StrBlob</strong>对象进行<code>push_back()</code>和<code>pop_back()</code>操作是没有问题的。</p>
<h3 id="const-StrBlob对象"><a href="#const-StrBlob对象" class="headerlink" title="const StrBlob对象"></a>const StrBlob对象</h3><p>上面的操作都很顺利，那么当我们声明一个const <strong>StrBlob</strong>对象会怎么样呢？<br>接下来，我们声明一个const类型的<strong>StrBlob</strong>对象：</p>
<pre><code>const StrBlob cb = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};       // const 对象
</code></pre><p>同样的，我们对<strong>cb</strong>调用<code>push_back()</code>和<code>pop_back()</code>，看看会发生什么：</p>
<pre><code>cb.push_back(&quot;test&quot;);       // 向cb添加元素test
</code></pre><p>运行一下程序，就会报错：</p>
<blockquote>
<p><em>Error C2662 “void StrBlob::push_back(const std::string &amp;)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>
</blockquote>
<pre><code>cb.pop_back();           // 删除元素
</code></pre><p>在运行程序，同样也会报错：</p>
<blockquote>
<p><em>Error C2662 “void StrBlob::pop_back(void)”: 不能将“this”指针从“const StrBlob”转换为“StrBlob &amp;”</em></p>
</blockquote>
<p>原因是我们在定义<strong>StrBlob</strong>类时，<code>push_back()</code>和<code>pop_back()</code>并没有添const版本。<br>那么，自然而然地，我们将添加const版本的<code>push_back()</code>和<code>pop_back()</code>，在StrBlob.h中添加以下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* StrBlob.h */</span></div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    check(<span class="number">0</span>, <span class="string">"pop_back on empty StrBlob"</span>);</div><div class="line">    data-&gt;pop_back();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 添加const类型的push_back()和pop_back()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> <span class="keyword">const</span> </span></div><div class="line">&#123;</div><div class="line">    data-&gt;push_back(t);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    check(<span class="number">0</span>, <span class="string">"pop_back on empty StrBlob"</span>);</div><div class="line">    data-&gt;pop_back();</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>再运行一下程序，通过了，并且输出和之前非const版本的一样。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>那么问题来了，我们到底需不需要const类型的`push_back()和pop_back()呢？</p>
<p>如果没有const的版本，那么对const类型的对象进行操作时，程序就会报错，貌似加const版本的<code>push_back()</code>和<code>pop_back()</code>是必须的。但是要注意的是：</p>
<p><strong>我们应该站在类的使用者的角度来看，而不是类的设计者的角度。虽然在类的具体实现中，数据成员是一个指向<code>vector&lt;string&gt;</code>的智能指针；但由于类的封装，在使用者看来，数据成员是<code>vector&lt;string&gt;</code>，他们并不知道具体实现使用了智能指针。那么当类的使用者声明类的常量对象时，他们期待的结果是<code>vector&lt;string&gt;</code>的内容不会改变。所以我们在设计这个类的时候，要考虑到类的使用者的真实意图，对于像<code>push_back()</code>和<code>pop_back()</code>这样会改变智能指针所指向的<code>vector&lt;string&gt;</code>内容的成员函数，我们不应该声明和定义成const版本。这样在类的使用者使用类的常量对象时，就不能调用<code>push_back()</code>和<code>pop_back()</code>成员函数，不能改变智能指针所指向的vector<string>的内容了，这正好与类的使用者意图相符。</string></strong></p>
<p>通过以上的考虑，我认为<strong>StrBlob</strong>不需要const版本的<code>push_back</code>和<code>pop_back</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> [1]:  <a href="https://www.douban.com/group/topic/61573279/" target="_blank" rel="external">豆瓣 - 大家来讨论一下 exercise 12.3</a><br> [2]:  <a href="https://stackoverflow.com/questions/20725190/operating-on-dynamic-memory-is-it-meaningful-to-overload-a-const-memeber-functi" target="_blank" rel="external">Stack Overflow - Operating on dynamic memory, is it meaningful to overload a const memeber function?</a></p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;StrBlob需要const版本的&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;pop_back&lt;/code&gt;吗？如果需要，添加进去。否则，解释为什么不需要。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++ Primer" scheme="https://felon03.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】杨辉三角形</title>
    <link href="https://felon03.github.io/2017/05/19/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>https://felon03.github.io/2017/05/19/【每周一坑】杨辉三角形/</id>
    <published>2017-05-19T06:28:26.000Z</published>
    <updated>2017-05-28T01:46:45.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>本周题目</strong></p>
<blockquote>
<p>杨辉三角形，也称帕斯卡三角，其定义为：<br>顶端是1，视为(row0).<br>第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).<br>以此类推<br>第2行(row2)：0+1=1; 1+1=2; 1+0=1.<br>第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.</p>
</blockquote>
<a id="more"></a>
<p>根据上述方法可产生杨辉三角。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">n = 0              1                     </div><div class="line">n = 1            1   1                   </div><div class="line">n = 2          1   2   1                 </div><div class="line">n = 3        1   3   3   1               </div><div class="line">n = 4      1   4   6   4   1             </div><div class="line">n = 5    1   5   10  10  5   1           </div><div class="line">n = ...         ...  ...</div></pre></td></tr></table></figure>
<p>根据上述定义，定义一个函数，传入正整数参数m、n，分别代表杨辉三角第M行，左起第N个数字(m,n都从0开始计算)。如超出范围则返回 <code>Invalid query</code>。</p>
<p>示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">yang_hui</span><span class="params">(m, n)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    &gt;&gt;&gt;yang_hui(1, 1)</div><div class="line">    1</div><div class="line">    &gt;&gt;&gt;yang_hui(3,2)</div><div class="line">    3</div><div class="line">    &gt;&gt;&gt;yang_hui(1,4)</div><div class="line">    Invalid query</div><div class="line">    '''</div></pre></td></tr></table></figure></p>
<p><strong>附加题</strong><br>生成杨辉三角形<br>定义一个函数，传入M&lt;1000,生成前M行杨辉三角形。<br>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_yh</span><span class="params">(m)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    generate_yh(3):</div><div class="line">    1</div><div class="line">    1 1</div><div class="line">    1 2 1</div><div class="line">    '''</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题目的描述，我们已经知道杨辉三角是怎么生成的了，不过还要判断超出范围的情况：<code>N &gt; M</code>时，返回的应该是 <code>Invalidquery</code>。还有 <code>n=0</code> 或 <code>n=m</code>     时，返回的值应该为1.<br>要求第(M,N)个数字，可以用递归的方式来求得：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yang_hui(m, n) = yang_hui(m<span class="number">-1</span>,n<span class="number">-1</span>) + yang_hui(m<span class="number">-1</span>,n)</div></pre></td></tr></table></figure></p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p><strong>yang_hui(m,n):</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出杨辉三角中第m行第n列的数值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">yang_hui</span><span class="params">(m, n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n <span class="keyword">and</span> n &gt; m:</div><div class="line">        <span class="keyword">return</span>  <span class="string">"Invalid query!"</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == m:</div><div class="line">        <span class="keyword">return</span>  <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> yang_hui(m<span class="number">-1</span>,n<span class="number">-1</span>) + yang_hui(m<span class="number">-1</span>,n)</div></pre></td></tr></table></figure></p>
<p><strong>triangles(m):</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">打印输出杨辉三角</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">(m)</span>:</span></div><div class="line">    ret = [<span class="number">1</span>]</div><div class="line">    <span class="keyword">while</span> m:</div><div class="line">        <span class="keyword">yield</span> ret</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(ret)):</div><div class="line">            ret[i] = pre[i] + pre[i<span class="number">-1</span>]</div><div class="line">        ret.append(<span class="number">1</span>)</div><div class="line">        pre = ret[:]</div><div class="line">        m = m - <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>在生成杨辉三角的时候，用到了<strong>生成器(generator)</strong>。generator在执行过程中，遇到<code>yield</code>语句就返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br><strong>普通函数和generator函数的区别：</strong><br>普通函数调用直接返回结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = abs(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>generator函数的“调用”实际返回一个generator对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g</div><div class="line">&lt;generator object fib at <span class="number">0x1022ef498</span>&gt;</div></pre></td></tr></table></figure></p>
<p>关于generator，可以参考<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000#0" target="_blank" rel="external">这里</a>。</p>
<p><strong>测试</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    print(yang_hui(<span class="number">0</span>, <span class="number">0</span>))</div><div class="line">    print(yang_hui(<span class="number">1</span>, <span class="number">1</span>))</div><div class="line">    print(yang_hui(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">    print(yang_hui(<span class="number">6</span>, <span class="number">3</span>))</div><div class="line">    print(yang_hui(<span class="number">4</span>, <span class="number">9</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># 打印杨辉三角</span></div><div class="line">    triangle = triangles(<span class="number">10</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> triangle:</div><div class="line">        print(i)</div></pre></td></tr></table></figure></p>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p>输出结果如下：</p>
<blockquote>
<p>1<br>1<br>Invalid query<br>20<br>Invalid query<br>[1]<br>[1, 1]<br>[1, 2, 1]<br>[1, 3, 3, 1]<br>[1, 4, 6, 4, 1]<br>[1, 5, 10, 10, 5, 1]<br>[1, 6, 15, 20, 15, 6, 1]<br>[1, 7, 21, 35, 35, 21, 7, 1]<br>[1, 8, 28, 56, 70, 56, 28, 8, 1]<br>[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]</p>
</blockquote>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本周题目&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;杨辉三角形，也称帕斯卡三角，其定义为：&lt;br&gt;顶端是1，视为(row0).&lt;br&gt;第1行(row1)是两个1，这两个1是由它们上头左右两数之和(不在三角形内视为0).&lt;br&gt;以此类推&lt;br&gt;第2行(row2)：0+1=1; 1+1=2; 1+0=1.&lt;br&gt;第3行(row3)：0+1=1; 1+2=3; 2+1=3; 1+0=1.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】神奇的九宫格</title>
    <link href="https://felon03.github.io/2017/05/15/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A5%9E%E5%A5%87%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    <id>https://felon03.github.io/2017/05/15/【每周一坑】神奇的九宫格/</id>
    <published>2017-05-15T14:09:03.000Z</published>
    <updated>2017-05-26T08:14:58.005Z</updated>
    
    <content type="html"><![CDATA[<p>本周题目：</p>
<blockquote>
<p>给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。</p>
</blockquote>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Jiugongge</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    &gt;&gt;&gt; Jiugongge()</div><div class="line">    4 9 2</div><div class="line">    3 5 7</div><div class="line">    8 1 6</div><div class="line">    '''</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>附加题：</p>
<blockquote>
<p>给定一个正整数 N（N &gt;= 1），将 1 - N^2 填充到 N * N 的格子中，使横、竖、斜（对角线）每条线的和都相等，输出至少一种组合。</p>
</blockquote>
<p>比如 N 等于 3 时就是 9 宫格， N 等于 4 时为 16 宫格。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在解决问题之前，要先了解一个东西 —— “幻方”。<br>Wiki上给出的中文定义：</p>
<blockquote>
<p><strong>幻方</strong>(Magic Square)，有时又称<strong>魔方</strong>（该称呼现一般指立方体的魔术方块）或<strong>纵横图</strong>，由一组排放在正方形中的整数组成，其每行、每列以及两条对角线上的数之和均相等。通常幻方由从$1$到 $N^{2}$的连续整数组成，其中$N$为正方形的行或列的数目。因此$N$阶幻方有$N$行$N$列，并且所填充的数为从$1$到$N^{2}$。</p>
<p>幻方可以使用$N$阶方阵来表示，方阵的每行、每列以及两条对角线的和都等于常数 $M_{2}(N)$，如果填充数为$1,2,\dots ,N^{2}$，那么有<br>$$M_{2}(N)={\frac  {N(N^{2}+1)}{2}}$$</p>
</blockquote>
<p>$N$阶幻方的解题思路分为三种情况：</p>
<ol>
<li>$N$为奇数</li>
<li>$N$为4的倍数</li>
<li>$N$为其他偶数</li>
</ol>
<h3 id="1-N-为奇数"><a href="#1-N-为奇数" class="headerlink" title="1. $N$为奇数"></a>1. $N$为奇数</h3><ul>
<li>将$1$放在第一行中间一列；</li>
<li>从$2$开始直到$n*n$为止各数依次按下列规则存放，按$45°$方向行走，如向右上，每一个数存放的行比前一个数的行数减$1$，列数加$1$；</li>
<li>如果行列范围超出矩阵范围，则回绕。例如$1$在第一行，则$2$应放在最下一行，列数同样加$1$；</li>
<li>如果按照上述规则确定的位置已有数，或上一个数是第$1$行$n$列时，则把下一个数放在上一个数的下面。</li>
</ul>
<h3 id="2-N-为-4-的倍数"><a href="#2-N-为-4-的倍数" class="headerlink" title="2. $N$为$4$的倍数"></a>2. $N$为$4$的倍数</h3><p>采用对称元素交换法。首先把数$1$到$n*n$按从上至下、从左至又的顺序填入矩阵。<br>然后将方阵的所有$N*N$子方阵中的两对角线上位置的数关于方阵中心作对称交换，即$a(i,j)$与$a(n-1-i, n-1-j)$交换，所有其它位置上的数不变。</p>
<h3 id="3-N-为非-4-的倍数的偶数-即-4n-2"><a href="#3-N-为非-4-的倍数的偶数-即-4n-2" class="headerlink" title="3. $N$为非$4$的倍数的偶数(即$4n+2$)"></a>3. $N$为非$4$的倍数的偶数(即$4n+2$)</h3><p>首先把大方阵分解为$4$个奇数字方阵。<br>按上述奇数幻方给分解的4个子方阵对应赋值,其中：<br>上左子阵最小$(i)$，下右子阵次小$(i+v)$，下左子阵最大$(i+3v)$，上右子阵次大$(i+2v)$<br>即$4$个子方阵对应元素相差$v$，其中$v={\frac {n*n}{4}}$<br>四个子矩阵由小到大排列方式为</p>
<p>$$<br>        \begin{bmatrix}<br>        1 &amp; 3 \<br>        4 &amp; 2 \<br>        \end{bmatrix}<br>$$</p>
<p>然后作相应的元素交换：$a(i,j)$ 与 $a(i+k,j)$在同一列做对应交换，$(j\lt t或j\gt n-t)$， $a(t,0)与a(t+k,0)$； $a(t,t)$ 与 $a(t+k,t)$ 两对元素交换，其中<br>$k = n//2，t=(n-2)//4$。</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># n为奇数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddN</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 构造二维列表</span></div><div class="line">    lst = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</div><div class="line">    <span class="comment"># 初始化列表位置</span></div><div class="line">    x, y = <span class="number">0</span>, n//<span class="number">2</span></div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n*n+<span class="number">1</span>):</div><div class="line">        lst[x][y] = num</div><div class="line">        xa, ya = x<span class="number">-1</span>, y+<span class="number">1</span></div><div class="line">        <span class="comment"># 回绕情况</span></div><div class="line">        <span class="keyword">if</span> xa &lt; <span class="number">0</span>:</div><div class="line">            xa = n<span class="number">-1</span></div><div class="line">        <span class="keyword">if</span> ya &gt; n<span class="number">-1</span>:</div><div class="line">            ya = <span class="number">0</span></div><div class="line">        <span class="comment"># 占位情况</span></div><div class="line">        <span class="keyword">if</span> lst[xa][ya] != <span class="number">0</span>:</div><div class="line">            x = x+<span class="number">1</span></div><div class="line">            <span class="keyword">if</span> x &gt; n<span class="number">-1</span>:</div><div class="line">                x = <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            x, y = xa, ya</div><div class="line">    <span class="keyword">return</span> lst</div><div class="line">    </div><div class="line"><span class="comment"># n为4的倍数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourN</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="comment"># 初始化列表</span></div><div class="line">    lst = [[i+j <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">1</span>,n*n+<span class="number">1</span>))[::n]] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</div><div class="line">    <span class="comment"># 交换对角线位置</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span>):</div><div class="line">        lst[i][i],lst[n<span class="number">-1</span>-i][n<span class="number">-1</span>-i] = lst[n<span class="number">-1</span>-i][n<span class="number">-1</span>-i],lst[i][i]</div><div class="line">        lst[i][n<span class="number">-1</span>-i],lst[n<span class="number">-1</span>-i][i] = lst[n<span class="number">-1</span>-i][i],lst[i][n<span class="number">-1</span>-i]</div><div class="line">    <span class="keyword">return</span> lst</div><div class="line"></div><div class="line"><span class="comment"># n为非4倍数的偶数</span></div><div class="line"><span class="comment"># 累加子矩阵</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(p, lst)</span>:</span></div><div class="line">    <span class="comment"># print(lst)</span></div><div class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> lst:</div><div class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(row)):</div><div class="line">            row[index] += p</div><div class="line"></div><div class="line">    <span class="keyword">return</span> lst</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourNplus2</span><span class="params">(n)</span>:</span></div><div class="line">    m = n // <span class="number">2</span></div><div class="line">    A, B, C, D = oddN(m), oddN(m), oddN(m), oddN(m)</div><div class="line">    B = acc(m ** <span class="number">2</span>, B)</div><div class="line">    C = acc(m ** <span class="number">2</span> * <span class="number">2</span>, C)</div><div class="line">    D = acc(m ** <span class="number">2</span> * <span class="number">3</span>, D)</div><div class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(A)):</div><div class="line">        A[row_index].extend(C[row_index])</div><div class="line">        D[row_index].extend(B[row_index])</div><div class="line">    <span class="comment"># 合并子矩阵</span></div><div class="line">    matrix = A + D</div><div class="line">    t = (n - <span class="number">2</span>) // <span class="number">4</span></div><div class="line">    <span class="comment"># 列交换</span></div><div class="line">    <span class="keyword">for</span> col_index <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</div><div class="line">        <span class="keyword">if</span> col_index &lt; t <span class="keyword">or</span> col_index &gt; n - t:</div><div class="line">            <span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(matrix) // <span class="number">2</span>):</div><div class="line">                matrix[row_index][col_index], matrix[row_index + m][col_index] = \</div><div class="line">                    matrix[row_index + m][col_index], matrix[row_index][col_index]</div><div class="line">                <span class="comment"># 交换特殊位置</span></div><div class="line">    matrix[t][<span class="number">0</span>], matrix[m + t][<span class="number">0</span>] = matrix[m + t][<span class="number">0</span>], matrix[t][<span class="number">0</span>]</div><div class="line">    matrix[t][t], matrix[m + t][t] = matrix[m + t][t], matrix[t][t]</div><div class="line">    <span class="keyword">return</span> matrix</div></pre></td></tr></table></figure>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个3*3的九宫格和1-9九个数字，将9个数字按照一定规则填充进九宫格内，使九宫格内横、竖、斜每条线的和都相等，输出至少一种结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Jiugongge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;gt;&amp;gt;&amp;gt; Jiugongge()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    4 9 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    3 5 7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    8 1 6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】求乘积最大</title>
    <link href="https://felon03.github.io/2017/05/03/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E6%B1%82%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7/"/>
    <id>https://felon03.github.io/2017/05/03/【每周一坑】求乘积最大/</id>
    <published>2017-05-03T13:58:01.000Z</published>
    <updated>2017-08-04T10:52:22.542Z</updated>
    
    <content type="html"><![CDATA[<p>本周题目：</p>
<blockquote>
<p>设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值</p>
</blockquote>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    &gt;&gt;&gt;product(312)</div><div class="line">    62</div><div class="line">    &gt;&gt;&gt;product(1234)</div><div class="line">    492</div><div class="line">    &gt;&gt;&gt;product(12345)</div><div class="line">    6170</div><div class="line">    &gt;&gt;&gt;product(123456)</div><div class="line">    74070</div><div class="line">    '''</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从头到尾遍历这个数字串，</p>
<ol>
<li>先是按顺序截取长度为1的子串与剩余的子串相乘得到一个结果</li>
<li>然后还是按顺序截取长度为2的子串与剩余的子串相乘得到新的结果</li>
<li>以此类推…<br>直到截取的长度为原来的数字串的长度(除了数字串本身)然后将这些结果进行比较，得到最大的并输出即可。</li>
</ol>
<p>可以将每一步求出的值存入初始值为0的<code>max_num</code>中，每次求出的值都与<code>max_num</code>比较，若大于<code>max_num</code>，则更新它的值，这样可以保证得到最大的值，也即我们要求的最大值。</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(num)</span>:</span></div><div class="line">    i = <span class="number">1</span>               </div><div class="line">    max_num = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> i != len(str(num)):</div><div class="line">        num1 = int(str(num)[:i])</div><div class="line">        num2 = int(str(num)[i:])</div><div class="line">        result = num1 * num2</div><div class="line">        <span class="comment"># result = int(str(num)[:i]) * int(str(num)[i:])</span></div><div class="line">        <span class="keyword">if</span> result &gt; max_num:</div><div class="line">            max_num = result</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> max_num</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">print(product(<span class="number">312</span>))</div><div class="line">print(product(<span class="number">1234</span>))</div><div class="line">print(product(<span class="number">12345</span>))</div><div class="line">print(product(<span class="number">123456</span>))</div></pre></td></tr></table></figure>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p>结果为：</p>
<blockquote>
<p>62<br>492<br>6170<br>74070</p>
</blockquote>
<p>结果与示例相符合</p>
<h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>上述的题目感觉还是比较简单的，因此多了一个附加题：</p>
<blockquote>
<p>输入的数字串可以重新打乱排列，比如输入123，打乱排列之后会有132，213，231，312，321等情况，其他条件不变，求最大值。</p>
</blockquote>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_2</span><span class="params">(num)</span>:</span></div><div class="line">  <span class="string">'''</span></div><div class="line">  &gt;&gt;&gt;product_2(1234)</div><div class="line">  1312</div><div class="line">  &gt;&gt;&gt;product_2(12345)</div><div class="line">  22412</div><div class="line">  &gt;&gt;&gt;product_2(123456)</div><div class="line">  342002</div><div class="line">  '''</div></pre></td></tr></table></figure></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可以打乱顺序，那么如何得到所有的可能数组串就是这个问题的关键了。可惜，我一开始并没有想到用什么方法，如果强行暴力求的话复杂度高不说，还可能求不全。于是我参考了别人的代码，发现了一个神奇的库：<a href="https://docs.python.org/3.6/library/itertools.html#module-itertools" target="_blank" rel="external"><strong>itertools</strong></a>。<br>它属于Python标准库，今天用到的是<a href="https://docs.python.org/3.6/library/itertools.html#itertools.permutations" target="_blank" rel="external"><strong>permutations()</strong></a>这个函数：</p>
<blockquote>
<p>permutations(p[,r]); 创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同<br>返回p中任意取r个元素做排列的元组的迭代器</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>permutations(‘ABCD’, 2)</p>
</blockquote>
<p>返回的结果为：</p>
<blockquote>
<p>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</p>
</blockquote>
<p>有了这个函数，我们就可以完成附加题了</p>
<h2 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_2</span><span class="params">(num)</span>:</span></div><div class="line">    i = <span class="number">1</span></div><div class="line">    max_num = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> permutations(str(num)):</div><div class="line">        new_num = <span class="string">""</span>.join(p)            <span class="comment"># 排列后返回的是一个元组，通过join()来重新生成数字串</span></div><div class="line">        <span class="comment"># print(new_num)</span></div><div class="line">        result = product(new_num)       <span class="comment"># 就是上面的product()</span></div><div class="line">        <span class="keyword">if</span> result &gt; max_num:</div><div class="line">            max_num = result</div><div class="line">    <span class="keyword">return</span> max_num</div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">print(product_2(<span class="number">1234</span>))</div><div class="line">print(product_2(<span class="number">12345</span>))</div><div class="line">print(product_2(<span class="number">123456</span>))</div></pre></td></tr></table></figure>
<h2 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h2><p>结果为：</p>
<blockquote>
<p>1312<br>22412<br>342002</p>
</blockquote>
<p>与示例一致</p>
<p>End~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设定一个长度为N的数字串，将其分为两部分，找出一个切分位置，是两部分的乘积值最大，并返回最大值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;gt;&amp;gt;&amp;gt;product(312)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;gt;&amp;gt;&amp;gt;product(1234)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    492&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;gt;&amp;gt;&amp;gt;product(12345)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    6170&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;gt;&amp;gt;&amp;gt;product(123456)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    74070&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【每周一坑】程序员的浪漫</title>
    <link href="https://felon03.github.io/2017/04/27/%E3%80%90%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    <id>https://felon03.github.io/2017/04/27/【每周一坑】程序员的浪漫/</id>
    <published>2017-04-27T07:39:22.000Z</published>
    <updated>2017-05-28T01:19:15.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-04-27.jpg" alt="wordcloud"></p>
<p>关注了<strong>Crossin的编程教室</strong>，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。</p>
<p>问题如下：</p>
<p>在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：</p>
<blockquote>
<p>‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n’</p>
</blockquote>
<p>在此给出4个选项</p>
<ol>
<li>我们在一起吧</li>
<li>我选择原谅你</li>
<li>别说话，吻我</li>
<li>多喝热水</li>
</ol>
<p>使用科学的方法算出说的是什么。<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实思路也挺简单，hashlib里有MD5模块，只需调用</p>
<blockquote>
<p>hashlib.md5(“要生成MD5的字符串”)</p>
</blockquote>
<p>即可生成。</p>
<p>而我们已经知道了经过MD5加密和base64加密后的字符串，可以通过base64的解码函数：</p>
<blockquote>
<p>base64.b64decode(“已知的字符串”)</p>
</blockquote>
<p>即可得到解码后的内容。</p>
<p>最后只要将hashlib.md5()的内容和base64.b64decode()的内容进行比较，如果相同就输出生成改md5的字符串即可。</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> base64, hashlib      <span class="comment"># 引入需要使用的库</span></div><div class="line"></div><div class="line">answer = <span class="string">'NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n'</span>   <span class="comment"># 问题中的字符串</span></div><div class="line">checkStr = &#123;<span class="string">'我们在一起吧'</span>, <span class="string">'我选择原谅你'</span>, <span class="string">'别说话，吻我'</span>, <span class="string">'多喝热水'</span>&#125;     <span class="comment"># 将选项存入字典，后面使用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> checkStr:      <span class="comment"># 遍历字典中的个字符串</span></div><div class="line">        md5 = hashlib.md5(x.encode(<span class="string">'utf-8'</span>))        <span class="comment"># 使用hashlib.md5()进行编码</span></div><div class="line">        md5_byte = bytes(md5.hexdigest().encode(<span class="string">'utf-8'</span>))       <span class="comment"># base64.decode()得到的是bytes类型的，</span></div><div class="line">		 <span class="comment"># 无法直接与string比较，这里把string类型的md5转换成bytes类型的</span></div><div class="line">        b64_byte = base64.decode(answer)</div><div class="line">        <span class="keyword">if</span> md5_byte == b64_byte:</div><div class="line">            print(<span class="string">'The answer is'</span>, x)</div><div class="line">            </div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p>万！万！没！想！到！ 结果居然是….</p>
<blockquote>
<p>多喝热水</p>
</blockquote>
<p>说好的程序员的浪漫呢！！要是女朋友千辛万苦解出来看到是这句话，估计会被打死吧…</p>
<p>然而…</p>
<p>和我并没有什么关系QAQ，谁叫我没有女朋友╮(╯▽╰)╭</p>
<p>End~</p>
<hr>
<p>[1]: 图片出处: <a href="http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA" target="_blank" rel="external">http://mp.weixin.qq.com/s/L2DEcnUTb5IFOC8miOO9UA</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-04-27.jpg&quot; alt=&quot;wordcloud&quot;&gt;&lt;/p&gt;
&lt;p&gt;关注了&lt;strong&gt;Crossin的编程教室&lt;/strong&gt;，每周会出一个Python的小题目，本周的题目是关于hashlib和base64加密模块的。&lt;/p&gt;
&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;在python中有hashlib和base64两大加密模块，将一串字符串先经过hashlib.md5加密，然后再经过base64加密，最后得到一串字符：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘NDRiMWZmMmVjZTk5MTFjMWI1MDNkYTY0MzZlYTAzMTA=\n’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此给出4个选项&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们在一起吧&lt;/li&gt;
&lt;li&gt;我选择原谅你&lt;/li&gt;
&lt;li&gt;别说话，吻我&lt;/li&gt;
&lt;li&gt;多喝热水&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用科学的方法算出说的是什么。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="每周一坑" scheme="https://felon03.github.io/tags/%E6%AF%8F%E5%91%A8%E4%B8%80%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>函数返回数组指针或数组引用</title>
    <link href="https://felon03.github.io/2017/04/15/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E6%88%96%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8/"/>
    <id>https://felon03.github.io/2017/04/15/函数返回数组指针或数组引用/</id>
    <published>2017-04-15T11:05:14.000Z</published>
    <updated>2017-04-15T11:08:49.766Z</updated>
    
    <content type="html"><![CDATA[<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。<br>下面就介绍几种方法：</p>
<a id="more"></a>
<h2 id="方法一：-使用类型别名"><a href="#方法一：-使用类型别名" class="headerlink" title="方法一： 使用类型别名"></a>方法一： 使用类型别名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];       <span class="comment">// arrT是一个类型别名，表示的类型</span></div><div class="line">                            <span class="comment">// 是含有10个整型的数组</span></div><div class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];       <span class="comment">// arrT的等价声明</span></div><div class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;          <span class="comment">// func返回一个指向含有10个整数的数组的指针</span></div></pre></td></tr></table></figure>
<p>其中<code>arrT</code>是含有10个整数的数组别名。因为无法返回数组，所以将返回类型定义成数组的指针。因此<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>
<h2 id="方法二：-声明一个返回数组指针的函数"><a href="#方法二：-声明一个返回数组指针的函数" class="headerlink" title="方法二： 声明一个返回数组指针的函数"></a>方法二： 声明一个返回数组指针的函数</h2><p>要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];            <span class="comment">// arr是一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];            <span class="comment">// p1是一个含有10个指针的数组</span></div><div class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// p2是一个指针，他只想含有10个整数的数组</span></div></pre></td></tr></table></figure></p>
<p>和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也更在函数名字后面且形参列表应该咸鱼数组的维度。因此，返回数组指针的函数形式如下所示：</p>
<blockquote>
<p>Type (*function(parameter_list)) [dimension]</p>
</blockquote>
<p>类似于其他数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两段的括号必须存在，就像定义<code>p2</code>时两段必须有括号一样。如果没有这对括号，函数返回的类型将是指针的数组。</p>
<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i)) [<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<p>可以按照以下的顺序来逐层理解该声明的含义：</p>
<ul>
<li><code>func(int i)</code>表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参</li>
<li><code>(*func(int i))</code>意味这我们可以对函数调用的结果执行解引用操作</li>
<li><code>(*func(int i)) [10]</code>表示解引用<code>func</code>的调用将得到一个大小是10的数组</li>
<li><code>int(*func(int i)) [10]</code>表示数组中元素是<code>int</code>类型</li>
</ul>
<h2 id="方法三：-使用尾置返回类型"><a href="#方法三：-使用尾置返回类型" class="headerlink" title="方法三： 使用尾置返回类型"></a>方法三： 使用尾置返回类型</h2><p>在C++11新标准中海油可以简化上述<code>func</code>声明的方法，就是使用<strong>尾置返回类型(trailing return type)</strong>。任何函数的定义都能使用尾置返回，但是这样形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。位置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</div><div class="line">auto func(int i) -&gt; int(*) [10];</div></pre></td></tr></table></figure>
<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</p>
<h2 id="方法四：-使用decltype"><a href="#方法四：-使用decltype" class="headerlink" title="方法四： 使用decltype"></a>方法四： 使用decltype</h2><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数<code>i</code>的不同指向两个已知数组中的某一个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</div><div class="line"><span class="comment">// 返回一个指针，该指针指向含有5个整数的数组</span></div><div class="line"><span class="keyword">decltype</span>(odd) *addPtr(<span class="keyword">int</span> i)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;      <span class="comment">// 返回一个指向数组的指针</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>arrPtr</code>使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有5个整数的数组的指针。有一个地方需要注意： decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还必须在函数声明是加一个<code>*</code>符号。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。"><a href="#1-编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。" class="headerlink" title="1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。"></a>1. 编写一个程序，使其返回数组的引用并且该数组白喊10个string对象。不要使用尾置返回类型、decltype或者类型别名。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> (&amp;func(<span class="built_in">string</span> (&amp;arr)[<span class="number">10</span>])) [<span class="number">10</span>];</div></pre></td></tr></table></figure>
<h3 id="2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。"><a href="#2-为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。" class="headerlink" title="2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。"></a>2. 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 使用类型别名</div><div class="line">using arrT = string[10];</div><div class="line">arrT&amp; func1(arrT&amp; arr);</div><div class="line"></div><div class="line">// 使用尾置返回类型</div><div class="line">auto func2(arrT&amp; arr)-&gt;string(&amp;) [10];</div><div class="line"></div><div class="line">// 使用decltype关键字</div><div class="line">string arrS[10];</div><div class="line">decltype(arrS) &amp;func3(arrT&amp; arr);</div></pre></td></tr></table></figure>
<h3 id="3-修改arrPtr函数，使其返回数组的引用"><a href="#3-修改arrPtr函数，使其返回数组的引用" class="headerlink" title="3. 修改arrPtr函数，使其返回数组的引用"></a>3. 修改arrPtr函数，使其返回数组的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</div><div class="line"><span class="keyword">decltype</span>(odd) &amp;arrPtr(<span class="keyword">int</span> i)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? odd : even;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。&lt;br&gt;下面就介绍几种方法：&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://felon03.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++前置递增（递减）和后置递增（递减）运算符</title>
    <link href="https://felon03.github.io/2017/04/07/C-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E5%92%8C%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%EF%BC%88%E9%80%92%E5%87%8F%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://felon03.github.io/2017/04/07/C-前置递增（递减）和后置递增（递减）运算符/</id>
    <published>2017-04-07T10:31:16.000Z</published>
    <updated>2017-04-07T10:34:36.925Z</updated>
    
    <content type="html"><![CDATA[<p>在做C++ primer 第五版课后习题4.31时遇到一个问题：</p>
<blockquote>
<p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。</p>
</blockquote>
<a id="more"></a>
<p>源程序代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type cnt = ivec.size();</div><div class="line"><span class="comment">// 将把从size到1的值赋给ivec的元素</span></div><div class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>;</div><div class="line">                    ix != ivec.size(); ++ix, --cnt)</div><div class="line">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>
<p>可以看到源程序用的是前置递增和递减运算符<br>我根据源代码写了一下可运行的版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">0</span>);        <span class="comment">// 初始化ivec</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type cnt = ivec.size();</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; </div><div class="line">	                    ix != ivec.size(); ++ix, --cnt)</div><div class="line">		ivec[ix] = cnt;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : ivec)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出的结果为</p>
<blockquote>
<p>10 9 8 7 6 5 4 3 2 1</p>
</blockquote>
<p>然后根据题目的意思，使用了后置版本的递增和递减运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">0</span>);        <span class="comment">// 初始化ivec</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type cnt = ivec.size();</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; </div><div class="line">	                    ix != ivec.size(); ix++, cnt--)</div><div class="line">		ivec[ix] = cnt;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : ivec)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出的结果为</p>
<blockquote>
<p>10 9 8 7 6 5 4 3 2 1</p>
</blockquote>
<p>结果一样啊喂！(＃°Д°)<br>哪里需要修改了(╯‵□′)╯︵┻━┻<br>各种百度没有没百度到，突然想起来可以找课后练习答案啊！<br>找到了结果，还以为我错了，没想到答案居然是…</p>
<blockquote>
<p>We use prefix and not postfix, just because of the <strong>Advice: Use Postfix   Advice: Use Postfix Operators only When Necessary</strong>.<br>So, it’s just a good habits. And there are no changes if we have to be made to use the postfix versions. Rewrite:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.size(); ix++, cnt--)  </div><div class="line">    ivec[ix] = cnt;</div></pre></td></tr></table></figure></p>
<p>This is not an appropriate example to discuss the difference of prefix and postfix.</p>
</blockquote>
<p>果然不是我的问题 ( •̀ ω •́ )</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做C++ primer 第五版课后习题4.31时遇到一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节程序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://felon03.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ string输入问题</title>
    <link href="https://felon03.github.io/2017/03/31/C-string%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://felon03.github.io/2017/03/31/C-string输入问题/</id>
    <published>2017-03-31T06:38:28.000Z</published>
    <updated>2017-03-31T06:46:20.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>使用cin读入一组字符串并存入一个vector对象</p>
</blockquote>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用如下代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*用cin读入一组字符串并把它们存入一个vector对象*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</div><div class="line">	<span class="built_in">string</span> word;</div><div class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>, word))</div><div class="line">	&#123;</div><div class="line">		text.push_back(word);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : text)</div><div class="line">		<span class="keyword">if</span> (i == text.back())</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; i;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">","</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在运行测试时发现了一个问题：<br>当输入为</p>
<blockquote>
<p>aa ss dd qq ww ee^Z (注意，^Z是在字符串输入完成后直接在后面加入的)</p>
</blockquote>
<p>按回车后发现输出卡出了，并不会输出所输入的字符串</p>
<p>当输入为</p>
<blockquote>
<p>aa ss dd qq ww ee<br>^Z(换行后的^Z)</p>
</blockquote>
<p>就可以正确输出了</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>百思不得其解，遂百度之。<br>看到了两种解释，感觉都有道理，就都贴上来好了<br>1.</p>
<blockquote>
<p>因为标准C++ I/O函数是有缓冲的，你输入aa dd ssctrl+z之后，cin调用read读到aa dd ss到缓冲中，返回aa给用户，再次调用直接返回dd，再次调用直接返回ss，从而忽略掉了ctrl+z，因为第一次read把它带过了。此刻调用cin，因为缓冲区空，于是read阻塞等待输入，你输入ctrl+z，read返回0，于是cin&gt;&gt;调用立即返回，cin状态为eof，while退出。</p>
</blockquote>
<p>2.</p>
<blockquote>
<p>windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。</p>
</blockquote>
<p>意思就是说如果使用ctrl+z来结束输入的话，一定要是单独使用，不能在输入后面直接加。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用cin读入一组字符串并存入一个vector对象&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://felon03.github.io/tags/C/"/>
    
      <category term="String" scheme="https://felon03.github.io/tags/String/"/>
    
      <category term="vector" scheme="https://felon03.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>给出一个表达式，按照顺序求出表达式的值</title>
    <link href="https://felon03.github.io/2017/03/25/%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/"/>
    <id>https://felon03.github.io/2017/03/25/给出一个表达式，按照顺序求出表达式的值/</id>
    <published>2017-03-25T14:54:21.000Z</published>
    <updated>2017-03-25T15:04:53.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="按顺序求出表达式的值"><a href="#按顺序求出表达式的值" class="headerlink" title="按顺序求出表达式的值"></a>按顺序求出表达式的值</h2><p>今天碰到一个题目：<br><strong>题目描述：</strong></p>
<blockquote>
<p>常规的表达式求值，我们都会根据计算的优先级来计算， 比如<code>*</code>、<code>/</code>的优先级就高于<code>+</code>、<code>-</code>。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有<code>/</code>，只有(<code>+</code>,<code>-</code>和<code>*</code>)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。</p>
</blockquote>
<p><strong>输入描述：</strong></p>
<blockquote>
<p>输入为一行字符串，即一个表达式。其中运算符只有<code>+</code>,<code>-</code>和<code>*</code>。参与计算的数字只有0-9。<br>保证表达式是合法的，排列规则如样例所示。</p>
</blockquote>
<p><strong>输出描述</strong></p>
<blockquote>
<p>输出一个数，即表达式的值</p>
</blockquote>
<a id="more"></a>
<p><strong>输入例子</strong></p>
<blockquote>
<p>3+5*7</p>
</blockquote>
<p><strong>输出例子</strong></p>
<blockquote>
<p>56</p>
</blockquote>
<p>刚开始觉得挺简单，就是字符串处理什么的，也没怎么在意，后来实现的时候才发现，原来还是有点麻烦的…</p>
<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 输入字符串表达式，按照输入顺序求出表达式的结果</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 字符串转数字</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_number</span><span class="params">(<span class="built_in">string</span> num_str)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">stringstream</span> stream;	<span class="comment">// 声明stringstram变量</span></div><div class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> str_len = num_str.length();</div><div class="line">	stream &lt;&lt; num_str;</div><div class="line">	stream &gt;&gt; result;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> s;		<span class="comment">// 保存输入的字符串</span></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入要计算的表达式(不包含除):"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; s;</div><div class="line">	<span class="keyword">int</span> number[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;		<span class="comment">// 保存数字的数组</span></div><div class="line">	<span class="built_in">string</span> operator_str;		<span class="comment">// 保存操作符的字符串</span></div><div class="line">	<span class="keyword">int</span> length = s.length();</div><div class="line">	<span class="built_in">string</span> number_str;		<span class="comment">// 保存每个操作符之前的字符串</span></div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;	<span class="comment">// 标记保存数字的数组的指针</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)		<span class="comment">// 如果是数字，则存入 number_str</span></div><div class="line">		&#123;</div><div class="line">			number_str += s[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>		<span class="comment">// 如果是操作符，存入operator_str</span></div><div class="line">		&#123;</div><div class="line">			operator_str += s[i];</div><div class="line">			number[index] = get_number(number_str);		<span class="comment">// 得到两个操作符之间的操作数，并存入数组</span></div><div class="line">			index++;</div><div class="line">			number_str = <span class="string">""</span>;			<span class="comment">// 将字符串置为空，重新存入下一个操作数的字符串</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (i == length <span class="number">-1</span>)		<span class="comment">// 得到表达式的最后一个操作数</span></div><div class="line">		&#123;</div><div class="line">			number[index] = get_number(number_str);</div><div class="line">			index++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;		<span class="comment">// 计算结果</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//todo 计算结果</span></div><div class="line">		<span class="keyword">if</span> (i&lt;<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			result += number[i];</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">switch</span> (operator_str[i<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">			<span class="keyword">case</span> <span class="string">'+'</span>:</div><div class="line">				result = result + number[i];</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> <span class="string">'-'</span>:</div><div class="line">				result = result - number[i];</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> <span class="string">'*'</span>:</div><div class="line">				result = result * number[i];</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//cout &lt;&lt; number[i] &lt;&lt; endl;</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//for (int i = 0; i &lt; operator_str.length(); i++)</span></div><div class="line">	<span class="comment">//&#123;</span></div><div class="line">	<span class="comment">//	cout &lt;&lt; operator_str[i] &lt;&lt; endl;</span></div><div class="line">	<span class="comment">//&#125;</span></div><div class="line">	<span class="comment">//cout &lt;&lt; "输入的字符串为:" &lt;&lt; s &lt;&lt; " 得到的数字为: " &lt;&lt; number &lt;&lt; endl;</span></div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>挺简单的题目，居然写了这么多！ <em> </em>(:3」∠)<em> </em><br>太久没写了，写的有点丑¬<em>¬，看来还是要多练习 (ง •̀</em>•́)ง</p>
<p>End~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;按顺序求出表达式的值&quot;&gt;&lt;a href=&quot;#按顺序求出表达式的值&quot; class=&quot;headerlink&quot; title=&quot;按顺序求出表达式的值&quot;&gt;&lt;/a&gt;按顺序求出表达式的值&lt;/h2&gt;&lt;p&gt;今天碰到一个题目：&lt;br&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常规的表达式求值，我们都会根据计算的优先级来计算， 比如&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;的优先级就高于&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法(心想：他们的世界是有多傻→_→)，意味着表达式中没有&lt;code&gt;/&lt;/code&gt;，只有(&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;)。现给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入为一行字符串，即一个表达式。其中运算符只有&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;。参与计算的数字只有0-9。&lt;br&gt;保证表达式是合法的，排列规则如样例所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输出描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出一个数，即表达式的值&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://felon03.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://felon03.github.io/tags/C/"/>
    
      <category term="String" scheme="https://felon03.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Python生成词云</title>
    <link href="https://felon03.github.io/2017/03/25/Python%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/"/>
    <id>https://felon03.github.io/2017/03/25/Python生成词云/</id>
    <published>2017-03-25T07:02:21.000Z</published>
    <updated>2017-03-25T08:02:58.361Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/imagesource/17-03-25-1.png" alt="wordcloud"></p>
<h2 id="Python如何生成词云"><a href="#Python如何生成词云" class="headerlink" title="Python如何生成词云"></a>Python如何生成词云</h2><p>最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P<br>通过度娘发现可以用Python库来生成词云， So Let’s go!<br><a id="more"></a></p>
<h3 id="用到的库"><a href="#用到的库" class="headerlink" title="用到的库"></a>用到的库</h3><h4 id="WorldCloud"><a href="#WorldCloud" class="headerlink" title="WorldCloud"></a>WorldCloud</h4><ul>
<li>官网: <a href="https://amueller.github.io/word_cloud" target="_blank" rel="external">https://amueller.github.io/word_cloud</a></li>
<li>github: <a href="https://github.com/amueller/word_cloud" target="_blank" rel="external">https://github.com/amueller/word_cloud</a> </li>
</ul>
<h3 id="安装WordCloud"><a href="#安装WordCloud" class="headerlink" title="安装WordCloud"></a>安装WordCloud</h3><h4 id="通过PIP安装"><a href="#通过PIP安装" class="headerlink" title="通过PIP安装"></a>通过PIP安装</h4><pre><code>pip install wordcloud
</code></pre><h4 id="下载WHL包安装"><a href="#下载WHL包安装" class="headerlink" title="下载WHL包安装"></a>下载WHL包安装</h4><p>当然可能通过PIP会安装出错，我们可以下<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="external">WHL包</a>手动安装</p>
<p>下载完成后，再使用PIP命令安装：</p>
<pre><code>pip install yourfilepath\wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl
</code></pre><p>其中， yourfilepath是你电脑中whl文件存放的位置，后面的包名为你所下载的whl包，我下的是<code>wordcloud‑1.3.1‑cp36‑cp36m‑win_amd64.whl</code>。</p>
<h3 id="使用WordlCloud"><a href="#使用WordlCloud" class="headerlink" title="使用WordlCloud"></a>使用WordlCloud</h3><p>安装完成后，就可以用了。可以先测试以下是否安装成功：</p>
<pre><code>from wordcould import WordCloud
</code></pre><p>如果没有报错，表示安装成功了。</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>下面就是源码部分了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> scipy.misc omport imread</div><div class="line"></div><div class="line"><span class="comment"># 读入一个文件</span></div><div class="line">text = open(<span class="string">'your text file.txt'</span>, <span class="string">'r'</span>).read()</div><div class="line"><span class="comment"># 读入图片</span></div><div class="line">bg_pic = imread(<span class="string">'your picture.png'</span>)</div><div class="line"><span class="comment"># 配置词云参数</span></div><div class="line">wc = WordCloud(</div><div class="line">    <span class="comment"># 设置背景色,我这里设置为了黑色</span></div><div class="line">    background_color = <span class="string">'black'</span>,</div><div class="line">    <span class="comment"># 设置词云形状，就是之前读入的图片</span></div><div class="line">    mask = bg_pic,</div><div class="line">    <span class="comment"># 设置字体,字体路径要正确，不然会报错，最好和py文件放在一块</span></div><div class="line">    font_path = <span class="string">'Sketch Fine Serif.otf'</span></div><div class="line">)</div><div class="line"><span class="comment"># 生成词云</span></div><div class="line">wordcloud = wc.generate(text)</div><div class="line"><span class="comment"># 显示词云图片</span></div><div class="line">plt.imshow(wordcloud)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.show()</div><div class="line"><span class="comment"># 保存图片</span></div><div class="line">wordcloud.to_file(<span class="string">'wordcloud.jpg'</span>)</div></pre></td></tr></table></figure></p>
<p>生成的词云效果如图:<br><img src="/images/imagesource/17-03-25-2.jpg" alt="my wordcloud"></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>其中配置词云参数的时候，有多个参数可选：</p>
<p>Parameters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font_path : string</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Font path to the font that will be used (OTF or TTF). Defaults to DroidSansMono path on a Linux machine. If you are on another OS or don’t have this font, you need to adjust this path.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">width : int (default=400)</div></pre></td></tr></table></figure>
<blockquote>
<p>Width of the canvas.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">height : int (default=200)</div></pre></td></tr></table></figure>
<blockquote>
<p>Height of canvas</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prefer_horizontal : float (default=0.90)</div></pre></td></tr></table></figure>
<blockquote>
<p>The ratio of times to try horizontal fitting as opposed to vertical. If prefer_horizontal &lt; 1, the algorithm will try rotating the word if it doesn’t fit. (There is currently no built-in way to get only vertical words.)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mask : nd-array or None (default=None)</div></pre></td></tr></table></figure>
<blockquote>
<p>If not None, gives a binary mask on where to draw words. If mask is not None, width and height will be ignored and the shape of mask will be used instead. All white (#FF or #FFFFFF) entries will be considerd “masked out” while other entries will be free to draw on. [This changed in the most recent version!]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scale : float (default=1)</div></pre></td></tr></table></figure>
<blockquote>
<p>Scaling between computation and drawing. For large word-cloud images, using scale instead of larger canvas size is significantly faster, but might lead to a coarser fit for the words.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min_font_size : int (default=4)</div></pre></td></tr></table></figure>
<blockquote>
<p>Smallest font size to use. Will stop when there is no more room in this size.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font_step : int (default=1)</div></pre></td></tr></table></figure>
<blockquote>
<p>Step size for the font. font_step &gt; 1 might speed up computation but give a worse fit.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max_words : number (default=200)</div></pre></td></tr></table></figure>
<blockquote>
<p>The maximum number of words.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stopwords : set of strings or None</div></pre></td></tr></table></figure>
<blockquote>
<p>The words that will be eliminated. If None, the build-in STOPWORDS list will be used.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background_color : color value (default=”black”)</div></pre></td></tr></table></figure>
<blockquote>
<p>Background color for the word cloud image.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max_font_size : int or None (default=None)</div></pre></td></tr></table></figure>
<blockquote>
<p>Maximum font size for the largest word. If None, height of the image is used.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mode : string (default=”RGB”)</div></pre></td></tr></table></figure>
<blockquote>
<p>Transparent background will be generated when mode is “RGBA” and background_color is None.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">relative_scaling : float (default=.5)</div></pre></td></tr></table></figure>
<blockquote>
<p>Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">color_func : callable, default=None</div></pre></td></tr></table></figure>
<blockquote>
<p>Callable with parameters word, font_size, position, orientation, font_path, random_state that returns a PIL color for each word. Overwrites “colormap”. See colormap for specifying a matplotlib colormap instead.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regexp : string or None (optional)</div></pre></td></tr></table></figure>
<blockquote>
<p>Regular expression to split the input text into tokens in process_text. If None is specified, r”\w[\w’]+” is used.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collocations : bool, default=True</div></pre></td></tr></table></figure>
<blockquote>
<p>Whether to include collocations (bigrams) of two words.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">colormap : string or matplotlib colormap, default=”viridis”</div></pre></td></tr></table></figure>
<blockquote>
<p>Matplotlib colormap to randomly draw colors from for each word. Ignored if “color_func” is specified.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">normalize_plurals : bool, default=True</div></pre></td></tr></table></figure>
<blockquote>
<p>Whether to remove trailing ‘s’ from words. If True and a word appears with and without a trailing ‘s’, the one with trailing ‘s’ is removed and its counts are added to the version without trailing ‘s’ – unless the word ends with ‘ss’.</p>
</blockquote>
<p>以上就是所有可以配置的参数，可以根据需要来用。</p>
<p>End~</p>
<hr>
<p>[1]: 图片出处: <a href="https://github.com/amueller/word_cloud" target="_blank" rel="external">https://github.com/amueller/word_cloud</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/imagesource/17-03-25-1.png&quot; alt=&quot;wordcloud&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Python如何生成词云&quot;&gt;&lt;a href=&quot;#Python如何生成词云&quot; class=&quot;headerlink&quot; title=&quot;Python如何生成词云&quot;&gt;&lt;/a&gt;Python如何生成词云&lt;/h2&gt;&lt;p&gt;最近看到词云这东西，感觉挺酷眩，就想自己实现以下:P&lt;br&gt;通过度娘发现可以用Python库来生成词云， So Let’s go!&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://felon03.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://felon03.github.io/tags/Python/"/>
    
      <category term="词云" scheme="https://felon03.github.io/tags/%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
</feed>
